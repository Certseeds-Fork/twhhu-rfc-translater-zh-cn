{
  "title": {
    "text": "RFC 2553: Basic Socket Interface Extensions for IPv6",
    "zh-CHS": "RFC 2553"
  },
  "number": 2553,
  "created_at": "2021-10-23 16:00:13.237516+08:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                        R. Gilligan\nRequest for Comments: 2553                                      FreeGate\nObsoletes: 2133                                               S. Thomson\nCategory: Informational                                         Bellcore\n                                                                J. Bound\n                                                                  Compaq\n                                                              W. Stevens\n                                                              Consultant\n                                                              March 1999",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 15,
      "text": "Basic Socket Interface Extensions for IPv6",
      "zh-CHS": "IPv6的基本套接字接口扩展"
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "zh-CHS": "本备忘录的状况"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "zh-CHS": "本备忘录为互联网社区提供信息。它没有规定任何类型的互联网标准。本备忘录的分发不受限制。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "zh-CHS": "版权公告"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1999). All Rights Reserved.",
      "zh-CHS": "版权所有（C）互联网协会（1999年）。版权所有。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "zh-CHS": "摘要"
    },
    {
      "indent": 3,
      "text": "The de facto standard application program interface (API) for TCP/IP applications is the \"sockets\" interface. Although this API was developed for Unix in the early 1980s it has also been implemented on a wide variety of non-Unix systems. TCP/IP applications written using the sockets API have in the past enjoyed a high degree of portability and we would like the same portability with IPv6 applications. But changes are required to the sockets API to support IPv6 and this memo describes these changes. These include a new socket address structure to carry IPv6 addresses, new address conversion functions, and some new socket options. These extensions are designed to provide access to the basic IPv6 features required by TCP and UDP applications, including multicasting, while introducing a minimum of change into the system and providing complete compatibility for existing IPv4 applications. Additional extensions for advanced IPv6 features (raw sockets and access to the IPv6 extension headers) are defined in another document [4].",
      "zh-CHS": "TCP/IP应用程序的实际标准应用程序接口（API）是“套接字”接口。尽管此API是在20世纪80年代早期为Unix开发的，但它也已在各种非Unix系统上实现。使用sockets API编写的TCP/IP应用程序在过去具有高度的可移植性，我们希望IPv6应用程序具有同样的可移植性。但是需要对套接字API进行更改以支持IPv6，本备忘录描述了这些更改。其中包括用于承载IPv6地址的新套接字地址结构、新的地址转换函数和一些新的套接字选项。这些扩展旨在提供对TCP和UDP应用程序所需的基本IPv6功能（包括多播）的访问，同时将对系统的更改降至最低，并为现有IPv4应用程序提供完全的兼容性。高级IPv6功能的其他扩展（原始套接字和对IPv6扩展头的访问）在另一个文档[4]中定义。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "zh-CHS": "目录"
    },
    {
      "indent": 3,
      "text": "1. Introduction.................................................3\n2. Design Considerations........................................3\n2.1 What Needs to be Changed....................................4\n2.2 Data Types..................................................5\n2.3 Headers.....................................................5\n2.4 Structures..................................................5\n3. Socket Interface.............................................6\n3.1 IPv6 Address Family and Protocol Family.....................6\n3.2 IPv6 Address Structure......................................6\n3.3 Socket Address Structure for 4.3BSD-Based Systems...........7\n3.4 Socket Address Structure for 4.4BSD-Based Systems...........8\n3.5 The Socket Functions........................................9\n3.6 Compatibility with IPv4 Applications.......................10\n3.7 Compatibility with IPv4 Nodes..............................10\n3.8 IPv6 Wildcard Address......................................11\n3.9 IPv6 Loopback Address......................................12\n3.10 Portability Additions.....................................13\n4. Interface Identification....................................16\n4.1 Name-to-Index..............................................16\n4.2 Index-to-Name..............................................17\n4.3 Return All Interface Names and Indexes.....................17\n4.4 Free Memory................................................18\n5. Socket Options..............................................18\n5.1 Unicast Hop Limit..........................................18\n5.2 Sending and Receiving Multicast Packets....................19\n6. Library Functions...........................................21\n6.1 Nodename-to-Address Translation............................21\n6.2 Address-To-Nodename Translation............................24\n6.3 Freeing memory for getipnodebyname and getipnodebyaddr.....26\n6.4 Protocol-Independent Nodename and Service Name Translation.26\n6.5 Socket Address Structure to Nodename and Service Name......29\n6.6 Address Conversion Functions...............................31\n6.7 Address Testing Macros.....................................32\n7. Summary of New Definitions..................................33\n8. Security Considerations.....................................35\n9. Year 2000 Considerations....................................35\nChanges From RFC 2133..........................................35\nAcknowledgments................................................38\nReferences.....................................................39\nAuthors' Addresses.............................................40\nFull Copyright Statement.......................................41",
      "raw": true,
      "toc": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "zh-CHS": "1. 介绍"
    },
    {
      "indent": 3,
      "text": "While IPv4 addresses are 32 bits long, IPv6 interfaces are identified by 128-bit addresses. The socket interface makes the size of an IP address quite visible to an application; virtually all TCP/IP applications for BSD-based systems have knowledge of the size of an IP address. Those parts of the API that expose the addresses must be changed to accommodate the larger IPv6 address size. IPv6 also introduces new features (e.g., traffic class and flowlabel), some of which must be made visible to applications via the API. This memo defines a set of extensions to the socket interface to support the larger address size and new features of IPv6.",
      "zh-CHS": "虽然IPv4地址为32位长，但IPv6接口由128位地址标识。套接字接口使IP地址的大小对应用程序非常可见；几乎所有基于BSD系统的TCP/IP应用程序都知道IP地址的大小。必须更改API中暴露地址的部分，以适应更大的IPv6地址大小。IPv6还引入了新功能（例如，流量类和流量标签），其中一些功能必须通过API对应用程序可见。此备忘录定义了套接字接口的一组扩展，以支持更大的地址大小和IPv6的新功能。"
    },
    {
      "indent": 0,
      "text": "2. Design Considerations",
      "section_title": true,
      "zh-CHS": "2. 设计考虑"
    },
    {
      "indent": 3,
      "text": "There are a number of important considerations in designing changes to this well-worn API:",
      "zh-CHS": "在设计对这一老旧API的更改时，有许多重要的考虑因素："
    },
    {
      "indent": 6,
      "text": "- The API changes should provide both source and binary compatibility for programs written to the original API. That is, existing program binaries should continue to operate when run on a system supporting the new API. In addition, existing applications that are re-compiled and run on a system supporting the new API should continue to operate. Simply put, the API changes for IPv6 should not break existing programs. An additonal mechanism for implementations to verify this is to verify the new symbols are protected by Feature Test Macros as described in IEEE Std 1003.1. (Such Feature Test Macros are not defined by this RFC.)",
      "zh-CHS": "- API更改应为写入原始API的程序提供源代码和二进制兼容性。也就是说，当在支持新API的系统上运行时，现有的程序二进制文件应该继续运行。此外，在支持新API的系统上重新编译和运行的现有应用程序应继续运行。简言之，IPv6的API更改不应破坏现有程序。实现验证这一点的另一种机制是验证新符号是否受到IEEE Std 1003.1中所述的功能测试宏的保护。（此RFC未定义此类功能测试宏。）"
    },
    {
      "indent": 6,
      "text": "- The changes to the API should be as small as possible in order to simplify the task of converting existing IPv4 applications to IPv6.",
      "zh-CHS": "- 为了简化将现有IPv4应用程序转换为IPv6的任务，对API的更改应该尽可能小。"
    },
    {
      "indent": 6,
      "text": "- Where possible, applications should be able to use this API to interoperate with both IPv6 and IPv4 hosts. Applications should not need to know which type of host they are communicating with.",
      "zh-CHS": "- 在可能的情况下，应用程序应该能够使用此API与IPv6和IPv4主机进行互操作。应用程序不需要知道它们正在与哪种类型的主机通信。"
    },
    {
      "indent": 6,
      "text": "- IPv6 addresses carried in data structures should be 64-bit aligned. This is necessary in order to obtain optimum performance on 64-bit machine architectures.",
      "zh-CHS": "- 数据结构中携带的IPv6地址应为64位对齐。为了在64位机器体系结构上获得最佳性能，这是必需的。"
    },
    {
      "indent": 3,
      "text": "Because of the importance of providing IPv4 compatibility in the API, these extensions are explicitly designed to operate on machines that provide complete support for both IPv4 and IPv6. A subset of this API could probably be designed for operation on systems that support only IPv6. However, this is not addressed in this memo.",
      "zh-CHS": "由于在API中提供IPv4兼容性的重要性，这些扩展被明确设计为在同时提供IPv4和IPv6完全支持的计算机上运行。此API的一个子集可能设计用于仅支持IPv6的系统上的操作。然而，本备忘录并未提及这一点。"
    },
    {
      "indent": 0,
      "text": "2.1 What Needs to be Changed",
      "section_title": true,
      "zh-CHS": "2.1 需要改变什么"
    },
    {
      "indent": 3,
      "text": "The socket interface API consists of a few distinct components:",
      "zh-CHS": "套接字接口API由几个不同的组件组成："
    },
    {
      "indent": 6,
      "text": "- Core socket functions.",
      "zh-CHS": "- 核心套接字功能。"
    },
    {
      "indent": 6,
      "text": "- Address data structures.",
      "zh-CHS": "- 地址数据结构。"
    },
    {
      "indent": 6,
      "text": "- Name-to-address translation functions.",
      "zh-CHS": "- 名称地址转换功能。"
    },
    {
      "indent": 6,
      "text": "- Address conversion functions.",
      "zh-CHS": "- 地址转换函数。"
    },
    {
      "indent": 3,
      "text": "The core socket functions -- those functions that deal with such things as setting up and tearing down TCP connections, and sending and receiving UDP packets -- were designed to be transport independent. Where protocol addresses are passed as function arguments, they are carried via opaque pointers. A protocol-specific address data structure is defined for each protocol that the socket functions support. Applications must cast pointers to these protocol-specific address structures into pointers to the generic \"sockaddr\" address structure when using the socket functions. These functions need not change for IPv6, but a new IPv6-specific address data structure is needed.",
      "zh-CHS": "核心套接字函数——这些函数处理诸如设置和断开TCP连接以及发送和接收UDP数据包之类的事情——被设计为独立于传输。当协议地址作为函数参数传递时，它们通过不透明指针携带。为套接字函数支持的每个协议定义了特定于协议的地址数据结构。当使用套接字函数时，应用程序必须将指向这些特定于协议的地址结构的指针强制转换为指向通用“sockaddr”地址结构的指针。IPv6不需要更改这些功能，但需要新的IPv6特定地址数据结构。"
    },
    {
      "indent": 3,
      "text": "The \"sockaddr_in\" structure is the protocol-specific data structure for IPv4. This data structure actually includes 8-octets of unused space, and it is tempting to try to use this space to adapt the sockaddr_in structure to IPv6. Unfortunately, the sockaddr_in structure is not large enough to hold the 16-octet IPv6 address as well as the other information (address family and port number) that is needed. So a new address data structure must be defined for IPv6.",
      "zh-CHS": "“sockaddr_in”结构是IPv4的特定于协议的数据结构。这个数据结构实际上包含8个八位字节的未使用空间，尝试使用这个空间来将sockaddr_in结构调整到IPv6是很有诱惑力的。不幸的是，sockaddr_in结构不够大，无法容纳16个八位组的IPv6地址以及所需的其他信息（地址系列和端口号）。因此，必须为IPv6定义新的地址数据结构。"
    },
    {
      "indent": 3,
      "text": "IPv6 addresses are scoped [2] so they could be link-local, site, organization, global, or other scopes at this time undefined. To support applications that want to be able to identify a set of interfaces for a specific scope, the IPv6 sockaddr_in structure must support a field that can be used by an implementation to identify a set of interfaces identifying the scope for an IPv6 address.",
      "zh-CHS": "IPv6地址的作用域为[2]，因此此时它们可能是链接本地、站点、组织、全局或其他未定义的作用域。为了支持希望能够识别特定作用域的一组接口的应用程序，IPv6 SockAddru in结构必须支持一个字段，实现可以使用该字段来识别识别IPv6地址作用域的一组接口。"
    },
    {
      "indent": 3,
      "text": "The name-to-address translation functions in the socket interface are gethostbyname() and gethostbyaddr(). These are left as is and new functions are defined to support IPv4 and IPv6. Additionally, the POSIX 1003.g draft [3] specifies a new nodename-to-address translation function which is protocol independent. This function can also be used with IPv4 and IPv6.",
      "zh-CHS": "套接字接口中的名称到地址转换函数是gethostbyname（）和gethostbyaddr（）。这些功能保持不变，并定义了新功能以支持IPv4和IPv6。此外，POSIX 1003.g草案[3]指定了一个新的节点名来处理独立于协议的转换功能。此功能也可用于IPv4和IPv6。"
    },
    {
      "indent": 3,
      "text": "The address conversion functions -- inet_ntoa() and inet_addr() -- convert IPv4 addresses between binary and printable form. These functions are quite specific to 32-bit IPv4 addresses. We have designed two analogous functions that convert both IPv4 and IPv6 addresses, and carry an address type parameter so that they can be extended to other protocol families as well.",
      "zh-CHS": "地址转换函数inet_ntoa（）和inet_addr（）在二进制和可打印形式之间转换IPv4地址。这些函数非常特定于32位IPv4地址。我们设计了两个类似的函数，它们转换IPv4和IPv6地址，并带有地址类型参数，以便它们也可以扩展到其他协议系列。"
    },
    {
      "indent": 3,
      "text": "Finally, a few miscellaneous features are needed to support IPv6. New interfaces are needed to support the IPv6 traffic class, flow label, and hop limit header fields. New socket options are needed to control the sending and receiving of IPv6 multicast packets.",
      "zh-CHS": "最后，需要一些其他特性来支持IPv6。需要新接口来支持IPv6流量类、流标签和跃点限制标头字段。需要新的套接字选项来控制IPv6多播数据包的发送和接收。"
    },
    {
      "indent": 3,
      "text": "The socket interface will be enhanced in the future to provide access to other IPv6 features. These extensions are described in [4].",
      "zh-CHS": "套接字接口将在将来得到增强，以提供对其他IPv6功能的访问。[4]中描述了这些扩展。"
    },
    {
      "indent": 0,
      "text": "2.2 Data Types",
      "section_title": true,
      "zh-CHS": "2.2 数据类型"
    },
    {
      "indent": 3,
      "text": "The data types of the structure elements given in this memo are intended to be examples, not absolute requirements. Whenever possible, data types from Draft 6.6 (March 1997) of POSIX 1003.1g are used: uintN_t means an unsigned integer of exactly N bits (e.g., uint16_t). We also assume the argument data types from 1003.1g when possible (e.g., the final argument to setsockopt() is a size_t value). Whenever buffer sizes are specified, the POSIX 1003.1 size_t data type is used (e.g., the two length arguments to getnameinfo()).",
      "zh-CHS": "本备忘录中给出的结构元素数据类型旨在作为示例，而非绝对要求。只要可能，就使用POSIX 1003.1g草案6.6（1997年3月）中的数据类型：uintN_t表示正好N位的无符号整数（例如uint16_t）。在可能的情况下，我们还假设参数数据类型为1003.1g（例如，setsockopt（）的最终参数是一个size_t值）。每当指定缓冲区大小时，都会使用POSIX 1003.1 size_t数据类型（例如，getnameinfo（）的两个长度参数）。"
    },
    {
      "indent": 0,
      "text": "2.3 Headers",
      "section_title": true,
      "zh-CHS": "2.3 标题"
    },
    {
      "indent": 3,
      "text": "When function prototypes and structures are shown we show the headers that must be #included to cause that item to be defined.",
      "zh-CHS": "当显示函数原型和结构时，我们会显示必须包含的标题，以便定义该项。"
    },
    {
      "indent": 0,
      "text": "2.4 Structures",
      "section_title": true,
      "zh-CHS": "2.4 结构"
    },
    {
      "indent": 3,
      "text": "When structures are described the members shown are the ones that must appear in an implementation. Additional, nonstandard members may also be defined by an implementation. As an additional precaution nonstandard members could be verified by Feature Test Macros as described in IEEE Std 1003.1. (Such Feature Test Macros are not defined by this RFC.)",
      "zh-CHS": "当描述结构时，显示的成员是必须出现在实现中的成员。其他非标准成员也可以由实现定义。作为额外的预防措施，可通过IEEE Std 1003.1中所述的特性测试宏对非标准构件进行验证。（此RFC未定义此类功能测试宏。）"
    },
    {
      "indent": 3,
      "text": "The ordering shown for the members of a structure is the recommended ordering, given alignment considerations of multibyte members, but an implementation may order the members differently.",
      "zh-CHS": "考虑到多字节成员的对齐注意事项，结构成员的顺序是推荐的顺序，但是实现可能会以不同的顺序排列成员。"
    },
    {
      "indent": 0,
      "text": "3. Socket Interface",
      "section_title": true,
      "zh-CHS": "3. 套接字接口"
    },
    {
      "indent": 3,
      "text": "This section specifies the socket interface changes for IPv6.",
      "zh-CHS": "本节指定IPv6的套接字接口更改。"
    },
    {
      "indent": 0,
      "text": "3.1 IPv6 Address Family and Protocol Family",
      "section_title": true,
      "zh-CHS": "3.1 IPv6地址族和协议族"
    },
    {
      "indent": 3,
      "text": "A new address family name, AF_INET6, is defined in <sys/socket.h>. The AF_INET6 definition distinguishes between the original sockaddr_in address data structure, and the new sockaddr_in6 data structure.",
      "zh-CHS": "在<sys/socket.h>中定义了一个新的地址族名称AF_INET6。AF_INET6定义区分了原始地址数据结构中的sockaddr_和新地址数据结构中的sockaddr_。"
    },
    {
      "indent": 3,
      "text": "A new protocol family name, PF_INET6, is defined in <sys/socket.h>. Like most of the other protocol family names, this will usually be defined to have the same value as the corresponding address family name:",
      "zh-CHS": "<sys/socket.h>中定义了一个新的协议族名称PF_INET6。与大多数其他协议族名称一样，这通常被定义为与相应的地址族名称具有相同的值："
    },
    {
      "indent": 6,
      "text": "#define PF_INET6 AF_INET6",
      "zh-CHS": "#定义PF_INET6 AF_INET6"
    },
    {
      "indent": 3,
      "text": "The PF_INET6 is used in the first argument to the socket() function to indicate that an IPv6 socket is being created.",
      "zh-CHS": "函数socket（）的第一个参数中使用PF_INET6来指示正在创建IPv6套接字。"
    },
    {
      "indent": 0,
      "text": "3.2 IPv6 Address Structure",
      "section_title": true,
      "zh-CHS": "3.2 IPv6地址结构"
    },
    {
      "indent": 3,
      "text": "A new in6_addr structure holds a single IPv6 address and is defined as a result of including <netinet/in.h>:",
      "zh-CHS": "一个新的in6_addr结构包含一个IPv6地址，并定义为包含<netinet/in.h>的结果："
    },
    {
      "indent": 6,
      "text": "struct in6_addr {\n    uint8_t  s6_addr[16];      /* IPv6 address */\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "This data structure contains an array of sixteen 8-bit elements, which make up one 128-bit IPv6 address. The IPv6 address is stored in network byte order.",
      "zh-CHS": "此数据结构包含16个8位元素的数组，这些元素构成一个128位IPv6地址。IPv6地址以网络字节顺序存储。"
    },
    {
      "indent": 3,
      "text": "The structure in6_addr above is usually implemented with an embedded union with extra fields that force the desired alignment level in a manner similar to BSD implementations of \"struct in_addr\". Those additional implementation details are omitted here for simplicity.",
      "zh-CHS": "上面6_addr中的结构通常是通过一个带有额外字段的嵌入式联合来实现的，这些字段以类似于“struct in_addr”的BSD实现的方式强制实现所需的对齐级别。为了简单起见，这里省略了这些附加的实现细节。"
    },
    {
      "indent": 3,
      "text": "An example is as follows:",
      "zh-CHS": "例如："
    },
    {
      "indent": 3,
      "text": "struct in6_addr {\n     union {\n         uint8_t  _S6_u8[16];\n         uint32_t _S6_u32[4];\n         uint64_t _S6_u64[2];\n     } _S6_un;\n};\n#define s6_addr _S6_un._S6_u8",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "3.3 Socket Address Structure for 4.3BSD-Based Systems",
      "section_title": true,
      "zh-CHS": "3.3 基于4.3BSD系统的套接字地址结构"
    },
    {
      "indent": 3,
      "text": "In the socket interface, a different protocol-specific data structure is defined to carry the addresses for each protocol suite. Each protocol- specific data structure is designed so it can be cast into a protocol- independent data structure -- the \"sockaddr\" structure. Each has a \"family\" field that overlays the \"sa_family\" of the sockaddr data structure. This field identifies the type of the data structure.",
      "zh-CHS": "在套接字接口中，定义了不同的协议特定数据结构，以承载每个协议套件的地址。每个特定于协议的数据结构都被设计为可以转换为独立于协议的数据结构——“sockaddr”结构。每个都有一个“族”字段，覆盖sockaddr数据结构的“sa_族”。此字段标识数据结构的类型。"
    },
    {
      "indent": 3,
      "text": "The sockaddr_in structure is the protocol-specific address data structure for IPv4. It is used to pass addresses between applications and the system in the socket functions. The following sockaddr_in6 structure holds IPv6 addresses and is defined as a result of including the <netinet/in.h> header:",
      "zh-CHS": "sockaddr_in结构是IPv4的特定于协议的地址数据结构。它用于在套接字函数中在应用程序和系统之间传递地址。以下sockaddr_in6结构保存IPv6地址，并定义为包含<netinet/in.h>头的结果："
    },
    {
      "indent": 0,
      "text": "struct sockaddr_in6 {\n    sa_family_t     sin6_family;    /* AF_INET6 */\n    in_port_t       sin6_port;      /* transport layer port # */\n    uint32_t        sin6_flowinfo;  /* IPv6 traffic class & flow info */\n    struct in6_addr sin6_addr;      /* IPv6 address */\n    uint32_t        sin6_scope_id;  /* set of interfaces for a scope */\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "This structure is designed to be compatible with the sockaddr data structure used in the 4.3BSD release.",
      "zh-CHS": "此结构设计为与4.3BSD版本中使用的sockaddr数据结构兼容。"
    },
    {
      "indent": 3,
      "text": "The sin6_family field identifies this as a sockaddr_in6 structure. This field overlays the sa_family field when the buffer is cast to a sockaddr data structure. The value of this field must be AF_INET6.",
      "zh-CHS": "sin6_family字段将其标识为sockaddr_in6结构。当缓冲区转换为sockaddr数据结构时，此字段覆盖sa_族字段。此字段的值必须为AF_INET6。"
    },
    {
      "indent": 3,
      "text": "The sin6_port field contains the 16-bit UDP or TCP port number. This field is used in the same way as the sin_port field of the sockaddr_in structure. The port number is stored in network byte order.",
      "zh-CHS": "sin6_端口字段包含16位UDP或TCP端口号。此字段的使用方式与结构中sockaddr_的sin_port字段相同。端口号以网络字节顺序存储。"
    },
    {
      "indent": 3,
      "text": "The sin6_flowinfo field is a 32-bit field that contains two pieces of information: the traffic class and the flow label. The contents and interpretation of this member is specified in [1]. The sin6_flowinfo field SHOULD be set to zero by an implementation prior to using the sockaddr_in6 structure by an application on receive operations.",
      "zh-CHS": "sin6_flowinfo字段是一个32位字段，包含两条信息：流量类别和流量标签。[1]中规定了该成员的内容和解释。应用程序在接收操作中使用sockaddr_in6结构之前，实现应将sin6_flowinfo字段设置为零。"
    },
    {
      "indent": 3,
      "text": "The sin6_addr field is a single in6_addr structure (defined in the previous section). This field holds one 128-bit IPv6 address. The address is stored in network byte order.",
      "zh-CHS": "sin6_addr字段是单个in6_addr结构（在上一节中定义）。此字段包含一个128位IPv6地址。地址以网络字节顺序存储。"
    },
    {
      "indent": 3,
      "text": "The ordering of elements in this structure is specifically designed so that when sin6_addr field is aligned on a 64-bit boundary, the start of the structure will also be aligned on a 64-bit boundary. This is done for optimum performance on 64-bit architectures.",
      "zh-CHS": "此结构中元素的顺序是专门设计的，因此当sin6_addr字段在64位边界上对齐时，结构的起点也将在64位边界上对齐。这样做是为了在64位体系结构上获得最佳性能。"
    },
    {
      "indent": 3,
      "text": "The sin6_scope_id field is a 32-bit integer that identifies a set of interfaces as appropriate for the scope of the address carried in the sin6_addr field. For a link scope sin6_addr sin6_scope_id would be an interface index. For a site scope sin6_addr, sin6_scope_id would be a site identifier. The mapping of sin6_scope_id to an interface or set of interfaces is left to implementation and future specifications on the subject of site identifiers.",
      "zh-CHS": "sin6_scope_id字段是一个32位整数，它根据sin6_addr字段中所携带地址的范围来标识一组接口。对于链接范围sin6_addr sin6_scope_id将是一个接口索引。对于站点范围sin6_addr，sin6_范围id将是站点标识符。sin6_scope_id到接口或接口集的映射留待实现和未来关于站点标识符的规范处理。"
    },
    {
      "indent": 3,
      "text": "Notice that the sockaddr_in6 structure will normally be larger than the generic sockaddr structure. On many existing implementations the sizeof(struct sockaddr_in) equals sizeof(struct sockaddr), with both being 16 bytes. Any existing code that makes this assumption needs to be examined carefully when converting to IPv6.",
      "zh-CHS": "请注意，sockaddr_in6结构通常比一般的sockaddr结构大。在许多现有的实现中，sizeof（struct sockaddr_in）等于sizeof（struct sockaddr），两者都是16字节。在转换到IPv6时，需要仔细检查任何做出此假设的现有代码。"
    },
    {
      "indent": 0,
      "text": "3.4 Socket Address Structure for 4.4BSD-Based Systems",
      "section_title": true,
      "zh-CHS": "3.4 基于4.4BSD系统的套接字地址结构"
    },
    {
      "indent": 3,
      "text": "The 4.4BSD release includes a small, but incompatible change to the socket interface. The \"sa_family\" field of the sockaddr data structure was changed from a 16-bit value to an 8-bit value, and the space saved used to hold a length field, named \"sa_len\". The sockaddr_in6 data structure given in the previous section cannot be correctly cast into the newer sockaddr data structure. For this reason, the following alternative IPv6 address data structure is provided to be used on systems based on 4.4BSD. It is defined as a result of including the <netinet/in.h> header.",
      "zh-CHS": "4.4BSD版本包括对套接字接口的一个小的但不兼容的更改。sockaddr数据结构的“sa_族”字段已从16位值更改为8位值，保存的空间用于保存名为“sa_len”的长度字段。上一节中给出的sockaddr_in6数据结构无法正确转换为较新的sockaddr数据结构。因此，提供了以下替代IPv6地址数据结构，以便在基于4.4BSD的系统上使用。它被定义为包含<netinet/in.h>标题的结果。"
    },
    {
      "indent": 0,
      "text": "struct sockaddr_in6 {\n    uint8_t         sin6_len;       /* length of this struct */\n    sa_family_t     sin6_family;    /* AF_INET6 */\n    in_port_t       sin6_port;      /* transport layer port # */\n    uint32_t        sin6_flowinfo;  /* IPv6 flow information */\n    struct in6_addr sin6_addr;      /* IPv6 address */\n    uint32_t        sin6_scope_id;  /* set of interfaces for a scope */\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The only differences between this data structure and the 4.3BSD variant are the inclusion of the length field, and the change of the family field to a 8-bit data type. The definitions of all the other fields are identical to the structure defined in the previous section.",
      "zh-CHS": "此数据结构与4.3BSD变体之间的唯一区别是包含长度字段，以及将族字段更改为8位数据类型。所有其他字段的定义与上一节中定义的结构相同。"
    },
    {
      "indent": 3,
      "text": "Systems that provide this version of the sockaddr_in6 data structure must also declare SIN6_LEN as a result of including the <netinet/in.h> header. This macro allows applications to determine whether they are being built on a system that supports the 4.3BSD or 4.4BSD variants of the data structure.",
      "zh-CHS": "由于包含<netinet/in.h>头，提供此版本sockaddr_in6数据结构的系统还必须声明SIN6_LEN。此宏允许应用程序确定它们是否构建在支持数据结构的4.3BSD或4.4BSD变体的系统上。"
    },
    {
      "indent": 0,
      "text": "3.5 The Socket Functions",
      "section_title": true,
      "zh-CHS": "3.5 套接字功能"
    },
    {
      "indent": 3,
      "text": "Applications call the socket() function to create a socket descriptor that represents a communication endpoint. The arguments to the socket() function tell the system which protocol to use, and what format address structure will be used in subsequent functions. For example, to create an IPv4/TCP socket, applications make the call:",
      "zh-CHS": "应用程序调用socket（）函数来创建表示通信端点的套接字描述符。socket（）函数的参数告诉系统要使用哪种协议，以及后续函数将使用哪种格式的地址结构。例如，要创建IPv4/TCP套接字，应用程序进行调用："
    },
    {
      "indent": 6,
      "text": "s = socket(PF_INET, SOCK_STREAM, 0);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "To create an IPv4/UDP socket, applications make the call:",
      "zh-CHS": "要创建IPv4/UDP套接字，应用程序将调用："
    },
    {
      "indent": 6,
      "text": "s = socket(PF_INET, SOCK_DGRAM, 0);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Applications may create IPv6/TCP and IPv6/UDP sockets by simply using the constant PF_INET6 instead of PF_INET in the first argument. For example, to create an IPv6/TCP socket, applications make the call:",
      "zh-CHS": "应用程序只需在第一个参数中使用常量PF_INET6而不是PF_INET，就可以创建IPv6/TCP和IPv6/UDP套接字。例如，要创建IPv6/TCP套接字，应用程序进行调用："
    },
    {
      "indent": 6,
      "text": "s = socket(PF_INET6, SOCK_STREAM, 0);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "To create an IPv6/UDP socket, applications make the call:",
      "zh-CHS": "要创建IPv6/UDP套接字，应用程序将调用："
    },
    {
      "indent": 6,
      "text": "s = socket(PF_INET6, SOCK_DGRAM, 0);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Once the application has created a PF_INET6 socket, it must use the sockaddr_in6 address structure when passing addresses in to the system. The functions that the application uses to pass addresses into the system are:",
      "zh-CHS": "应用程序创建PF_INET6套接字后，在向系统传递地址时必须使用sockaddr_in6地址结构。应用程序用于将地址传递到系统的功能包括："
    },
    {
      "indent": 6,
      "text": "bind() connect() sendmsg() sendto()",
      "zh-CHS": "绑定（）连接（）发送消息（）发送到（）"
    },
    {
      "indent": 3,
      "text": "The system will use the sockaddr_in6 address structure to return addresses to applications that are using PF_INET6 sockets. The functions that return an address from the system to an application are:",
      "zh-CHS": "系统将使用sockaddr_in6地址结构将地址返回给使用PF_INET6套接字的应用程序。从系统向应用程序返回地址的功能有："
    },
    {
      "indent": 6,
      "text": "accept() recvfrom() recvmsg() getpeername() getsockname()",
      "zh-CHS": "accept（）recvfrom（）recvmsg（）getpeername（）getsockname（）"
    },
    {
      "indent": 3,
      "text": "No changes to the syntax of the socket functions are needed to support IPv6, since all of the \"address carrying\" functions use an opaque address pointer, and carry an address length as a function argument.",
      "zh-CHS": "支持IPv6不需要更改套接字函数的语法，因为所有“地址承载”函数都使用不透明的地址指针，并将地址长度作为函数参数。"
    },
    {
      "indent": 0,
      "text": "3.6 Compatibility with IPv4 Applications",
      "section_title": true,
      "zh-CHS": "3.6 与IPv4应用程序的兼容性"
    },
    {
      "indent": 3,
      "text": "In order to support the large base of applications using the original API, system implementations must provide complete source and binary compatibility with the original API. This means that systems must continue to support PF_INET sockets and the sockaddr_in address structure. Applications must be able to create IPv4/TCP and IPv4/UDP sockets using the PF_INET constant in the socket() function, as described in the previous section. Applications should be able to hold a combination of IPv4/TCP, IPv4/UDP, IPv6/TCP and IPv6/UDP sockets simultaneously within the same process.",
      "zh-CHS": "为了支持大量使用原始API的应用程序，系统实现必须与原始API提供完整的源代码和二进制兼容性。这意味着系统必须继续支持PF_INET套接字和sockaddr_in地址结构。应用程序必须能够使用socket（）函数中的PF_INET常量创建IPv4/TCP和IPv4/UDP套接字，如前一节所述。应用程序应该能够在同一进程中同时持有IPv4/TCP、IPv4/UDP、IPv6/TCP和IPv6/UDP套接字的组合。"
    },
    {
      "indent": 3,
      "text": "Applications using the original API should continue to operate as they did on systems supporting only IPv4. That is, they should continue to interoperate with IPv4 nodes.",
      "zh-CHS": "使用原始API的应用程序应继续在仅支持IPv4的系统上运行。也就是说，它们应该继续与IPv4节点进行互操作。"
    },
    {
      "indent": 0,
      "text": "3.7 Compatibility with IPv4 Nodes",
      "section_title": true,
      "zh-CHS": "3.7 与IPv4节点的兼容性"
    },
    {
      "indent": 3,
      "text": "The API also provides a different type of compatibility: the ability for IPv6 applications to interoperate with IPv4 applications. This feature uses the IPv4-mapped IPv6 address format defined in the IPv6 addressing architecture specification [2]. This address format",
      "zh-CHS": "API还提供了一种不同类型的兼容性：IPv6应用程序能够与IPv4应用程序进行互操作。此功能使用IPv6寻址体系结构规范[2]中定义的IPv4映射IPv6地址格式。这个地址格式"
    },
    {
      "indent": 3,
      "text": "allows the IPv4 address of an IPv4 node to be represented as an IPv6 address. The IPv4 address is encoded into the low-order 32 bits of the IPv6 address, and the high-order 96 bits hold the fixed prefix 0:0:0:0:0:FFFF. IPv4- mapped addresses are written as follows:",
      "zh-CHS": "允许将IPv4节点的IPv4地址表示为IPv6地址。IPv4地址被编码到IPv6地址的低阶32位，高阶96位保留固定前缀0:0:0:0:FFFF。IPv4映射地址的写入方式如下："
    },
    {
      "indent": 6,
      "text": "::FFFF:<IPv4-address>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "These addresses can be generated automatically by the getipnodebyname() function when the specified host has only IPv4 addresses (as described in Section 6.1).",
      "zh-CHS": "当指定的主机只有IPv4地址时（如第6.1节所述），这些地址可以由getipnodebyname（）函数自动生成。"
    },
    {
      "indent": 3,
      "text": "Applications may use PF_INET6 sockets to open TCP connections to IPv4 nodes, or send UDP packets to IPv4 nodes, by simply encoding the destination's IPv4 address as an IPv4-mapped IPv6 address, and passing that address, within a sockaddr_in6 structure, in the connect() or sendto() call. When applications use PF_INET6 sockets to accept TCP connections from IPv4 nodes, or receive UDP packets from IPv4 nodes, the system returns the peer's address to the application in the accept(), recvfrom(), or getpeername() call using a sockaddr_in6 structure encoded this way.",
      "zh-CHS": "应用程序可以使用PF_INET6套接字打开到IPv4节点的TCP连接，或向IPv4节点发送UDP数据包，只需将目标的IPv4地址编码为IPv4映射的IPv6地址，并在connect（）或sendto（）调用中在sockaddr_in6结构中传递该地址即可。当应用程序使用PF_INET6套接字接受来自IPv4节点的TCP连接，或从IPv4节点接收UDP数据包时，系统使用以这种方式编码的sockaddr_in6结构，在accept（）、recvfrom（）或getpeername（）调用中将对等方的地址返回给应用程序。"
    },
    {
      "indent": 3,
      "text": "Few applications will likely need to know which type of node they are interoperating with. However, for those applications that do need to know, the IN6_IS_ADDR_V4MAPPED() macro, defined in Section 6.7, is provided.",
      "zh-CHS": "很少有应用程序需要知道它们正在与哪种类型的节点进行互操作。但是，对于那些确实需要知道的应用程序，提供了第6.7节中定义的IN6_IS_ADDR_V4MAPPED（）宏。"
    },
    {
      "indent": 0,
      "text": "3.8 IPv6 Wildcard Address",
      "section_title": true,
      "zh-CHS": "3.8 IPv6通配符地址"
    },
    {
      "indent": 3,
      "text": "While the bind() function allows applications to select the source IP address of UDP packets and TCP connections, applications often want the system to select the source address for them. With IPv4, one specifies the address as the symbolic constant INADDR_ANY (called the \"wildcard\" address) in the bind() call, or simply omits the bind() entirely.",
      "zh-CHS": "虽然bind（）函数允许应用程序选择UDP数据包和TCP连接的源IP地址，但应用程序通常希望系统为它们选择源地址。对于IPv4，可以在bind（）调用中将地址指定为符号常量INADDR_ANY（称为“通配符”地址），或者干脆完全忽略bind（）。"
    },
    {
      "indent": 3,
      "text": "Since the IPv6 address type is a structure (struct in6_addr), a symbolic constant can be used to initialize an IPv6 address variable, but cannot be used in an assignment. Therefore systems provide the IPv6 wildcard address in two forms.",
      "zh-CHS": "由于IPv6地址类型是一种结构（struct in6_addr），符号常量可用于初始化IPv6地址变量，但不能用于赋值。因此，系统以两种形式提供IPv6通配符地址。"
    },
    {
      "indent": 3,
      "text": "The first version is a global variable named \"in6addr_any\" that is an in6_addr structure. The extern declaration for this variable is defined in <netinet/in.h>:",
      "zh-CHS": "第一个版本是名为“in6addr_any”的全局变量，它是一个in6_addr结构。此变量的外部声明在<netinet/in.h>中定义："
    },
    {
      "indent": 6,
      "text": "extern const struct in6_addr in6addr_any;",
      "zh-CHS": "6地址中的外部常量结构6地址中的任何地址；"
    },
    {
      "indent": 3,
      "text": "Applications use in6addr_any similarly to the way they use INADDR_ANY in IPv4. For example, to bind a socket to port number 23, but let the system select the source address, an application could use the following code:",
      "zh-CHS": "应用程序使用in6addr\\u any的方式与IPv4中使用INADR\\u any的方式类似。例如，要将套接字绑定到端口号23，但让系统选择源地址，应用程序可以使用以下代码："
    },
    {
      "indent": 6,
      "text": "struct sockaddr_in6 sin6;\n . . .\nsin6.sin6_family = AF_INET6;\nsin6.sin6_flowinfo = 0;\nsin6.sin6_port = htons(23);\nsin6.sin6_addr = in6addr_any;  /* structure assignment */\n . . .\nif (bind(s, (struct sockaddr *) &sin6, sizeof(sin6)) == -1)\n        . . .",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The other version is a symbolic constant named IN6ADDR_ANY_INIT and is defined in <netinet/in.h>. This constant can be used to initialize an in6_addr structure:",
      "zh-CHS": "另一个版本是名为IN6ADDR\\u ANY\\u INIT的符号常量，在<netinet/in.h>中定义。此常量可用于初始化in6_addr结构："
    },
    {
      "indent": 6,
      "text": "struct in6_addr anyaddr = IN6ADDR_ANY_INIT;",
      "zh-CHS": "结构in6\\u addr anyaddr=IN6ADDR\\u ANY\\u INIT；"
    },
    {
      "indent": 3,
      "text": "Note that this constant can be used ONLY at declaration time. It can not be used to assign a previously declared in6_addr structure. For example, the following code will not work:",
      "zh-CHS": "请注意，此常量只能在声明时使用。它不能用于分配以前在6_addr结构中声明的。例如，以下代码将不起作用："
    },
    {
      "indent": 6,
      "text": "/* This is the WRONG way to assign an unspecified address */\nstruct sockaddr_in6 sin6;\n . . .\nsin6.sin6_addr = IN6ADDR_ANY_INIT; /* will NOT compile */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Be aware that the IPv4 INADDR_xxx constants are all defined in host byte order but the IPv6 IN6ADDR_xxx constants and the IPv6 in6addr_xxx externals are defined in network byte order.",
      "zh-CHS": "请注意，IPv4 INADDR_xxx常量都是按主机字节顺序定义的，但IPv6 IN6ADDR_xxx常量和IPv6 IN6ADDR_xxx外部是按网络字节顺序定义的。"
    },
    {
      "indent": 0,
      "text": "3.9 IPv6 Loopback Address",
      "section_title": true,
      "zh-CHS": "3.9 IPv6环回地址"
    },
    {
      "indent": 3,
      "text": "Applications may need to send UDP packets to, or originate TCP connections to, services residing on the local node. In IPv4, they can do this by using the constant IPv4 address INADDR_LOOPBACK in their connect(), sendto(), or sendmsg() call.",
      "zh-CHS": "应用程序可能需要向驻留在本地节点上的服务发送UDP数据包或发起TCP连接。在IPv4中，他们可以通过在connect（）、sendto（）或sendmsg（）调用中使用常量IPv4地址INADDR_环回来实现这一点。"
    },
    {
      "indent": 3,
      "text": "IPv6 also provides a loopback address to contact local TCP and UDP services. Like the unspecified address, the IPv6 loopback address is provided in two forms -- a global variable and a symbolic constant.",
      "zh-CHS": "IPv6还提供一个环回地址来联系本地TCP和UDP服务。与未指定的地址一样，IPv6环回地址以两种形式提供——全局变量和符号常量。"
    },
    {
      "indent": 3,
      "text": "The global variable is an in6_addr structure named \"in6addr_loopback.\" The extern declaration for this variable is defined in <netinet/in.h>:",
      "zh-CHS": "全局变量是名为“in6addr\\u loopback”的in6\\u addr结构。此变量的外部声明在<netinet/in.h>中定义："
    },
    {
      "indent": 6,
      "text": "extern const struct in6_addr in6addr_loopback;",
      "zh-CHS": "6地址6地址环回中的外部常量结构；"
    },
    {
      "indent": 3,
      "text": "Applications use in6addr_loopback as they would use INADDR_LOOPBACK in IPv4 applications (but beware of the byte ordering difference mentioned at the end of the previous section). For example, to open a TCP connection to the local telnet server, an application could use the following code:",
      "zh-CHS": "应用程序使用in6addr_环回，就像在IPv4应用程序中使用INADDR_环回一样（但请注意上一节末尾提到的字节顺序差异）。例如，要打开到本地telnet服务器的TCP连接，应用程序可以使用以下代码："
    },
    {
      "indent": 6,
      "text": "struct sockaddr_in6 sin6;\n . . .\nsin6.sin6_family = AF_INET6;\nsin6.sin6_flowinfo = 0;\nsin6.sin6_port = htons(23);\nsin6.sin6_addr = in6addr_loopback;  /* structure assignment */\n . . .\nif (connect(s, (struct sockaddr *) &sin6, sizeof(sin6)) == -1)\n        . . .",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The symbolic constant is named IN6ADDR_LOOPBACK_INIT and is defined in <netinet/in.h>. It can be used at declaration time ONLY; for example:",
      "zh-CHS": "符号常量在6addr\\u LOOPBACK\\u INIT中命名，并在<netinet/in.h>中定义。只能在申报时使用；例如："
    },
    {
      "indent": 6,
      "text": "struct in6_addr loopbackaddr = IN6ADDR_LOOPBACK_INIT;",
      "zh-CHS": "结构in6\\u addr loopbackaddr=IN6ADDR\\u LOOPBACK\\u INIT；"
    },
    {
      "indent": 3,
      "text": "Like IN6ADDR_ANY_INIT, this constant cannot be used in an assignment to a previously declared IPv6 address variable.",
      "zh-CHS": "与IN6ADDR_ANY_INIT一样，该常量不能用于对先前声明的IPv6地址变量的赋值。"
    },
    {
      "indent": 0,
      "text": "3.10 Portability Additions",
      "section_title": true,
      "zh-CHS": "3.10 可移植性增加"
    },
    {
      "indent": 3,
      "text": "One simple addition to the sockets API that can help application writers is the \"struct sockaddr_storage\". This data structure can simplify writing code portable across multiple address families and platforms. This data structure is designed with the following goals.",
      "zh-CHS": "sockets API的一个简单新增功能是“struct sockaddr_storage”，它可以帮助应用程序编写者。这种数据结构可以简化编写跨多个地址族和平台的可移植代码。此数据结构的设计目标如下。"
    },
    {
      "indent": 6,
      "text": "- It has a large enough implementation specific maximum size to store the desired set of protocol specific socket address data structures. Specifically, it is at least large enough to accommodate sockaddr_in and sockaddr_in6 and possibly other protocol specific socket addresses too. - It is aligned at an appropriate boundary so protocol specific socket address data structure pointers can be cast to it and access their fields without alignment problems. (e.g. pointers to sockaddr_in6 and/or sockaddr_in can be cast to it and access fields without alignment problems).",
      "zh-CHS": "- 它具有足够大的特定于实现的最大大小来存储所需的特定于协议的套接字地址数据结构集。具体来说，它至少足够大，可以容纳sockaddr_in和sockaddr_in 6，还可以容纳其他特定于协议的套接字地址。-它在适当的边界上对齐，因此特定于协议的套接字地址数据结构指针可以强制转换到它并访问它们的字段，而不会出现对齐问题。（例如，指向sockaddr_in 6和/或sockaddr_in的指针可以强制转换到它，访问字段时不会出现对齐问题）。"
    },
    {
      "indent": 6,
      "text": "- It has the initial field(s) isomorphic to the fields of the \"struct sockaddr\" data structure on that implementation which can be used as a discriminants for deriving the protocol in use. These initial field(s) would on most implementations either be a single field of type \"sa_family_t\" (isomorphic to sa_family field, 16 bits) or two fields of type uint8_t and sa_family_t respectively, (isomorphic to sa_len and sa_family_t, 8 bits each).",
      "zh-CHS": "- 它具有与该实现上的“struct sockaddr”数据结构的字段同构的初始字段，该字段可用作派生正在使用的协议的鉴别器。在大多数实现中，这些初始字段要么是“sa_family_t”类型的单个字段（同构于sa_family字段，16位），要么是uint8_t和sa_family_t类型的两个字段（同构于sa_len和sa_family_t，各8位）。"
    },
    {
      "indent": 3,
      "text": "An example implementation design of such a data structure would be as follows.",
      "zh-CHS": "这种数据结构的示例实现设计如下所示。"
    },
    {
      "indent": 0,
      "text": "/*\n * Desired design of maximum size and alignment\n */\n#define _SS_MAXSIZE    128  /* Implementation specific max size */\n#define _SS_ALIGNSIZE  (sizeof (int64_t))\n                         /* Implementation specific desired alignment */\n/*\n * Definitions used for sockaddr_storage structure paddings design.\n */\n#define _SS_PAD1SIZE   (_SS_ALIGNSIZE - sizeof (sa_family_t))\n#define _SS_PAD2SIZE   (_SS_MAXSIZE - (sizeof (sa_family_t)+\n                              _SS_PAD1SIZE + _SS_ALIGNSIZE))\nstruct sockaddr_storage {\n    sa_family_t  __ss_family;     /* address family */\n    /* Following fields are implementation specific */\n    char      __ss_pad1[_SS_PAD1SIZE];\n              /* 6 byte pad, this is to make implementation\n              /* specific pad up to alignment field that */\n              /* follows explicit in the data structure */\n    int64_t   __ss_align;     /* field to force desired structure */\n               /* storage alignment */\n    char      __ss_pad2[_SS_PAD2SIZE];\n              /* 112 byte pad to achieve desired size, */\n              /* _SS_MAXSIZE value minus size of ss_family */\n              /* __ss_pad1, __ss_align fields is 112 */\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "On implementations where sockaddr data structure includes a \"sa_len\", field this data structure would look like this:",
      "zh-CHS": "在sockaddr数据结构包含“sau len”字段的实现中，此数据结构如下所示："
    },
    {
      "indent": 0,
      "text": "/*\n * Definitions used for sockaddr_storage structure paddings design.\n */\n#define _SS_PAD1SIZE (_SS_ALIGNSIZE -\n                            (sizeof (uint8_t) + sizeof (sa_family_t))\n#define _SS_PAD2SIZE (_SS_MAXSIZE - (sizeof (sa_family_t)+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "                              _SS_PAD1SIZE + _SS_ALIGNSIZE))\nstruct sockaddr_storage {\n    uint8_t      __ss_len;        /* address length */\n    sa_family_t  __ss_family;     /* address family */\n    /* Following fields are implementation specific */\n    char         __ss_pad1[_SS_PAD1SIZE];\n                  /* 6 byte pad, this is to make implementation\n                  /* specific pad up to alignment field that */\n                  /* follows explicit in the data structure */\n    int64_t      __ss_align;  /* field to force desired structure */\n                  /* storage alignment */\n    char         __ss_pad2[_SS_PAD2SIZE];\n                  /* 112 byte pad to achieve desired size, */\n                  /* _SS_MAXSIZE value minus size of ss_len, */\n                  /* __ss_family, __ss_pad1, __ss_align fields is 112 */\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The above example implementation illustrates a data structure which\nwill align on a 64 bit boundary. An implementation specific field\n\"__ss_align\" along \"__ss_pad1\" is used to force a 64-bit alignment\nwhich covers proper alignment good enough for needs of sockaddr_in6\n(IPv6), sockaddr_in (IPv4) address data structures.  The size of\npadding fields __ss_pad1 depends on the chosen alignment boundary.\nThe size of padding field __ss_pad2 depends on the value of overall\nsize chosen for the total size of the structure. This size and\nalignment are represented in the above example by implementation\nspecific (not required) constants _SS_MAXSIZE (chosen value 128) and\n_SS_ALIGNMENT (with chosen value 8).  Constants _SS_PAD1SIZE (derived\nvalue 6) and _SS_PAD2SIZE (derived value 112) are also for\nillustration and not required.  The implementation specific\ndefinitions and structure field names above start with an underscore\nto denote implementation private namespace.  Portable code is not\nexpected to access or reference those fields or constants.",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The sockaddr_storage structure solves the problem of declaring storage for automatic variables which is large enough and aligned enough for storing socket address data structure of any family. For example, code with a file descriptor and without the context of the address family can pass a pointer to a variable of this type where a pointer to a socket address structure is expected in calls such as getpeername() and determine the address family by accessing the received content after the call.",
      "zh-CHS": "sockaddru存储结构解决了为自动变量声明存储的问题，该变量足够大且对齐，足以存储任何族的套接字地址数据结构。例如，带有文件描述符但不带地址族上下文的代码可以传递指向此类变量的指针，其中在诸如getpeername（）之类的调用中，预期会有指向套接字地址结构的指针，并通过在调用后访问接收到的内容来确定地址族。"
    },
    {
      "indent": 3,
      "text": "The sockaddr_storage structure may also be useful and applied to certain other interfaces where a generic socket address large enough and aligned for use with multiple address families may be needed. A discussion of those interfaces is outside the scope of this document.",
      "zh-CHS": "sockaddru存储结构也可能很有用，并应用于某些其他接口，其中可能需要足够大的通用套接字地址并与多个地址族对齐。对这些接口的讨论超出了本文件的范围。"
    },
    {
      "indent": 3,
      "text": "Also, much existing code assumes that any socket address structure can fit in a generic sockaddr structure. While this has been true for IPv4 socket address structures, it has always been false for Unix domain socket address structures (but in practice this has not been a problem) and it is also false for IPv6 socket address structures (which can be a problem).",
      "zh-CHS": "此外，许多现有代码都假设任何套接字地址结构都可以适合于一般的sockaddr结构。虽然这对于IPv4套接字地址结构来说是正确的，但对于Unix域套接字地址结构来说总是错误的（但实际上这并不是一个问题），对于IPv6套接字地址结构来说也是错误的（这可能是一个问题）。"
    },
    {
      "indent": 3,
      "text": "So now an application can do the following:",
      "zh-CHS": "因此，现在应用程序可以执行以下操作："
    },
    {
      "indent": 6,
      "text": "struct sockaddr_storage __ss;\nstruct sockaddr_in6 *sin6;\nsin6 = (struct sockaddr_in6 *) &__ss;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "4. Interface Identification",
      "section_title": true,
      "zh-CHS": "4. 接口标识"
    },
    {
      "indent": 3,
      "text": "This API uses an interface index (a small positive integer) to identify the local interface on which a multicast group is joined (Section 5.3). Additionally, the advanced API [4] uses these same interface indexes to identify the interface on which a datagram is received, or to specify the interface on which a datagram is to be sent.",
      "zh-CHS": "此API使用接口索引（一个小的正整数）来标识加入多播组的本地接口（第5.3节）。此外，高级API[4]使用这些相同的接口索引来标识接收数据报的接口，或指定发送数据报的接口。"
    },
    {
      "indent": 3,
      "text": "Interfaces are normally known by names such as \"le0\", \"sl1\", \"ppp2\", and the like. On Berkeley-derived implementations, when an interface is made known to the system, the kernel assigns a unique positive integer value (called the interface index) to that interface. These are small positive integers that start at 1. (Note that 0 is never used for an interface index.) There may be gaps so that there is no current interface for a particular positive interface index.",
      "zh-CHS": "接口通常以诸如“le0”、“sl1”、“ppp2”等名称为人所知。在Berkeley派生的实现中，当系统知道某个接口时，内核会为该接口分配一个唯一的正整数值（称为接口索引）。这些是从1开始的小正整数。（请注意，0从未用于接口索引。）可能存在间隙，因此对于特定的正接口索引，没有当前接口。"
    },
    {
      "indent": 3,
      "text": "This API defines two functions that map between an interface name and index, a third function that returns all the interface names and indexes, and a fourth function to return the dynamic memory allocated by the previous function. How these functions are implemented is left up to the implementation. 4.4BSD implementations can implement these functions using the existing sysctl() function with the NET_RT_IFLIST command. Other implementations may wish to use ioctl() for this purpose.",
      "zh-CHS": "此API定义了两个在接口名称和索引之间映射的函数，第三个函数返回所有接口名称和索引，第四个函数返回前一个函数分配的动态内存。如何实现这些功能取决于实现。4.4BSD实现可以使用现有的sysctl（）函数和NET\\u RT\\u IFLIST命令来实现这些函数。其他实现可能希望为此使用ioctl（）。"
    },
    {
      "indent": 0,
      "text": "4.1 Name-to-Index",
      "section_title": true,
      "zh-CHS": "4.1 要索引的名称"
    },
    {
      "indent": 3,
      "text": "The first function maps an interface name into its corresponding index.",
      "zh-CHS": "第一个函数将接口名称映射到其相应的索引中。"
    },
    {
      "indent": 6,
      "text": "#include <net/if.h>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "unsigned int  if_nametoindex(const char *ifname);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "If the specified interface name does not exist, the return value is 0, and errno is set to ENXIO. If there was a system error (such as running out of memory), the return value is 0 and errno is set to the proper value (e.g., ENOMEM).",
      "zh-CHS": "如果指定的接口名称不存在，则返回值为0，errno设置为ENXIO。如果出现系统错误（例如内存不足），则返回值为0，errno设置为正确的值（例如ENOMEM）。"
    },
    {
      "indent": 0,
      "text": "4.2 Index-to-Name",
      "section_title": true,
      "zh-CHS": "4.2 名称索引"
    },
    {
      "indent": 3,
      "text": "The second function maps an interface index into its corresponding name.",
      "zh-CHS": "第二个函数将接口索引映射到其相应的名称中。"
    },
    {
      "indent": 6,
      "text": "#include <net/if.h>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "char  *if_indextoname(unsigned int ifindex, char *ifname);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The ifname argument must point to a buffer of at least IF_NAMESIZE bytes into which the interface name corresponding to the specified index is returned. (IF_NAMESIZE is also defined in <net/if.h> and its value includes a terminating null byte at the end of the interface name.) This pointer is also the return value of the function. If there is no interface corresponding to the specified index, NULL is returned, and errno is set to ENXIO, if there was a system error (such as running out of memory), if_indextoname returns NULL and errno would be set to the proper value (e.g., ENOMEM).",
      "zh-CHS": "ifname参数必须指向至少为IF_NAMESIZE字节的缓冲区，与指定索引对应的接口名将返回到该缓冲区中。（IF_NAMESIZE也在<net/IF.h>中定义，其值包括接口名称末尾的终止空字节。）此指针也是函数的返回值。如果没有与指定索引对应的接口，则返回NULL，并将errno设置为ENXIO；如果出现系统错误（例如内存不足），则If_indextoname返回NULL，errno将设置为正确的值（例如ENOMEM）。"
    },
    {
      "indent": 0,
      "text": "4.3 Return All Interface Names and Indexes",
      "section_title": true,
      "zh-CHS": "4.3 返回所有接口名称和索引"
    },
    {
      "indent": 3,
      "text": "The if_nameindex structure holds the information about a single interface and is defined as a result of including the <net/if.h> header.",
      "zh-CHS": "if_nameindex结构保存关于单个接口的信息，并定义为包含<net/if.h>头的结果。"
    },
    {
      "indent": 6,
      "text": "struct if_nameindex {\n  unsigned int   if_index;  /* 1, 2, ... */\n  char          *if_name;   /* null terminated name: \"le0\", ... */\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The final function returns an array of if_nameindex structures, one structure per interface.",
      "zh-CHS": "最后一个函数返回一个if_nameindex结构数组，每个接口一个结构。"
    },
    {
      "indent": 6,
      "text": "struct if_nameindex  *if_nameindex(void);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The end of the array of structures is indicated by a structure with an if_index of 0 and an if_name of NULL. The function returns a NULL pointer upon an error, and would set errno to the appropriate value.",
      "zh-CHS": "结构数组的结尾由一个if_索引为0、if_名称为NULL的结构表示。函数在发生错误时返回空指针，并将errno设置为适当的值。"
    },
    {
      "indent": 3,
      "text": "The memory used for this array of structures along with the interface names pointed to by the if_name members is obtained dynamically. This memory is freed by the next function.",
      "zh-CHS": "用于此结构数组的内存以及if_name成员指向的接口名称是动态获取的。此内存由下一个函数释放。"
    },
    {
      "indent": 0,
      "text": "4.4 Free Memory",
      "section_title": true,
      "zh-CHS": "4.4 空闲内存"
    },
    {
      "indent": 3,
      "text": "The following function frees the dynamic memory that was allocated by if_nameindex().",
      "zh-CHS": "以下函数释放由if_nameindex（）分配的动态内存。"
    },
    {
      "indent": 6,
      "text": "#include <net/if.h>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "void  if_freenameindex(struct if_nameindex *ptr);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The argument to this function must be a pointer that was returned by if_nameindex().",
      "zh-CHS": "此函数的参数必须是if_nameindex（）返回的指针。"
    },
    {
      "indent": 3,
      "text": "Currently net/if.h doesn't have prototype definitions for functions and it is recommended that these definitions be defined in net/if.h as well and the struct if_nameindex{}.",
      "zh-CHS": "目前net/if.h没有函数的原型定义，建议在net/if.h和结构if_nameindex{}中也定义这些定义。"
    },
    {
      "indent": 0,
      "text": "5. Socket Options",
      "section_title": true,
      "zh-CHS": "5. 插座选项"
    },
    {
      "indent": 3,
      "text": "A number of new socket options are defined for IPv6. All of these new options are at the IPPROTO_IPV6 level. That is, the \"level\" parameter in the getsockopt() and setsockopt() calls is IPPROTO_IPV6 when using these options. The constant name prefix IPV6_ is used in all of the new socket options. This serves to clearly identify these options as applying to IPv6.",
      "zh-CHS": "为IPv6定义了许多新的套接字选项。所有这些新选项都是IPPROTO_IPV6级别的。也就是说，当使用这些选项时，getsockopt（）和setsockopt（）调用中的“level”参数是IPPROTO_IPV6。所有新套接字选项中都使用了常量名称前缀IPV6_u。这有助于清楚地确定这些选项是否适用于IPv6。"
    },
    {
      "indent": 3,
      "text": "The declaration for IPPROTO_IPV6, the new IPv6 socket options, and related constants defined in this section are obtained by including the header <netinet/in.h>.",
      "zh-CHS": "本节中定义的IPPROTO_IPV6声明、新的IPV6套接字选项和相关常量可通过包含标题<netinet/in.h>获得。"
    },
    {
      "indent": 0,
      "text": "5.1 Unicast Hop Limit",
      "section_title": true,
      "zh-CHS": "5.1 单播跳限制"
    },
    {
      "indent": 3,
      "text": "A new setsockopt() option controls the hop limit used in outgoing unicast IPv6 packets. The name of this option is IPV6_UNICAST_HOPS, and it is used at the IPPROTO_IPV6 layer. The following example illustrates how it is used:",
      "zh-CHS": "新的setsockopt（）选项控制传出单播IPv6数据包中使用的跃点限制。此选项的名称为IPV6_单播_跳，用于IPPROTO_IPV6层。以下示例说明了如何使用它："
    },
    {
      "indent": 6,
      "text": "int hoplimit = 10;",
      "zh-CHS": "int-hopflimit=10；"
    },
    {
      "indent": 6,
      "text": "if (setsockopt(s, IPPROTO_IPV6, IPV6_UNICAST_HOPS,\n               (char *) &hoplimit, sizeof(hoplimit)) == -1)\n    perror(\"setsockopt IPV6_UNICAST_HOPS\");",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "When the IPV6_UNICAST_HOPS option is set with setsockopt(), the option value given is used as the hop limit for all subsequent unicast packets sent via that socket. If the option is not set, the system selects a default value. The integer hop limit value (called x) is interpreted as follows:",
      "zh-CHS": "使用setsockopt（）设置IPV6_UNICAST_HOPS选项时，给定的选项值将用作通过该套接字发送的所有后续单播数据包的跳数限制。如果未设置该选项，系统将选择默认值。整数跃点限制值（称为x）解释如下："
    },
    {
      "indent": 6,
      "text": "x < -1:        return an error of EINVAL\nx == -1:       use kernel default\n0 <= x <= 255: use x\nx >= 256:      return an error of EINVAL",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The IPV6_UNICAST_HOPS option may be used with getsockopt() to determine the hop limit value that the system will use for subsequent unicast packets sent via that socket. For example:",
      "zh-CHS": "IPV6_UNICAST_HOPS选项可与getsockopt（）一起使用，以确定系统将用于通过该套接字发送的后续单播数据包的跃点限制值。例如："
    },
    {
      "indent": 6,
      "text": "int  hoplimit;\nsize_t  len = sizeof(hoplimit);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "if (getsockopt(s, IPPROTO_IPV6, IPV6_UNICAST_HOPS,\n               (char *) &hoplimit, &len) == -1)\n    perror(\"getsockopt IPV6_UNICAST_HOPS\");\nelse\n    printf(\"Using %d for hop limit.\\n\", hoplimit);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "5.2 Sending and Receiving Multicast Packets",
      "section_title": true,
      "zh-CHS": "5.2 发送和接收多播数据包"
    },
    {
      "indent": 3,
      "text": "IPv6 applications may send UDP multicast packets by simply specifying an IPv6 multicast address in the address argument of the sendto() function.",
      "zh-CHS": "IPv6应用程序只需在sendto（）函数的address参数中指定IPv6多播地址，即可发送UDP多播数据包。"
    },
    {
      "indent": 3,
      "text": "Three socket options at the IPPROTO_IPV6 layer control some of the parameters for sending multicast packets. Setting these options is not required: applications may send multicast packets without using these options. The setsockopt() options for controlling the sending of multicast packets are summarized below. These three options can also be used with getsockopt().",
      "zh-CHS": "IPPROTO_IPV6层的三个套接字选项控制发送多播数据包的一些参数。不需要设置这些选项：应用程序可以在不使用这些选项的情况下发送多播数据包。下面总结了用于控制多播数据包发送的setsockopt（）选项。这三个选项也可以与getsockopt（）一起使用。"
    },
    {
      "indent": 6,
      "text": "IPV6_MULTICAST_IF",
      "zh-CHS": "IPV6\\u多播\\u如果"
    },
    {
      "indent": 9,
      "text": "Set the interface to use for outgoing multicast packets. The argument is the index of the interface to use.",
      "zh-CHS": "设置用于传出多播数据包的接口。参数是要使用的接口的索引。"
    },
    {
      "indent": 9,
      "text": "Argument type: unsigned int",
      "zh-CHS": "参数类型：unsigned int"
    },
    {
      "indent": 6,
      "text": "IPV6_MULTICAST_HOPS",
      "zh-CHS": "IPV6\\多播\\跳"
    },
    {
      "indent": 9,
      "text": "Set the hop limit to use for outgoing multicast packets. (Note a separate option - IPV6_UNICAST_HOPS - is provided to set the hop limit to use for outgoing unicast packets.)",
      "zh-CHS": "设置用于传出多播数据包的跃点限制。（注意：提供了一个单独的选项—IPV6_单播_跳数—来设置用于传出单播数据包的跳数限制。）"
    },
    {
      "indent": 9,
      "text": "The interpretation of the argument is the same as for the IPV6_UNICAST_HOPS option:",
      "zh-CHS": "此参数的解释与IPV6_单播_跃点选项的解释相同："
    },
    {
      "indent": 11,
      "text": "x < -1:        return an error of EINVAL\nx == -1:       use kernel default\n0 <= x <= 255: use x\nx >= 256:      return an error of EINVAL",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 11,
      "text": "If IPV6_MULTICAST_HOPS is not set, the default is 1 (same as IPv4 today)",
      "zh-CHS": "如果未设置IPV6\\多播\\跃点，则默认值为1（与今天的IPv4相同）"
    },
    {
      "indent": 9,
      "text": "Argument type: int",
      "zh-CHS": "参数类型：int"
    },
    {
      "indent": 6,
      "text": "IPV6_MULTICAST_LOOP",
      "zh-CHS": "IPV6_多播_循环"
    },
    {
      "indent": 9,
      "text": "If a multicast datagram is sent to a group to which the sending host itself belongs (on the outgoing interface), a copy of the datagram is looped back by the IP layer for local delivery if this option is set to 1. If this option is set to 0 a copy is not looped back. Other option values return an error of EINVAL.",
      "zh-CHS": "如果将多播数据报发送到发送主机本身所属的组（在传出接口上），则如果此选项设置为1，则IP层会将数据报的副本循环回本地传递。如果此选项设置为0，则不会循环回副本。其他选项值返回EINVAL错误。"
    },
    {
      "indent": 9,
      "text": "If IPV6_MULTICAST_LOOP is not set, the default is 1 (loopback; same as IPv4 today).",
      "zh-CHS": "如果未设置IPV6_多播_循环，则默认值为1（环回；与今天的IPv4相同）。"
    },
    {
      "indent": 9,
      "text": "Argument type: unsigned int",
      "zh-CHS": "参数类型：unsigned int"
    },
    {
      "indent": 3,
      "text": "The reception of multicast packets is controlled by the two setsockopt() options summarized below. An error of EOPNOTSUPP is returned if these two options are used with getsockopt().",
      "zh-CHS": "多播数据包的接收由下面总结的两个setsockopt（）选项控制。如果这两个选项与getsockopt（）一起使用，则返回EOPNOTSUPP错误。"
    },
    {
      "indent": 6,
      "text": "IPV6_JOIN_GROUP",
      "zh-CHS": "IPV6\\u加入\\u组"
    },
    {
      "indent": 9,
      "text": "Join a multicast group on a specified local interface. If the interface index is specified as 0, the kernel chooses the local interface. For example, some kernels look up the multicast group in the normal IPv6 routing table and using the resulting interface.",
      "zh-CHS": "在指定的本地接口上加入多播组。如果接口索引指定为0，内核将选择本地接口。例如，一些内核在普通IPv6路由表中查找多播组，并使用生成的接口。"
    },
    {
      "indent": 9,
      "text": "Argument type: struct ipv6_mreq",
      "zh-CHS": "参数类型：结构ipv6\\u mreq"
    },
    {
      "indent": 6,
      "text": "IPV6_LEAVE_GROUP",
      "zh-CHS": "IPV6_离开_组"
    },
    {
      "indent": 9,
      "text": "Leave a multicast group on a specified interface.",
      "zh-CHS": "将多播组保留在指定接口上。"
    },
    {
      "indent": 9,
      "text": "Argument type: struct ipv6_mreq",
      "zh-CHS": "参数类型：结构ipv6\\u mreq"
    },
    {
      "indent": 3,
      "text": "The argument type of both of these options is the ipv6_mreq structure,\ndefined as a result of including the <netinet/in.h> header;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "struct ipv6_mreq {\n    struct in6_addr ipv6mr_multiaddr; /* IPv6 multicast addr */\n    unsigned int    ipv6mr_interface; /* interface index */\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Note that to receive multicast datagrams a process must join the multicast group and bind the UDP port to which datagrams will be sent. Some processes also bind the multicast group address to the socket, in addition to the port, to prevent other datagrams destined to that same port from being delivered to the socket.",
      "zh-CHS": "请注意，要接收多播数据报，进程必须加入多播组并绑定数据报将发送到的UDP端口。除端口外，一些进程还将多播组地址绑定到套接字，以防止发送到同一端口的其他数据报发送到套接字。"
    },
    {
      "indent": 0,
      "text": "6. Library Functions",
      "section_title": true,
      "zh-CHS": "6. 图书馆职能"
    },
    {
      "indent": 3,
      "text": "New library functions are needed to perform a variety of operations with IPv6 addresses. Functions are needed to lookup IPv6 addresses in the Domain Name System (DNS). Both forward lookup (nodename-to-address translation) and reverse lookup (address-to-nodename translation) need to be supported. Functions are also needed to convert IPv6 addresses between their binary and textual form.",
      "zh-CHS": "使用IPv6地址执行各种操作需要新的库函数。在域名系统（DNS）中查找IPv6地址需要函数。需要支持正向查找（节点名到地址转换）和反向查找（地址到节点名转换）。还需要函数在二进制和文本形式之间转换IPv6地址。"
    },
    {
      "indent": 3,
      "text": "We note that the two existing functions, gethostbyname() and gethostbyaddr(), are left as-is. New functions are defined to handle both IPv4 and IPv6 addresses.",
      "zh-CHS": "我们注意到现有的两个函数gethostbyname（）和gethostbyaddr（）保持原样。定义了新函数来处理IPv4和IPv6地址。"
    },
    {
      "indent": 0,
      "text": "6.1 Nodename-to-Address Translation",
      "section_title": true,
      "zh-CHS": "6.1 地址转换的Nodename"
    },
    {
      "indent": 3,
      "text": "The commonly used function gethostbyname() is inadequate for many applications, first because it provides no way for the caller to specify anything about the types of addresses desired (IPv4 only, IPv6 only, IPv4-mapped IPv6 are OK, etc.), and second because many implementations of this function are not thread safe. RFC 2133 defined a function named gethostbyname2() but this function was also inadequate, first because its use required setting a global option (RES_USE_INET6) when IPv6 addresses were required, and second because a flag argument is needed to provide the caller with additional control over the types of addresses required.",
      "zh-CHS": "常用的函数gethostbyname（）对于许多应用程序来说是不够的，首先是因为它无法让调用者指定任何有关所需地址类型的内容（仅IPv4、仅IPv6、IPv4映射的IPv6都可以，等等），其次是因为此函数的许多实现都不是线程安全的。RFC 2133定义了一个名为gethostbyname2（）的函数，但该函数也不充分，首先是因为它的使用需要在需要IPv6地址时设置一个全局选项（RES_use_INET6），其次是因为需要一个标志参数来为调用方提供对所需地址类型的额外控制。"
    },
    {
      "indent": 3,
      "text": "The following function is new and must be thread safe:",
      "zh-CHS": "以下函数是新函数，必须是线程安全的："
    },
    {
      "indent": 3,
      "text": "#include <sys/socket.h>\n#include <netdb.h>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "struct hostent *getipnodebyname(const char *name, int af, int flags\n                                    int *error_num);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The name argument can be either a node name or a numeric address string (i.e., a dotted-decimal IPv4 address or an IPv6 hex address). The af argument specifies the address family, either AF_INET or",
      "zh-CHS": "name参数可以是节点名称或数字地址字符串（即点十进制IPv4地址或IPv6十六进制地址）。af参数指定地址族，可以是af_INET，也可以是"
    },
    {
      "indent": 3,
      "text": "AF_INET6. The error_num value is returned to the caller, via a pointer, with the appropriate error code in error_num, to support thread safe error code returns. error_num will be set to one of the following values:",
      "zh-CHS": "AF_INET6。error_num值通过指针返回给调用方，并在error_num中包含相应的错误代码，以支持线程安全的错误代码返回。error_num将设置为以下值之一："
    },
    {
      "indent": 6,
      "text": "HOST_NOT_FOUND",
      "zh-CHS": "找不到主机"
    },
    {
      "indent": 9,
      "text": "No such host is known.",
      "zh-CHS": "目前还不知道这样的主机。"
    },
    {
      "indent": 6,
      "text": "NO_ADDRESS",
      "zh-CHS": "无地址"
    },
    {
      "indent": 9,
      "text": "The server recognised the request and the name but no address is available. Another type of request to the name server for the domain might return an answer.",
      "zh-CHS": "服务器识别了请求和名称，但没有可用的地址。对域的名称服务器的另一种类型的请求可能会返回答案。"
    },
    {
      "indent": 6,
      "text": "NO_RECOVERY",
      "zh-CHS": "不可恢复"
    },
    {
      "indent": 9,
      "text": "An unexpected server failure occurred which cannot be recovered.",
      "zh-CHS": "发生无法恢复的意外服务器故障。"
    },
    {
      "indent": 6,
      "text": "TRY_AGAIN",
      "zh-CHS": "再试一次"
    },
    {
      "indent": 9,
      "text": "A temporary and possibly transient error occurred, such as a failure of a server to respond.",
      "zh-CHS": "发生了一个临时错误，可能是暂时错误，例如服务器无法响应。"
    },
    {
      "indent": 3,
      "text": "The flags argument specifies the types of addresses that are searched for, and the types of addresses that are returned. We note that a special flags value of AI_DEFAULT (defined below) should handle most applications.",
      "zh-CHS": "flags参数指定搜索的地址类型和返回的地址类型。我们注意到，AI_DEFAULT（定义如下）的特殊标志值应该处理大多数应用程序。"
    },
    {
      "indent": 3,
      "text": "That is, porting simple applications to use IPv6 replaces the call",
      "zh-CHS": "也就是说，移植简单的应用程序以使用IPv6取代了调用"
    },
    {
      "indent": 6,
      "text": "hptr = gethostbyname(name);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "with",
      "zh-CHS": "具有"
    },
    {
      "indent": 6,
      "text": "hptr = getipnodebyname(name, AF_INET6, AI_DEFAULT, &error_num);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "and changes any subsequent error diagnosis code to use error_num instead of externally declared variables, such as h_errno.",
      "zh-CHS": "并将任何后续错误诊断代码更改为使用error_num，而不是外部声明的变量，如h_errno。"
    },
    {
      "indent": 3,
      "text": "Applications desiring finer control over the types of addresses searched for and returned, can specify other combinations of the flags argument.",
      "zh-CHS": "希望更好地控制搜索和返回的地址类型的应用程序可以指定flags参数的其他组合。"
    },
    {
      "indent": 3,
      "text": "A flags of 0 implies a strict interpretation of the af argument:",
      "zh-CHS": "标志为0表示对af参数的严格解释："
    },
    {
      "indent": 6,
      "text": "- If flags is 0 and af is AF_INET, then the caller wants only IPv4 addresses. A query is made for A records. If successful, the IPv4 addresses are returned and the h_length member of the hostent structure will be 4, else the function returns a NULL pointer.",
      "zh-CHS": "- 如果flags为0且af为af_INET，则调用方只需要IPv4地址。对记录进行查询。如果成功，将返回IPv4地址，并且hostent结构的h_长度成员将为4，否则函数将返回空指针。"
    },
    {
      "indent": 6,
      "text": "- If flags is 0 and if af is AF_INET6, then the caller wants only IPv6 addresses. A query is made for AAAA records. If successful, the IPv6 addresses are returned and the h_length member of the hostent structure will be 16, else the function returns a NULL pointer.",
      "zh-CHS": "- 如果flags为0且af为af_INET6，则调用者只需要IPv6地址。查询AAAA记录。如果成功，将返回IPv6地址，并且hostent结构的h_长度成员将为16，否则函数将返回空指针。"
    },
    {
      "indent": 3,
      "text": "Other constants can be logically-ORed into the flags argument, to modify the behavior of the function.",
      "zh-CHS": "其他常量可以逻辑地或入flags参数，以修改函数的行为。"
    },
    {
      "indent": 6,
      "text": "- If the AI_V4MAPPED flag is specified along with an af of AF_INET6, then the caller will accept IPv4-mapped IPv6 addresses. That is, if no AAAA records are found then a query is made for A records and any found are returned as IPv4-mapped IPv6 addresses (h_length will be 16). The AI_V4MAPPED flag is ignored unless af equals AF_INET6.",
      "zh-CHS": "- 如果AI_V4MAPPED标志与af_INET6的af一起指定，则调用者将接受IPv4映射的IPv6地址。也就是说，如果没有找到AAAA记录，则会对a记录进行查询，找到的任何记录都将作为IPv4映射的IPv6地址返回（h_长度将为16）。除非af等于af INET6，否则将忽略AI_V4MAPPED标志。"
    },
    {
      "indent": 6,
      "text": "- The AI_ALL flag is used in conjunction with the AI_V4MAPPED flag, and is only used with the IPv6 address family. When AI_ALL is logically or'd with AI_V4MAPPED flag then the caller wants all addresses: IPv6 and IPv4-mapped IPv6. A query is first made for AAAA records and if successful, the IPv6 addresses are returned. Another query is then made for A records and any found are returned as IPv4-mapped IPv6 addresses. h_length will be 16. Only if both queries fail does the function return a NULL pointer. This flag is ignored unless af equals AF_INET6.",
      "zh-CHS": "- AI_ALL标志与AI_V4MAPPED标志一起使用，并且仅与IPv6地址系列一起使用。当AI_ALL使用AI_V4MAPPED标志进行逻辑or时，调用方需要所有地址：IPv6和IPv4映射IPv6。首先对AAAA记录进行查询，如果查询成功，将返回IPv6地址。然后对记录进行另一个查询，找到的任何记录都将作为IPv4映射的IPv6地址返回。h_长度为16。只有当两个查询都失败时，函数才会返回空指针。除非af等于af_INET6，否则将忽略此标志。"
    },
    {
      "indent": 6,
      "text": "- The AI_ADDRCONFIG flag specifies that a query for AAAA records should occur only if the node has at least one IPv6 source address configured and a query for A records should occur only if the node has at least one IPv4 source address configured.",
      "zh-CHS": "- AI_ADDRCONFIG标志指定仅当节点至少配置了一个IPv6源地址时才应查询AAAA记录，并且仅当节点至少配置了一个IPv4源地址时才应查询记录。"
    },
    {
      "indent": 8,
      "text": "For example, if the node has no IPv6 source addresses configured, and af equals AF_INET6, and the node name being looked up has both AAAA and A records, then:",
      "zh-CHS": "例如，如果节点未配置IPv6源地址，且af等于af_INET6，且正在查找的节点名同时具有AAAA和A记录，则："
    },
    {
      "indent": 12,
      "text": "(a) if only AI_ADDRCONFIG is specified, the function\n    returns a NULL pointer;\n(b) if AI_ADDRCONFIG | AI_V4MAPPED is specified, the A\n    records are returned as IPv4-mapped IPv6 addresses;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The special flags value of AI_DEFAULT is defined as",
      "zh-CHS": "AI_DEFAULT的特殊标志值定义为"
    },
    {
      "indent": 6,
      "text": "#define AI_DEFAULT (AI_V4MAPPED | AI_ADDRCONFIG)",
      "zh-CHS": "#定义AI_默认值（AI_V4MAPPED | AI_ADDRCONFIG）"
    },
    {
      "indent": 3,
      "text": "We noted that the getipnodebyname() function must allow the name argument to be either a node name or a literal address string (i.e., a dotted-decimal IPv4 address or an IPv6 hex address). This saves applications from having to call inet_pton() to handle literal address strings.",
      "zh-CHS": "我们注意到，getipnodebyname（）函数必须允许name参数为节点名或文本地址字符串（即点式十进制IPv4地址或IPv6十六进制地址）。这使应用程序不必调用inet_pton（）来处理文本地址字符串。"
    },
    {
      "indent": 3,
      "text": "There are four scenarios based on the type of literal address string and the value of the af argument.",
      "zh-CHS": "根据文本地址字符串的类型和af参数的值，有四种情况。"
    },
    {
      "indent": 3,
      "text": "The two simple cases are:",
      "zh-CHS": "两个简单的例子是："
    },
    {
      "indent": 3,
      "text": "When name is a dotted-decimal IPv4 address and af equals AF_INET, or when name is an IPv6 hex address and af equals AF_INET6. The members of the returned hostent structure are: h_name points to a copy of the name argument, h_aliases is a NULL pointer, h_addrtype is a copy of the af argument, h_length is either 4 (for AF_INET) or 16 (for AF_INET6), h_addr_list[0] is a pointer to the 4-byte or 16-byte binary address, and h_addr_list[1] is a NULL pointer.",
      "zh-CHS": "当名称是虚线十进制IPv4地址且af等于af_INET时，或当名称是IPv6十六进制地址且af等于af_INET6时。返回的hostent结构的成员是：h_name指向name参数的副本，h_别名是空指针，h_addrtype是af参数的副本，h_length是4（对于af_INET）或16（对于af_INET6），h_addr_list[0]是指向4字节或16字节二进制地址的指针，h_addr_list[1]是空指针。"
    },
    {
      "indent": 3,
      "text": "When name is a dotted-decimal IPv4 address and af equals AF_INET6, and flags equals AI_V4MAPPED, an IPv4-mapped IPv6 address is returned: h_name points to an IPv6 hex address containing the IPv4- mapped IPv6 address, h_aliases is a NULL pointer, h_addrtype is AF_INET6, h_length is 16, h_addr_list[0] is a pointer to the 16-byte binary address, and h_addr_list[1] is a NULL pointer. If AI_V4MAPPED is set (with or without AI_ALL) return IPv4-mapped otherwise return NULL.",
      "zh-CHS": "当名称是虚线十进制IPv4地址，af等于af_INET6，标志等于AI_V4MAPPED时，返回IPv4映射IPv6地址：h_name指向包含IPv4映射IPv6地址的IPv6十六进制地址，h_别名是空指针，h_addrtype是af_INET6，h_长度是16，h_addr_list[0]是指向16字节二进制地址的指针，h_addr_list[1]是一个空指针。如果设置了AI_V4MAPPED（带或不带AI_ALL），则返回IPv4映射，否则返回NULL。"
    },
    {
      "indent": 3,
      "text": "It is an error when name is an IPv6 hex address and af equals AF_INET. The function's return value is a NULL pointer and error_num equals HOST_NOT_FOUND.",
      "zh-CHS": "当名称为IPv6十六进制地址且af等于af_INET时，这是一个错误。该函数的返回值为空指针，错误_num等于主机_NOT _FOUND。"
    },
    {
      "indent": 0,
      "text": "6.2 Address-To-Nodename Translation",
      "section_title": true,
      "zh-CHS": "6.2 地址到节点名转换"
    },
    {
      "indent": 3,
      "text": "The following function has the same arguments as the existing gethostbyaddr() function, but adds an error number.",
      "zh-CHS": "以下函数的参数与现有gethostbyaddr（）函数的参数相同，但添加了一个错误号。"
    },
    {
      "indent": 6,
      "text": "#include <sys/socket.h> #include <netdb.h>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "struct hostent *getipnodebyaddr(const void *src, size_t len,\n                                    int af, int *error_num);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "As with getipnodebyname(), getipnodebyaddr() must be thread safe. The error_num value is returned to the caller with the appropriate error code, to support thread safe error code returns. The following error conditions may be returned for error_num:",
      "zh-CHS": "与getipnodebyname（）一样，GetIPNodeByAddress（）必须是线程安全的。error_num值返回给调用者，并带有适当的错误代码，以支持线程安全的错误代码返回。对于error_num，可能会返回以下错误条件："
    },
    {
      "indent": 6,
      "text": "HOST_NOT_FOUND",
      "zh-CHS": "找不到主机"
    },
    {
      "indent": 9,
      "text": "No such host is known.",
      "zh-CHS": "目前还不知道这样的主机。"
    },
    {
      "indent": 6,
      "text": "NO_ADDRESS",
      "zh-CHS": "无地址"
    },
    {
      "indent": 9,
      "text": "The server recognized the request and the name but no address is available. Another type of request to the name server for the domain might return an answer.",
      "zh-CHS": "服务器识别了请求和名称，但没有可用的地址。对域的名称服务器的另一种类型的请求可能会返回答案。"
    },
    {
      "indent": 6,
      "text": "NO_RECOVERY",
      "zh-CHS": "不可恢复"
    },
    {
      "indent": 9,
      "text": "An unexpected server failure occurred which cannot be recovered.",
      "zh-CHS": "发生无法恢复的意外服务器故障。"
    },
    {
      "indent": 6,
      "text": "TRY_AGAIN",
      "zh-CHS": "再试一次"
    },
    {
      "indent": 9,
      "text": "A temporary and possibly transient error occurred, such as a failure of a server to respond.",
      "zh-CHS": "发生了一个临时错误，可能是暂时错误，例如服务器无法响应。"
    },
    {
      "indent": 3,
      "text": "One possible source of confusion is the handling of IPv4-mapped IPv6 addresses and IPv4-compatible IPv6 addresses, but the following logic should apply.",
      "zh-CHS": "一个可能的混淆源是IPv4映射IPv6地址和IPv4兼容IPv6地址的处理，但以下逻辑应适用。"
    },
    {
      "indent": 6,
      "text": "1. If af is AF_INET6, and if len equals 16, and if the IPv6 address is an IPv4-mapped IPv6 address or an IPv4-compatible IPv6 address, then skip over the first 12 bytes of the IPv6 address, set af to AF_INET, and set len to 4.",
      "zh-CHS": "1. 如果af是af_INET6，len等于16，并且IPv6地址是IPv4映射的IPv6地址或IPv4兼容的IPv6地址，则跳过IPv6地址的前12个字节，将af设置为af_INET，并将len设置为4。"
    },
    {
      "indent": 6,
      "text": "2. If af is AF_INET, lookup the name for the given IPv4 address (e.g., query for a PTR record in the in-addr.arpa domain).",
      "zh-CHS": "2. 如果af是af_INET，则查找给定IPv4地址的名称（例如，在in-addr.arpa域中查询PTR记录）。"
    },
    {
      "indent": 6,
      "text": "3. If af is AF_INET6, lookup the name for the given IPv6 address (e.g., query for a PTR record in the ip6.int domain).",
      "zh-CHS": "3. 如果af是af_INET6，则查找给定IPv6地址的名称（例如，查询ip6.int域中的PTR记录）。"
    },
    {
      "indent": 6,
      "text": "4. If the function is returning success, then the single address that is returned in the hostent structure is a copy of the first argument to the function with the same address family that was passed as an argument to this function.",
      "zh-CHS": "4. 如果函数返回成功，则在hostent结构中返回的单个地址是该函数的第一个参数的副本，其地址族与作为参数传递给该函数的地址族相同。"
    },
    {
      "indent": 3,
      "text": "All four steps listed are performed, in order. Also note that the IPv6 hex addresses \"::\" and \"::1\" MUST NOT be treated as IPv4- compatible addresses, and if the address is \"::\", HOST_NOT_FOUND MUST be returned and a query of the address not performed.",
      "zh-CHS": "按顺序执行列出的所有四个步骤。还请注意，IPv6十六进制地址“：”和“：：1”不得视为IPv4兼容的地址，如果地址为“：”，则必须返回HOST\\u NOT\\u FOUND，并且不执行地址查询。"
    },
    {
      "indent": 3,
      "text": "Also for the macro in section 6.7 IN6_IS_ADDR_V4COMPAT MUST return false for \"::\" and \"::1\".",
      "zh-CHS": "此外，对于第6.7节中的宏，对于“：”和“：：1”，Compat必须返回false。"
    },
    {
      "indent": 0,
      "text": "6.3 Freeing memory for getipnodebyname and getipnodebyaddr",
      "section_title": true,
      "zh-CHS": "6.3 释放getipnodebyname和GetIPNodeByAddress的内存"
    },
    {
      "indent": 3,
      "text": "The hostent structure does not change from its existing definition. This structure, and the information pointed to by this structure, are dynamically allocated by getipnodebyname and getipnodebyaddr. The following function frees this memory:",
      "zh-CHS": "hostent结构不会改变其现有定义。此结构以及此结构指向的信息由getipnodebyname和GetIPNodeByAddress动态分配。以下功能释放此内存："
    },
    {
      "indent": 6,
      "text": "#include <netdb.h>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "void freehostent(struct hostent *ptr);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "6.4 Protocol-Independent Nodename and Service Name Translation",
      "section_title": true,
      "zh-CHS": "6.4 协议无关的节点名和服务名转换"
    },
    {
      "indent": 3,
      "text": "Nodename-to-address translation is done in a protocol-independent fashion using the getaddrinfo() function that is taken from the Institute of Electrical and Electronic Engineers (IEEE) POSIX 1003.1g (Protocol Independent Interfaces) draft specification [3].",
      "zh-CHS": "节点名到地址的转换以协议独立的方式进行，使用getaddrinfo（）函数，该函数取自电气和电子工程师协会（IEEE）POSIX 1003.1g（协议独立接口）规范草案[3]。"
    },
    {
      "indent": 3,
      "text": "The official specification for this function will be the final POSIX standard, with the following additional requirements:",
      "zh-CHS": "此功能的官方规范将是最终POSIX标准，并附带以下附加要求："
    },
    {
      "indent": 6,
      "text": "- getaddrinfo() (along with the getnameinfo() function described in the next section) must be thread safe.",
      "zh-CHS": "- getaddrinfo（）以及下一节中描述的getnameinfo（）函数必须是线程安全的。"
    },
    {
      "indent": 6,
      "text": "- The AI_NUMERICHOST is new with this document.",
      "zh-CHS": "- AI_NUMERICHOST是本文档新增的。"
    },
    {
      "indent": 6,
      "text": "- All fields in socket address structures returned by getaddrinfo() that are not filled in through an explicit argument (e.g., sin6_flowinfo and sin_zero) must be set to 0. (This makes it easier to compare socket address structures.)",
      "zh-CHS": "- getaddrinfo（）返回的套接字地址结构中未通过显式参数填充的所有字段（例如sin6_flowinfo和sin_zero）必须设置为0。（这使得比较套接字地址结构更加容易。）"
    },
    {
      "indent": 6,
      "text": "- getaddrinfo() must fill in the length field of a socket address structure (e.g., sin6_len) on systems that support this field.",
      "zh-CHS": "- 在支持此字段的系统上，getaddrinfo（）必须填写套接字地址结构（例如sin6_len）的长度字段。"
    },
    {
      "indent": 3,
      "text": "We are providing this independent description of the function because POSIX standards are not freely available (as are IETF documents).",
      "zh-CHS": "我们提供此功能的独立描述是因为POSIX标准不是免费提供的（IETF文档也是如此）。"
    },
    {
      "indent": 6,
      "text": "#include <sys/socket.h>\n#include <netdb.h>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "int getaddrinfo(const char *nodename, const char *servname,\n                const struct addrinfo *hints,\n                struct addrinfo **res);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The addrinfo structure is defined as a result of including the <netdb.h> header.",
      "zh-CHS": "addrinfo结构定义为包含<netdb.h>头的结果。"
    },
    {
      "indent": 2,
      "text": "struct addrinfo {\n  int     ai_flags;     /* AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST */\n  int     ai_family;    /* PF_xxx */\n  int     ai_socktype;  /* SOCK_xxx */\n  int     ai_protocol;  /* 0 or IPPROTO_xxx for IPv4 and IPv6 */\n  size_t  ai_addrlen;   /* length of ai_addr */\n  char   *ai_canonname; /* canonical name for nodename */\n  struct sockaddr  *ai_addr; /* binary address */\n  struct addrinfo  *ai_next; /* next structure in linked list */\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The return value from the function is 0 upon success or a nonzero error code. The following names are the nonzero error codes from getaddrinfo(), and are defined in <netdb.h>:",
      "zh-CHS": "函数的返回值在成功时为0或错误代码为非零。以下名称是getaddrinfo（）中的非零错误代码，在<netdb.h>中定义："
    },
    {
      "indent": 6,
      "text": "EAI_ADDRFAMILY address family for nodename not supported EAI_AGAIN temporary failure in name resolution EAI_BADFLAGS invalid value for ai_flags EAI_FAIL non-recoverable failure in name resolution EAI_FAMILY ai_family not supported EAI_MEMORY memory allocation failure EAI_NODATA no address associated with nodename EAI_NONAME nodename nor servname provided, or not known EAI_SERVICE servname not supported for ai_socktype EAI_SOCKTYPE ai_socktype not supported EAI_SYSTEM system error returned in errno",
      "zh-CHS": "不支持节点名称的EAI_addr家庭地址系列EAI_再次临时名称解析失败EAI_BADFLAGS无效ai_标志值EAI_失败不可恢复名称解析失败EAI_家庭ai_系列不支持EAI_内存分配失败EAI_节点数据没有与节点名称EAI_NONAME或servname关联的地址提供的或未知的EAI_服务servname不支持ai_socktype EAI_socktype ai_socktype不支持EAI_系统错误在errno中返回"
    },
    {
      "indent": 3,
      "text": "The nodename and servname arguments are pointers to null-terminated strings or NULL. One or both of these two arguments must be a non-NULL pointer. In the normal client scenario, both the nodename and servname are specified. In the normal server scenario, only the servname is specified. A non-NULL nodename string can be either a node name or a numeric host address string (i.e., a dotted-decimal IPv4 address or an IPv6 hex address). A non-NULL servname string can be either a service name or a decimal port number.",
      "zh-CHS": "nodename和servname参数是指向以null结尾的字符串或null的指针。这两个参数中的一个或两个必须是非空指针。在正常的客户端场景中，节点名和服务名都被指定。在正常服务器场景中，仅指定servname。非空节点名字符串可以是节点名或数字主机地址字符串（即点十进制IPv4地址或IPv6十六进制地址）。非空servname字符串可以是服务名称或十进制端口号。"
    },
    {
      "indent": 3,
      "text": "The caller can optionally pass an addrinfo structure, pointed to by the third argument, to provide hints concerning the type of socket that the caller supports. In this hints structure all members other than ai_flags, ai_family, ai_socktype, and ai_protocol must be zero or a NULL pointer. A value of PF_UNSPEC for ai_family means the",
      "zh-CHS": "调用者可以选择性地传递第三个参数所指向的addrinfo结构，以提供关于调用者支持的套接字类型的提示。在此提示结构中，除ai_标志、ai_族、ai_socktype和ai_协议之外的所有成员都必须为零或空指针。ai_族的PF_Unsec值表示"
    },
    {
      "indent": 3,
      "text": "caller will accept any protocol family. A value of 0 for ai_socktype means the caller will accept any socket type. A value of 0 for ai_protocol means the caller will accept any protocol. For example, if the caller handles only TCP and not UDP, then the ai_socktype member of the hints structure should be set to SOCK_STREAM when getaddrinfo() is called. If the caller handles only IPv4 and not IPv6, then the ai_family member of the hints structure should be set to PF_INET when getaddrinfo() is called. If the third argument to getaddrinfo() is a NULL pointer, this is the same as if the caller had filled in an addrinfo structure initialized to zero with ai_family set to PF_UNSPEC.",
      "zh-CHS": "调用方将接受任何协议族。ai_socktype的值为0表示调用方将接受任何套接字类型。ai_协议的值为0表示调用方将接受任何协议。例如，如果调用方只处理TCP而不处理UDP，则在调用getaddrinfo（）时，提示结构的ai_socktype成员应设置为SOCK_STREAM。如果调用方只处理IPv4而不处理IPv6，则在调用getaddrinfo（）时，提示结构的ai_族成员应设置为PF_INET。如果getaddrinfo（）的第三个参数是空指针，则这与调用方填写的addrinfo结构初始化为零，并且ai_family设置为PF_unsec的情况相同。"
    },
    {
      "indent": 3,
      "text": "Upon successful return a pointer to a linked list of one or more addrinfo structures is returned through the final argument. The caller can process each addrinfo structure in this list by following the ai_next pointer, until a NULL pointer is encountered. In each returned addrinfo structure the three members ai_family, ai_socktype, and ai_protocol are the corresponding arguments for a call to the socket() function. In each addrinfo structure the ai_addr member points to a filled-in socket address structure whose length is specified by the ai_addrlen member.",
      "zh-CHS": "成功返回后，通过最后一个参数返回指向一个或多个addrinfo结构的链接列表的指针。调用者可以通过跟随ai_next指针来处理此列表中的每个addrinfo结构，直到遇到空指针为止。在每个返回的addrinfo结构中，三个成员ai_family、ai_socktype和ai_protocol是调用socket（）函数的相应参数。在每个addrinfo结构中，ai_addr成员指向一个填充的套接字地址结构，其长度由ai_addrlen成员指定。"
    },
    {
      "indent": 3,
      "text": "If the AI_PASSIVE bit is set in the ai_flags member of the hints structure, then the caller plans to use the returned socket address structure in a call to bind(). In this case, if the nodename argument is a NULL pointer, then the IP address portion of the socket address structure will be set to INADDR_ANY for an IPv4 address or IN6ADDR_ANY_INIT for an IPv6 address.",
      "zh-CHS": "如果在提示结构的AI_标志成员中设置了AI_被动位，则调用方计划在对bind（）的调用中使用返回的套接字地址结构。在这种情况下，如果nodename参数是空指针，则套接字地址结构的IP地址部分将被设置为IPv4地址的INADDR_ANY或IPv6地址的IN6ADDR_ANY_INIT。"
    },
    {
      "indent": 3,
      "text": "If the AI_PASSIVE bit is not set in the ai_flags member of the hints structure, then the returned socket address structure will be ready for a call to connect() (for a connection-oriented protocol) or either connect(), sendto(), or sendmsg() (for a connectionless protocol). In this case, if the nodename argument is a NULL pointer, then the IP address portion of the socket address structure will be set to the loopback address.",
      "zh-CHS": "如果提示结构的AI_标志成员中未设置AI_被动位，则返回的套接字地址结构将准备好调用connect（）（对于面向连接的协议）或connect（）、sendto（）或sendmsg（）（对于无连接的协议）。在这种情况下，如果nodename参数是空指针，那么套接字地址结构的IP地址部分将设置为环回地址。"
    },
    {
      "indent": 3,
      "text": "If the AI_CANONNAME bit is set in the ai_flags member of the hints structure, then upon successful return the ai_canonname member of the first addrinfo structure in the linked list will point to a null-terminated string containing the canonical name of the specified nodename.",
      "zh-CHS": "如果在提示结构的AI_标志成员中设置了AI_CANONNAME位，则在成功返回后，链表中第一个addrinfo结构的AI_CANONNAME成员将指向包含指定节点名的规范名的以null结尾的字符串。"
    },
    {
      "indent": 3,
      "text": "If the AI_NUMERICHOST bit is set in the ai_flags member of the hints structure, then a non-NULL nodename string must be a numeric host address string. Otherwise an error of EAI_NONAME is returned. This flag prevents any type of name resolution service (e.g., the DNS) from being called.",
      "zh-CHS": "如果在提示结构的AI_标志成员中设置了AI_NumeriHost位，则非空节点名字符串必须是数字主机地址字符串。否则将返回EAI_NONAME错误。此标志防止调用任何类型的名称解析服务（例如DNS）。"
    },
    {
      "indent": 3,
      "text": "All of the information returned by getaddrinfo() is dynamically allocated: the addrinfo structures, and the socket address structures and canonical node name strings pointed to by the addrinfo structures. To return this information to the system the function freeaddrinfo() is called:",
      "zh-CHS": "getaddrinfo（）返回的所有信息都是动态分配的：addrinfo结构，以及addrinfo结构指向的套接字地址结构和规范节点名字符串。要将此信息返回到系统，调用函数freeaddrinfo（）："
    },
    {
      "indent": 6,
      "text": "#include <sys/socket.h> #include <netdb.h>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "void freeaddrinfo(struct addrinfo *ai);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The addrinfo structure pointed to by the ai argument is freed, along with any dynamic storage pointed to by the structure. This operation is repeated until a NULL ai_next pointer is encountered.",
      "zh-CHS": "将释放ai参数指向的addrinfo结构以及该结构指向的任何动态存储。重复此操作，直到遇到空的ai_下一个指针。"
    },
    {
      "indent": 3,
      "text": "To aid applications in printing error messages based on the EAI_xxx codes returned by getaddrinfo(), the following function is defined.",
      "zh-CHS": "为了帮助应用程序根据getaddrinfo（）返回的EAI_xxx代码打印错误消息，定义了以下函数。"
    },
    {
      "indent": 6,
      "text": "#include <sys/socket.h> #include <netdb.h>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "char *gai_strerror(int ecode);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The argument is one of the EAI_xxx values defined earlier and the return value points to a string describing the error. If the argument is not one of the EAI_xxx values, the function still returns a pointer to a string whose contents indicate an unknown error.",
      "zh-CHS": "参数是前面定义的EAI_xxx值之一，返回值指向描述错误的字符串。如果参数不是EAI_xxx值之一，则函数仍然返回指向字符串的指针，该字符串的内容指示未知错误。"
    },
    {
      "indent": 0,
      "text": "6.5 Socket Address Structure to Nodename and Service Name",
      "section_title": true,
      "zh-CHS": "6.5 节点名和服务名的套接字地址结构"
    },
    {
      "indent": 3,
      "text": "The POSIX 1003.1g specification includes no function to perform the reverse conversion from getaddrinfo(): to look up a nodename and service name, given the binary address and port. Therefore, we define the following function:",
      "zh-CHS": "POSIX 1003.1g规范不包含从getaddrinfo（）执行反向转换的函数：根据二进制地址和端口查找节点名和服务名。因此，我们定义了以下函数："
    },
    {
      "indent": 6,
      "text": "#include <sys/socket.h>\n#include <netdb.h>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "int getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, size_t hostlen, char *serv, size_t servlen, int flags);",
      "zh-CHS": "int getnameinfo（const struct sockaddr*sa、socklen\\u t salen、char*host、size\\u t hostlen、char*serv、size\\u t servlen、int标志）；"
    },
    {
      "indent": 3,
      "text": "This function looks up an IP address and port number provided by the caller in the DNS and system-specific database, and returns text strings for both in buffers provided by the caller. The function indicates successful completion by a zero return value; a non-zero return value indicates failure.",
      "zh-CHS": "此函数在DNS和特定于系统的数据库中查找调用者提供的IP地址和端口号，并在调用者提供的缓冲区中返回这两者的文本字符串。该函数以零返回值表示成功完成；非零返回值表示失败。"
    },
    {
      "indent": 3,
      "text": "The first argument, sa, points to either a sockaddr_in structure (for IPv4) or a sockaddr_in6 structure (for IPv6) that holds the IP address and port number. The salen argument gives the length of the sockaddr_in or sockaddr_in6 structure.",
      "zh-CHS": "第一个参数sa指向保存IP地址和端口号的sockaddr_in结构（对于IPv4）或sockaddr_in 6结构（对于IPv6）。salen参数给出了sockaddr_in或sockaddr_in 6结构的长度。"
    },
    {
      "indent": 3,
      "text": "The function returns the nodename associated with the IP address in the buffer pointed to by the host argument. The caller provides the size of this buffer via the hostlen argument. The service name associated with the port number is returned in the buffer pointed to by serv, and the servlen argument gives the length of this buffer. The caller specifies not to return either string by providing a zero value for the hostlen or servlen arguments. Otherwise, the caller must provide buffers large enough to hold the nodename and the service name, including the terminating null characters.",
      "zh-CHS": "函数返回与主机参数指向的缓冲区中的IP地址关联的节点名。调用者通过hostlen参数提供此缓冲区的大小。与端口号关联的服务名称在serv指向的缓冲区中返回，servlen参数给出该缓冲区的长度。调用方通过为hostlen或servlen参数提供零值来指定不返回任何字符串。否则，调用方必须提供足够大的缓冲区来容纳节点名和服务名，包括终止的空字符。"
    },
    {
      "indent": 3,
      "text": "Unfortunately most systems do not provide constants that specify the maximum size of either a fully-qualified domain name or a service name. Therefore to aid the application in allocating buffers for these two returned strings the following constants are defined in <netdb.h>:",
      "zh-CHS": "不幸的是，大多数系统都不提供常量来指定完全限定域名或服务名的最大大小。因此，为了帮助应用程序为这两个返回字符串分配缓冲区，<netdb.h>中定义了以下常量："
    },
    {
      "indent": 6,
      "text": "#define NI_MAXHOST 1025 #define NI_MAXSERV 32",
      "zh-CHS": "#定义NI_MAXHOST 1025#定义NI_MAXSERV 32"
    },
    {
      "indent": 3,
      "text": "The first value is actually defined as the constant MAXDNAME in recent versions of BIND's <arpa/nameser.h> header (older versions of BIND define this constant to be 256) and the second is a guess based on the services listed in the current Assigned Numbers RFC.",
      "zh-CHS": "在BIND的<arpa/nameser.h>头的最新版本（旧版本的BIND将此常量定义为256）中，第一个值实际上定义为常量MAXDNAME，第二个值是基于当前分配的编号RFC中列出的服务的猜测。"
    },
    {
      "indent": 3,
      "text": "The final argument is a flag that changes the default actions of this function. By default the fully-qualified domain name (FQDN) for the host is looked up in the DNS and returned. If the flag bit NI_NOFQDN is set, only the nodename portion of the FQDN is returned for local hosts.",
      "zh-CHS": "最后一个参数是更改此函数默认操作的标志。默认情况下，将在DNS中查找并返回主机的完全限定域名（FQDN）。如果设置了标志位NI_NOFQDN，则对于本地主机，仅返回FQDN的节点名部分。"
    },
    {
      "indent": 3,
      "text": "If the flag bit NI_NUMERICHOST is set, or if the host's name cannot be located in the DNS, the numeric form of the host's address is returned instead of its name (e.g., by calling inet_ntop() instead of getipnodebyaddr()). If the flag bit NI_NAMEREQD is set, an error is returned if the host's name cannot be located in the DNS.",
      "zh-CHS": "如果设置了标志位NI_numeriCost，或者如果DNS中找不到主机名，则返回主机地址的数字形式而不是其名称（例如，通过调用inet_ntop（）而不是getipnodebyaddr（））。如果设置了标志位NI_NAMEREQD，则如果在DNS中找不到主机名，则返回错误。"
    },
    {
      "indent": 3,
      "text": "If the flag bit NI_NUMERICSERV is set, the numeric form of the service address is returned (e.g., its port number) instead of its name. The two NI_NUMERICxxx flags are required to support the \"-n\" flag that many commands provide.",
      "zh-CHS": "如果设置了标志位NI_NUMERICSERV，则返回服务地址的数字形式（例如，其端口号），而不是其名称。需要两个NI_NUMERICxxx标志来支持许多命令提供的“-n”标志。"
    },
    {
      "indent": 3,
      "text": "A fifth flag bit, NI_DGRAM, specifies that the service is a datagram service, and causes getservbyport() to be called with a second argument of \"udp\" instead of its default of \"tcp\". This is required for the few ports (e.g. 512-514) that have different services for UDP and TCP.",
      "zh-CHS": "第五个标志位NI_DGRAM指定该服务是一个数据报服务，并导致使用第二个参数“udp”而不是其默认值“tcp”调用getservbyport（）。对于为UDP和TCP提供不同服务的少数端口（例如512-514），这是必需的。"
    },
    {
      "indent": 3,
      "text": "These NI_xxx flags are defined in <netdb.h> along with the AI_xxx flags already defined for getaddrinfo().",
      "zh-CHS": "这些NI_xxx标志与已经为getaddrinfo（）定义的AI_xxx标志一起在<netdb.h>中定义。"
    },
    {
      "indent": 0,
      "text": "6.6 Address Conversion Functions",
      "section_title": true,
      "zh-CHS": "6.6 地址转换函数"
    },
    {
      "indent": 3,
      "text": "The two functions inet_addr() and inet_ntoa() convert an IPv4 address between binary and text form. IPv6 applications need similar functions. The following two functions convert both IPv6 and IPv4 addresses:",
      "zh-CHS": "两个函数inet_addr（）和inet_ntoa（）在二进制和文本形式之间转换IPv4地址。IPv6应用程序需要类似的功能。以下两个函数用于转换IPv6和IPv4地址："
    },
    {
      "indent": 6,
      "text": "#include <sys/socket.h>\n#include <arpa/inet.h>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "int inet_pton(int af, const char *src, void *dst);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "const char *inet_ntop(int af, const void *src,\n                      char *dst, size_t size);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The inet_pton() function converts an address in its standard text presentation form into its numeric binary form. The af argument specifies the family of the address. Currently the AF_INET and AF_INET6 address families are supported. The src argument points to the string being passed in. The dst argument points to a buffer into which the function stores the numeric address. The address is returned in network byte order. Inet_pton() returns 1 if the conversion succeeds, 0 if the input is not a valid IPv4 dotted-decimal string or a valid IPv6 address string, or -1 with errno set to EAFNOSUPPORT if the af argument is unknown. The calling application must ensure that the buffer referred to by dst is large enough to hold the numeric address (e.g., 4 bytes for AF_INET or 16 bytes for AF_INET6).",
      "zh-CHS": "函数的作用是：将标准文本表示形式的地址转换为数字二进制形式。af参数指定地址族。目前支持AF_INET和AF_INET6地址系列。src参数指向传入的字符串。dst参数指向函数存储数字地址的缓冲区。地址以网络字节顺序返回。如果转换成功，Inet_pton（）将返回1；如果输入不是有效的IPv4虚线十进制字符串或有效的IPv6地址字符串，则返回0；如果af参数未知，则返回-1，并将errno设置为EAFNOSUPPORT。调用应用程序必须确保dst引用的缓冲区足够大，以容纳数字地址（例如，4字节用于AF_INET，16字节用于AF_INET6）。"
    },
    {
      "indent": 3,
      "text": "If the af argument is AF_INET, the function accepts a string in the standard IPv4 dotted-decimal form:",
      "zh-CHS": "如果af参数为af_INET，则函数接受标准十进制形式的字符串："
    },
    {
      "indent": 6,
      "text": "ddd.ddd.ddd.ddd",
      "zh-CHS": "ddd.ddd.ddd.ddd"
    },
    {
      "indent": 3,
      "text": "where ddd is a one to three digit decimal number between 0 and 255. Note that many implementations of the existing inet_addr() and inet_aton() functions accept nonstandard input: octal numbers, hexadecimal numbers, and fewer than four numbers. inet_pton() does not accept these formats.",
      "zh-CHS": "其中，ddd是介于0和255之间的一到三位十进制数。请注意，现有inet_addr（）和inet_aton（）函数的许多实现都接受非标准输入：八进制数、十六进制数和少于四个数。inet_pton（）不接受这些格式。"
    },
    {
      "indent": 3,
      "text": "If the af argument is AF_INET6, then the function accepts a string in one of the standard IPv6 text forms defined in Section 2.2 of the addressing architecture specification [2].",
      "zh-CHS": "如果af参数是af_INET6，则函数接受寻址体系结构规范[2]第2.2节中定义的标准IPv6文本形式之一的字符串。"
    },
    {
      "indent": 3,
      "text": "The inet_ntop() function converts a numeric address into a text string suitable for presentation. The af argument specifies the family of the address. This can be AF_INET or AF_INET6. The src argument points to a buffer holding an IPv4 address if the af argument is AF_INET, or an IPv6 address if the af argument is AF_INET6, the address must be in network byte order. The dst argument points to a buffer where the function will store the resulting text string. The size argument specifies the size of this buffer. The application must specify a non-NULL dst argument. For IPv6 addresses, the buffer must be at least 46-octets. For IPv4 addresses, the buffer must be at least 16-octets. In order to allow applications to easily declare buffers of the proper size to store IPv4 and IPv6 addresses in string form, the following two constants are defined in <netinet/in.h>:",
      "zh-CHS": "函数的作用是：将数字地址转换为适合显示的文本字符串。af参数指定地址族。这可以是AF_INET或AF_INET6。src参数指向保存IPv4地址的缓冲区（如果af参数为af_INET），或者IPv6地址（如果af参数为af_INET6），则地址必须按网络字节顺序排列。dst参数指向一个缓冲区，函数将在其中存储生成的文本字符串。size参数指定此缓冲区的大小。应用程序必须指定非空dst参数。对于IPv6地址，缓冲区必须至少为46个八位字节。对于IPv4地址，缓冲区必须至少为16个八位字节。为了使应用程序能够轻松声明适当大小的缓冲区，以字符串形式存储IPv4和IPv6地址，在<netinet/In.h>中定义了以下两个常量："
    },
    {
      "indent": 6,
      "text": "#define INET_ADDRSTRLEN 16 #define INET6_ADDRSTRLEN 46",
      "zh-CHS": "#定义INET_ADDRSTRLEN 16#定义INET6_ADDRSTRLEN 46"
    },
    {
      "indent": 3,
      "text": "The inet_ntop() function returns a pointer to the buffer containing the text string if the conversion succeeds, and NULL otherwise. Upon failure, errno is set to EAFNOSUPPORT if the af argument is invalid or ENOSPC if the size of the result buffer is inadequate.",
      "zh-CHS": "如果转换成功，则inet_ntop（）函数返回一个指向包含文本字符串的缓冲区的指针，否则返回NULL。失败时，如果af参数无效，errno设置为EAFNOSUPPORT；如果结果缓冲区的大小不足，errno设置为ENOSPC。"
    },
    {
      "indent": 0,
      "text": "6.7 Address Testing Macros",
      "section_title": true,
      "zh-CHS": "6.7 地址测试宏"
    },
    {
      "indent": 3,
      "text": "The following macros can be used to test for special IPv6 addresses.",
      "zh-CHS": "以下宏可用于测试特殊IPv6地址。"
    },
    {
      "indent": 6,
      "text": "#include <netinet/in.h>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "int  IN6_IS_ADDR_UNSPECIFIED (const struct in6_addr *);\nint  IN6_IS_ADDR_LOOPBACK    (const struct in6_addr *);\nint  IN6_IS_ADDR_MULTICAST   (const struct in6_addr *);\nint  IN6_IS_ADDR_LINKLOCAL   (const struct in6_addr *);\nint  IN6_IS_ADDR_SITELOCAL   (const struct in6_addr *);\nint  IN6_IS_ADDR_V4MAPPED    (const struct in6_addr *);\nint  IN6_IS_ADDR_V4COMPAT    (const struct in6_addr *);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "int  IN6_IS_ADDR_MC_NODELOCAL(const struct in6_addr *);\nint  IN6_IS_ADDR_MC_LINKLOCAL(const struct in6_addr *);\nint  IN6_IS_ADDR_MC_SITELOCAL(const struct in6_addr *);\nint  IN6_IS_ADDR_MC_ORGLOCAL (const struct in6_addr *);\nint  IN6_IS_ADDR_MC_GLOBAL   (const struct in6_addr *);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The first seven macros return true if the address is of the specified type, or false otherwise. The last five test the scope of a multicast address and return true if the address is a multicast address of the specified scope or false if the address is either not a multicast address or not of the specified scope. Note that IN6_IS_ADDR_LINKLOCAL and IN6_IS_ADDR_SITELOCAL return true only for the two local-use IPv6 unicast addresses. These two macros do not return true for IPv6 multicast addresses of either link-local scope or site-local scope.",
      "zh-CHS": "如果地址为指定类型，则前七个宏返回true，否则返回false。最后五个测试多播地址的范围，如果地址是指定范围的多播地址，则返回true；如果地址不是多播地址或不属于指定范围，则返回false。请注意，IN6_IS_ADDR_LINKLOCAL和IN6_IS_ADDR_SITELOCAL仅对两个本地使用IPv6单播地址返回true。对于链路本地作用域或站点本地作用域的IPv6多播地址，这两个宏都不会返回true。"
    },
    {
      "indent": 0,
      "text": "7. Summary of New Definitions",
      "section_title": true,
      "zh-CHS": "7. 新定义摘要"
    },
    {
      "indent": 3,
      "text": "The following list summarizes the constants, structure, and extern definitions discussed in this memo, sorted by header.",
      "zh-CHS": "以下列表总结了本备忘录中讨论的常量、结构和外部定义，并按标题排序。"
    },
    {
      "indent": 6,
      "text": "<net/if.h>      IF_NAMESIZE\n<net/if.h>      struct if_nameindex{};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "<netdb.h>       AI_ADDRCONFIG\n<netdb.h>       AI_DEFAULT\n<netdb.h>       AI_ALL\n<netdb.h>       AI_CANONNAME\n<netdb.h>       AI_NUMERICHOST\n<netdb.h>       AI_PASSIVE\n<netdb.h>       AI_V4MAPPED\n<netdb.h>       EAI_ADDRFAMILY\n<netdb.h>       EAI_AGAIN\n<netdb.h>       EAI_BADFLAGS\n<netdb.h>       EAI_FAIL\n<netdb.h>       EAI_FAMILY\n<netdb.h>       EAI_MEMORY\n<netdb.h>       EAI_NODATA\n<netdb.h>       EAI_NONAME\n<netdb.h>       EAI_SERVICE\n<netdb.h>       EAI_SOCKTYPE\n<netdb.h>       EAI_SYSTEM\n<netdb.h>       NI_DGRAM\n<netdb.h>       NI_MAXHOST\n<netdb.h>       NI_MAXSERV\n<netdb.h>       NI_NAMEREQD\n<netdb.h>       NI_NOFQDN\n<netdb.h>       NI_NUMERICHOST\n<netdb.h>       NI_NUMERICSERV\n<netdb.h>       struct addrinfo{};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "<netinet/in.h>  IN6ADDR_ANY_INIT\n<netinet/in.h>  IN6ADDR_LOOPBACK_INIT\n<netinet/in.h>  INET6_ADDRSTRLEN",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "<netinet/in.h>  INET_ADDRSTRLEN\n<netinet/in.h>  IPPROTO_IPV6\n<netinet/in.h>  IPV6_JOIN_GROUP\n<netinet/in.h>  IPV6_LEAVE_GROUP\n<netinet/in.h>  IPV6_MULTICAST_HOPS\n<netinet/in.h>  IPV6_MULTICAST_IF\n<netinet/in.h>  IPV6_MULTICAST_LOOP\n<netinet/in.h>  IPV6_UNICAST_HOPS\n<netinet/in.h>  SIN6_LEN\n<netinet/in.h>  extern const struct in6_addr in6addr_any;\n<netinet/in.h>  extern const struct in6_addr in6addr_loopback;\n<netinet/in.h>  struct in6_addr{};\n<netinet/in.h>  struct ipv6_mreq{};\n<netinet/in.h>  struct sockaddr_in6{};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "<sys/socket.h>  AF_INET6\n<sys/socket.h>  PF_INET6\n<sys/socket.h>  struct sockaddr_storage;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The following list summarizes the function and macro prototypes discussed in this memo, sorted by header.",
      "zh-CHS": "下表总结了本备忘录中讨论的功能和宏原型，按标题排序。"
    },
    {
      "indent": 0,
      "text": "<arpa/inet.h>   int inet_pton(int, const char *, void *);\n<arpa/inet.h>   const char *inet_ntop(int, const void *,\n                                      char *, size_t);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "<net/if.h>      char *if_indextoname(unsigned int, char *);\n<net/if.h>      unsigned int if_nametoindex(const char *);\n<net/if.h>      void if_freenameindex(struct if_nameindex *);\n<net/if.h>      struct if_nameindex *if_nameindex(void);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "<netdb.h>       int getaddrinfo(const char *, const char *,\n                                const struct addrinfo *,\n                                struct addrinfo **);\n<netdb.h>       int getnameinfo(const struct sockaddr *, socklen_t,\n                                char *, size_t, char *, size_t, int);\n<netdb.h>       void freeaddrinfo(struct addrinfo *);\n<netdb.h>       char *gai_strerror(int);\n<netdb.h>       struct hostent *getipnodebyname(const char *, int, int,\n                                       int *);\n<netdb.h>       struct hostent *getipnodebyaddr(const void *, size_t,\n                                       int, int *);\n<netdb.h>       void freehostent(struct hostent *);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "<netinet/in.h>  int IN6_IS_ADDR_LINKLOCAL(const struct in6_addr *);\n<netinet/in.h>  int IN6_IS_ADDR_LOOPBACK(const struct in6_addr *);\n<netinet/in.h>  int IN6_IS_ADDR_MC_GLOBAL(const struct in6_addr *);\n<netinet/in.h>  int IN6_IS_ADDR_MC_LINKLOCAL(const struct in6_addr *);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "<netinet/in.h>  int IN6_IS_ADDR_MC_NODELOCAL(const struct in6_addr *);\n<netinet/in.h>  int IN6_IS_ADDR_MC_ORGLOCAL(const struct in6_addr *);\n<netinet/in.h>  int IN6_IS_ADDR_MC_SITELOCAL(const struct in6_addr *);\n<netinet/in.h>  int IN6_IS_ADDR_MULTICAST(const struct in6_addr *);\n<netinet/in.h>  int IN6_IS_ADDR_SITELOCAL(const struct in6_addr *);\n<netinet/in.h>  int IN6_IS_ADDR_UNSPECIFIED(const struct in6_addr *);\n<netinet/in.h>  int IN6_IS_ADDR_V4COMPAT(const struct in6_addr *);\n<netinet/in.h>  int IN6_IS_ADDR_V4MAPPED(const struct in6_addr *);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "zh-CHS": "8. 安全考虑"
    },
    {
      "indent": 3,
      "text": "IPv6 provides a number of new security mechanisms, many of which need to be accessible to applications. Companion memos detailing the extensions to the socket interfaces to support IPv6 security are being written.",
      "zh-CHS": "IPv6提供了许多新的安全机制，其中许多机制需要应用程序可以访问。正在编写配套备忘录，详细说明支持IPv6安全的套接字接口扩展。"
    },
    {
      "indent": 0,
      "text": "9. Year 2000 Considerations",
      "section_title": true,
      "zh-CHS": "9. 2000年的考虑"
    },
    {
      "indent": 3,
      "text": "There are no issues for this memo concerning the Year 2000 issue regarding the use of dates.",
      "zh-CHS": "本备忘录不涉及日期使用方面的2000年问题。"
    },
    {
      "indent": 0,
      "text": "Changes From RFC 2133",
      "zh-CHS": "RFC 2133的变更"
    },
    {
      "indent": 3,
      "text": "Changes made in the March 1998 Edition (-01 draft):",
      "zh-CHS": "1998年3月版（-01草案）中所做的更改："
    },
    {
      "indent": 6,
      "text": "Changed all \"hostname\" to \"nodename\" for consistency with other IPv6 documents.",
      "zh-CHS": "为了与其他IPv6文档保持一致，将所有“主机名”更改为“节点名”。"
    },
    {
      "indent": 6,
      "text": "Section 3.3: changed comment for sin6_flowinfo to be \"traffic class & flow info\" and updated corresponding text description to current definition of these two fields.",
      "zh-CHS": "第3.3节：将sin6_flowinfo的注释更改为“交通等级和流量信息”，并将相应的文本描述更新为这两个字段的当前定义。"
    },
    {
      "indent": 6,
      "text": "Section 3.10 (\"Portability Additions\") is new.",
      "zh-CHS": "第3.10节（“便携性增加”）是新的。"
    },
    {
      "indent": 6,
      "text": "Section 6: a new paragraph was added reiterating that the existing gethostbyname() and gethostbyaddr() are not changed.",
      "zh-CHS": "第6节：添加了一个新段落，重申现有的gethostbyname（）和gethostbyaddr（）没有更改。"
    },
    {
      "indent": 6,
      "text": "Section 6.1: change gethostbyname3() to getnodebyname(). Add AI_DEFAULT to handle majority of applications. Renamed AI_V6ADDRCONFIG to AI_ADDRCONFIG and define it for A records and IPv4 addresses too. Defined exactly what getnodebyname() must return if the name argument is a numeric address string.",
      "zh-CHS": "第6.1节：将gethostbyname3（）更改为getnodebyname（）。添加AI_默认值以处理大多数应用程序。将AI_V6ADDRCONFIG重命名为AI_ADDRCONFIG，并为记录和IPv4地址定义它。定义了如果name参数是数字地址字符串，则getnodebyname（）必须返回的内容。"
    },
    {
      "indent": 6,
      "text": "Section 6.2: change gethostbyaddr() to getnodebyaddr(). Reword items 2 and 3 in the description of how to handle IPv4-mapped and IPv4- compatible addresses to \"lookup a name\" for a given address, instead of specifying what type of DNS query to issue.",
      "zh-CHS": "第6.2节：将gethostbyaddr（）更改为getnodebyaddr（）。将如何处理IPv4映射和IPv4兼容地址的说明中的第2项和第3项改写为“查找给定地址的名称”，而不是指定要发出的DNS查询类型。"
    },
    {
      "indent": 6,
      "text": "Section 6.3: added two more requirements to getaddrinfo().",
      "zh-CHS": "第6.3节：在getaddrinfo（）中增加了两个要求。"
    },
    {
      "indent": 6,
      "text": "Section 7: added the following constants to the list for <netdb.h>: AI_ADDRCONFIG, AI_ALL, and AI_V4MAPPED. Add union sockaddr_union and SA_LEN to the lists for <sys/socket.h>.",
      "zh-CHS": "第7节：将以下常量添加到<netdb.h>的列表中：AI_ADDRCONFIG、AI_ALL和AI_V4MAPPED。将union sockaddr\\u union和sau LEN添加到<sys/socket.h>的列表中。"
    },
    {
      "indent": 6,
      "text": "Updated references.",
      "zh-CHS": "更新参考资料。"
    },
    {
      "indent": 3,
      "text": "Changes made in the November 1997 Edition (-00 draft):",
      "zh-CHS": "1997年11月版（-00草稿）中的更改："
    },
    {
      "indent": 6,
      "text": "The data types have been changed to conform with Draft 6.6 of the Posix 1003.1g standard.",
      "zh-CHS": "数据类型已更改，以符合Posix 1003.1g标准草案6.6。"
    },
    {
      "indent": 6,
      "text": "Section 3.2: data type of s6_addr changed to \"uint8_t\".",
      "zh-CHS": "第3.2节：s6地址的数据类型更改为“uint8”。"
    },
    {
      "indent": 6,
      "text": "Section 3.3: data type of sin6_family changed to \"sa_family_t\". data type of sin6_port changed to \"in_port_t\", data type of sin6_flowinfo changed to \"uint32_t\".",
      "zh-CHS": "第3.3节：sin6_系列的数据类型更改为“sa_系列”。sin6_端口的数据类型更改为“in_port_t”，sin6_flowinfo的数据类型更改为“uint32_t”。"
    },
    {
      "indent": 6,
      "text": "Section 3.4: same as Section 3.3, plus data type of sin6_len changed to \"uint8_t\".",
      "zh-CHS": "第3.4节：与第3.3节相同，加上sin6_len的数据类型更改为“uint8_t”。"
    },
    {
      "indent": 6,
      "text": "Section 6.2: first argument of gethostbyaddr() changed from \"const char *\" to \"const void *\" and second argument changed from \"int\" to \"size_t\".",
      "zh-CHS": "第6.2节：gethostbyaddr（）的第一个参数从“const char*”更改为“const void*”，第二个参数从“int”更改为“size\\t”。"
    },
    {
      "indent": 6,
      "text": "Section 6.4: second argument of getnameinfo() changed from \"size_t\" to \"socklen_t\".",
      "zh-CHS": "第6.4节：getnameinfo（）的第二个参数从“size\\u t”更改为“socklen\\u t”。"
    },
    {
      "indent": 6,
      "text": "The wording was changed when new structures were defined, to be more explicit as to which header must be included to define the structure:",
      "zh-CHS": "定义新结构时，措辞发生了变化，以便更明确地说明定义结构时必须包括哪些标题："
    },
    {
      "indent": 6,
      "text": "Section 3.2 (in6_addr{}), Section 3.3 (sockaddr_in6{}), Section 3.4 (sockaddr_in6{}), Section 4.3 (if_nameindex{}), Section 5.3 (ipv6_mreq{}), and Section 6.3 (addrinfo{}).",
      "zh-CHS": "第3.2节（in6_-addr{}）、第3.3节（sockaddr_-in6{}）、第3.4节（sockaddr{u-in6}）、第4.3节（if_-nameindex{}）、第5.3节（ipv6_-mreq{}）和第6.3节（addrinfo{}）。"
    },
    {
      "indent": 6,
      "text": "Section 4: NET_RT_LIST changed to NET_RT_IFLIST.",
      "zh-CHS": "第4节：网络列表更改为网络列表。"
    },
    {
      "indent": 6,
      "text": "Section 5.1: The IPV6_ADDRFORM socket option was removed.",
      "zh-CHS": "第5.1节：删除了IPV6_ADDRFORM套接字选项。"
    },
    {
      "indent": 6,
      "text": "Section 5.3: Added a note that an option value other than 0 or 1 for IPV6_MULTICAST_LOOP returns an error. Added a note that IPV6_MULTICAST_IF, IPV6_MULTICAST_HOPS, and IPV6_MULTICAST_LOOP can also be used with getsockopt(), but IPV6_ADD_MEMBERSHIP and IPV6_DROP_MEMBERSHIP cannot be used with getsockopt().",
      "zh-CHS": "第5.3节：添加了一个注释，即IPV6_多播_循环的选项值不是0或1，而是返回一个错误。添加了一个注意事项，即IPV6_多播_IF、IPV6_多播_HOPS和IPV6_多播_LOOP也可以与getsockopt（）一起使用，但IPV6_添加_成员身份和IPV6_删除_成员身份不能与getsockopt（）一起使用。"
    },
    {
      "indent": 6,
      "text": "Section 6.1: Removed the description of gethostbyname2() and its associated RES_USE_INET6 option, replacing it with gethostbyname3().",
      "zh-CHS": "第6.1节：删除了gethostbyname2（）及其关联的RES_USE_INET6选项的说明，将其替换为gethostbyname3（）。"
    },
    {
      "indent": 6,
      "text": "Section 6.2: Added requirement that gethostbyaddr() be thread safe. Reworded step 4 to avoid using the RES_USE_INET6 option.",
      "zh-CHS": "第6.2节：增加了gethostbyaddr（）是线程安全的要求。重写步骤4以避免使用RES_USE_INET6选项。"
    },
    {
      "indent": 6,
      "text": "Section 6.3: Added the requirement that getaddrinfo() and getnameinfo() be thread safe. Added the AI_NUMERICHOST flag.",
      "zh-CHS": "第6.3节：添加了getaddrinfo（）和getnameinfo（）是线程安全的要求。添加了AI_NUMERICHOST标志。"
    },
    {
      "indent": 6,
      "text": "Section 6.6: Added clarification about IN6_IS_ADDR_LINKLOCAL and IN6_IS_ADDR_SITELOCAL macros.",
      "zh-CHS": "第6.6节：添加了关于IN6_IS_ADDR_LINKLOCAL和IN6_IS_ADDR_SITELOCAL宏的说明。"
    },
    {
      "indent": 3,
      "text": "Changes made to the draft -01 specification Sept 98",
      "zh-CHS": "1998年9月对草案-01规范所做的更改"
    },
    {
      "indent": 6,
      "text": "Changed priority to traffic class in the spec.",
      "zh-CHS": "已在规范中将优先级更改为通信量类别。"
    },
    {
      "indent": 6,
      "text": "Added the need for scope identification in section 2.1.",
      "zh-CHS": "在第2.1节中增加了范围标识的需要。"
    },
    {
      "indent": 6,
      "text": "Added sin6_scope_id to struct sockaddr_in6 in sections 3.3 and 3.4.",
      "zh-CHS": "在第3.3节和第3.4节的第6节中，将sin6_范围_id添加到结构sockaddr_中。"
    },
    {
      "indent": 6,
      "text": "Changed 3.10 to use generic storage structure to support holding IPv6 addresses and removed the SA_LEN macro.",
      "zh-CHS": "将3.10更改为使用通用存储结构来支持保留IPv6地址，并删除了SA_LEN宏。"
    },
    {
      "indent": 6,
      "text": "Distinguished between invalid input parameters and system failures for Interface Identification in Section 4.1 and 4.2.",
      "zh-CHS": "区分第4.1节和第4.2节中接口标识的无效输入参数和系统故障。"
    },
    {
      "indent": 6,
      "text": "Added defaults for multicast operations in section 5.2 and changed the names from ADD to JOIN and DROP to LEAVE to be consistent with IPv6 multicast terminology.",
      "zh-CHS": "在第5.2节中添加了多播操作的默认值，并将名称从“添加”更改为“加入”，从“删除”更改为“离开”，以与IPv6多播术语保持一致。"
    },
    {
      "indent": 6,
      "text": "Changed getnodebyname to getipnodebyname, getnodebyaddr to getipnodebyaddr, and added MT safe error code to function parameters in section 6.",
      "zh-CHS": "将getnodebyname更改为getipnodebyname，将GetNodeByAddress更改为GetIPNodeByAddress，并在第6节的函数参数中添加了MT安全错误代码。"
    },
    {
      "indent": 6,
      "text": "Moved freehostent to its own sub-section after getipnodebyaddr now 6.3 (so this bumps all remaining sections in section 6.",
      "zh-CHS": "在getipnodebyaddr 6.3之后，将freehostent移动到它自己的子部分（因此这会影响第6部分中的所有剩余部分）。"
    },
    {
      "indent": 6,
      "text": "Clarified the use of AI_ALL and AI_V4MAPPED that these are dependent on the AF parameter and must be used as a conjunction in section 6.1.",
      "zh-CHS": "阐明了AI_ALL和AI_V4;的使用，它们取决于AF参数，必须在第6.1节中用作连词。"
    },
    {
      "indent": 6,
      "text": "Removed the restriction that literal addresses cannot be used with a flags argument in section 6.1.",
      "zh-CHS": "删除了第6.1节中文字地址不能与标志参数一起使用的限制。"
    },
    {
      "indent": 6,
      "text": "Added Year 2000 Section to the draft",
      "zh-CHS": "在草案中增加了2000年一节"
    },
    {
      "indent": 6,
      "text": "Deleted Reference to the following because the attached is deleted from the ID directory and has expired. But the logic from the aforementioned draft still applies, so that was kept in Section 6.2 bullets after 3rd paragraph.",
      "zh-CHS": "已删除对以下内容的引用，因为附加的已从ID目录中删除，并且已过期。但上述草案的逻辑仍然适用，因此第3段之后的第6.2节中保留了该逻辑。"
    },
    {
      "indent": 6,
      "text": "[7] P. Vixie, \"Reverse Name Lookups of Encapsulated IPv4 Addresses in IPv6\", Internet-Draft, <draft-vixie-ipng-ipv4ptr-00.txt>, May 1996.",
      "zh-CHS": "[7] P.Vixie，“IPv6中封装IPv4地址的反向名称查找”，互联网草案，<Draft-Vixie-ipng-ipv4ptr-00.txt>，1996年5月。"
    },
    {
      "indent": 6,
      "text": "Deleted the following reference as it is no longer referenced. And the draft has expired.",
      "zh-CHS": "已删除以下引用，因为它不再被引用。汇票已经过期了。"
    },
    {
      "indent": 6,
      "text": "[3] D. McDonald, \"A Simple IP Security API Extension to BSD Sockets\", Internet-Draft, <draft-mcdonald-simple-ipsec-api-01.txt>, March 1997.",
      "zh-CHS": "[3] D.McDonald，“BSD套接字的简单IP安全API扩展”，互联网草案，<Draft-McDonald-Simple-ipsec-API-01.txt>，1997年3月。"
    },
    {
      "indent": 6,
      "text": "Deleted the following reference as it is no longer referenced.",
      "zh-CHS": "已删除以下引用，因为它不再被引用。"
    },
    {
      "indent": 6,
      "text": "[4] C. Metz, \"Network Security API for Sockets\", Internet-Draft, <draft-metz-net-security-api-01.txt>, January 1998.",
      "zh-CHS": "[4] C.Metz，“套接字的网络安全API”，互联网草案，<Draft-Metz-net-Security-API-01.txt>，1998年1月。"
    },
    {
      "indent": 6,
      "text": "Update current references to current status.",
      "zh-CHS": "将当前引用更新为当前状态。"
    },
    {
      "indent": 6,
      "text": "Added alignment notes for in6_addr and sin6_addr.",
      "zh-CHS": "添加了in6_addr和sin6_addr的对齐注释。"
    },
    {
      "indent": 6,
      "text": "Clarified further that AI_V4MAPPED must be used with a dotted IPv4 literal address for getipnodebyname(), when address family is AF_INET6.",
      "zh-CHS": "进一步澄清，当地址族为AF_INET6时，AI_V4MAPPED必须与getipnodebyname（）的虚线IPv4文本地址一起使用。"
    },
    {
      "indent": 6,
      "text": "Added text to clarify \"::\" and \"::1\" when used by getipnodebyaddr().",
      "zh-CHS": "添加文本以澄清getipnodebyaddr（）使用时的“：”和“：：1”。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "zh-CHS": "致谢"
    },
    {
      "indent": 3,
      "text": "Thanks to the many people who made suggestions and provided feedback to this document, including: Werner Almesberger, Ran Atkinson, Fred Baker, Dave Borman, Andrew Cherenson, Alex Conta, Alan Cox, Steve Deering, Richard Draves, Francis Dupont, Robert Elz, Marc Hasson, Tom Herbert, Bob Hinden, Wan-Yen Hsu, Christian Huitema, Koji Imada, Markus Jork, Ron Lee, Alan Lloyd, Charles Lynn, Dan McDonald, Dave Mitton, Thomas Narten, Josh Osborne, Craig Partridge, Jean-Luc Richier, Erik Scoredos, Keith Sklower, Matt Thomas, Harvey Thompson, Dean D. Throop, Karen Tracey, Glenn Trewitt, Paul Vixie, David Waitzman, Carl Williams, and Kazu Yamamoto,",
      "zh-CHS": "感谢对本文件提出建议和提供反馈的许多人，包括：沃纳·阿尔梅斯伯格、冉·阿特金森、弗雷德·贝克、戴夫·鲍曼、安德鲁·切伦森、亚历克斯·孔塔、艾伦·考克斯、史蒂夫·迪林、理查德·德拉维斯、弗朗西斯·杜邦、罗伯特·埃尔兹、马克·哈森、汤姆·赫伯特、鲍勃·欣登、许万燕、克里斯蒂安·惠特马、伊玛达、马库斯·乔克、，Ron Lee、Alan Lloyd、Charles Lynn、Dan McDonald、Dave Mitton、Thomas Narten、Josh Osborne、Craig Partridge、Jean-Luc Richier、Erik Scoredos、Keith Sklower、Matt Thomas、Harvey Thompson、Dean D.Throop、Karen Tracey、Glen Trewitt、Paul Vixie、David Waitzman、Carl Williams和Kazu Yamamoto，"
    },
    {
      "indent": 3,
      "text": "The getaddrinfo() and getnameinfo() functions are taken from an earlier Internet Draft by Keith Sklower. As noted in that draft, William Durst, Steven Wise, Michael Karels, and Eric Allman provided many useful discussions on the subject of protocol-independent name-to-address translation, and reviewed early versions of Keith Sklower's original proposal. Eric Allman implemented the first prototype of getaddrinfo(). The observation that specifying the pair of name and service would suffice for connecting to a service independent of protocol details was made by Marshall Rose in a proposal to X/Open for a \"Uniform Network Interface\".",
      "zh-CHS": "getaddrinfo（）和getnameinfo（）函数取自Keith Sklower早期的Internet草稿。如该草案所述，William Durst、Steven Wise、Michael Karels和Eric Allman就协议独立名称翻译问题进行了许多有益的讨论，并审查了Keith Sklower最初提案的早期版本。Eric Allman实现了getaddrinfo（）的第一个原型。Marshall Rose在向X/Open提交的“统一网络接口”提案中指出，指定名称和服务对就足以连接到独立于协议细节的服务。"
    },
    {
      "indent": 3,
      "text": "Craig Metz, Jack McCann, Erik Nordmark, Tim Hartrick, and Mukesh Kacker made many contributions to this document. Ramesh Govindan made a number of contributions and co-authored an earlier version of this memo.",
      "zh-CHS": "Craig Metz、Jack McCann、Erik Nordmark、Tim Hartrick和Mukesh Kacker对本文件做出了许多贡献。拉梅什·戈文丹（Ramesh Govindan）做出了许多贡献，并与他人共同撰写了这份备忘录的早期版本。"
    },
    {
      "indent": 0,
      "text": "References",
      "zh-CHS": "工具书类"
    },
    {
      "indent": 3,
      "text": "[1] Deering, S. and R. Hinden, \"Internet Protocol, Version 6 (IPv6) Specification\", RFC 2460, December 1998.",
      "zh-CHS": "[1] Deering，S.和R.Hinden，“互联网协议，第6版（IPv6）规范”，RFC 2460，1998年12月。"
    },
    {
      "indent": 3,
      "text": "[2] Hinden, R. and S. Deering, \"IP Version 6 Addressing Architecture\", RFC 2373, July 1998.",
      "zh-CHS": "[2] Hinden，R.和S.Deering，“IP版本6寻址体系结构”，RFC 23731998年7月。"
    },
    {
      "indent": 3,
      "text": "[3] IEEE, \"Protocol Independent Interfaces\", IEEE Std 1003.1g, DRAFT 6.6, March 1997.",
      "zh-CHS": "[3] IEEE，“协议独立接口”，IEEE标准1003.1g，草案6.6，1997年3月。"
    },
    {
      "indent": 3,
      "text": "[4] Stevens, W. and M. Thomas, \"Advanced Sockets API for IPv6\", RFC 2292, February 1998.",
      "zh-CHS": "[4] Stevens，W.和M.Thomas，“IPv6的高级套接字API”，RFC 2292，1998年2月。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "zh-CHS": "作者地址"
    },
    {
      "indent": 3,
      "text": "Robert E. Gilligan FreeGate Corporation 1208 E. Arques Ave. Sunnyvale, CA 94086",
      "zh-CHS": "罗伯特·吉利根·弗里盖特公司，加利福尼亚州桑尼维尔市阿克斯大道东1208号，邮编94086"
    },
    {
      "indent": 3,
      "text": "Phone: +1 408 617 1004\nEMail: gilligan@freegate.com",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Susan Thomson Bell Communications Research MRE 2P-343, 445 South Street Morristown, NJ 07960",
      "zh-CHS": "Susan Thomson Bell通信研究公司MRE 2P-343，地址：新泽西州莫里斯镇南街445号，邮编：07960"
    },
    {
      "indent": 3,
      "text": "Phone: +1 201 829 4514\nEMail: set@thumper.bellcore.com",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Jim Bound Compaq Computer Corporation 110 Spitbrook Road ZK3-3/U14 Nashua, NH 03062-2698",
      "zh-CHS": "吉姆邦德康柏计算机公司地址：新罕布什尔州纳舒亚市斯皮布鲁克路110号ZK3-3/U14邮编：03062-2698"
    },
    {
      "indent": 3,
      "text": "Phone: +1 603 884 0400\nEMail: bound@zk3.dec.com",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "W. Richard Stevens 1202 E. Paseo del Zorro Tucson, AZ 85718-2826",
      "zh-CHS": "W.Richard Stevens 1202 E.帕西奥·德尔·佐罗·图森，亚利桑那州85718-2826"
    },
    {
      "indent": 3,
      "text": "Phone: +1 520 297 9416\nEMail: rstevens@kohala.com",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "zh-CHS": "完整版权声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1999). All Rights Reserved.",
      "zh-CHS": "版权所有（C）互联网协会（1999年）。版权所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "zh-CHS": "本文件及其译本可复制并提供给他人，对其进行评论或解释或协助其实施的衍生作品可全部或部分编制、复制、出版和分发，不受任何限制，前提是上述版权声明和本段包含在所有此类副本和衍生作品中。但是，不得以任何方式修改本文件本身，例如删除版权通知或对互联网协会或其他互联网组织的引用，除非出于制定互联网标准的需要，在这种情况下，必须遵循互联网标准过程中定义的版权程序，或根据需要将其翻译成英语以外的其他语言。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "zh-CHS": "上述授予的有限许可是永久性的，互联网协会或其继承人或受让人不会撤销。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "zh-CHS": "本文件和其中包含的信息是按“原样”提供的，互联网协会和互联网工程任务组否认所有明示或暗示的保证，包括但不限于任何保证，即使用本文中的信息不会侵犯任何权利，或对适销性或特定用途适用性的任何默示保证。"
    }
  ]
}