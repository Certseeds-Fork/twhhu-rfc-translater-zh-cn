{
  "title": {
    "text": "RFC 2713:  Schema for Representing Java(tm) Objects in an LDAP Directory ",
    "zh-CHS": "RFC 2713"
  },
  "number": 2713,
  "created_at": "2021-10-24 06:35:35.779792+08:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                            V. Ryan\nRequest for Comments: 2713                                   S. Seligman\nCategory: Informational                                           R. Lee\n                                                  Sun Microsystems, Inc.\n                                                            October 1999",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "Schema for Representing Java(tm) Objects in an LDAP Directory",
      "zh-CHS": "用于在LDAP目录中表示Java（tm）对象的模式"
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "zh-CHS": "本备忘录的状况"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "zh-CHS": "本备忘录为互联网社区提供信息。它没有规定任何类型的互联网标准。本备忘录的分发不受限制。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "zh-CHS": "版权公告"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1999). All Rights Reserved.",
      "zh-CHS": "版权所有（C）互联网协会（1999年）。版权所有。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "zh-CHS": "摘要"
    },
    {
      "indent": 3,
      "text": "This document defines the schema for representing Java(tm) objects in an LDAP directory [LDAPv3]. It defines schema elements to represent a Java serialized object [Serial], a Java marshalled object [RMI], a Java remote object [RMI], and a JNDI reference [JNDI].",
      "zh-CHS": "本文档定义了在LDAP目录[LDAPv3]中表示Java（tm）对象的模式。它定义了模式元素来表示Java序列化对象[Serial]、Java封送对象[RMI]、Java远程对象[RMI]和JNDI引用[JNDI]。"
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "zh-CHS": "1. 介绍"
    },
    {
      "indent": 3,
      "text": "This document assumes that the reader has a general knowledge of the Java programming language [Java]. For brevity we use the term \"Java object\" in place of \"object in the Java programming language\" throughout this text.",
      "zh-CHS": "本文档假设读者对Java编程语言[Java]具有一般知识。为了简洁起见，我们在本文中使用术语“Java对象”代替“Java编程语言中的对象”。"
    },
    {
      "indent": 3,
      "text": "Traditionally, LDAP directories have been used to store data. Users and programmers think of the directory as a hierarchy of directory entries, each containing a set of attributes. You look up an entry from the directory and extract the attribute(s) of interest. For example, you can look up a person's telephone number from the directory. Alternatively, you can search the directory for entries with a particular set of attributes. For example, you can search for all persons in the directory with the surname \"Smith\".",
      "zh-CHS": "传统上，LDAP目录用于存储数据。用户和程序员将目录视为目录项的层次结构，每个目录项都包含一组属性。您可以从目录中查找条目并提取感兴趣的属性。例如，您可以从目录中查找某人的电话号码。或者，您可以在目录中搜索具有特定属性集的条目。例如，您可以搜索目录中姓氏为“Smith”的所有人员。"
    },
    {
      "indent": 3,
      "text": "For applications written in the Java programming language, a kind of data that is typically shared are Java objects themselves. For such applications, it makes sense to be able to use the directory as a repository for Java objects. The directory provides a centrally administered, and possibly replicated, service for use by Java applications distributed across the network.",
      "zh-CHS": "对于用Java编程语言编写的应用程序，通常共享的一种数据是Java对象本身。对于这样的应用程序，能够将目录用作Java对象的存储库是有意义的。该目录提供了一个集中管理的（可能是复制的）服务，供分布在网络上的Java应用程序使用。"
    },
    {
      "indent": 3,
      "text": "For example, an application server might use the directory for \"registering\" objects representing the services that it manages, so that a client can later search the directory to locate those services as it needs.",
      "zh-CHS": "例如，应用程序服务器可能会使用该目录“注册”表示其管理的服务的对象，以便客户端以后可以根据需要搜索该目录以定位这些服务。"
    },
    {
      "indent": 3,
      "text": "The motivation for this document is to define a common way for applications to store and retrieve Java objects from the directory. Using this common schema, any Java application that needs to read or store Java objects in the directory can do so in an interoperable way.",
      "zh-CHS": "本文档的目的是为应用程序定义一种从目录中存储和检索Java对象的通用方法。使用这个公共模式，任何需要在目录中读取或存储Java对象的Java应用程序都可以以可互操作的方式读取或存储Java对象。"
    },
    {
      "indent": 0,
      "text": "2 Representation of Java Objects",
      "zh-CHS": "2 Java对象的表示"
    },
    {
      "indent": 3,
      "text": "This document defines schema elements to represent three types of Java objects: a Java serialized object, a Java marshalled object, and a JNDI reference. A Java remote object is stored as either a Java marshalled object or a JNDI reference.",
      "zh-CHS": "本文档定义了模式元素来表示三种类型的Java对象：Java序列化对象、Java编组对象和JNDI引用。Java远程对象存储为Java封送对象或JNDI引用。"
    },
    {
      "indent": 0,
      "text": "2.1 Common Representations",
      "section_title": true,
      "zh-CHS": "2.1 共同表述"
    },
    {
      "indent": 3,
      "text": "A Java object is stored in the LDAP directory by using the object class javaObject. This is the base class from which other Java object related classes derive: javaSerializedObject, javaMarshalledObject, and javaNamingReference. javaObject is an abstract object class, which means that a javaObject cannot exist by itself in the directory; only auxiliary or structural subclasses of it can exist in the directory.",
      "zh-CHS": "Java对象通过使用对象类javaObject存储在LDAP目录中。这是其他Java对象相关类派生的基类：javaSerializedObject、javaMarshalledObject和javaNamingReference。javaObject是一个抽象的对象类，这意味着javaObject不能单独存在于目录中；目录中只能存在它的辅助子类或结构子类。"
    },
    {
      "indent": 3,
      "text": "The object class javaContainer represents a directory entry dedicated to storing a Java object. It is a structural object class. In cases where a subclass of javaObject is mixed in with another structural object class, javaContainer is not required.",
      "zh-CHS": "对象类javaContainer表示专用于存储Java对象的目录项。它是一个结构对象类。如果javaObject的子类与另一个结构对象类混合，则不需要javaContainer。"
    },
    {
      "indent": 3,
      "text": "The definitions for the object classes javaObject and javaContainer are presented in Section 4.",
      "zh-CHS": "第4节介绍了对象类javaObject和javaContainer的定义。"
    },
    {
      "indent": 3,
      "text": "The javaObject class has one mandatory attribute (javaClassName) and four optional attributes (javaClassNames, javaCodebase, javaDoc, description). javaClassName is a single valued attribute that is used to store the fully qualified name of the object's Java class (for example, \"java.lang.String\"). This may be the object's most derived class's name, but does not have to be; that of a superclass or interface in some cases might be most appropriate. This attribute is intended for storing the name of the object's \"distinguished\" class, that is, the class or interface with which the object should be identified.",
      "zh-CHS": "javaObject类有一个强制属性（javaClassName）和四个可选属性（javaClassName、javaCodebase、javaDoc、description）。javaClassName是一个单值属性，用于存储对象Java类的完全限定名（例如，“Java.lang.String”）。这可能是对象最派生的类的名称，但不一定是；在某些情况下，超类或接口可能是最合适的。此属性用于存储对象的“可分辨”类的名称，即对象应标识的类或接口。"
    },
    {
      "indent": 3,
      "text": "javaClassNames is a multivalued attribute that is used to store the fully qualified names of the object's Java classes and interfaces (for example, \"java.lang.Byte\"). Like all multivalued attributes, the javaClassNames attribute's values are unordered and so no one value is more \"distinguished\" than the others. This attribute is intended for storing an object's class and interface names and those of its ancestor classes and interfaces, although the list of values does not have to be complete. If the javaClassNames attribute is present, it should include the value of javaClassName.",
      "zh-CHS": "javaClassNames是一个多值属性，用于存储对象的Java类和接口的完全限定名（例如，“Java.lang.Byte”）。与所有多值属性一样，javaClassNames属性的值是无序的，因此没有一个值比其他值更“与众不同”。此属性用于存储对象的类和接口名称及其祖先类和接口的名称，尽管值列表不必完整。如果存在javaClassNames属性，那么它应该包含javaClassName的值。"
    },
    {
      "indent": 3,
      "text": "For example, suppose an object is stored in the directory with a javaClassName attribute of \"java.io.FilePermission\", and a javaClassNames attribute of {\"java.security.Permission\", \"java.io.FilePermission\", \"java.security.Guard\", \"java.io.Serializable\"}. An application searching a directory for Java objects might use javaClassName to produce a summary of the names and types of Java objects in that directory. Another application might use the javaClassNames attribute to find, for example, all java.security.Permission objects.",
      "zh-CHS": "例如，假设一个对象存储在目录中，其javaClassName属性为“java.io.FilePermission”，javaClassNames属性为{“java.security.Permission”、“java.io.FilePermission”、“java.security.Guard”、“java.io.Serializable”}。在目录中搜索Java对象的应用程序可能会使用javaClassName生成该目录中Java对象的名称和类型的摘要。另一个应用程序可能使用javaClassNames属性来查找所有java.security.Permission对象。"
    },
    {
      "indent": 3,
      "text": "javaCodebase is a multivalued attribute that is used to store the location(s) of the object's class definition. javaDoc is used to store a pointer (URL) to the Java documentation for the class. description is used to store a textual description of a Java object and is defined in [v3Schema]. The definitions of these attributes are presented in Section 3.",
      "zh-CHS": "javaCodebase是一个多值属性，用于存储对象类定义的位置。javaDoc用于存储指向类的Java文档的指针（URL）。description用于存储Java对象的文本描述，并在[v3Schema]中定义。这些属性的定义见第3节。"
    },
    {
      "indent": 0,
      "text": "2.2 Serialized Objects",
      "section_title": true,
      "zh-CHS": "2.2 序列化对象"
    },
    {
      "indent": 3,
      "text": "To \"serialize\" an object means to convert its state into a byte stream in such a way that the byte stream can be converted back into a copy of the object. A Java object is \"serializable\" if its class or any of its superclasses implements either the java.io.Serializable interface or its subinterface java.io.Externalizable. \"Deserialization\" is the process of converting the serialized form of an object back into a copy of the object. When an object is serialized, the entire tree of objects rooted at the object is also serialized. When it is deserialized, the tree is reconstructed. For example, suppose a serializable Book object contains (a serializable field of) an array of Page objects. When a Book object is serialized, so is the array of Page objects.",
      "zh-CHS": "“序列化”对象意味着将其状态转换为字节流，以便字节流可以转换回对象的副本。如果Java对象的类或其任何超类实现Java.io.serializable接口或其子接口Java.io.Externalizable，则Java对象是“可序列化的”。“反序列化”是将对象的序列化形式转换回对象副本的过程。序列化对象时，以该对象为根的整个对象树也将序列化。当它被反序列化时，树被重建。例如，假设一个可序列化的图书对象包含一个页面对象数组（的可序列化字段）。当图书对象被序列化时，页面对象数组也被序列化。"
    },
    {
      "indent": 3,
      "text": "The Java platform specifies a default algorithm by which serializable objects are serialized. A Java class can also override this default serialization with its own algorithm. [Serial] describes object serialization in detail.",
      "zh-CHS": "Java平台指定了一个默认算法，可序列化对象通过该算法进行序列化。Java类还可以使用自己的算法覆盖此默认序列化。[Serial]详细描述了对象序列化。"
    },
    {
      "indent": 3,
      "text": "When an object is serialized, information that identifies its class is recorded in the serialized stream. However, the class's definition (\"class file\") itself is not recorded. It is the responsibility of the system that is deserializing the object to determine the mechanism to use for locating and loading the associated class definitions. For example, the Java application might include in its classpath a JAR file containing the class definitions of the serialized object, or load the class definitions using information from the directory, as explained below.",
      "zh-CHS": "序列化对象时，标识其类的信息将记录在序列化流中。但是，不会记录类的定义（“类文件”）。反序列化对象的系统负责确定用于定位和加载关联类定义的机制。例如，Java应用程序可能在其类路径中包含一个包含序列化对象的类定义的JAR文件，或者使用目录中的信息加载类定义，如下所述。"
    },
    {
      "indent": 0,
      "text": "2.2.1 Representation in the Directory",
      "section_title": true,
      "zh-CHS": "2.2.1 目录中的表示"
    },
    {
      "indent": 3,
      "text": "A serialized object is represented in the directory by the attributes javaClassName, javaClassNames, javaCodebase, and javaSerializedData, as defined in Section 3. The mandatory attribute, javaSerializedData, contains the serialized form of the object. Although the serialized form already contains the class name, the mandatory javaClassName attribute also records the class name of the serialized object so that applications can determined class information without having to first deserialize the object. The optional javaClassNames attribute is used to record additional class information about the serialized object. The optional javaCodebase attribute is used to record the locations of the class definitions needed to deserialize the serialized object.",
      "zh-CHS": "序列化对象在目录中由属性javaClassName、javaClassName、javaCodebase和javaSerializedData表示，如第3节所定义。强制属性javaSerializedData包含对象的序列化形式。尽管序列化表单已经包含类名，但强制的javaClassName属性也会记录序列化对象的类名，这样应用程序就可以确定类信息，而不必首先反序列化对象。可选的javaClassNames属性用于记录有关序列化对象的其他类信息。可选的javaCodebase属性用于记录反序列化序列化对象所需的类定义的位置。"
    },
    {
      "indent": 3,
      "text": "A directory entry that contains a serialized object is represented by the object class javaSerializedObject, which is a subclass of javaObject. javaSerializedObject is an auxiliary object class, which means that it needs to be mixed in with a structural object class. javaSerializedObject's definition is given in Section 4.",
      "zh-CHS": "包含序列化对象的目录项由对象类javaSerializedObject表示，它是javaObject的子类。javaSerializedObject是一个辅助对象类，这意味着它需要与结构对象类混合。javaSerializedObject的定义见第4节。"
    },
    {
      "indent": 0,
      "text": "2.3 Marshalled Objects",
      "section_title": true,
      "zh-CHS": "2.3 编组对象"
    },
    {
      "indent": 3,
      "text": "To \"marshal\" an object means to record its state and codebase(s) in such a way that when the marshalled object is \"unmarshalled,\" a copy of the original object is obtained, possibly by automatically loading the class definitions of the object. You can marshal any object that is serializable or remote (that is, implements the java.rmi.Remote interface). Marshalling is like serialization, except marshalling also records codebases. Marshalling is different from serialization in that marshalling treats remote objects specially. If an object is a java.rmi.Remote object, marshalling records the remote object's \"stub\" (see Section 2.5), instead of the remote object itself. Like serialization, when an object is marshalled, the entire tree of objects rooted at the object is marshalled. When it is unmarshalled, the tree is reconstructed.",
      "zh-CHS": "“封送”对象意味着记录其状态和代码库，当封送的对象被“取消封送”时，可能通过自动加载对象的类定义来获得原始对象的副本。您可以封送任何可序列化或远程的对象（即，实现java.rmi.remote接口）。编组与序列化类似，只是编组还记录代码基。编组与序列化的不同之处在于编组专门处理远程对象。如果对象是java.rmi.Remote对象，编组将记录远程对象的“存根”（参见第2.5节），而不是远程对象本身。与序列化类似，当封送对象时，将封送以该对象为根的整个对象树。当它被解组时，树被重建。"
    },
    {
      "indent": 3,
      "text": "A \"marshalled\" object is the represented by the java.rmi.MarshalledObject class. Here's an example of how to create MarshalledObjects for serializable and remote objects:",
      "zh-CHS": "“封送”对象由java.rmi.MarshalledObject类表示。以下是如何为可序列化对象和远程对象创建MarshalledObjects的示例："
    },
    {
      "indent": 7,
      "text": "java.io.Serializable sobj = ...;\njava.rmi.MarshalledObject mobj1 =\n    new java.rmi.MarshalledObject(sobj);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "java.rmi.Remote robj = ...;\njava.rmi.MarshalledObject mobj2 =\n    new java.rmi.MarshalledObject(robj);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Then, to retrieve the original objects from the MarshalledObjects, do as follows:",
      "zh-CHS": "然后，要从MarshalledObjects中检索原始对象，请执行以下操作："
    },
    {
      "indent": 7,
      "text": "java.io.Serializable sobj = (java.io.Serializable) mobj1.get();\njava.io.Remote rstub = (java.io.Remote) mobj2.get();",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "MarshalledObject is available only on the Java 2 Platform, Standard Edition, v1.2, and higher releases.",
      "zh-CHS": "MarshalledObject仅在Java 2平台、标准版、v1.2和更高版本上可用。"
    },
    {
      "indent": 0,
      "text": "2.3.1 Representation in the Directory",
      "section_title": true,
      "zh-CHS": "2.3.1 目录中的表示"
    },
    {
      "indent": 3,
      "text": "A marshalled object is represented in the directory by the attributes javaClassName, javaClassNames, and javaSerializedData, as defined in Section 3. The mandatory attribute, javaSerializedData, contains the serialized form of the marshalled object (that is, the serialized form of a MarshalledObject instance). The mandatory javaClassName attribute records the distinguished class name of the object before it has been marshalled. The optional javaClassNames attribute is used to record additional class information about the object before it has been marshalled.",
      "zh-CHS": "编组对象在目录中由属性javaClassName、javaClassName和javaSerializedData表示，如第3节所定义。强制属性javaSerializedData包含封送对象的序列化形式（即封送对象实例的序列化形式）。强制的javaClassName属性记录对象在编组之前的可分辨类名。可选的javaClassNames属性用于在封送对象之前记录有关该对象的其他类信息。"
    },
    {
      "indent": 3,
      "text": "A directory entry that contains a marshalled object is represented by the object class javaMarshalledObject, which is a subclass of javaObject. javaMarshalledObject is an auxiliary object class, which means that it needs to be mixed in with a structural object class. javaMarshalledObject's definition is given in Section 4.",
      "zh-CHS": "包含编组对象的目录项由对象类javaMarshalledObject表示，javaMarshalledObject是javaObject的子类。javaMarshalledObject是一个辅助对象类，这意味着它需要与结构对象类混合。javaMarshalledObject的定义在第4节中给出。"
    },
    {
      "indent": 3,
      "text": "As evident in this description, a javaMarshalledObject differs from a javaSerializedObject only in the interpretation of the javaClassName and javaClassNames attributes.",
      "zh-CHS": "如本描述中所示，javaMarshalledObject与javaSerializedObject的区别仅在于javaClassName和javaClassNames属性的解释。"
    },
    {
      "indent": 0,
      "text": "2.4 JNDI References",
      "section_title": true,
      "zh-CHS": "2.4 JNDI参考"
    },
    {
      "indent": 3,
      "text": "Java Naming and Directory Interface(tm) (JNDI) is a directory access API specified in the Java programming language [JNDI]. It provides an object-oriented view of the directory, allowing Java objects to be added to and retrieved from the directory without requiring the client to manage data representation issues.",
      "zh-CHS": "Java命名和目录接口（tm）（JNDI）是Java编程语言[JNDI]中指定的目录访问API。它提供了目录的面向对象视图，允许将Java对象添加到目录中并从中检索，而无需客户端管理数据表示问题。"
    },
    {
      "indent": 3,
      "text": "JNDI defines the notion of a \"reference\" for use when an object cannot be stored in the directory directly, or when it is inappropriate or undesirable to do so. An object with an associated reference is stored in the directory indirectly, by storing its reference instead.",
      "zh-CHS": "JNDI定义了“引用”的概念，用于对象不能直接存储在目录中，或者不适合或不希望这样做的情况。具有关联引用的对象通过存储其引用而间接存储在目录中。"
    },
    {
      "indent": 0,
      "text": "2.4.1 Contents of a Reference",
      "section_title": true,
      "zh-CHS": "2.4.1 参考文献的内容"
    },
    {
      "indent": 3,
      "text": "A JNDI reference is a Java object of class javax.naming.Reference. It consists of class information about the object being referenced and an ordered list of addresses. An address is a Java object of class javax.naming.RefAddr. Each address contains information on how to construct the object.",
      "zh-CHS": "JNDI引用是类javax.naming.reference的Java对象。它由被引用对象的类信息和地址的有序列表组成。地址是类javax.naming.RefAddr的Java对象。每个地址都包含有关如何构造对象的信息。"
    },
    {
      "indent": 3,
      "text": "A common use for JNDI references is to represent connections to a network service such as a database, directory, or file system. Each address may then identify a \"communications endpoint\" for that service, containing information on how to contact the service. Multiple addresses may arise for various reasons, such as replication or the object offering interfaces over more than one communication mechanism.",
      "zh-CHS": "JNDI引用的一个常见用途是表示到网络服务（如数据库、目录或文件系统）的连接。然后，每个地址可以标识该服务的“通信端点”，其中包含关于如何联系该服务的信息。由于各种原因可能会出现多个地址，例如复制或通过多个通信机制提供接口的对象。"
    },
    {
      "indent": 3,
      "text": "A reference also contains information to assist in the creation of an instance of the object to which the reference refers. It contains the Java class name of that object, and the class name and location of the object factory to be used to create the object. The procedures for creating an object given its reference and the reverse are described in [JNDI].",
      "zh-CHS": "引用还包含帮助创建引用对象实例的信息。它包含该对象的Java类名，以及用于创建该对象的对象工厂的类名和位置。[JNDI]中描述了在给定对象引用和相反引用的情况下创建对象的过程。"
    },
    {
      "indent": 0,
      "text": "2.4.2 Representation in the Directory",
      "section_title": true,
      "zh-CHS": "2.4.2 目录中的表示"
    },
    {
      "indent": 3,
      "text": "A JNDI reference is stored in the directory by using the attributes javaClassName, javaClassNames, javaCodebase, javaReferenceAddress, and javaFactory, defined in Section 3. These attributes store information corresponding to the contents of a reference described above. javaReferenceAddress is a multivalued optional attribute for storing reference addresses. javaFactory is the optional attribute for storing the object factory's fully qualified class name. The mandatory javaClassName attribute is used to store the name of the distinguished class of the object. The optional javaClassNames",
      "zh-CHS": "JNDI引用通过使用第3节中定义的属性javaClassName、javaClassName、javaCodebase、javaReferenceAddress和javaFactory存储在目录中。这些属性存储与上述引用的内容相对应的信息。javaReferenceAddress是用于存储引用地址的多值可选属性。javaFactory是用于存储对象工厂的完全限定类名的可选属性。必需的javaClassName属性用于存储对象的可分辨类的名称。可选的JavaClassName"
    },
    {
      "indent": 3,
      "text": "attribute is used to record additional class and interface names. The optional javaCodebase attribute is used to store the locations of the object factory's and the object's class definitions.",
      "zh-CHS": "属性用于记录其他类和接口名称。可选的javaCodebase属性用于存储对象工厂和对象类定义的位置。"
    },
    {
      "indent": 3,
      "text": "A directory entry containing a JNDI reference is represented by the object class javaNamingReference, which is a subclass of javaObject. javaNamingReference is an auxiliary object class, which means that it needs to be mixed in with a structural object class. javaNamingReference's definition is given in Section 4.",
      "zh-CHS": "包含JNDI引用的目录项由对象类javaNamingReference表示，javaNamingReference是javaObject的子类。javaNamingReference是一个辅助对象类，这意味着它需要与结构对象类混合。javaNamingReference的定义见第4节。"
    },
    {
      "indent": 0,
      "text": "2.5 Remote Objects",
      "section_title": true,
      "zh-CHS": "2.5 远程对象"
    },
    {
      "indent": 3,
      "text": "The Java Remote Method Invocation (RMI) system [RMI] is a mechanism that enables an object on one Java virtual machine to invoke methods on an object in another Java virtual machine. Any object whose methods can be invoked in this way must implement the java.rmi.Remote interface. When such an object is invoked, its arguments are marshalled and sent from the local virtual machine to the remote one, where the arguments are unmarshalled and used. When the method terminates, the results are marshalled from the remote machine and sent to the caller's virtual machine.",
      "zh-CHS": "Java远程方法调用（RMI）系统[RMI]是一种机制，它使一个Java虚拟机上的对象能够调用另一个Java虚拟机上的对象上的方法。其方法可以通过这种方式调用的任何对象都必须实现java.rmi.Remote接口。当调用这样的对象时，它的参数将被编组并从本地虚拟机发送到远程虚拟机，在远程虚拟机中，参数将被取消编组并使用。当方法终止时，结果将从远程计算机封送并发送到调用方的虚拟机。"
    },
    {
      "indent": 3,
      "text": "To make a remote object accessible to other virtual machines, a program typically registers it with the RMI registry. The program supplies to the RMI registry the string name of the remote object and the remote object itself. When a program wants to access a remote object, it supplies the object's string name to the RMI registry on the same machine as the remote object. The RMI registry returns to the caller a reference (called \"stub\") to the remote object. When the program receives the stub for the remote object, it can invoke methods on the remote object (through the stub). A program can also obtain references to remote objects as a result of remote calls to other remote objects or from other naming services. For example, the program can look up a reference to a remote object from an LDAP server that supports the schema defined in this document.",
      "zh-CHS": "为了使远程对象可供其他虚拟机访问，程序通常向RMI注册表注册它。该程序向RMI注册表提供远程对象和远程对象本身的字符串名称。当程序想要访问远程对象时，它会将对象的字符串名称提供给远程对象所在机器上的RMI注册表。RMI注册表将远程对象的引用（称为“存根”）返回给调用方。当程序收到远程对象的存根时，它可以调用远程对象上的方法（通过存根）。程序还可以通过远程调用其他远程对象或从其他命名服务获取对远程对象的引用。例如，程序可以从支持本文档中定义的模式的LDAP服务器中查找对远程对象的引用。"
    },
    {
      "indent": 3,
      "text": "The string name accepted by the RMI registry has the syntax \"rmi://hostname:port/remoteObjectName\", where \"hostname\" and \"port\" identify the machine and port on which the RMI registry is running, respectively, and \"remoteObjectName\" is the string name of the remote object. \"hostname\", \"port\", and the prefix, \"rmi:\", are optional. If \"hostname\" is not specified, it defaults to the local host. If \"port\" is not specified, it defaults to 1099. If \"remoteObjectName\" is not specified, then the object being named is the RMI registry itself. See [RMI] for details.",
      "zh-CHS": "RMI注册表接受的字符串名称的语法为“rmi://hostname:port/remoteObjectName，其中“主机名”和“端口”分别标识运行RMI注册表的计算机和端口，“remoteObjectName”是远程对象的字符串名称。“主机名”、“端口”和前缀“rmi:”是可选的。如果未指定“主机名”，则默认为本地主机。如果未指定“端口”，则默认为1099。如果未指定“remoteObjectName”，则要命名的对象是RMI注册表本身。有关详细信息，请参见[RMI]。"
    },
    {
      "indent": 3,
      "text": "RMI can be supported using different protocols: the Java Remote Method Protocol (JRMP) and the Internet Inter-ORB Protocol (IIOP). The JRMP is a specialized protocol designed for RMI; the IIOP is the standard protocol for communication between CORBA objects [CORBA]. RMI over IIOP allows Java remote objects to communicate with CORBA objects which might be written in a non-Java programming language [RMI-IIOP].",
      "zh-CHS": "RMI可以使用不同的协议来支持：Java远程方法协议（JRMP）和Internet ORB间协议（IIOP）。JRMP是为RMI设计的专用协议；IIOP是CORBA对象之间通信的标准协议[CORBA]。RMI over IIOP允许Java远程对象与CORBA对象通信，CORBA对象可以用非Java编程语言[RMI-IIOP]编写。"
    },
    {
      "indent": 0,
      "text": "2.5.1 Representation in the Directory",
      "section_title": true,
      "zh-CHS": "2.5.1 目录中的表示"
    },
    {
      "indent": 3,
      "text": "Remote objects that use the IIOP are represented in the directory as CORBA object references [CORBA-LDAP]. Remote objects that use the JRMP are represented in the directory in one of two ways: as a marshalled object, or as a JNDI reference.",
      "zh-CHS": "使用IIOP的远程对象在目录中表示为CORBA对象引用[CORBA-LDAP]。使用JRMP的远程对象在目录中以两种方式之一表示：封送对象或JNDI引用。"
    },
    {
      "indent": 3,
      "text": "A marshalled object records the codebases of the remote object's stub and any serializable or remote objects that it references, and replaces remote objects with their stubs. To store a Remote object as a marshalled object (java.rmi.MarshalledObject), you first create a java.rmi.MarshalledObject instance for it.",
      "zh-CHS": "封送对象记录远程对象的存根和它引用的任何可序列化或远程对象的代码基，并用它们的存根替换远程对象。要将远程对象存储为封送对象（java.rmi.MarshalledObject），首先为其创建一个java.rmi.MarshalledObject实例。"
    },
    {
      "indent": 7,
      "text": "java.rmi.Remote robj = ...;\njava.rmi.MarshalledObject mobj =\n    new java.rmi.MarshalledObject(robj);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "You can then store the MarshalledObject instance as a javaMarshalledObject. The javaClassName attribute should contain the fully qualified name of the distinguished class of the remote object. The javaClassNames attribute should contain the names of the classes and interfaces of the remote object. To read the remote object back from the directory, first deserialize the contents of the javaSerializedData to get a MarshalledObject (mobj), then retrieve it from the MarshalledObject as follows:",
      "zh-CHS": "然后可以将MarshalledObject实例存储为javaMarshalledObject。javaClassName属性应该包含远程对象的可分辨类的完全限定名。javaClassNames属性应该包含远程对象的类和接口的名称。要从目录中读回远程对象，请首先反序列化javaSerializedData的内容以获取MarshalledObject（mobj），然后从MarshalledObject中检索它，如下所示："
    },
    {
      "indent": 7,
      "text": "java.rmi.Remote robj = (java.rmi.Remote)mobj.get();",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "This returns the remote stub, which you can then use to invoke remote methods.",
      "zh-CHS": "这将返回远程存根，然后可以使用它调用远程方法。"
    },
    {
      "indent": 3,
      "text": "MarshalledObject is available only on the Java 2 Platform, Standard Edition, v1.2 and higher releases. Therefore, a remote object stored as a MarshalledObject can only be read by clients using the the Java 2 Platform, Standard Edition, v1.2 or higher releases.",
      "zh-CHS": "MarshalledObject仅在Java 2平台、标准版、v1.2及更高版本上可用。因此，存储为MarshalledObject的远程对象只能由使用Java 2平台、标准版、v1.2或更高版本的客户端读取。"
    },
    {
      "indent": 3,
      "text": "To store a remote object as a JNDI reference, you first create a javax.naming.Reference object instance for it using the remote object's string name as it has been, or will be, recorded with the RMI registry, with the additional restriction that the \"rmi:\" prefix must be present. Here's an example:",
      "zh-CHS": "要将远程对象存储为JNDI引用，首先使用远程对象的字符串名称为它创建一个javax.naming.reference对象实例，因为它已经或将被RMI注册表记录，但附加的限制是“RMI:”前缀必须存在。下面是一个例子："
    },
    {
      "indent": 7,
      "text": "javax.naming.Reference ref = new javax.naming.Reference(\n  obj.getClass().getName(),\n  new javax.naming.StringRefAddr(\"URL\",\n      \"rmi://rserver/AppRemoteObjectX\"));",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "You then store the javax.naming.Reference instance as a javaNamingReference. The advantage of using a JNDI reference is that this can be done without a reference to the remote object. In fact, the remote object does not have to exist at the time that this recording in the directory is made. The remote object needs to exist and be bound with the RMI registry when the object is looked up from the directory.",
      "zh-CHS": "然后将javax.naming.Reference实例存储为javaNamingReference。使用JNDI引用的优点是，这可以在不引用远程对象的情况下完成。事实上，在目录中进行此记录时，远程对象不必存在。当从目录中查找对象时，远程对象需要存在并与RMI注册表绑定。"
    },
    {
      "indent": 0,
      "text": "2.6 Serialized Objects Vs. Marshalled Objects Vs. References",
      "section_title": true,
      "zh-CHS": "2.6 序列化对象与编组对象与引用"
    },
    {
      "indent": 3,
      "text": "The object classes defined in this document store different aspects of the Java objects.",
      "zh-CHS": "本文档中定义的对象类存储Java对象的不同方面。"
    },
    {
      "indent": 3,
      "text": "A javaSerializedObject or a serializable object stored as a javaMarshalledObject represents the object itself, while a javaNamingReference or a remote object stored as a javaMarshalledObject represents a \"pointer\" to the object.",
      "zh-CHS": "存储为javaMarshalledObject的javaSerializedObject或可序列化对象表示对象本身，而存储为javaMarshalledObject的javaNamingReference或远程对象表示指向对象的“指针”。"
    },
    {
      "indent": 3,
      "text": "When storing a serializable object in the directory, you have a choice of storing it as a javaSerializedObject or a javaMarshalledObject. The javaSerializedObject object class provides the basic way in which to store serializable objects. When you create an LDAP entry using the javaSerializableObject object class, you must explicitly set the javaCodebase attribute if you want readers of that entry to know where to load the class definitions of the object. When you create an LDAP entry using the javaMarshalledObject object class, you use the MarshalledObject class. The MarshalledObject class uses the RMI infrastructure available on the Java platform to automate how codebase information is gathered and recorded, thus freeing you from having to set the javaCodebase attribute. On the other hand, the javaCodebase attribute is human-readable and can be updated easily by using text-based tools without having to change other parts of the entry. This allows you, for instance, to move the class definitions to another location and then update the javaCodebase attribute to reflect the move without having to update the serialized object itself.",
      "zh-CHS": "在目录中存储可序列化对象时，可以选择将其存储为javaSerializedObject或javaMarshalledObject。javaSerializedObject对象类提供了存储可序列化对象的基本方式。使用javaSerializableObject对象类创建LDAP条目时，如果希望该条目的读者知道在何处加载对象的类定义，则必须显式设置javaCodebase属性。使用javaMarshalledObject对象类创建LDAP条目时，使用MarshalledObject类。MarshalledObject类使用Java平台上可用的RMI基础结构来自动收集和记录代码库信息，从而使您无需设置javaCodebase属性。另一方面，javaCodebase属性是人类可读的，可以通过使用基于文本的工具轻松更新，而无需更改条目的其他部分。例如，这允许您将类定义移动到另一个位置，然后更新javaCodebase属性以反映移动，而无需更新序列化对象本身。"
    },
    {
      "indent": 3,
      "text": "A javaNamingReference provides a way of recording address information about an object which itself is not directly stored in the directory. A remote object stored as a javaMarshalledObject also records address information (the object's \"stub\") of an object which itself is not directory stored in the directory. In other words, you can think of these as compact representations of the information required to access the object.",
      "zh-CHS": "javaNamingReference提供了一种记录对象地址信息的方法，该对象本身并不直接存储在目录中。存储为javaMarshalledObject的远程对象还记录对象的地址信息（对象的“存根”），该对象本身不是存储在目录中的目录。换句话说，您可以将其视为访问对象所需信息的紧凑表示。"
    },
    {
      "indent": 3,
      "text": "A javaNamingReference typically consists of a small number of human-readable strings. Standard text-based tools for directory administration may therefore be used to add, read, or modify reference entries -- if so desired -- quite easily. Serialized and marshalled objects are not intended to be read or manipulated directly by humans.",
      "zh-CHS": "javaNamingReference通常由少量人类可读的字符串组成。因此，用于目录管理的标准基于文本的工具可以很容易地用于添加、读取或修改引用条目（如果需要）。序列化和封送的对象不打算由人直接读取或操作。"
    },
    {
      "indent": 0,
      "text": "3 Attribute Type Definitions",
      "zh-CHS": "3属性类型定义"
    },
    {
      "indent": 3,
      "text": "The following attribute types are defined in this document:",
      "zh-CHS": "本文档中定义了以下属性类型："
    },
    {
      "indent": 7,
      "text": "javaClassName javaClassNames javaCodebase javaSerializedData javaFactory javaReferenceAddress javaDoc",
      "zh-CHS": "javaClassName javaClassNames javaCodebase javaSerializedData javaFactory javaReferenceAddress javaDoc"
    },
    {
      "indent": 0,
      "text": "3.1 javaClassName",
      "section_title": true,
      "zh-CHS": "3.1 javaClassName"
    },
    {
      "indent": 3,
      "text": "This attribute stores the fully qualified name of the Java object's \"distinguished\" class or interface (for example, \"java.lang.String\"). It is a single-valued attribute. This attribute's syntax is ' Directory String' and its case is significant.",
      "zh-CHS": "该属性存储Java对象的“可分辨”类或接口的完全限定名（例如，“Java.lang.String”）。它是一个单值属性。此属性的语法为“目录字符串”，其大小写意义重大。"
    },
    {
      "indent": 7,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.6 NAME 'javaClassName' DESC 'Fully qualified name of distinguished Java class or interface' EQUALITY caseExactMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 SINGLE-VALUE )",
      "zh-CHS": "（1.3.6.1.4.1.42.2.27.4.1.6名称“javaClassName”DESC“可分辨Java类或接口的完全限定名”EQUALITY caseExactMatch语法1.3.6.1.4.1.1466.115.121.1.15单值）"
    },
    {
      "indent": 0,
      "text": "3.2 javaCodebase",
      "section_title": true,
      "zh-CHS": "3.2 javaCodebase"
    },
    {
      "indent": 3,
      "text": "This attribute stores the Java class definition's locations. It specifies the locations from which to load the class definition for the class specified by the javaClassName attribute. Each value of the attribute contains an ordered list of URLs, separated by spaces. For example, a value of \"url1 url2 url3\" means that the three (possibly interdependent) URLs (url1, url2, and url3) form the codebase for loading in the Java class definition.",
      "zh-CHS": "此属性存储Java类定义的位置。它指定了加载javaClassName属性指定的类的类定义的位置。该属性的每个值都包含URL的有序列表，以空格分隔。例如，值“url1 url2 url3”意味着三个（可能相互依赖的）URL（url1、url2和url3）构成了用于加载Java类定义的代码库。"
    },
    {
      "indent": 3,
      "text": "If the javaCodebase attribute contains more than one value, each value is an independent codebase. That is, there is no relationship between the URLs in one value and those in another; each value can be viewed as an alternate source for loading the Java class definition. See [Java] for information regarding class loading.",
      "zh-CHS": "如果javaCodebase属性包含多个值，则每个值都是独立的代码库。也就是说，一个值中的URL与另一个值中的URL之间没有关系；每个值都可以被视为加载Java类定义的备用源。有关类加载的信息，请参见[Java]。"
    },
    {
      "indent": 3,
      "text": "This attribute's syntax is 'IA5 String' and its case is significant.",
      "zh-CHS": "此属性的语法为“IA5 String”，其大小写意义重大。"
    },
    {
      "indent": 7,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.7 NAME 'javaCodebase' DESC 'URL(s) specifying the location of class definition' EQUALITY caseExactIA5Match SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 )",
      "zh-CHS": "（1.3.6.1.4.1.42.2.27.4.1.7指定类定义“EQUALITY caseExactIA5Match SYNTAX 1.3.6.1.4.1.1466.115.121.1.26”位置的名称“javaCodebase”描述URL）"
    },
    {
      "indent": 0,
      "text": "3.3 javaClassNames",
      "section_title": true,
      "zh-CHS": "3.3 Java类名"
    },
    {
      "indent": 3,
      "text": "This attribute stores the Java object's fully qualified class or interface names (for example, \"java.lang.String\"). It is a multivalued attribute. When more than one value is present, each is the name of a class or interface, or ancestor class or interface, of this object.",
      "zh-CHS": "该属性存储Java对象的完全限定类或接口名（例如，“Java.lang.String”）。它是一个多值属性。当存在多个值时，每个值都是该对象的类或接口或祖先类或接口的名称。"
    },
    {
      "indent": 3,
      "text": "This attribute's syntax is 'Directory String' and its case is significant.",
      "zh-CHS": "此属性的语法为“目录字符串”，其大小写意义重大。"
    },
    {
      "indent": 7,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.13 NAME 'javaClassNames' DESC 'Fully qualified Java class or interface name' EQUALITY caseExactMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )",
      "zh-CHS": "（1.3.6.1.4.1.42.2.27.4.1.13名称“javaClassNames”DESC“完全限定Java类或接口名称”EQUALITY caseExactMatch语法1.3.6.1.4.1.1466.115.121.1.15）"
    },
    {
      "indent": 0,
      "text": "3.4 javaSerializedData",
      "section_title": true,
      "zh-CHS": "3.4 爪哇数据"
    },
    {
      "indent": 3,
      "text": "This attribute stores the serialized form of a Java object. The serialized form is described in [Serial].",
      "zh-CHS": "此属性存储Java对象的序列化形式。序列化形式在[Serial]中描述。"
    },
    {
      "indent": 3,
      "text": "This attribute's syntax is 'Octet String'.",
      "zh-CHS": "此属性的语法为“八进制字符串”。"
    },
    {
      "indent": 7,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.8 NAME 'javaSerializedData DESC 'Serialized form of a Java object' SYNTAX 1.3.6.1.4.1.1466.115.121.1.40 SINGLE-VALUE )",
      "zh-CHS": "（1.3.6.1.4.1.42.2.27.4.1.8名称“javaSerializedData DESC”Java对象的序列化形式”语法1.3.6.1.4.1.1466.115.121.1.40单值）"
    },
    {
      "indent": 0,
      "text": "3.5 javaFactory",
      "section_title": true,
      "zh-CHS": "3.5 爪哇工厂"
    },
    {
      "indent": 3,
      "text": "This attribute stores the fully qualified class name of the object factory (for example, \"com.wiz.jndi.WizObjectFactory\") that can be used to create an instance of the object identified by the javaClassName attribute.",
      "zh-CHS": "此属性存储对象工厂的完全限定类名（例如，“com.wiz.jndi.WizObjectFactory”），可用于创建javaClassName属性标识的对象实例。"
    },
    {
      "indent": 3,
      "text": "This attribute's syntax is 'Directory String' and its case is significant.",
      "zh-CHS": "此属性的语法为“目录字符串”，其大小写意义重大。"
    },
    {
      "indent": 7,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.10 NAME 'javaFactory' DESC 'Fully qualified Java class name of a JNDI object factory' EQUALITY caseExactMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 SINGLE-VALUE )",
      "zh-CHS": "（1.3.6.1.4.1.42.2.27.4.1.10名称'javaFactory'DESC'JNDI对象工厂的完全限定Java类名'EQUALITY caseExactMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15单值）"
    },
    {
      "indent": 0,
      "text": "3.6 javaReferenceAddress",
      "section_title": true,
      "zh-CHS": "3.6 javaReferenceAddress"
    },
    {
      "indent": 3,
      "text": "This attribute represents the sequence of addresses of a JNDI reference. Each of its values represents one address, a Java object of type javax.naming.RefAddr. Its value is a concatenation of the address type and address contents, preceded by a sequence number (the order of addresses in a JNDI reference is significant). For example:",
      "zh-CHS": "此属性表示JNDI引用的地址序列。它的每个值表示一个地址，即javax.naming.RefAddr类型的Java对象。它的值是地址类型和地址内容的串联，前面是一个序列号（JNDI引用中的地址顺序很重要）。例如："
    },
    {
      "indent": 7,
      "text": "#0#TypeA#ValA #1#TypeB#ValB #2#TypeC##rO0ABXNyABpq...",
      "zh-CHS": "#0#TypeA#ValA#1#TypeB#ValB#2#TypeC#rO0ABXNyABpq。。。"
    },
    {
      "indent": 3,
      "text": "In more detail, the value is encoded as follows:",
      "zh-CHS": "更详细地说，该值编码如下："
    },
    {
      "indent": 3,
      "text": "The delimiter is the first character of the value. For readability the character '#' is recommended when it is not otherwise used anywhere in the value, but any character may be used subject to restrictions given below.",
      "zh-CHS": "分隔符是值的第一个字符。为确保可读性，如果未在值中的任何位置使用字符“#”，则建议使用字符“#”，但任何字符的使用都可能受到以下限制。"
    },
    {
      "indent": 3,
      "text": "The first delimiter is followed by the sequence number. The sequence number of an address is its position in the JNDI reference, with the first address being numbered 0. It is represented by its shortest string form, in decimal notation.",
      "zh-CHS": "第一个分隔符后面跟着序列号。地址的序列号是它在JNDI引用中的位置，第一个地址编号为0。它由最短的字符串形式表示，以十进制表示。"
    },
    {
      "indent": 3,
      "text": "The sequence number is followed by a delimiter, then by the address type, and then by another delimiter. If the address is of Java class javax.naming.StringRefAddr, then this delimiter is followed by the value of the address contents (which is a string). Otherwise, this delimiter is followed immediately by another delimiter, and then by the Base64 encoding of the serialized form of the entire address.",
      "zh-CHS": "序列号后跟一个分隔符，然后是地址类型，然后是另一个分隔符。如果地址是Java类javax.naming.StringRefAddress，则此分隔符后面跟着地址内容的值（这是一个字符串）。否则，此分隔符后面紧跟着另一个分隔符，然后是整个地址的序列化形式的Base64编码。"
    },
    {
      "indent": 3,
      "text": "The delimiter may be any character other than a digit or a character contained in the address type. In addition, if the address contents is a string, the delimiter may not be the first character of that string.",
      "zh-CHS": "分隔符可以是除数字或地址类型中包含的字符以外的任何字符。此外，如果地址内容是字符串，则分隔符可能不是该字符串的第一个字符。"
    },
    {
      "indent": 3,
      "text": "This attribute's syntax is 'Directory String' and its case is significant. It can contain multiple values.",
      "zh-CHS": "此属性的语法为“目录字符串”，其大小写意义重大。它可以包含多个值。"
    },
    {
      "indent": 7,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.11 NAME 'javaReferenceAddress' DESC 'Addresses associated with a JNDI Reference' EQUALITY caseExactMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )",
      "zh-CHS": "（1.3.6.1.4.1.42.2.27.4.1.11名称'javaReferenceAddress'DESC'地址与JNDI引用'EQUALITY caseExactMatch语法1.3.6.1.4.1.1466.115.121.1.15关联）"
    },
    {
      "indent": 0,
      "text": "3.7 javaDoc",
      "section_title": true,
      "zh-CHS": "3.7 javaDoc"
    },
    {
      "indent": 3,
      "text": "This attribute stores a pointer to the Java documentation for the\nclass.  It's value is a URL. For example, the following URL points to\nthe specification of the java.lang.String class:\nhttp://java.sun.com/products/jdk/1.2/docs/api/java/lang/String.html",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "This attribute's syntax is 'IA5 String' and its case is significant.",
      "zh-CHS": "此属性的语法为“IA5 String”，其大小写意义重大。"
    },
    {
      "indent": 7,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.12 NAME 'javaDoc' DESC 'The Java documentation for the class' EQUALITY caseExactIA5Match SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 )",
      "zh-CHS": "（1.3.6.1.4.1.42.2.27.4.1.12名称“javaDoc”描述类“EQUALITY caseExactIA5Match SYNTAX 1.3.6.1.4.1.1466.115.121.1.26”的Java文档）"
    },
    {
      "indent": 0,
      "text": "4 Object Class Definitions",
      "zh-CHS": "4对象类定义"
    },
    {
      "indent": 3,
      "text": "The following object classes are defined in this document:",
      "zh-CHS": "本文档中定义了以下对象类："
    },
    {
      "indent": 7,
      "text": "javaContainer javaObject javaSerializedObject javaMarshalledObject javaNamingReference",
      "zh-CHS": "javaContainer javaObject javaSerializedObject javaMarshalledObject javaNamingReference"
    },
    {
      "indent": 0,
      "text": "4.1 javaContainer",
      "section_title": true,
      "zh-CHS": "4.1 javaContainer"
    },
    {
      "indent": 3,
      "text": "This structural object class represents a container for a Java object.",
      "zh-CHS": "此结构对象类表示Java对象的容器。"
    },
    {
      "indent": 7,
      "text": "( 1.3.6.1.4.1.42.2.27.4.2.1 NAME 'javaContainer' DESC 'Container for a Java object' SUP top STRUCTURAL MUST ( cn ) )",
      "zh-CHS": "（1.3.6.1.4.1.42.2.27.4.2.1 Java对象的名称“javaContainer”DESC“Container”SUP top STRUCTURAL MUST（cn））"
    },
    {
      "indent": 0,
      "text": "4.2 javaObject",
      "section_title": true,
      "zh-CHS": "4.2 javaObject"
    },
    {
      "indent": 3,
      "text": "This abstract object class represents a Java object. A javaObject cannot exist in the directory; only auxiliary or structural subclasses of it can exist in the directory.",
      "zh-CHS": "这个抽象对象类表示一个Java对象。目录中不能存在javaObject；目录中只能存在它的辅助子类或结构子类。"
    },
    {
      "indent": 7,
      "text": "( 1.3.6.1.4.1.42.2.27.4.2.4 NAME 'javaObject' DESC 'Java object representation' SUP top ABSTRACT MUST ( javaClassName ) MAY ( javaClassNames $ javaCodebase $ javaDoc $ description ) )",
      "zh-CHS": "（1.3.6.1.4.1.42.2.27.4.2.4名称“javaObject”DESC“Java对象表示”SUP-top-ABSTRACT-MUST（javaClassName）MAY（javaClassNames$javaCodebase$javaDoc$description））"
    },
    {
      "indent": 0,
      "text": "4.3 javaSerializedObject",
      "section_title": true,
      "zh-CHS": "4.3 JavaDobject"
    },
    {
      "indent": 3,
      "text": "This auxiliary object class represents a Java serialized object. It must be mixed in with a structural object class.",
      "zh-CHS": "此辅助对象类表示Java序列化对象。它必须与结构对象类混合。"
    },
    {
      "indent": 7,
      "text": "( 1.3.6.1.4.1.42.2.27.4.2.5 NAME 'javaSerializedObject' DESC 'Java serialized object' SUP javaObject AUXILIARY MUST ( javaSerializedData ) )",
      "zh-CHS": "（1.3.6.1.4.1.42.2.27.4.2.5名称“javaSerializedObject”DESC“Java序列化对象”SUP javaObject辅助必须（javaSerializedData））"
    },
    {
      "indent": 0,
      "text": "4.4 javaMarshalledObject",
      "section_title": true,
      "zh-CHS": "4.4 javaMarshalledObject"
    },
    {
      "indent": 3,
      "text": "This auxiliary object class represents a Java marshalled object. It must be mixed in with a structural object class.",
      "zh-CHS": "此辅助对象类表示Java编组对象。它必须与结构对象类混合。"
    },
    {
      "indent": 7,
      "text": "( 1.3.6.1.4.1.42.2.27.4.2.8 NAME 'javaMarshalledObject' DESC 'Java marshalled object' SUP javaObject AUXILIARY MUST ( javaSerializedData ) )",
      "zh-CHS": "（1.3.6.1.4.1.42.2.27.4.2.8名称“javaMarshalledObject”DESC“Java marshalled object”SUP javaObject辅助必须（javaSerializedData））"
    },
    {
      "indent": 0,
      "text": "4.5 javaNamingReference",
      "section_title": true,
      "zh-CHS": "4.5 javaNamingReference"
    },
    {
      "indent": 3,
      "text": "This auxiliary object class represents a JNDI reference. It must be mixed in with a structural object class.",
      "zh-CHS": "这个辅助对象类表示一个JNDI引用。它必须与结构对象类混合。"
    },
    {
      "indent": 7,
      "text": "( 1.3.6.1.4.1.42.2.27.4.2.7 NAME 'javaNamingReference' DESC 'JNDI reference' SUP javaObject AUXILIARY MAY ( javaReferenceAddress $ javaFactory ) )",
      "zh-CHS": "（1.3.6.1.4.1.42.2.27.4.2.7名称“javaNamingReference”DESC“JNDI reference”SUP javaObject AUXILIARY MAY（javaReferenceAddress$javaFactory））"
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "zh-CHS": "5. 安全考虑"
    },
    {
      "indent": 3,
      "text": "Serializing an object and storing it into the directory enables (a copy of) the object to be examined and used outside the environment in which it was originally created. The directory entry containing the serialized object could be read and modified within the constraints imposed by the access control mechanisms of the directory. If an object contains sensitive information or information that could be misused outside of the context in which it was created, the object should not be stored in the directory. For more details on security issues relating to serialization in general, see [Serial].",
      "zh-CHS": "序列化对象并将其存储到目录中可以在最初创建该对象的环境之外检查和使用该对象（其副本）。可以在目录的访问控制机制施加的约束范围内读取和修改包含序列化对象的目录项。如果对象包含敏感信息或可能在创建该对象的上下文之外被误用的信息，则不应将该对象存储在目录中。有关一般序列化相关安全问题的更多详细信息，请参阅[Serial]。"
    },
    {
      "indent": 0,
      "text": "6. Acknowledgements",
      "section_title": true,
      "zh-CHS": "6. 致谢"
    },
    {
      "indent": 3,
      "text": "We would like to thank Joseph Fialli, Peter Jones, Roger Riggs, Bob Scheifler, and Ann Wollrath of Sun Microsystems for their comments and suggestions.",
      "zh-CHS": "我们要感谢Sun Microsystems的约瑟夫·菲亚利、彼得·琼斯、罗杰·里格斯、鲍勃·谢弗勒和安·沃尔拉斯的评论和建议。"
    },
    {
      "indent": 0,
      "text": "7. References",
      "section_title": true,
      "zh-CHS": "7. 工具书类"
    },
    {
      "indent": 3,
      "text": "[CORBA] The Object Management Group, \"Common Object Request Broker Architecture Specification 2.0,\" http://www.omg.org",
      "zh-CHS": "[CORBA]对象管理组，“公共对象请求代理体系结构规范2.0”http://www.omg.org"
    },
    {
      "indent": 3,
      "text": "[CORBA-LDAP] Ryan, V., Lee, R. and S. Seligman, \"Schema for Representing CORBA Object References in an LDAP Directory\", RFC 2714, October 1999.",
      "zh-CHS": "[CORBA-LDAP]Ryan，V.，Lee，R.和S.Seligman，“在LDAP目录中表示CORBA对象引用的模式”，RFC 2714，1999年10月。"
    },
    {
      "indent": 3,
      "text": "[Java] Ken Arnold and James Gosling, \"The Java(tm) Programming Language,\" Second Edition, ISBN 0-201-31006-6.",
      "zh-CHS": "[Java]Ken Arnold和James Gosling，“Java（tm）编程语言”，第二版，ISBN 0-201-31006-6。"
    },
    {
      "indent": 3,
      "text": "[JNDI]       Java Software, Sun Microsystems, Inc., \"The Java(tm)\n             Naming and Directory Interface (tm) Specification,\"\n             February 1998.  http://java.sun.com/products/jndi/",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "[LDAPv3] Wahl, M., Howes, T. and S. Kille, \"Lightweight Directory Access Protocol (v3)\", RFC 2251, December 1997.",
      "zh-CHS": "[LDAPv3]Wahl，M.，Howes，T.和S.Kille，“轻量级目录访问协议（v3）”，RFC 2251，1997年12月。"
    },
    {
      "indent": 3,
      "text": "[RMI]        Java Software, Sun Microsystems, Inc., \"Remote Method\n             Invocation,\" November 1998.\n             http://java.sun.com/products/jdk/1.2/docs/guide/rmi",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "[RMI-IIOP]   IBM and Java Software, Sun Microsystems, Inc., \"RMI over\n             IIOP\", June 1999.\n             http://java.sun.com/products/rmi-iiop/",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "[Serial]     Java Software, Sun Microsystems, Inc., \"Object\n             Serialization Specification,\" November 1998.\n             http://java.sun.com/products/jdk/1.2/docs/guide/\n             serialization",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "[v3Schema] Wahl, M., \"A Summary of the X.500(96) User Schema for use with LDAPv3\", RFC 2256, December 1997.",
      "zh-CHS": "[v3Schema]Wahl，M.“与LDAPv3一起使用的X.500（96）用户模式摘要”，RFC 2256，1997年12月。"
    },
    {
      "indent": 0,
      "text": "8. Authors' Addresses",
      "section_title": true,
      "zh-CHS": "8. 作者地址"
    },
    {
      "indent": 3,
      "text": "Vincent Ryan Sun Microsystems, Inc. Mail Stop EDUB03 901 San Antonio Road Palo Alto, CA 94303 USA",
      "zh-CHS": "Vincent Ryan Sun Microsystems，Inc.美国加利福尼亚州帕洛阿尔托市圣安东尼奥路901号邮政站EDUB03 94303"
    },
    {
      "indent": 3,
      "text": "Phone: +353 1 819 9151\nEMail: vincent.ryan@ireland.sun.com",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Scott Seligman Sun Microsystems, Inc. Mail Stop UCUP02-209 901 San Antonio Road Palo Alto, CA 94303 USA",
      "zh-CHS": "Scott Seligman Sun Microsystems，Inc.美国加利福尼亚州帕洛阿尔托市圣安东尼奥路901号邮政站UCUP02-209邮编94303"
    },
    {
      "indent": 3,
      "text": "Phone: +1 408 863 3222\nEMail: scott.seligman@eng.sun.com",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Rosanna Lee Sun Microsystems, Inc. Mail Stop UCUP02-206 901 San Antonio Road Palo Alto, CA 94303 USA",
      "zh-CHS": "Rosanna Lee Sun Microsystems，Inc.美国加利福尼亚州帕洛阿尔托市圣安东尼奥路901号邮政站UCUP02-206 94303"
    },
    {
      "indent": 3,
      "text": "Phone: +1 408 863 3221\nEMail: rosanna.lee@eng.sun.com",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "Appendix - LDAP Schema",
      "zh-CHS": "附录-LDAP模式"
    },
    {
      "indent": 2,
      "text": "-- Attribute types --",
      "zh-CHS": "--属性类型--"
    },
    {
      "indent": 2,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.6 NAME 'javaClassName' DESC 'Fully qualified name of distinguished Java class or interface' EQUALITY caseExactMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 SINGLE-VALUE )",
      "zh-CHS": "（1.3.6.1.4.1.42.2.27.4.1.6名称“javaClassName”DESC“可分辨Java类或接口的完全限定名”EQUALITY caseExactMatch语法1.3.6.1.4.1.1466.115.121.1.15单值）"
    },
    {
      "indent": 2,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.7 NAME 'javaCodebase' DESC 'URL(s) specifying the location of class definition' EQUALITY caseExactIA5Match SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 )",
      "zh-CHS": "（1.3.6.1.4.1.42.2.27.4.1.7指定类定义“EQUALITY caseExactIA5Match SYNTAX 1.3.6.1.4.1.1466.115.121.1.26”位置的名称“javaCodebase”描述URL）"
    },
    {
      "indent": 2,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.8 NAME 'javaSerializedData' DESC 'Serialized form of a Java object' SYNTAX 1.3.6.1.4.1.1466.115.121.1.40 SINGLE-VALUE )",
      "zh-CHS": "（1.3.6.1.4.1.42.2.27.4.1.8名称“javaSerializedData”DESC“Java对象的序列化形式”语法1.3.6.1.4.1.1466.115.121.1.40单值）"
    },
    {
      "indent": 2,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.10 NAME 'javaFactory' DESC 'Fully qualified Java class name of a JNDI object factory' EQUALITY caseExactMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 SINGLE-VALUE )",
      "zh-CHS": "（1.3.6.1.4.1.42.2.27.4.1.10名称'javaFactory'DESC'JNDI对象工厂的完全限定Java类名'EQUALITY caseExactMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15单值）"
    },
    {
      "indent": 2,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.11 NAME 'javaReferenceAddress' DESC 'Addresses associated with a JNDI Reference' EQUALITY caseExactMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )",
      "zh-CHS": "（1.3.6.1.4.1.42.2.27.4.1.11名称'javaReferenceAddress'DESC'地址与JNDI引用'EQUALITY caseExactMatch语法1.3.6.1.4.1.1466.115.121.1.15关联）"
    },
    {
      "indent": 2,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.12 NAME 'javaDoc' DESC 'The Java documentation for the class' EQUALITY caseExactIA5Match SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 )",
      "zh-CHS": "（1.3.6.1.4.1.42.2.27.4.1.12名称“javaDoc”描述类“EQUALITY caseExactIA5Match SYNTAX 1.3.6.1.4.1.1466.115.121.1.26”的Java文档）"
    },
    {
      "indent": 2,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.13 NAME 'javaClassNames' DESC 'Fully qualified Java class or interface name' EQUALITY caseExactMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )",
      "zh-CHS": "（1.3.6.1.4.1.42.2.27.4.1.13名称“javaClassNames”DESC“完全限定Java类或接口名称”EQUALITY caseExactMatch语法1.3.6.1.4.1.1466.115.121.1.15）"
    },
    {
      "indent": 2,
      "text": "-- from RFC-2256 --",
      "zh-CHS": "--来自RFC-2256--"
    },
    {
      "indent": 2,
      "text": "( 2.5.4.13 NAME 'description' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15{1024} )",
      "zh-CHS": "（2.5.4.13名称'description'相等caseIgnoreMatch SUBSTR caseIgnoreMatch语法1.3.6.1.4.1.1466.115.121.1.15{1024}）"
    },
    {
      "indent": 2,
      "text": "-- Object classes --",
      "zh-CHS": "--对象类--"
    },
    {
      "indent": 2,
      "text": "( 1.3.6.1.4.1.42.2.27.4.2.1 NAME 'javaContainer' DESC 'Container for a Java object' SUP top STRUCTURAL MUST ( cn ) )",
      "zh-CHS": "（1.3.6.1.4.1.42.2.27.4.2.1 Java对象的名称“javaContainer”DESC“Container”SUP top STRUCTURAL MUST（cn））"
    },
    {
      "indent": 2,
      "text": "( 1.3.6.1.4.1.42.2.27.4.2.4 NAME 'javaObject' DESC 'Java object representation' SUP top ABSTRACT MUST ( javaClassName ) MAY ( javaClassNames $ javaCodebase $ javaDoc $ description ) )",
      "zh-CHS": "（1.3.6.1.4.1.42.2.27.4.2.4名称“javaObject”DESC“Java对象表示”SUP-top-ABSTRACT-MUST（javaClassName）MAY（javaClassNames$javaCodebase$javaDoc$description））"
    },
    {
      "indent": 2,
      "text": "( 1.3.6.1.4.1.42.2.27.4.2.5 NAME 'javaSerializedObject' DESC 'Java serialized object' SUP javaObject AUXILIARY MUST ( javaSerializedData ) )",
      "zh-CHS": "（1.3.6.1.4.1.42.2.27.4.2.5名称“javaSerializedObject”DESC“Java序列化对象”SUP javaObject辅助必须（javaSerializedData））"
    },
    {
      "indent": 2,
      "text": "( 1.3.6.1.4.1.42.2.27.4.2.7 NAME 'javaNamingReference' DESC 'JNDI reference' SUP javaObject AUXILIARY MAY ( javaReferenceAddress $ javaFactory ) )",
      "zh-CHS": "（1.3.6.1.4.1.42.2.27.4.2.7名称“javaNamingReference”DESC“JNDI reference”SUP javaObject AUXILIARY MAY（javaReferenceAddress$javaFactory））"
    },
    {
      "indent": 2,
      "text": "( 1.3.6.1.4.1.42.2.27.4.2.8 NAME 'javaMarshalledObject' DESC 'Java marshalled object' SUP javaObject AUXILIARY MUST ( javaSerializedData ) )",
      "zh-CHS": "（1.3.6.1.4.1.42.2.27.4.2.8名称“javaMarshalledObject”DESC“Java marshalled object”SUP javaObject辅助必须（javaSerializedData））"
    },
    {
      "indent": 2,
      "text": "-- Matching rule from ISO X.520 --",
      "zh-CHS": "--ISO X.520中的匹配规则--"
    },
    {
      "indent": 2,
      "text": "( 2.5.13.5 NAME 'caseExactMatch' SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )",
      "zh-CHS": "（2.5.13.5名称“caseExactMatch”语法1.3.6.1.4.1.1466.115.121.1.15）"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "zh-CHS": "完整版权声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1999). All Rights Reserved.",
      "zh-CHS": "版权所有（C）互联网协会（1999年）。版权所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "zh-CHS": "本文件及其译本可复制并提供给他人，对其进行评论或解释或协助其实施的衍生作品可全部或部分编制、复制、出版和分发，不受任何限制，前提是上述版权声明和本段包含在所有此类副本和衍生作品中。但是，不得以任何方式修改本文件本身，例如删除版权通知或对互联网协会或其他互联网组织的引用，除非出于制定互联网标准的需要，在这种情况下，必须遵循互联网标准过程中定义的版权程序，或根据需要将其翻译成英语以外的其他语言。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "zh-CHS": "上述授予的有限许可是永久性的，互联网协会或其继承人或受让人不会撤销。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "zh-CHS": "本文件和其中包含的信息是按“原样”提供的，互联网协会和互联网工程任务组否认所有明示或暗示的保证，包括但不限于任何保证，即使用本文中的信息不会侵犯任何权利，或对适销性或特定用途适用性的任何默示保证。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "zh-CHS": "确认"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "zh-CHS": "RFC编辑功能的资金目前由互联网协会提供。"
    }
  ]
}