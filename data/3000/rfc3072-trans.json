{
  "title": {
    "text": "RFC 3072:  Structured Data Exchange Format (SDXF) ",
    "zh-CHS": "RFC 3072"
  },
  "number": 3072,
  "created_at": "2021-10-25 20:23:07.137388+08:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                       M. Wildgrube\nRequest for Comments: 3072                                    March 2001\nCategory: Informational",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 17,
      "text": "Structured Data Exchange Format (SDXF)",
      "zh-CHS": "结构化数据交换格式（SDXF）"
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "zh-CHS": "本备忘录的状况"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "zh-CHS": "本备忘录为互联网社区提供信息。它没有规定任何类型的互联网标准。本备忘录的分发不受限制。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "zh-CHS": "版权公告"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2001). All Rights Reserved.",
      "zh-CHS": "版权所有（C）互联网协会（2001年）。版权所有。"
    },
    {
      "indent": 0,
      "text": "IESG Note",
      "zh-CHS": "IESG注释"
    },
    {
      "indent": 3,
      "text": "This document specifies a data exchange format and, partially, an API that can be used for creating and parsing such a format. The IESG notes that the same problem space can be addressed using formats that the IETF normally uses including ASN.1 and XML. The document reader is strongly encouraged to carefully read section 13 before choosing SDXF over ASN.1 or XML. Further, when storing text in SDXF, the user is encourage to use the datatype for UTF-8, specified in section 2.5.",
      "zh-CHS": "本文档指定了数据交换格式，部分还指定了可用于创建和解析此类格式的API。IESG指出，可以使用IETF通常使用的格式（包括ASN.1和XML）解决相同的问题空间。强烈建议文档读者在选择SDXF而不是ASN.1或XML之前仔细阅读第13节。此外，在SDXF中存储文本时，鼓励用户使用第2.5节中指定的UTF-8数据类型。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "zh-CHS": "摘要"
    },
    {
      "indent": 3,
      "text": "This specification describes an all-purpose interchange format for use as a file format or for net-working. Data is organized in chunks which can be ordered in hierarchical structures. This format is self-describing and CPU-independent.",
      "zh-CHS": "本规范描述了用作文件格式或网络工作的通用交换格式。数据被组织成块，可以按层次结构排序。这种格式是自描述的，与CPU无关。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "zh-CHS": "目录"
    },
    {
      "indent": 3,
      "text": "1.  Introduction ................................................. 2\n2.  Description of the SDXF data format .......................... 3\n3.  Introduction to the SDXF functions ........................... 5\n3.1 General remarks .............................................. 5\n3.2 Writing a SDXF buffer ........................................ 5\n3.3 Reading a SDXF buffer ........................................ 6\n3.4 Example ...................................................... 6\n4.  Platform independence ........................................ 8\n5.  Compression .................................................. 9\n6.  Encryption ...................................................11\n7.  Arrays........................................................11\n8.  Description of the SDXF functions ............................12",
      "raw": true,
      "toc": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "8.1 Introduction .................................................12\n8.2 Basic definitions ............................................13\n8.3 Definitions for C++ ..........................................15\n8.4 Common Definitions ...........................................16\n8.5 Special functions ............................................17\n9.  'Support' of UTF-8 ...........................................19\n10.  Security Considerations .....................................19\n11.  Some general hints ..........................................20\n12.  IANA Considerations .........................................20\n13.  Discussion ..................................................21\n13.1 SDXF vs. ASN.1 ..............................................21\n13.2 SDXF vs. XML ................................................22\n14.  Author's Address ............................................24\n15.  Acknowledgements ............................................24\n16.  References ..................................................24\n17.  Full Copyright Statement ....................................26",
      "raw": true,
      "toc": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "zh-CHS": "1. 介绍"
    },
    {
      "indent": 3,
      "text": "The purpose of the Structured Data eXchange Format (SDXF) is to permit the interchange of an arbitrary structured data block with different kinds of data (numerical, text, bitstrings). Because data is normalized to an abstract computer architecture independent \"network format\", SDXF is usable as a network interchange data format.",
      "zh-CHS": "结构化数据交换格式（SDXF）的目的是允许任意结构化数据块与不同类型的数据（数字、文本、位字符串）进行交换。由于数据被规范化为独立于抽象计算机体系结构的“网络格式”，因此SDXF可用作网络交换数据格式。"
    },
    {
      "indent": 3,
      "text": "This data format is not limited to any application, the demand for this format is that it is usable as a text format for word-processing, as a picture format, a sound format, for remote procedure calls with complex parameters, suitable for document formats, for interchanging business data, etc.",
      "zh-CHS": "该数据格式不限于任何应用程序，对该格式的需求是，它可用作文字处理的文本格式、图片格式、声音格式、具有复杂参数的远程过程调用、适合文档格式、交换业务数据等。"
    },
    {
      "indent": 3,
      "text": "SDXF is self-describing, every program can unpack every SDXF-data without knowing the meaning of the individual data elements.",
      "zh-CHS": "SDXF是自描述的，每个程序都可以解包每个SDXF数据，而不知道单个数据元素的含义。"
    },
    {
      "indent": 3,
      "text": "Together with the description of the data format a set of functions will be introduced. With the help of these functions one can create and access the data elements of SDXF. The idea is that a programmer should only use these functions instead of maintaining the structure by himself on the level of bits and bytes. (In the speech of object-oriented programming these functions are methods of an object which works as a handle for a given SDXF data block.)",
      "zh-CHS": "在介绍数据格式的同时，还将介绍一组函数。借助这些函数，可以创建和访问SDXF的数据元素。其思想是程序员应该只使用这些函数，而不是自己在位和字节级别上维护结构。（在面向对象编程中，这些函数是对象的方法，用作给定SDXF数据块的句柄。）"
    },
    {
      "indent": 3,
      "text": "SDXF is not limited to a specific platform, along with a correct preparation of the SDXF functions the SDXF data can be interchanged (via network or data carrier) across the boundaries of different architectures (specified by the character code like ASCII, ANSI or EBCDIC and the byte order for binary data).",
      "zh-CHS": "SDXF不限于特定平台，只要正确准备SDXF功能，SDXF数据就可以（通过网络或数据载体）跨不同体系结构的边界进行交换（由ASCII、ANSI或EBCDIC等字符代码以及二进制数据的字节顺序指定）。"
    },
    {
      "indent": 3,
      "text": "SDXF is also prepared to compress and encrypt parts or the whole block of SDXF data.",
      "zh-CHS": "SDXF还准备对部分或整个SDXF数据块进行压缩和加密。"
    },
    {
      "indent": 0,
      "text": "2. Description of SDXF data format.",
      "zh-CHS": "2. SDXF数据格式说明。"
    },
    {
      "indent": 0,
      "text": "2.1 First we introduce the term \"chunk\". A chunk is a data structure with a fixed set of components. A chunk may be \"elementary\" or \"structured\". The latter one contains itself one or more other chunks.",
      "zh-CHS": "2.1 首先我们介绍术语“块”。块是一种具有固定组件集的数据结构。语块可以是“基本的”或“结构化的”。后者本身包含一个或多个其他块。"
    },
    {
      "indent": 3,
      "text": "A chunk consists of a header and the data body (content):",
      "zh-CHS": "区块由标头和数据体（内容）组成："
    },
    {
      "indent": 3,
      "text": "+----------+-----+-------+-----------------------------------+\n| Name     | Pos.| Length| Description                       |\n+----------+-----+-------+-----------------------------------+\n| chunk-ID |  1  |   2   | ID of the chunk (unsigned short)  |\n| flags    |  3  |   1   | type and properties of this chunk |\n| length   |  4  |   3   | length  of the following data     |\n| content  |  7  |   *)  | net data or a list of of chunks   |\n+----------+-----+-------+-----------------------------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "(* as stated in \"length\". total length of chunk is length+6. The chunk ID is a non-zero positive number.",
      "zh-CHS": "（*如“长度”中所述。区块的总长度为长度+6。区块ID为非零正数。"
    },
    {
      "indent": 3,
      "text": "or more visually:",
      "zh-CHS": "或者更直观地说："
    },
    {
      "indent": 3,
      "text": "+----+----+----+----+----+----+----+----+----+-...\n| chunkID | fl | length       |  content\n+----+----+----+----+----+----+----+----+----+-...",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "or in ASN.1 syntax:",
      "zh-CHS": "或在ASN.1语法中："
    },
    {
      "indent": 3,
      "text": "chunk  ::=  SEQUENCE\n{\n  chunkID INTEGER (1..65535),\n  flags   BIT STRING,\n  length  OCTET STRING SIZE 3, -- or: INTEGER (0..16777215)\n  content OCTET STRING\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "2.2 Structured chunk.",
      "zh-CHS": "2.2 结构化块。"
    },
    {
      "indent": 3,
      "text": "A structured chunk is marked as such by the flag byte (see 2.5). Opposed to an elementary chunk its content consists of a list of chunks (elementary or structured):",
      "zh-CHS": "结构化块由标志字节标记（见2.5）。与基本块相对，其内容由一系列块（基本块或结构化块）组成："
    },
    {
      "indent": 3,
      "text": "+----+-+---+-------+-------+-------+-----+-------+\n| id |f|len| chunk | chunk | chunk | ... | chunk |\n+----+-+---+-------+-------+-------+-----+-------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "With the help of this concept you can reproduce every hierarchically structured data into a SDXF chunk.",
      "zh-CHS": "有了这个概念的帮助，您可以将每个层次结构的数据复制到SDXF块中。"
    },
    {
      "indent": 0,
      "text": "2.3 Some Remarks about the internal representation of the chunk's elements:",
      "zh-CHS": "2.3 关于区块元素的内部表示的一些备注："
    },
    {
      "indent": 3,
      "text": "Binary values are always in high-order-first (big endian) format, like the binary values in the IP header (network format). A length of 300 (=256 + 32 + 12) is stored as",
      "zh-CHS": "二进制值始终采用高阶优先（big-endian）格式，就像IP报头中的二进制值一样（网络格式）。300（=256+32+12）的长度存储为"
    },
    {
      "indent": 3,
      "text": "+----+----+----+----+----+----+----+----+----+--\n|         |    | 00   01   2C |  content\n+----+----+----+----+----+----+----+----+----+--",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "in hexadecimal notation.",
      "zh-CHS": "用十六进制表示法。"
    },
    {
      "indent": 3,
      "text": "This is also valid for the chunk-ID.",
      "zh-CHS": "这对于chunk-ID也是有效的。"
    },
    {
      "indent": 0,
      "text": "2.4 Character values in the content portion are also an object of adaptation: see chapter 4.",
      "zh-CHS": "2.4 内容部分中的字符值也是改编的对象：参见第4章。"
    },
    {
      "indent": 0,
      "text": "2.5 Meaning of the flag-bits: Let us represent the flag byte in this manner:",
      "zh-CHS": "2.5 标志位的含义：让我们用以下方式表示标志字节："
    },
    {
      "indent": 5,
      "text": "+-+-+-+-+-+-+-+-+\n|0|1|2|3|4|5|6|7|\n+-+-+-+-+-+-+-+-+\n | | | | | | | |\n | | | | | | | +-- reserved\n | | | | | | +---- array\n | | | | | +------ short chunk\n | | | | +-------- encrypted chunk\n | | | +---------- compressed chunk\n | | |\n +-+-+------------ data type (0..7)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "data types are:",
      "zh-CHS": "数据类型包括："
    },
    {
      "indent": 3,
      "text": "0 -- pending structure (chunk is inconsistent, see also 11.1) 1 -- structure 2 -- bit string 3 -- numeric 4 -- character 5 -- float (ANSI/IEEE 754-1985)",
      "zh-CHS": "0--挂起结构（数据块不一致，另见11.1）1--结构2--位字符串3--数字4--字符5--浮点（ANSI/IEEE 754-1985）"
    },
    {
      "indent": 3,
      "text": "6 -- UTF-8 7 -- reserved",
      "zh-CHS": "6--UTF-8 7--预留"
    },
    {
      "indent": 0,
      "text": "2.6 A short chunk has no data body. The 3 byte Length field is used as data bytes instead. This is used in order to save space when there are many small chunks.",
      "zh-CHS": "2.6 短块没有数据体。3字节长度字段用作数据字节。当有许多小块时，这是为了节省空间。"
    },
    {
      "indent": 0,
      "text": "2.7 Compressed and encrypted chunks are explained in chapter 5 and 6.",
      "zh-CHS": "2.7 第5章和第6章解释了压缩和加密的块。"
    },
    {
      "indent": 0,
      "text": "2.8 Arrays are explained in chapter 7.",
      "zh-CHS": "2.8 第7章对数组进行了解释。"
    },
    {
      "indent": 0,
      "text": "2.9 Handling of UTF-8 is explained in chapter 9.",
      "zh-CHS": "2.9 第9章解释了UTF-8的处理。"
    },
    {
      "indent": 0,
      "text": "2.10 Not all combinations of bits are allowed or reasonable:",
      "zh-CHS": "2.10 并非所有位的组合都是允许的或合理的："
    },
    {
      "indent": 3,
      "text": "- the flags 'array' and 'short' are mutually exclusive. - 'short' is not applicable for data type 'structure' and 'float'. - 'array' is not applicable for data type 'structure'.",
      "zh-CHS": "- 标志“array”和“short”是互斥的。-'short'不适用于数据类型'structure'和'float'。-数组“”不适用于数据类型“结构”。"
    },
    {
      "indent": 0,
      "text": "3. Introduction to the SDXF functions",
      "section_title": true,
      "zh-CHS": "3. SDXF函数简介"
    },
    {
      "indent": 0,
      "text": "3.1 General remarks",
      "section_title": true,
      "zh-CHS": "3.1 一般评论"
    },
    {
      "indent": 3,
      "text": "The functionality of the SDXF concept is not bounded to any programming language, but of course the functions themselves must be coded in a particular language. I discuss these functions in C and C++, because in the meanwhile these languages are available on almost all platforms.",
      "zh-CHS": "SDXF概念的功能不受任何编程语言的限制，但当然，函数本身必须用特定语言编码。我讨论了C和C++中的这些函数，因为这些语言在几乎所有的平台上都是可用的。"
    },
    {
      "indent": 3,
      "text": "All these functions for reading and writing SDXF chunks uses only one parameter, a parameter structure. In C++ this parameter structure is part of the \"SDXF class\" and the SDXF functions are methods of this class.",
      "zh-CHS": "所有这些用于读取和写入SDXF块的函数只使用一个参数，即参数结构。在C++中，这个参数结构是“SDXF类”的一部分，SDXF函数是这个类的方法。"
    },
    {
      "indent": 3,
      "text": "An exact description of the interface is given in chapter 8.",
      "zh-CHS": "第8章给出了接口的准确描述。"
    },
    {
      "indent": 0,
      "text": "3.2 Writing a SDXF buffer",
      "section_title": true,
      "zh-CHS": "3.2 写入SDXF缓冲区"
    },
    {
      "indent": 3,
      "text": "For to write SDXF chunks, there are following functions:",
      "zh-CHS": "要编写SDXF块，有以下函数："
    },
    {
      "indent": 3,
      "text": "init -- initialize the parameter structure create -- create a new chunk leave -- \"close\" a structured chunk",
      "zh-CHS": "init--初始化参数结构create--创建一个新块离开--“关闭”一个结构化块"
    },
    {
      "indent": 0,
      "text": "3.3 Reading a SDXF buffer",
      "section_title": true,
      "zh-CHS": "3.3 读取SDXF缓冲区"
    },
    {
      "indent": 3,
      "text": "For to read SDXF chunks, there are following functions:",
      "zh-CHS": "要读取SDXF块，有以下函数："
    },
    {
      "indent": 3,
      "text": "init -- initialize the parameter structure enter -- \"go into\" a structured chunk next -- \"go to\" the next chunk inside a structured chunk extract -- extract the content of an elementary chunk into user's data area leave -- \"go out\" off a structured chunk",
      "zh-CHS": "init--初始化参数结构输入--“进入”结构化块下一个--“进入”结构化块内的下一个块提取--将基本块的内容提取到用户的数据区域离开--“退出”结构化块"
    },
    {
      "indent": 0,
      "text": "3.4 Example:",
      "zh-CHS": "3.4 例子："
    },
    {
      "indent": 0,
      "text": "3.4.1 Writing:",
      "zh-CHS": "3.4.1 写作："
    },
    {
      "indent": 3,
      "text": "For demonstration we use a reduced (outlined) C++ Form of these functions with polymorph definitions:",
      "zh-CHS": "为了演示，我们使用缩写（概述）C++函数形式的这些函数与多态性定义："
    },
    {
      "indent": 3,
      "text": "void create (short chunkID); // opens a new structure, void create (short chunkID, char *string); // creates a new chunk with dataType character, etc.)",
      "zh-CHS": "void create（短chunkID）；//打开一个新结构，void create（短chunkID，char*string）；//使用数据类型字符等创建新块）"
    },
    {
      "indent": 3,
      "text": "The sequence:",
      "zh-CHS": "顺序如下："
    },
    {
      "indent": 3,
      "text": "SDXF x(new); // create the SDXF object \"x\" for a new chunk\n             // includes the \"init\"\nx.create (3301);   // opens a new structure\nx.create (3302, \"first chunk\");\nx.create (3303, \"second chunk\");\nx.create (3304);   // opens a new structure\nx.create (3305, \"chunk in a structure\");\nx.create (3306, \"next chunk in a structure\");\nx.leave ();        // closes the inner structure\nx.create (3307, \"third chunk\");\nx.leave ();        // closes the outer structure",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "creates a chunk which we can show graphically like:",
      "zh-CHS": "创建一个块，我们可以将其以图形方式显示，如："
    },
    {
      "indent": 3,
      "text": "3301\n |\n +--- 3302 = \"first chunk\"\n |\n +--- 3303 = \"second chunk\"\n |\n +--- 3304\n |      |\n |      +--- 3305 = \"chunk in a structure\"\n |      |\n |      +--- 3306 = \"next chunk in a structure\"\n |\n +--- 3307 = \"last chunk\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "3.4.2 Reading",
      "section_title": true,
      "zh-CHS": "3.4.2 阅读"
    },
    {
      "indent": 3,
      "text": "A typically access to a structured SDXF chunk is a selection inside a loop:",
      "zh-CHS": "对结构化SDXF区块的典型访问是循环内的选择："
    },
    {
      "indent": 3,
      "text": "SDXF x(old); // defines a SDXF object \"x\" for an old chunk\nx.enter ();  // enters the structure",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "while (x.rc == 0) // 0 == ok, rc will set by the SDXF functions\n{\n  switch (x.chunkID)\n  {\n    case 3302:\n      x.extract (data1, maxLength1);\n                // extr. 1st chunk into data1\n      break;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "case 3303:\n  x.extract (data2, maxLength2);\n            // extr. 2nd chunk into data2\n  break;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "case 3304:  // we know this is a structure\n  x.enter (); // enters the inner structure",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "while (x.rc == 0) // inner loop\n{\n  switch (x.chunkID)\n  {\n    case 3305:\n      x.extract (data3, maxLength3);\n                // extr. the chunk inside struct.",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "      break;\n    case 3306:\n      x.extract (data4, maxLength4);\n                // extr. 2nd chunk inside struct.\n      break;\n  }\n  x.next (); // returns x.rc == 1 at end of structure\n} // end-while\nbreak;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "case 3307:\n  x.extract (data5, maxLength5);\n            // extract last chunk into data\n  break;\n// default: none - ignore unknown chunks !!!",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "  } // end-switch\n  x.next (); // returns x.rc = 1 at end of structure\n} // end-while",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "4. Platform independence",
      "section_title": true,
      "zh-CHS": "4. 平台独立性"
    },
    {
      "indent": 3,
      "text": "The very most of the computer platforms today have a 8-Bits-in-a-Byte architecture, which enables data exchange between these platforms. But there are two significant points in which platforms may be different:",
      "zh-CHS": "当今的大多数计算机平台都有一个8位字节体系结构，可以在这些平台之间进行数据交换。但平台可能有两个重要的不同点："
    },
    {
      "indent": 3,
      "text": "a) The representation of binary numerical (the short and long int and floats).",
      "zh-CHS": "a) 二进制数字的表示（短整型和长整型以及浮点型）。"
    },
    {
      "indent": 3,
      "text": "b) The representation of characters (ASCII/ANSI vs. EBCDIC)",
      "zh-CHS": "b) 字符的表示（ASCII/ANSI与EBCDIC）"
    },
    {
      "indent": 3,
      "text": "Point (a) is the phenomenon of \"byte swapping\": How is a short int value 259 = 0x0103 = X'0103' be stored at address 4402?",
      "zh-CHS": "第（a）点是“字节交换”现象：如何在地址4402处存储短int值259=0x0103=X'0103？"
    },
    {
      "indent": 3,
      "text": "The two flavours are:",
      "zh-CHS": "这两种口味是："
    },
    {
      "indent": 3,
      "text": "4402 4403 01 03 the big-endian, and 03 01 the little-endian.",
      "zh-CHS": "4402 4403 01 03大端，03 01小端。"
    },
    {
      "indent": 3,
      "text": "Point (b) is represented by a table of the assignment of the 256 possible values of a Byte to printable or control characters. (In ASCII the letter \"A\" is assigned to value (or position) 0x41 = 65, in EBCDIC it is 0xC1 = 193.)",
      "zh-CHS": "点（b）由一个表表示，该表将一个字节的256个可能值分配给可打印字符或控制字符。（在ASCII中，字母“A”被分配给值（或位置）0x41=65，在EBCDIC中，字母“A”被分配给值（或位置）0xC1=193。）"
    },
    {
      "indent": 3,
      "text": "The solution of these problems is to normalize the data:",
      "zh-CHS": "这些问题的解决方案是规范化数据："
    },
    {
      "indent": 3,
      "text": "We fix:",
      "zh-CHS": "我们确定："
    },
    {
      "indent": 3,
      "text": "(a) The internal representation of binary numerals are 2-complements in big-endian order.",
      "zh-CHS": "(a) 二进制数字的内部表示是大端序的2-补码。"
    },
    {
      "indent": 3,
      "text": "(b) The internal representation of characters is ISO 8859-1 (also known as Latin 1).",
      "zh-CHS": "(b) 字符的内部表示法是ISO 8859-1（也称为拉丁语1）。"
    },
    {
      "indent": 3,
      "text": "The fixing of point (b) should be regarded as a first strike. In some environment 8859-1 seems not to be the best choice, in a greek or russian environment 8859-5 or 8859-7 are appropriate.",
      "zh-CHS": "（b）点的确定应视为第一次打击。在某些环境中，8859-1似乎不是最佳选择，在希腊或俄罗斯环境中，8859-5或8859-7是合适的。"
    },
    {
      "indent": 3,
      "text": "Nevertheless, in a specific group (or world) of applications, that is to say all the applications which wants to interchange data with a defined protocol (via networking or diskette or something else), this internal character table must be unique.",
      "zh-CHS": "然而，在特定的应用程序组（或世界）中，也就是说，所有希望使用定义的协议（通过网络、软盘或其他方式）交换数据的应用程序，该内部字符表必须是唯一的。"
    },
    {
      "indent": 3,
      "text": "So a possibility to define a translation table (and his inversion) should be given.",
      "zh-CHS": "因此，应该给出定义翻译表（和他的倒装）的可能性。"
    },
    {
      "indent": 3,
      "text": "Important: You construct a SDXF chunk not for a specific addressee, but you adapt your data into a normalized format (or network format).",
      "zh-CHS": "重要提示：您不是为特定的收件人构建SDXF块，而是将数据调整为规范化格式（或网络格式）。"
    },
    {
      "indent": 3,
      "text": "This adaption is not done by the programmer, it will be done by the create and extract function. An administrator has take care of defining the correct translation tables.",
      "zh-CHS": "这种自适应不是由程序员完成的，而是由create和extract函数完成的。管理员必须负责定义正确的翻译表。"
    },
    {
      "indent": 0,
      "text": "5. Compression",
      "section_title": true,
      "zh-CHS": "5. 压缩"
    },
    {
      "indent": 3,
      "text": "As stated in 2.5 there is a flag bit which declares that the following data (elementary or structured) are compressed. This data is not further interpretable until it is decompressed. Compression is transparently done by the SDXF functions: \"create\" does the compression for elementary chunks, \"leave\" for structured chunks, \"extract\" does the decompression for elementary chunks, \"enter\" for structured chunks.",
      "zh-CHS": "如2.5所述，有一个标志位声明压缩以下数据（基本数据或结构化数据）。在解压之前，此数据无法进一步解释。压缩是由SDXF函数透明地完成的：“create”对基本块进行压缩，“leave”对结构化块进行压缩，“extract”对基本块进行解压缩，“enter”对结构化块进行解压缩。"
    },
    {
      "indent": 3,
      "text": "Transparently means that the programmer has only to tell the SDXF functions that he want compress the following chunk(s).",
      "zh-CHS": "透明意味着程序员只需告诉SDXF函数他想要压缩以下块。"
    },
    {
      "indent": 3,
      "text": "For choosing between different compression methods and for controlling the decompressed (original) length, there is an additional definition:",
      "zh-CHS": "对于选择不同的压缩方法和控制解压缩（原始）长度，还有一个额外的定义："
    },
    {
      "indent": 3,
      "text": "After the chunk header for a compressed chunk, a compression header is following:",
      "zh-CHS": "在压缩块的块头之后，压缩头如下所示："
    },
    {
      "indent": 3,
      "text": "+-----------------------+---------------+---------------->\n|      chunk header     | compr. header | compressed data\n+---+---+---+---+---+---+---+---+---+---+---------------->\n|chunkID|flg|   length  |md | orglength |\n+---+---+---+---+---+---+---+---+---+---+---------------->",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "- 'orglength' is the original (decompressed) length of the data.",
      "zh-CHS": "- “orglength”是数据的原始（解压缩）长度。"
    },
    {
      "indent": 3,
      "text": "- 'md' is the \"compression method\": Two methods are described here:",
      "zh-CHS": "- “md”是“压缩方法”：这里描述了两种方法："
    },
    {
      "indent": 6,
      "text": "# method 01 for a simple (fast but not very effective) \"Run Length 1\" or \"Byte Run 1\" algorithm. (More then two consecutive identical characters are replaced by the number of these characters and the character itself.)",
      "zh-CHS": "#方法01用于简单（快速但不是非常有效）“运行长度1”或“字节运行1”算法。（超过两个连续的相同字符将替换为这些字符的数量和字符本身。）"
    },
    {
      "indent": 9,
      "text": "more precisely:",
      "zh-CHS": "更准确地说："
    },
    {
      "indent": 9,
      "text": "The compressed data consists of several sections of various length. Every section starts with a \"counter\" byte, a signed \"tiny\" (8 bit) integer, which contains a length information.",
      "zh-CHS": "压缩数据由不同长度的几个部分组成。每个部分都以一个“计数器”字节开始，这是一个有符号的“微小”（8位）整数，它包含一个长度信息。"
    },
    {
      "indent": 9,
      "text": "If this byte contains the value \"n\",\nwith n >= 0 (and n <128), the next n+1 bytes will be taken\nunchanged;\nwith n < 0 (and n > -128), the next byte will be replicated\n-n+1 times;\nn = -128 will be ignored.",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "Appending blanks will be cutted in general. If these are necessary, they can be reconstructed while \"extract\"ing with the parameter field \"filler\" (see 8.2.1) set to space character.",
      "zh-CHS": "一般情况下，将切割附加坯料。如有必要，可在“提取”时将参数字段“填充”（见8.2.1）设置为空格字符，对其进行重构。"
    },
    {
      "indent": 6,
      "text": "# method 02 for the wonderful \"deflate\" algorithm which comes from the \"zip\"-people. The authors are: Jean-loup Gailly (deflate routine), Mark Adler (inflate routine), and others.",
      "zh-CHS": "#方法02用于奇妙的“deflate”算法，该算法来自“zip”-人。作者是：Jean loup Gailly（放气程序）、Mark Adler（充气程序）和其他人。"
    },
    {
      "indent": 9,
      "text": "The deflate format is described in [DEFLATE].",
      "zh-CHS": "[deflate]中描述了deflate格式。"
    },
    {
      "indent": 6,
      "text": "The values for the compression method number are maintained by IANA, see chap. 12.1.",
      "zh-CHS": "压缩方法编号的值由IANA维护，见第12.1章。"
    },
    {
      "indent": 0,
      "text": "6. Encryption",
      "section_title": true,
      "zh-CHS": "6. 加密"
    },
    {
      "indent": 3,
      "text": "As stated in 2.5 there is a flag bit which declares that the following data (elementary or structured) is encrypted. This data is not interpretable until it is decrypted. En/Decryption is transparently done by the SDXF functions, \"create\" does the encryption for elementary chunks, \"leave\" for structured chunks, \"extract\" does the decryption for elementary chunks, \"enter\" for structured chunks. (Yes it sounds very similar to chapter 5.) More then one encryption method for a given range of applications is not very reasonable. Some encryption algorithms work with block ciphering algorithms. That means that the length of the data to encrypt must be rounded up to the next multiple of this block length. This blocksize (zero means non-blocking) is reported by the encryption interface routine (addressed by the option field *encryptProc, see chapter 8.5) with mode=3. If blocking is used, at least one byte is added, the last byte of the lengthening data contains the number of added bytes minus one. With this the decryption interface routine can calculate the real data length.",
      "zh-CHS": "如2.5所述，有一个标志位声明以下数据（基本数据或结构化数据）已加密。此数据在解密之前不可解释。En/解密由SDXF函数透明地完成，“创建”对基本块进行加密，“保留”对结构化块进行加密，“提取”对基本块进行解密，“输入”对结构化块进行加密。（是的，听起来与第5章非常相似。）对于给定的应用范围，不止一种加密方法是不合理的。一些加密算法与块加密算法一起工作。这意味着要加密的数据长度必须向上舍入到该块长度的下一个倍数。此块大小（零表示非阻塞）由加密接口例程（由选项字段*encryptProc寻址，参见第8.5章）报告，模式=3。如果使用阻塞，则至少添加一个字节，加长数据的最后一个字节包含添加的字节数减去一。通过这种方式，解密接口例程可以计算实际数据长度。"
    },
    {
      "indent": 3,
      "text": "If an application (or network connect handshaking protocol) needs to negotiate an encryption method it should be used a method number maintained by IANA, see chap. 12.2.",
      "zh-CHS": "如果应用程序（或网络连接握手协议）需要协商加密方法，则应使用IANA维护的方法编号，参见第12.2章。"
    },
    {
      "indent": 3,
      "text": "Even the en/decryption is done transparently, an encryption key (password) must be given to the SDXF functions. Encryption is done after translating character data into, decryption is done before translation from the internal (\"network-\") format.",
      "zh-CHS": "即使加密/解密是透明的，也必须为SDXF函数提供加密密钥（密码）。加密是在将字符数据转换为之后完成的，解密是在从内部（“网络-”）格式转换之前完成的。"
    },
    {
      "indent": 3,
      "text": "If both, encryption and compression are applied on the same chunk, compression is done first - compression on good encrypted data (same strings appears as different after encryption) tends to zero compression rates.",
      "zh-CHS": "如果在同一块上同时应用加密和压缩，则首先进行压缩-对加密良好的数据（加密后相同的字符串显示为不同的字符串）的压缩率趋于零。"
    },
    {
      "indent": 0,
      "text": "7. Arrays",
      "section_title": true,
      "zh-CHS": "7. 阵列"
    },
    {
      "indent": 3,
      "text": "An array is a sequence of chunks with identical chunk-ID, length and data type.",
      "zh-CHS": "数组是具有相同块ID、长度和数据类型的块序列。"
    },
    {
      "indent": 3,
      "text": "At first a hint: in principle a special definition in SDXF for such an array is not really necessary:",
      "zh-CHS": "首先有一个提示：原则上，SDXF中对这样一个数组的特殊定义并不是真正必要的："
    },
    {
      "indent": 3,
      "text": "It is not forbidden that there are more than one chunk with equal chunk-ID within the same structured chunk.",
      "zh-CHS": "不禁止在同一结构化块中存在多个具有相同块ID的块。"
    },
    {
      "indent": 3,
      "text": "Therefore with a sequence of SDX_next / SDX_extract calls one can fill the destination array step by step.",
      "zh-CHS": "因此，通过一系列SDX_next/SDX_extract调用，可以一步一步地填充目标数组。"
    },
    {
      "indent": 3,
      "text": "If there are many occurrences of chunks with the same chunk-ID (and a comparative small length), the overhead of the chunk-packages may be significant.",
      "zh-CHS": "如果出现许多具有相同块ID（且长度相对较小）的块，则块包的开销可能会很大。"
    },
    {
      "indent": 3,
      "text": "Therefore the array flag is introduced. An array chunk has only one chunk header for the complete sequence of elementary chunks. After the chunk header for an array chunk, an array header is following:",
      "zh-CHS": "因此引入了数组标志。对于基本块的完整序列，数组块只有一个块头。在数组块的块头之后，数组头如下所示："
    },
    {
      "indent": 3,
      "text": "This is a short integer (big endian!) which contains the number of the array elements (CT). Every element has a fixed length (EL), so the chunklength (CL) is CL = EL * CT + 2.",
      "zh-CHS": "这是一个短整数（大端！），包含数组元素数（CT）。每个元素都有一个固定的长度（EL），因此chunklength（CL）是CL=EL*CT+2。"
    },
    {
      "indent": 3,
      "text": "The data elements follows immediately after the array header.",
      "zh-CHS": "数据元素紧跟在数组头之后。"
    },
    {
      "indent": 3,
      "text": "The complete array will be constructed by SDX_create, the complete array will be read by SDX_extract.",
      "zh-CHS": "完整数组将由SDX_create构建，完整数组将由SDX_extract读取。"
    },
    {
      "indent": 3,
      "text": "The parameter fields (see 8.2.1) 'dataLength' and 'count' are used for the SDXF functions 'extract' and 'create':",
      "zh-CHS": "参数字段（见8.2.1）“数据长度”和“计数”用于SDXF函数“提取”和“创建”："
    },
    {
      "indent": 3,
      "text": "Field 'dataLength' is the common length of the array elements, 'count' is the actual dimension of the array for 'create' (input).",
      "zh-CHS": "字段“dataLength”是数组元素的公共长度，“count”是“create”（输入）数组的实际维度。"
    },
    {
      "indent": 3,
      "text": "For the 'extract' function 'count' acts both as an input and output parameter:",
      "zh-CHS": "对于“提取”功能，“计数”同时作为输入和输出参数："
    },
    {
      "indent": 3,
      "text": "Input : the maximum dimension output: the actual array dimension.",
      "zh-CHS": "输入：最大维度输出：实际数组维度。"
    },
    {
      "indent": 3,
      "text": "(If output count is greater than input count, the 'data cutted' warning will be responded and the destination array is filled up to the maximum dimension.)",
      "zh-CHS": "（如果输出计数大于输入计数，将响应“数据剪切”警告，并将目标数组填充到最大维度。）"
    },
    {
      "indent": 0,
      "text": "8. Description of the SDXF functions",
      "section_title": true,
      "zh-CHS": "8. SDXF函数的说明"
    },
    {
      "indent": 0,
      "text": "8.1 Introduction",
      "section_title": true,
      "zh-CHS": "8.1 介绍"
    },
    {
      "indent": 3,
      "text": "Following the principles of Object Oriented Programming, not only the description of the data is necessary, but also the functions which manipulate data - the \"methods\".",
      "zh-CHS": "遵循面向对象编程的原则，不仅需要对数据进行描述，还需要操作数据的函数“方法”。"
    },
    {
      "indent": 3,
      "text": "For the programmer knowing the methods is more important than knowing the data structure, the methods has to know the exact specifications of the data and guarantees the consistence of the data while creating them.",
      "zh-CHS": "对于程序员来说，了解方法比了解数据结构更重要，方法必须知道数据的确切规格，并在创建数据时保证数据的一致性。"
    },
    {
      "indent": 3,
      "text": "A SDXF object is an instance of a parameter structure which acts as a programming interface. Especially it points to an actual SDXF data chunk, and, while processing on this data, there is a pointer to the actual inner chunk which will be the focus for the next operation.",
      "zh-CHS": "SDXF对象是作为编程接口的参数结构的实例。特别是它指向一个实际的SDXF数据块，并且在处理该数据时，有一个指向实际内部块的指针，该块将是下一个操作的焦点。"
    },
    {
      "indent": 3,
      "text": "The benefit of an exact interface description is the same as using for example the standard C library functions: By using standard interfaces your code remains platform independent.",
      "zh-CHS": "精确接口描述的好处与使用标准C库函数的好处相同：通过使用标准接口，代码保持平台独立。"
    },
    {
      "indent": 0,
      "text": "8.2 Basic definitions",
      "section_title": true,
      "zh-CHS": "8.2 基本定义"
    },
    {
      "indent": 0,
      "text": "8.2.1 The SDXF Parameter structure",
      "section_title": true,
      "zh-CHS": "8.2.1 SDXF参数结构"
    },
    {
      "indent": 3,
      "text": "All SDXF access functions need only one parameter, a pointer to the SDXF parameter structure:",
      "zh-CHS": "所有SDXF访问函数只需要一个参数，即指向SDXF参数结构的指针："
    },
    {
      "indent": 3,
      "text": "First 3 prerequisite definitions:",
      "zh-CHS": "前3个先决条件定义："
    },
    {
      "indent": 3,
      "text": "typedef short int      ChunkID;\ntypedef unsigned char  Byte;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "typedef struct Chunk\n{\n  ChunkID    chunkID;\n  Byte       flags;\n  char       length [3];\n  Byte       data;\n} Chunk;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "And now the parameter structure:",
      "zh-CHS": "现在是参数结构："
    },
    {
      "indent": 3,
      "text": "typedef struct\n{\n  ChunkID  chunkID;       // name (ID) of Chunk\n  Byte    *container;     // pointer to the whole Chunk\n  long     bufferSize;    // size of container\n  Chunk   *currChunk;     // pointer to actual Chunk\n  long     dataLength;    // length of data in Chunk\n  long     maxLength;     // max. length of Chunk for SDX_extract\n  long     remainingSize; // rem. size in cont. after SDX_create\n  long     value;         // for data type numeric\n  double   fvalue;        // for data type float\n  char    *function;      // name of the executed SDXF function\n  Byte    *data;          // pointer to Data\n  Byte    *cryptkey;      // pointer to Crypt Key\n  short    count;         // (max.) number of elements in an array\n  short    dataType;      // Chunk data type / init open type\n  short    ec;            // extended return-code",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "  short    rc;            // return-code\n  short    level;         // level of hierarchy\n  char     filler;        // filler char for SDX_extract\n  Byte     encrypt;       // Indication if data to encrypt (0 / 1)\n  Byte     compression;   // compression method\n                          //   (00=none, 01=RL1, 02=zip/deflate)\n} SDX_obj, *SDX_handle;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Only the \"public\" fields of the parameter structure which acts as input and output for the SDXF functions is described here. A given implementation may add some \"private\" fields to this structure.",
      "zh-CHS": "此处仅描述作为SDXF函数输入和输出的参数结构的“公共”字段。给定的实现可能会将一些“私有”字段添加到此结构中。"
    },
    {
      "indent": 0,
      "text": "8.2.2 Basic Functions",
      "section_title": true,
      "zh-CHS": "8.2.2 基本功能"
    },
    {
      "indent": 3,
      "text": "All these functions works with a SDX_handle as the only formal parameter. Every function returns as output ec and rc as a report of success. For the values for ec, rc and dataType see chap. 8.4.",
      "zh-CHS": "所有这些函数都使用SDX_句柄作为唯一的形式参数。每个函数作为输出ec返回，rc作为成功报告返回。有关ec、rc和数据类型的值，请参见第8.4章。"
    },
    {
      "indent": 4,
      "text": "1. SDX_init : Initialize the parameter structure.",
      "zh-CHS": "1. SDX_init：初始化参数结构。"
    },
    {
      "indent": 9,
      "text": "input : container, dataType, bufferSize (for dataType = SDX_NEW only) output: currChunk, dataLength (for dataType = SDX_OLD only), ec, rc, the other fields of the parameter structure will be initialized.",
      "zh-CHS": "输入：container、dataType、bufferSize（仅适用于dataType=SDX_NEW）输出：currcunk、dataLength（仅适用于dataType=SDX_OLD）、ec、rc，参数结构的其他字段将被初始化。"
    },
    {
      "indent": 4,
      "text": "2. SDX_enter : Enter a structured chunk. You can access the first chunk inside this structured chunk. input : none output: currChunk, chunkID, dataLength, level, dataType, ec, rc",
      "zh-CHS": "2. SDX_enter：输入结构化块。您可以访问此结构化块中的第一个块。输入：无输出：currChunk、chunkID、数据长度、级别、数据类型、ec、rc"
    },
    {
      "indent": 4,
      "text": "3. SDX_leave : Leave the actual entered structured chunk. input : none output: currChunk, chunkID, dataLength, level, dataType, ec, rc",
      "zh-CHS": "3. SDX_leave：保留实际输入的结构化块。输入：无输出：currChunk、chunkID、数据长度、级别、数据类型、ec、rc"
    },
    {
      "indent": 4,
      "text": "4. SDX_next : Go to the next chunk inside a structured chunk. input : none output: currChunk, chunkID, dataLength, dataType, count, ec, rc",
      "zh-CHS": "4. SDX_next：转到结构化块中的下一块。输入：无输出：currChunk，chunkID，dataLength，dataType，count，ec，rc"
    },
    {
      "indent": 8,
      "text": "At the end of a structured chunk SDX_next returns rc = SDX_RC_failed and ec = SDX_EC_eoc (end of chunk) The actual structured chunk is SDX_leave'd automatically.",
      "zh-CHS": "在结构化块的末尾，SDX_next返回rc=SDX_rc_failed和ec=SDX_ec_eoc（块的末尾），实际的结构化块将自动离开。"
    },
    {
      "indent": 4,
      "text": "5. SDX_extract : Extract data of the actual chunk. (If actual chunk is structured, only a copy is done, elsewhere the data is converted to host format.) input / output depends on the dataType:",
      "zh-CHS": "5. SDX_extract：提取实际块的数据。（如果实际数据块是结构化的，则只进行复制，其他地方的数据将转换为主机格式。）输入/输出取决于数据类型："
    },
    {
      "indent": 7,
      "text": "if dataType is structured, binary or char: input : data, maxLength, count, filler output: dataLength, count, ec, rc",
      "zh-CHS": "如果数据类型为结构化、二进制或字符：输入：数据、maxLength、计数、填充输出：dataLength、计数、ec、rc"
    },
    {
      "indent": 7,
      "text": "if dataType is numeric (float resp.): input : none output: value (fvalue resp.), ec, rc",
      "zh-CHS": "如果数据类型为数字（浮动响应）：输入：无输出：值（fvalue响应），ec，rc"
    },
    {
      "indent": 4,
      "text": "6. SDX_select : Go to the (next) chunk with a given chunkID. input : chunkID output: currChunk, dataLength, dataType, ec, rc",
      "zh-CHS": "6. SDX_选择：使用给定的chunkID转到（下一个）块。输入：chunkID输出：currChunk、dataLength、dataType、ec、rc"
    },
    {
      "indent": 4,
      "text": "7. SDX_create : Creating a new chunk (at the end of the actual structured chunk). input : chunkID, dataLength, data, (f)value, dataType, compression, encrypt, count update: remainingSize, level output: currChunk, dataLength, ec, rc",
      "zh-CHS": "7. SDX_create：创建一个新块（在实际结构化块的末尾）。输入：chunkID，dataLength，数据，（f）值，数据类型，压缩，加密，计数更新：remainingSize，级别输出：currChunk，dataLength，ec，rc"
    },
    {
      "indent": 4,
      "text": "8. SDX_append : Append a complete chunk at the end of the actual structured chunk). input : data, maxLength, currChunk update: remainingSize, level output: chunkID, chunkLength, maxLength, dataType, ec, rc",
      "zh-CHS": "8. SDX_append：在实际结构化块的末尾追加一个完整块）。输入：数据，maxLength，currChunk更新：remainingSize，级别输出：chunkID，chunkLength，maxLength，数据类型，ec，rc"
    },
    {
      "indent": 0,
      "text": "8.3 Definitions for C++",
      "section_title": true,
      "zh-CHS": "8.3 C++的定义"
    },
    {
      "indent": 3,
      "text": "This is the specification of the SDXF class in C++: (The type 'Byte' is defined as \"unsigned char\" for bitstrings, opposed to \"signed char\" for character strings)",
      "zh-CHS": "这是C++中SDXF类的规范：（“Byte”类型对于位字符串定义为“unsigned char”，而对于字符串定义为“signed char”）"
    },
    {
      "indent": 3,
      "text": "class C_SDXF { public:",
      "zh-CHS": "类C_SDXF{public:"
    },
    {
      "indent": 5,
      "text": "// constructors and destructor: C_SDXF (); // dummy C_SDXF (Byte *cont); // old container C_SDXF (Byte *cont, long size); // new container C_SDXF (long size); // new container ~C_SDXF (); // methods:",
      "zh-CHS": "//构造函数和析构函数：C_SDXF（）；//虚拟C_SDXF（字节*续）；//旧容器C_SDXF（字节*cont，长尺寸）；//新集装箱C_SDXF（长尺寸）；//新容器~C_SDXF（）；//方法："
    },
    {
      "indent": 5,
      "text": "void init  (void);                   // old container\nvoid init  (Byte *cont);             // old container\nvoid init  (Byte *cont, long size);  // new container\nvoid init  (long size);              // new container",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "void enter   (void);\nvoid leave   (void);\nvoid next    (void);\nlong extract (Byte *data, long length);    // chars, bits\nlong extract (void);                       // numeric data\nvoid create  (ChunkID);                    // structured\nvoid create  (ChunkID, long value);        // numeric\nvoid create  (ChunkID, double fvalue);     // float\nvoid create  (ChunkID, Byte *data, long length);// binary\nvoid create  (ChunkID, char *data);             // chars\nvoid set_compression (Byte compression_method);\nvoid set_encryption  (Byte *encryption_key);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "// interface:",
      "zh-CHS": "//接口："
    },
    {
      "indent": 5,
      "text": "ChunkID  id;        // see 8.4.1\nshort    dataType;  // see 8.4.2\nlong     length;    // length of data or chunk",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "long     value;\ndouble   fvalue;\nshort    rc;  // the raw return code       see 8.4.3\nshort    ec;  // the extended return code  see 8.4.4",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "protected: // implementation dependent ...",
      "zh-CHS": "受保护：//依赖于实现。。。"
    },
    {
      "indent": 3,
      "text": "};",
      "zh-CHS": "};"
    },
    {
      "indent": 0,
      "text": "8.4 Common Definitions:",
      "zh-CHS": "8.4 共同定义："
    },
    {
      "indent": 0,
      "text": "8.4.1 Definition of ChunkID:",
      "zh-CHS": "8.4.1 ChunkID的定义："
    },
    {
      "indent": 3,
      "text": "typedef short ChunkID;",
      "zh-CHS": "typedef短ChunkID；"
    },
    {
      "indent": 0,
      "text": "8.4.2 Values for dataType:",
      "zh-CHS": "8.4.2 数据类型的值："
    },
    {
      "indent": 3,
      "text": "SDX_DT_inconsistent = 0 SDX_DT_structured = 1 SDX_DT_binary = 2 SDX_DT_numeric = 3 SDX_DT_char = 4 SDX_DT_float = 5",
      "zh-CHS": "SDX_DT_不一致=0 SDX_DT_结构化=1 SDX_DT_二进制=2 SDX_DT_数值=3 SDX_DT_字符=4 SDX_DT_浮点=5"
    },
    {
      "indent": 3,
      "text": "SDX_DT_UTF8             = 6",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": " data types for SDX_init: SDX_OLD = 1 SDX_NEW = 2",
      "zh-CHS": "SDX_init的数据类型：SDX_OLD=1 SDX_NEW=2"
    },
    {
      "indent": 0,
      "text": "8.4.3 Values for rc:",
      "zh-CHS": "8.4.3 rc的值："
    },
    {
      "indent": 3,
      "text": "SDX_RC_ok = 0 SDX_RC_failed = 1 SDX_RC_warning = 1 SDX_RC_illegalOperation = 2 SDX_RC_dataError = 3 SDX_RC_parameterError = 4 SDX_RC_programError = 5 SDX_RC_noMemory = 6",
      "zh-CHS": "SDX_RC_ok=0 SDX_RC_failed=1 SDX_RC_warning=1 SDX_RC_illegalOperation=2 SDX_RC_dataError=3 SDX_RC_参数Error=4 SDX_RC_programError=5 SDX_RC_Nomenomery=6"
    },
    {
      "indent": 0,
      "text": "8.4.4 Values for ec:",
      "zh-CHS": "8.4.4 ec值："
    },
    {
      "indent": 3,
      "text": "SDX_EC_ok              =  0\nSDX_EC_eoc             =  1 // end of chunk\nSDX_EC_notFound        =  2\nSDX_EC_dataCutted      =  3\nSDX_EC_overflow        =  4\nSDX_EC_wrongInitType   =  5\nSDX_EC_comprerr        =  6 // compression error\nSDX_EC_forbidden       =  7\nSDX_EC_unknown         =  8\nSDX_EC_levelOvflw      =  9\nSDX_EC_paramMissing    = 10\nSDX_EC_magicError      = 11\nSDX_EC_not_consistent  = 12\nSDX_EC_wrongDataType   = 13\nSDX_EC_noMemory        = 14\nSDX_EC_error           = 99 // rc is sufficiently",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "8.5 Special functions",
      "section_title": true,
      "zh-CHS": "8.5 特殊功能"
    },
    {
      "indent": 3,
      "text": "Besides the basic definitions there is a global function (SDX_getOptions) which returns a pointer to a global table of options.",
      "zh-CHS": "除了基本定义之外，还有一个全局函数（SDX_getOptions），它返回指向全局选项表的指针。"
    },
    {
      "indent": 3,
      "text": "With the help of these options you can adapt the behaviour of SDXF. Especially you can define an alternative pair of translation tables or an alternative function which reads these tables from an external resource (p.e. from disk).",
      "zh-CHS": "借助这些选项，您可以调整SDXF的行为。特别是，您可以定义一对可选的转换表或从外部资源（即从磁盘）读取这些表的可选函数。"
    },
    {
      "indent": 3,
      "text": "Within this table of options there is also a pointer to the function which is used for encryption / decryption: You can install your own encryption algorithm by setting this pointer.",
      "zh-CHS": "在此选项表中，还有一个指向用于加密/解密的函数的指针：您可以通过设置此指针安装自己的加密算法。"
    },
    {
      "indent": 3,
      "text": "The options pointer is received by:",
      "zh-CHS": "选项指针由以下人员接收："
    },
    {
      "indent": 3,
      "text": "SDX_TOptions *opt = SDX_getOptions ();",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "With:",
      "zh-CHS": "与："
    },
    {
      "indent": 3,
      "text": "typedef struct\n{\n Byte            *toHost;        // Trans tab net -> host\n Byte            *toNet;         // Trans tab host -> net\n int              maxlevel;      // highest possible level\n int              translation;   // translation net <-> host\n                                 // is in effect=1 or not=0\n TEncryptProc    *encryptProc;   // alternate encryption routine\n TGetTablesProc  *getTablesProc; // alternate routine defining\n                                 // translation Tables\n TcvtUTF8Proc    *convertUTF8;   // routine to convert to/from UTF-8\n}  SDX_TOptions;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "typedef long TencryptProc (\n  int   mode,   // 1= to encrypt, 2= to decrypt, 3= encrypted length\n  Byte *buffer, // data to en/decrypt\n  long  len,    // len: length of buffer\n  char *passw); // Password",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "// returns length of en/de-crypted data\n// (parameter buffer and passw are ignored for mode=3)\n// returns blocksize for mode=3 and len=0.\n// blocksize is zero for non-blocking algorithms",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "typedef int TGetTablesProc (Byte **toNet, Byte **toHost);\n // toNet, toHost: pointer to output params.  Both params\n // points to translation tables of 256 Bytes.\n // returns success: 1 = ok, 0 = error.",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "typedef int TcvtUTF8Proc\n( int   mode,     // 1 = to UTF-8, 2 = from UTF-8\n  Byte *target, int *targetlength,  // output\n  Byte *source, int sourcelength);  // input\n// targetlength contains maximal size as input param.\n// returns success: 1 = ok, 0 = no conversion",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "9. 'Support' of UTF-8.",
      "zh-CHS": "9. UTF-8的“支持”。"
    },
    {
      "indent": 3,
      "text": "Many systems supports [UTF-8] as a character format for transferred data. The benefit is that no fixing of a specific character set for an application is needed because the set of 'all' characters is used, represented by the 'Universal Character Set' UCS-2 [UCS], a double byte coding for characters.",
      "zh-CHS": "许多系统支持[UTF-8]作为传输数据的字符格式。好处是不需要为应用程序修复特定字符集，因为使用了“所有”字符集，由“通用字符集”UCS-2[UCS]表示，这是字符的双字节编码。"
    },
    {
      "indent": 3,
      "text": "SDXF does not really deal with UTF-8 by itself, there are many possibilities to interprete an UTF-8 sequence: The application may:",
      "zh-CHS": "SDXF本身并不能真正处理UTF-8，有许多可能解释UTF-8序列：应用程序可能："
    },
    {
      "indent": 3,
      "text": "- reconstruct the UCS-2 sequence, - accepts only the pure ASCII character and maps non-ASCII to a special 'non-printable' character. - target is pure ASCII, non-ASCII is replaced in a senseful manner (French accented vowels replaced by vowels without accents, etc.). - target is a specific ANSI character set, the non-ASCII chars are mapped as possible, other replaced to a 'non-printable'. - etc.",
      "zh-CHS": "- 重建UCS-2序列，-仅接受纯ASCII字符，并将非ASCII映射到特殊的“不可打印”字符。-目标是纯ASCII，非ASCII以有意义的方式替换（法语重音元音替换为无重音元音，等等）目标是一个特定的ANSI字符集，非ASCII字符尽可能映射，其他字符替换为“不可打印”等"
    },
    {
      "indent": 3,
      "text": "But SDXF offers an interface for the 'extract' and 'create' functions:",
      "zh-CHS": "但SDXF为“提取”和“创建”功能提供了接口："
    },
    {
      "indent": 3,
      "text": "A function pointer may be specified in the options table to maintain this possibility (see 8.5). Default for this pointer is NULL: No further conversions are done by SDXF, the data are copied 'as is', it is treated as a bit string as for data type 'binary'.",
      "zh-CHS": "可在选项表中指定函数指针，以保持这种可能性（见8.5）。此指针的默认值为NULL：SDXF不进行进一步的转换，数据按“原样”复制，与数据类型“二进制”一样，它被视为位字符串。"
    },
    {
      "indent": 3,
      "text": "If this function is specified, it is used by the 'create' function with the 'toUTF8' mode, and by the 'extract' function with the ' fromUTF8' mode. The invoking of these functions is done by SDXF transparently.",
      "zh-CHS": "如果指定了此函数，“创建”函数使用“toUTF8”模式，而“提取”函数使用“fromUTF8”模式。这些函数的调用由SDXF透明地完成。"
    },
    {
      "indent": 3,
      "text": "If the function returns zero (no conversion) SDXF copies the data without conversion.",
      "zh-CHS": "如果函数返回零（无转换），SDXF将复制数据而不进行转换。"
    },
    {
      "indent": 0,
      "text": "10. Security Considerations",
      "section_title": true,
      "zh-CHS": "10. 安全考虑"
    },
    {
      "indent": 3,
      "text": "Any corruption of data in the chunk headers denounce the complete SDXF structure.",
      "zh-CHS": "区块头中的任何数据损坏都表明完整的SDXF结构。"
    },
    {
      "indent": 3,
      "text": "Any corruption of data in a encrypted or compressed SDXF structure makes this chunk unusable. An integrity check after decryption or decompression should be done by the \"enter\" function.",
      "zh-CHS": "加密或压缩的SDXF结构中的任何数据损坏都会导致此块不可用。解密或解压缩后的完整性检查应由“enter”函数完成。"
    },
    {
      "indent": 3,
      "text": "While using TCP/IP (more precisely: IP) as a transmission medium we can trust on his CRC check on the transport layer.",
      "zh-CHS": "当使用TCP/IP（更准确地说：IP）作为传输介质时，我们可以信任他在传输层上的CRC检查。"
    },
    {
      "indent": 0,
      "text": "11. Some general hints",
      "section_title": true,
      "zh-CHS": "11. 一些一般提示"
    },
    {
      "indent": 3,
      "text": "1. A consistent construction of a SDXF structure is done if every \"create\" to a structured chunk is closed by a paired \"leave\". While a structured chunk is under construction, his data type is set to zero - that means: this chunk is inconsistent. The SDX_leave function sets the datatype to \"structured\".",
      "zh-CHS": "1. 如果对结构化块的每个“创建”都被成对的“离开”关闭，那么就完成了SDXF结构的一致构造。当一个结构化块正在构建时，他的数据类型被设置为零——这意味着：这个块是不一致的。SDX_leave函数将数据类型设置为“结构化”。"
    },
    {
      "indent": 3,
      "text": "2. While creating an elementary chunk a platform dependent transformation to a platform independent format of the data is performed - at the end of construction the content of the buffer is ready to transport to another site, without any further translation.",
      "zh-CHS": "2. 在创建基本块时，将执行平台相关的数据转换为平台无关的数据格式-在构建结束时，缓冲区的内容准备好传输到另一个站点，而无需进一步翻译。"
    },
    {
      "indent": 3,
      "text": "3. As you see no data definition in your programming language is needed for to construct a specific SDXF structure. The data is created dynamically by function calls.",
      "zh-CHS": "3. 正如您所见，构建特定的SDXF结构不需要编程语言中的数据定义。数据是通过函数调用动态创建的。"
    },
    {
      "indent": 3,
      "text": "4. With SDXF as a base you can define protocols for client / server applications. These protocols may be extended in downward compatibility manner by following two rules:",
      "zh-CHS": "4. 以SDXF为基础，您可以为客户机/服务器应用程序定义协议。这些协议可以通过以下两条规则以向下兼容的方式扩展："
    },
    {
      "indent": 6,
      "text": "Rule 1: Ignore unknown chunkIDs.",
      "zh-CHS": "规则1：忽略未知的chunkID。"
    },
    {
      "indent": 6,
      "text": "Rule 2: The sequence of chunks should not be significant.",
      "zh-CHS": "规则2：组块的顺序不应该很重要。"
    },
    {
      "indent": 0,
      "text": "12. IANA Considerations",
      "section_title": true,
      "zh-CHS": "12. IANA考虑"
    },
    {
      "indent": 3,
      "text": "The compression and encryption algorithms for SDXF is not fixed, SDXF is open for various algorithms. Therefore an agreement is necessary to interprete the compression and encryption algorithm method numbers. (Encryption methods are not a semantic part of SDXF, but may be used for a connection protocol to negotiate the encryption method to use.)",
      "zh-CHS": "SDXF的压缩和加密算法不是固定的，SDXF对各种算法开放。因此，有必要达成协议来解释压缩和加密算法方法编号。（加密方法不是SDXF的语义部分，但可用于连接协议，以协商要使用的加密方法。）"
    },
    {
      "indent": 3,
      "text": "Following two items are registered by IANA:",
      "zh-CHS": "IANA注册了以下两个项目："
    },
    {
      "indent": 0,
      "text": "12.1 COMPRESSION METHODS FOR SDXF",
      "section_title": true,
      "zh-CHS": "12.1 SDXF的压缩方法"
    },
    {
      "indent": 3,
      "text": "The compressed SDXF chunk starts with a \"compression header\". This header contains the compression method as an unsigned 1-Byte integer (1-255). These numbers are assigned by IANA and listed here:",
      "zh-CHS": "压缩的SDXF块以“压缩头”开头。此标头将压缩方法包含为无符号1字节整数（1-255）。这些编号由IANA分配，如下所示："
    },
    {
      "indent": 3,
      "text": "compression\n method     Description                     Hints\n---------   ------------------------------- -------------\n      01    RUN-LENGTH algorithm            see chap. 5\n      02    DEFLATE (ZIP)                   see [DEFLATE]\n  03-239    IANA to assign\n 240-255    private or application specific",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "12.2 ENCRYPTION METHODS FOR SDXF",
      "section_title": true,
      "zh-CHS": "12.2 SDXF的加密方法"
    },
    {
      "indent": 3,
      "text": "An unique encryption method is fixed or negotiated by handshaking. For the latter one a number for each encryption method is necessary. These numbers are unsigned 1-Byte integers (1-255). These numbers are assigned by IANA and listed here:",
      "zh-CHS": "唯一的加密方法是固定的或通过握手协商的。对于后者，每种加密方法都需要一个数字。这些数字是无符号1字节整数（1-255）。这些编号由IANA分配，如下所示："
    },
    {
      "indent": 3,
      "text": "encryption\n  method    Description\n ---------  ------------------------------\n  01-239    IANA to assign\n 240-255    private or application specific",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "12.3 Hints for assigning a number:",
      "zh-CHS": "12.3 分配号码的提示："
    },
    {
      "indent": 3,
      "text": "Developers which want to register a compression or encrypt method for SDXF should contact IANA for a method number. The ASSIGNED NUMBERS document should be referred to for a current list of METHOD numbers and their corresponding protocols, see [IANA]. The new method SHOULD be a standard published as a RFC or by a established standardization organization (as OSI).",
      "zh-CHS": "希望为SDXF注册压缩或加密方法的开发人员应联系IANA以获取方法编号。有关方法编号及其相应协议的当前列表，请参考分配编号文件，请参见[IANA]。新方法应为RFC或已建立的标准化组织（OSI）发布的标准。"
    },
    {
      "indent": 0,
      "text": "13. Discussion",
      "section_title": true,
      "zh-CHS": "13. 讨论"
    },
    {
      "indent": 3,
      "text": "There are already some standards for Internet data exchanging, IETF prefers ASN.1 and XML therefore. So the reasons for establish a new data format should be discussed.",
      "zh-CHS": "互联网数据交换已经有了一些标准，因此IETF更喜欢ASN.1和XML。因此，应该讨论建立新数据格式的原因。"
    },
    {
      "indent": 0,
      "text": "13.1 SDXF vs. ASN.1",
      "section_title": true,
      "zh-CHS": "13.1 SDXF与ASN.1"
    },
    {
      "indent": 3,
      "text": "The demand of ASN.1 (see [ASN.1]) is to serve program language independent means to define data structures. The real data format which is used to send the data is not defined by ASN.1 but usually BER or PER (or some derivates of them like CER and DER) are used in this context, see [BER] and [PER].",
      "zh-CHS": "ASN.1（参见[ASN.1]）的要求是提供独立于程序语言的方法来定义数据结构。ASN.1未定义用于发送数据的实际数据格式，但在此上下文中通常使用BER或PER（或CER和DER等其派生形式），请参见[BER]和[PER]。"
    },
    {
      "indent": 3,
      "text": "The idea behind ASN.1 is: On every platform on which a given application is to develop descriptions of the used data structures are available in ASN.1 notation. Out off these notations the real language dependent definitions are generated with the help of an ASN.1-compiler.",
      "zh-CHS": "ASN.1背后的思想是：在每个平台上，给定的应用程序都可以在ASN.1符号中描述所使用的数据结构。在ASN.1编译器的帮助下，除了这些符号外，真正的语言相关定义是生成的。"
    },
    {
      "indent": 3,
      "text": "This compiler generates also transform functions for these data structures for to pack and unpack to and from the BER (or other) format.",
      "zh-CHS": "该编译器还为这些数据结构生成转换函数，以便在BER（或其他）格式之间进行打包和解包。"
    },
    {
      "indent": 3,
      "text": "A direct comparison between ASN.1 and SDXF is somehow inappropriate: The data format of SDXF is related rather to BER (and relatives). The use of ASN.1 to define data structures is no contradiction to SDXF, but: SDXF does not require a complete data structure to build the message to send, nor a complete data structure will be generated out off the received message.",
      "zh-CHS": "直接比较ASN.1和SDXF在某种程度上是不合适的：SDXF的数据格式与误码率（BER）相关。使用ASN.1定义数据结构与SDXF并不矛盾，但是：SDXF不需要完整的数据结构来构建要发送的消息，也不需要从接收到的消息中生成完整的数据结构。"
    },
    {
      "indent": 3,
      "text": "The main difference lies in the concept of building and interpretation of the message, I want to name it the \"static\" and \"dynamic\" concept:",
      "zh-CHS": "主要区别在于信息的构建和解释概念，我想将其命名为“静态”和“动态”概念："
    },
    {
      "indent": 3,
      "text": "o ASN.1 uses a \"static\" approach: The whole data structure must exists before the message can be created.",
      "zh-CHS": "o ASN.1使用“静态”方法：在创建消息之前，必须存在整个数据结构。"
    },
    {
      "indent": 3,
      "text": "o SDXF constructs and interpretes the message in a \"dynamic\" way, the message will be packed and unpacked step by step by SDXF functions.",
      "zh-CHS": "o SDXF以“动态”的方式构造和解释消息，消息将通过SDXF函数逐步打包和解包。"
    },
    {
      "indent": 3,
      "text": "The use of static structures may be appropriate for a series of applications, but for complex tasks it is often impossible to define the message as a whole. As an example try to define an ASN.1 description for a complex structured text document which is presented in XML: There are sections and paragraphs and text elements which may recursively consist of sections with specific text attributes.",
      "zh-CHS": "静态结构的使用可能适用于一系列应用程序，但对于复杂任务，通常不可能将消息定义为一个整体。例如，尝试为以XML表示的复杂结构化文本文档定义ASN.1描述：有节、段落和文本元素，它们可能递归地由具有特定文本属性的节组成。"
    },
    {
      "indent": 0,
      "text": "13.2 SDXF vs. XML",
      "section_title": true,
      "zh-CHS": "13.2 SDXF与XML"
    },
    {
      "indent": 3,
      "text": "On the one hand SDXF and XML are similar as they can handle any recursive complex data stream. The main difference is the kind of data which are to be maintained:",
      "zh-CHS": "一方面，SDXF和XML很相似，因为它们可以处理任何递归的复杂数据流。主要区别在于需要维护的数据类型："
    },
    {
      "indent": 3,
      "text": "o XML works with pure text data (though it should be noted that the character representation is not standardized by XML). And: a XML document with all his tags is readable by human. Binary data as graphic is not included directly but may be referenced by an external link as in HTML.",
      "zh-CHS": "o XML使用纯文本数据（尽管应该注意，字符表示不是XML标准化的）。而且：一个包含所有his标记的XML文档是可读的。作为图形的二进制数据不直接包括在内，但可以通过HTML中的外部链接引用。"
    },
    {
      "indent": 6,
      "text": "In XML there is no strong separation between informational and control data, escape characters (like \"<\" and \"&\") and the <![CDATA[...]]> construction are used to distinguish between these two types of data.",
      "zh-CHS": "在XML中，信息数据和控制数据、转义字符（如“<”和“&”）和<之间没有很强的分离！[CDATA[…]]>构造用于区分这两种类型的数据。"
    },
    {
      "indent": 3,
      "text": "o SDXF maintains machine-readable data, it is not designed to be readable by human nor to edit SDXF data with a text editor (even more if compression and encryption is used). With the help of the SDXF functions you have a quick and easy access to every data element. The standard parser for a SDXF data structure follows always a simple template, the \"while - switch -case ID - enter/extract\" pattern as outlined in chap. 3.4.2.",
      "zh-CHS": "o SDXF维护机器可读的数据，它不是为人类可读而设计的，也不是为使用文本编辑器编辑SDXF数据而设计的（如果使用压缩和加密，则更是如此）。借助SDXF函数，您可以快速轻松地访问每个数据元素。SDXF数据结构的标准解析器始终遵循一个简单的模板，“while-switch-case ID-enter/extract”模式，如第3.4.2章所述。"
    },
    {
      "indent": 3,
      "text": "Because of the complete different philosophy behind XML and SDXF (and even ASN.1) a direct comparison may not be very senseful, as XML has its own right to exist next to ASN.1 (and even SDXF).",
      "zh-CHS": "由于XML和SDXF（甚至是ASN.1）背后的理念完全不同，直接比较可能不是很有意义，因为XML有它自己的权利存在于ASN.1（甚至是SDXF）的旁边。"
    },
    {
      "indent": 3,
      "text": "Nevertheless there is a chance to convert a XML data stream into a SDXF structure: As a first strike, every XML tag becomes a SDXF chunk ID. An elementary sequence <tag>pure text</tag> can be transformed into an elementary (non-structured) chunk with data type \"character\". Tags with attributes and sequences with nested tags are transformed into structured chunks. Because XML allows a tag sequence everywhere in a text stream, an artificially \"elementary text\" tag must be introduced: If <t> is the tag for text elements, the sequence:",
      "zh-CHS": "尽管如此，还是有机会将XML数据流转换为SDXF结构：首先，每个XML标记都成为SDXF块ID。基本序列<tag>纯文本<tag>可以转换为数据类型为“character”的基本（非结构化）块。将具有属性的标记和具有嵌套标记的序列转换为结构化块。由于XML允许标记序列在文本流中的任何位置，因此必须引入人工的“基本文本”标记：如果<t>是文本元素的标记，则序列："
    },
    {
      "indent": 3,
      "text": "<t>this is a text <attr value='bold'>with</attr> attributes</t>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "is to be \"in thought\" replaced by:",
      "zh-CHS": "将“思考中”替换为："
    },
    {
      "indent": 3,
      "text": "<t><et>this is a text </et><attr value='bold'><et>with</et></attr>\n<et> attributes</et></t>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "(With \"et\" as the \"elementary text\" tag)",
      "zh-CHS": "（将“et”作为“基本文本”标记）"
    },
    {
      "indent": 3,
      "text": "This results in following SDXF structure:",
      "zh-CHS": "这将导致以下SDXF结构："
    },
    {
      "indent": 3,
      "text": "ID_t\n|\n+-- ID_et = \" this is a text \"\n|\n+-- ID_attr\n|   |\n|   +-- ID_value = \"bold\"\n|   |\n|   +-- ID_et = \"with\"\n|\n+-- ID_et = \" attributes\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "ID_t and ID_et may be represented by the same chunk ID, only distinguished by the data type (\"structured\" for <t> and \"character\" for <et>)",
      "zh-CHS": "ID_t和ID_et可以由相同的块ID表示，仅通过数据类型（“结构化”表示<t>，而“字符”表示<et>）"
    },
    {
      "indent": 3,
      "text": "Binary data as pictures can be directly imbedded into a SDXF structure instead referencing them as an external link like in HTML.",
      "zh-CHS": "作为图片的二进制数据可以直接嵌入到SDXF结构中，而不是像HTML中那样作为外部链接引用它们。"
    },
    {
      "indent": 0,
      "text": "14. Author's Address",
      "section_title": true,
      "zh-CHS": "14. 作者地址"
    },
    {
      "indent": 3,
      "text": "Max Wildgrube Schlossstrasse 120 60486 Frankfurt Germany",
      "zh-CHS": "德国法兰克福MaxWildgrube Schlossstrasse 120 60486"
    },
    {
      "indent": 3,
      "text": "EMail: max@wildgrube.com",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "15. Acknowledgements",
      "section_title": true,
      "zh-CHS": "15. 致谢"
    },
    {
      "indent": 3,
      "text": "I would like to thank Michael J. Slifcak (mslifcak@iss.net) for the supporting discussions.",
      "zh-CHS": "我要感谢Michael J.Slifcak(mslifcak@iss.net)支持讨论。"
    },
    {
      "indent": 0,
      "text": "16. References",
      "section_title": true,
      "zh-CHS": "16. 工具书类"
    },
    {
      "indent": 3,
      "text": "[ASN.1] Information processing systems - Open Systems Interconnection, \"Specification of Abstract Syntax Notation One (ASN.1)\", International Organization for Standardization, International Standard 8824, December 1987.",
      "zh-CHS": "[ASN.1]信息处理系统-开放系统互连，“抽象语法符号1规范（ASN.1）”，国际标准化组织，国际标准88241987年12月。"
    },
    {
      "indent": 3,
      "text": "[BER] Information Processing Systems - Open Systems Interconnection - \"Specification of Basic Encoding Rules for Abstract Notation One (ASN.1)\", International Organization for Standardization, International Standard 8825-1, December 1987.",
      "zh-CHS": "[BER]信息处理系统-开放系统互连-“抽象符号1（ASN.1）基本编码规则规范”，国际标准化组织，国际标准8825-11987年12月。"
    },
    {
      "indent": 3,
      "text": "[DEFLATE] Deutsch, P., \"DEFLATE Compressed Data Format Specification version 1.3\", RFC 1951, May 1996.",
      "zh-CHS": "[DEFLATE]Deutsch，P.，“DEFLATE压缩数据格式规范1.3版”，RFC1951，1996年5月。"
    },
    {
      "indent": 3,
      "text": "[IANA]    Internet Assigned Numbers Authority,\n          http://www.iana.org/numbers.htm",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "[PER] Information Processing Systems - Open Systems Interconnection -\"Specification of Packed Encoding Rules for Abstract Syntax Notation One (ASN.1)\", International Organization for Standardization, International Standard 8825-2.",
      "zh-CHS": "[PER]信息处理系统-开放系统互连-“抽象语法符号1（ASN.1）的压缩编码规则规范”，国际标准化组织，国际标准8825-2。"
    },
    {
      "indent": 3,
      "text": "[UCS] ISO/IEC 10646-1:1993. International Standard -- Information technology -- Universal Multiple-Octet Coded Character Set (UCS)",
      "zh-CHS": "[UCS]ISO/IEC 10646-1:1993。国际标准信息技术通用多八位编码字符集（UCS）"
    },
    {
      "indent": 3,
      "text": "[UTF8] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", RFC 2279, January 1998.",
      "zh-CHS": "[UTF8]Yergeau，F.，“UTF-8，ISO 10646的转换格式”，RFC 2279，1998年1月。"
    },
    {
      "indent": 0,
      "text": "17. Full Copyright Statement",
      "section_title": true,
      "zh-CHS": "17. 完整版权声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2001). All Rights Reserved.",
      "zh-CHS": "版权所有（C）互联网协会（2001年）。版权所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "zh-CHS": "本文件及其译本可复制并提供给他人，对其进行评论或解释或协助其实施的衍生作品可全部或部分编制、复制、出版和分发，不受任何限制，前提是上述版权声明和本段包含在所有此类副本和衍生作品中。但是，不得以任何方式修改本文件本身，例如删除版权通知或对互联网协会或其他互联网组织的引用，除非出于制定互联网标准的需要，在这种情况下，必须遵循互联网标准过程中定义的版权程序，或根据需要将其翻译成英语以外的其他语言。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "zh-CHS": "上述授予的有限许可是永久性的，互联网协会或其继承人或受让人不会撤销。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "zh-CHS": "本文件和其中包含的信息是按“原样”提供的，互联网协会和互联网工程任务组否认所有明示或暗示的保证，包括但不限于任何保证，即使用本文中的信息不会侵犯任何权利，或对适销性或特定用途适用性的任何默示保证。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "zh-CHS": "确认"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "zh-CHS": "RFC编辑功能的资金目前由互联网协会提供。"
    }
  ]
}