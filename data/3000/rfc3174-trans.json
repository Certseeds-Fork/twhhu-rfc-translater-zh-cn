{
  "title": {
    "text": "RFC 3174:  US Secure Hash Algorithm 1 (SHA1) ",
    "zh-CHS": "RFC 3174"
  },
  "number": 3174,
  "created_at": "2021-10-26 04:46:06.135752+08:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                   D. Eastlake, 3rd\nRequest for Comments: 3174                                      Motorola\nCategory: Informational                                         P. Jones\n                                                           Cisco Systems\n                                                          September 2001",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 19,
      "text": "US Secure Hash Algorithm 1 (SHA1)",
      "zh-CHS": "美国安全哈希算法1（SHA1）"
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "zh-CHS": "本备忘录的状况"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "zh-CHS": "本备忘录为互联网社区提供信息。它没有规定任何类型的互联网标准。本备忘录的分发不受限制。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "zh-CHS": "版权公告"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2001). All Rights Reserved.",
      "zh-CHS": "版权所有（C）互联网协会（2001年）。版权所有。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "zh-CHS": "摘要"
    },
    {
      "indent": 3,
      "text": "The purpose of this document is to make the SHA-1 (Secure Hash Algorithm 1) hash algorithm conveniently available to the Internet community. The United States of America has adopted the SHA-1 hash algorithm described herein as a Federal Information Processing Standard. Most of the text herein was taken by the authors from FIPS 180-1. Only the C code implementation is \"original\".",
      "zh-CHS": "本文档的目的是使SHA-1（安全哈希算法1）哈希算法方便地提供给互联网社区。美利坚合众国已采用本文所述的SHA-1哈希算法作为联邦信息处理标准。本文中的大部分文本由作者摘自FIPS 180-1。只有C代码实现是“原始的”。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "zh-CHS": "致谢"
    },
    {
      "indent": 3,
      "text": "Most of the text herein was taken from [FIPS 180-1]. Only the C code implementation is \"original\" but its style is similar to the previously published MD4 and MD5 RFCs [RFCs 1320, 1321].",
      "zh-CHS": "本文大部分内容摘自[FIPS 180-1]。只有C代码实现是“原始的”，但它的风格类似于之前发布的MD4和MD5 RFC[RFCS13201321]。"
    },
    {
      "indent": 3,
      "text": "The SHA-1 is based on principles similar to those used by Professor Ronald L. Rivest of MIT when designing the MD4 message digest algorithm [MD4] and is modeled after that algorithm [RFC 1320].",
      "zh-CHS": "SHA-1基于与麻省理工学院Ronald L.Rivest教授在设计MD4消息摘要算法[MD4]时使用的原理相似的原理，并以该算法[RFC 1320]为模型。"
    },
    {
      "indent": 3,
      "text": "Useful comments from the following, which have been incorporated herein, are gratefully acknowledged:",
      "zh-CHS": "感谢以下各方提出的有用意见，这些意见已纳入本文："
    },
    {
      "indent": 6,
      "text": "Tony Hansen Garrett Wollman",
      "zh-CHS": "托尼·汉森·加勒特·沃尔曼"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "zh-CHS": "目录"
    },
    {
      "indent": 3,
      "text": "1. Overview of Contents...........................................  2\n2. Definitions of Bit Strings and Integers........................  3\n3. Operations on Words............................................  3\n4. Message Padding................................................  4\n5. Functions and Constants Used...................................  6\n6. Computing the Message Digest...................................  6\n6.1 Method 1......................................................  6\n6.2 Method 2......................................................  7\n7. C Code.........................................................  8\n7.1 .h file.......................................................  8\n7.2 .c file....................................................... 10\n7.3 Test Driver................................................... 18\n8. Security Considerations........................................ 20\nReferences........................................................ 21\nAuthors' Addresses................................................ 21\nFull Copyright Statement.......................................... 22",
      "raw": true,
      "toc": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "1. Overview of Contents",
      "section_title": true,
      "zh-CHS": "1. 内容概述"
    },
    {
      "indent": 3,
      "text": "NOTE: The text below is mostly taken from [FIPS 180-1] and assertions therein of the security of SHA-1 are made by the US Government, the author of [FIPS 180-1], and not by the authors of this document.",
      "zh-CHS": "注：以下文字主要摘自[FIPS 180-1]，其中关于SHA-1安全性的声明由[FIPS 180-1]的作者美国政府提出，而非本文件的作者。"
    },
    {
      "indent": 3,
      "text": "This document specifies a Secure Hash Algorithm, SHA-1, for computing a condensed representation of a message or a data file. When a message of any length < 2^64 bits is input, the SHA-1 produces a 160-bit output called a message digest. The message digest can then, for example, be input to a signature algorithm which generates or verifies the signature for the message. Signing the message digest rather than the message often improves the efficiency of the process because the message digest is usually much smaller in size than the message. The same hash algorithm must be used by the verifier of a digital signature as was used by the creator of the digital signature. Any change to the message in transit will, with very high probability, result in a different message digest, and the signature will fail to verify.",
      "zh-CHS": "本文档指定了一种安全哈希算法SHA-1，用于计算消息或数据文件的压缩表示。当输入任何长度小于2^64位的消息时，SHA-1产生一个160位的输出，称为消息摘要。然后，例如，可以将消息摘要输入到签名算法，该算法生成或验证消息的签名。签名消息摘要而不是消息通常会提高流程的效率，因为消息摘要的大小通常比消息小得多。数字签名的验证者必须使用与数字签名的创建者相同的哈希算法。对传输中的消息的任何更改都极有可能导致不同的消息摘要，并且签名将无法验证。"
    },
    {
      "indent": 3,
      "text": "The SHA-1 is called secure because it is computationally infeasible to find a message which corresponds to a given message digest, or to find two different messages which produce the same message digest. Any change to a message in transit will, with very high probability, result in a different message digest, and the signature will fail to verify.",
      "zh-CHS": "SHA-1被称为安全的，因为在计算上不可能找到与给定消息摘要相对应的消息，也不可能找到生成相同消息摘要的两条不同消息。对传输中的消息的任何更改都极有可能导致不同的消息摘要，并且签名将无法验证。"
    },
    {
      "indent": 3,
      "text": "Section 2 below defines the terminology and functions used as building blocks to form SHA-1.",
      "zh-CHS": "下文第2节定义了构成SHA-1的构建块所使用的术语和功能。"
    },
    {
      "indent": 0,
      "text": "2. Definitions of Bit Strings and Integers",
      "section_title": true,
      "zh-CHS": "2. 位字符串和整数的定义"
    },
    {
      "indent": 3,
      "text": "The following terminology related to bit strings and integers will be used:",
      "zh-CHS": "将使用以下与位字符串和整数相关的术语："
    },
    {
      "indent": 3,
      "text": "a. A hex digit is an element of the set {0, 1, ... , 9, A, ... , F}. A hex digit is the representation of a 4-bit string. Examples: 7 = 0111, A = 1010.",
      "zh-CHS": "a. 十六进制数字是集合{0，1，…，9，A，…，F}的一个元素。十六进制数字是4位字符串的表示形式。示例：7=0111，A=1010。"
    },
    {
      "indent": 3,
      "text": "b. A word equals a 32-bit string which may be represented as a sequence of 8 hex digits. To convert a word to 8 hex digits each 4-bit string is converted to its hex equivalent as described in (a) above. Example:",
      "zh-CHS": "b. 一个字等于一个32位字符串，可以表示为8个十六进制数字的序列。要将一个字转换为8个十六进制数字，每个4位字符串将转换为其十六进制等效值，如上文（a）所述。例子："
    },
    {
      "indent": 6,
      "text": "1010 0001 0000 0011 1111 1110 0010 0011 = A103FE23.",
      "zh-CHS": "1010 0001 0000 0011 1111 1110 0010 0011=A103FE23。"
    },
    {
      "indent": 3,
      "text": "c. An integer between 0 and 2^32 - 1 inclusive may be represented as a word. The least significant four bits of the integer are represented by the right-most hex digit of the word representation. Example: the integer 291 = 2^8+2^5+2^1+2^0 = 256+32+2+1 is represented by the hex word, 00000123.",
      "zh-CHS": "c. 介于0和2^32-1（含）之间的整数可以表示为一个字。整数的最低有效位由单词表示法的最右边的十六进制数字表示。示例：整数291=2^8+2^5+2^1+2^0=256+32+2+1由十六进制字00000123表示。"
    },
    {
      "indent": 6,
      "text": "If z is an integer, 0 <= z < 2^64, then z = (2^32)x + y where 0 <=\nx < 2^32 and 0 <= y < 2^32.  Since x and y can be represented as\nwords X and Y, respectively, z can be represented as the pair of\nwords (X,Y).",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "d. block = 512-bit string. A block (e.g., B) may be represented as a sequence of 16 words.",
      "zh-CHS": "d. 块=512位字符串。块（例如，B）可以表示为16个字的序列。"
    },
    {
      "indent": 0,
      "text": "3. Operations on Words",
      "section_title": true,
      "zh-CHS": "3. 文字操作"
    },
    {
      "indent": 3,
      "text": "The following logical operators will be applied to words:",
      "zh-CHS": "以下逻辑运算符将应用于字："
    },
    {
      "indent": 3,
      "text": "a. Bitwise logical word operations",
      "zh-CHS": "a. 按位逻辑字运算"
    },
    {
      "indent": 6,
      "text": "X AND Y = bitwise logical \"and\" of X and Y.",
      "zh-CHS": "X和Y=X和Y的按位逻辑“AND”。"
    },
    {
      "indent": 6,
      "text": "X OR Y = bitwise logical \"inclusive-or\" of X and Y.",
      "zh-CHS": "X或Y=X和Y的按位逻辑“包含或”。"
    },
    {
      "indent": 6,
      "text": "X XOR Y = bitwise logical \"exclusive-or\" of X and Y.",
      "zh-CHS": "X XOR Y=X和Y的按位逻辑“异或”。"
    },
    {
      "indent": 6,
      "text": "NOT X = bitwise logical \"complement\" of X.",
      "zh-CHS": "NOT X=X的按位逻辑“补码”。"
    },
    {
      "indent": 6,
      "text": "Example:",
      "zh-CHS": "例子："
    },
    {
      "indent": 9,
      "text": "      01101100101110011101001001111011\nXOR   01100101110000010110100110110111\n      --------------------------------\n  =   00001001011110001011101111001100",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "b. The operation X + Y is defined as follows:  words X and Y\n   represent integers x and y, where 0 <= x < 2^32 and 0 <= y < 2^32.\n   For positive integers n and m, let n mod m be the remainder upon\n   dividing n by m.  Compute",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "z  =  (x + y) mod 2^32.",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "Then 0 <= z < 2^32. Convert z to a word, Z, and define Z = X + Y.",
      "zh-CHS": "然后0<=z<2^32。将z转换为单词z，并定义z=X+Y。"
    },
    {
      "indent": 3,
      "text": "c. The circular left shift operation S^n(X), where X is a word and n\n   is an integer with 0 <= n < 32, is defined by",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "S^n(X)  =  (X << n) OR (X >> 32-n).",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "In the above, X << n is obtained as follows: discard the left-most n bits of X and then pad the result with n zeroes on the right (the result will still be 32 bits). X >> n is obtained by discarding the right-most n bits of X and then padding the result with n zeroes on the left. Thus S^n(X) is equivalent to a circular shift of X by n positions to the left.",
      "zh-CHS": "在上面的例子中，X<<n如下所示：丢弃X的最左边的n位，然后在右边用n个零填充结果（结果仍然是32位）。X>>n是通过丢弃X的最右边的n位，然后在左边用n个零填充结果来获得的。因此，S^n（X）相当于X向左移动n个位置。"
    },
    {
      "indent": 0,
      "text": "4. Message Padding",
      "section_title": true,
      "zh-CHS": "4. 消息填充"
    },
    {
      "indent": 3,
      "text": "SHA-1 is used to compute a message digest for a message or data file that is provided as input. The message or data file should be considered to be a bit string. The length of the message is the number of bits in the message (the empty message has length 0). If the number of bits in a message is a multiple of 8, for compactness we can represent the message in hex. The purpose of message padding is to make the total length of a padded message a multiple of 512. SHA-1 sequentially processes blocks of 512 bits when computing the message digest. The following specifies how this padding shall be performed. As a summary, a \"1\" followed by m \"0\"s followed by a 64- bit integer are appended to the end of the message to produce a padded message of length 512 * n. The 64-bit integer is the length of the original message. The padded message is then processed by the SHA-1 as n 512-bit blocks.",
      "zh-CHS": "SHA-1用于计算作为输入提供的消息或数据文件的消息摘要。消息或数据文件应视为位字符串。消息的长度是消息中的位数（空消息的长度为0）。如果消息中的位数是8的倍数，为了简洁起见，我们可以用十六进制表示消息。消息填充的目的是使填充消息的总长度为512的倍数。在计算消息摘要时，SHA-1顺序处理512位的块。以下规定了应如何进行填充。作为总结，将“1”后跟m“0”后跟64位整数附加到消息末尾，以生成长度为512*n的填充消息。64位整数是原始消息的长度。然后，SHA-1将填充消息作为n 512位块进行处理。"
    },
    {
      "indent": 3,
      "text": "Suppose a message has length l < 2^64. Before it is input to the SHA-1, the message is padded on the right as follows:",
      "zh-CHS": "假设一条消息的长度l<2^64。在输入到SHA-1之前，消息在右侧填充，如下所示："
    },
    {
      "indent": 3,
      "text": "a. \"1\" is appended. Example: if the original message is \"01010000\", this is padded to \"010100001\".",
      "zh-CHS": "a. 附加“1”。示例：如果原始消息为“01010000”，则填充为“010100001”。"
    },
    {
      "indent": 3,
      "text": "b. \"0\"s are appended. The number of \"0\"s will depend on the original length of the message. The last 64 bits of the last 512-bit block are reserved",
      "zh-CHS": "b. 追加了“0”。“0”的数量将取决于消息的原始长度。最后512位块的最后64位保留"
    },
    {
      "indent": 6,
      "text": "for the length l of the original message.",
      "zh-CHS": "对于原始消息的长度l。"
    },
    {
      "indent": 6,
      "text": "Example: Suppose the original message is the bit string",
      "zh-CHS": "示例：假设原始消息是位字符串"
    },
    {
      "indent": 9,
      "text": "01100001 01100010 01100011 01100100 01100101.",
      "zh-CHS": "01100001 01100010 01100011 01100100 01100101."
    },
    {
      "indent": 6,
      "text": "After step (a) this gives",
      "zh-CHS": "在步骤（a）之后，给出"
    },
    {
      "indent": 9,
      "text": "01100001 01100010 01100011 01100100 01100101 1.",
      "zh-CHS": "01100001 01100010 01100011 01100100 01100101 1."
    },
    {
      "indent": 6,
      "text": "Since l = 40, the number of bits in the above is 41 and 407 \"0\"s are appended, making the total now 448. This gives (in hex)",
      "zh-CHS": "因为l=40，上面的位数是41，加上407个“0”，总数现在是448。这给出了（十六进制）"
    },
    {
      "indent": 9,
      "text": "61626364 65800000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000.",
      "zh-CHS": "61626364 65800000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000."
    },
    {
      "indent": 3,
      "text": "c. Obtain the 2-word representation of l, the number of bits in the original message. If l < 2^32 then the first word is all zeroes. Append these two words to the padded message.",
      "zh-CHS": "c. 获取l的2字表示形式，即原始消息中的位数。如果l<2^32，则第一个字为全零。将这两个单词附加到填充的消息中。"
    },
    {
      "indent": 6,
      "text": "Example: Suppose the original message is as in (b). Then l = 40 (note that l is computed before any padding). The two-word representation of 40 is hex 00000000 00000028. Hence the final padded message is hex",
      "zh-CHS": "示例：假设原始消息如（b）所示。然后l=40（注意，l是在任何填充之前计算的）。40的两个单词表示为十六进制00000000000028。因此，最后的填充消息是hex"
    },
    {
      "indent": 9,
      "text": "61626364 65800000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000028.",
      "zh-CHS": "61626364 65800000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000028."
    },
    {
      "indent": 6,
      "text": "The padded message will contain 16 * n words for some n > 0. The padded message is regarded as a sequence of n blocks M(1) , M(2), first characters (or bits) of the message.",
      "zh-CHS": "填充消息将包含16*n个单词，表示某些n>0。填充消息被视为消息的n个块M（1）、M（2）、第一个字符（或位）的序列。"
    },
    {
      "indent": 0,
      "text": "5. Functions and Constants Used",
      "section_title": true,
      "zh-CHS": "5. 使用的函数和常量"
    },
    {
      "indent": 3,
      "text": "A sequence of logical functions f(0), f(1),..., f(79) is used in SHA-1. Each f(t), 0 <= t <= 79, operates on three 32-bit words B, C, D and produces a 32-bit word as output. f(t;B,C,D) is defined as follows: for words B, C, D,",
      "zh-CHS": "SHA-1中使用了一系列逻辑函数f（0），f（1），…，f（79）。每个f（t），0<=t<=79，对三个32位字B、C、D进行运算，并产生一个32位字作为输出。f（t；B，C，D）的定义如下：对于单词B，C，D，"
    },
    {
      "indent": 6,
      "text": "f(t;B,C,D) = (B AND C) OR ((NOT B) AND D)         ( 0 <= t <= 19)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "f(t;B,C,D) = B XOR C XOR D                        (20 <= t <= 39)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "f(t;B,C,D) = (B AND C) OR (B AND D) OR (C AND D)  (40 <= t <= 59)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "f(t;B,C,D) = B XOR C XOR D (60 <= t <= 79).",
      "zh-CHS": "f（t；B，C，D）=B XOR C XOR D（60<=t<=79）。"
    },
    {
      "indent": 3,
      "text": "A sequence of constant words K(0), K(1), ... , K(79) is used in the SHA-1. In hex these are given by",
      "zh-CHS": "一系列常量字K（0），K（1），SHA-1中使用了K（79）。在十六进制中，它们由"
    },
    {
      "indent": 6,
      "text": "K(t) = 5A827999         ( 0 <= t <= 19)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "K(t) = 6ED9EBA1         (20 <= t <= 39)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "K(t) = 8F1BBCDC         (40 <= t <= 59)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "K(t) = CA62C1D6 (60 <= t <= 79).",
      "zh-CHS": "K（t）=CA62C1D6（60<=t<=79）。"
    },
    {
      "indent": 0,
      "text": "6. Computing the Message Digest",
      "section_title": true,
      "zh-CHS": "6. 计算消息摘要"
    },
    {
      "indent": 3,
      "text": "The methods given in 6.1 and 6.2 below yield the same message digest. Although using method 2 saves sixty-four 32-bit words of storage, it is likely to lengthen execution time due to the increased complexity of the address computations for the { W[t] } in step (c). There are other computation methods which give identical results.",
      "zh-CHS": "下面6.1和6.2中给出的方法产生相同的消息摘要。尽管使用方法2节省了64个32位的存储字，但由于步骤（c）中{W[t]}的地址计算的复杂性增加，可能会延长执行时间。还有其他的计算方法给出了相同的结果。"
    },
    {
      "indent": 0,
      "text": "6.1 Method 1",
      "section_title": true,
      "zh-CHS": "6.1 方法1"
    },
    {
      "indent": 3,
      "text": "The message digest is computed using the message padded as described in section 4. The computation is described using two buffers, each consisting of five 32-bit words, and a sequence of eighty 32-bit words. The words of the first 5-word buffer are labeled A,B,C,D,E. The words of the second 5-word buffer are labeled H0, H1, H2, H3, H4. The words of the 80-word sequence are labeled W(0), W(1),..., W(79). A single word buffer TEMP is also employed.",
      "zh-CHS": "消息摘要使用第4节中描述的填充消息进行计算。使用两个缓冲区描述计算，每个缓冲区由五个32位字和一个由八十个32位字组成的序列组成。第一个5字缓冲区的字标记为A、B、C、D、E。第二个5字缓冲区的字标记为H0、H1、H2、H3、H4。80个单词序列中的单词标记为W（0）、W（1）、…、W（79）。还使用了单字缓冲区TEMP。"
    },
    {
      "indent": 3,
      "text": "To generate the message digest, the 16-word blocks M(1), M(2),..., M(n) defined in section 4 are processed in order. The processing of each M(i) involves 80 steps.",
      "zh-CHS": "为了生成消息摘要，按顺序处理第4节中定义的16字块M（1）、M（2）、…、M（n）。每个M（i）的处理涉及80个步骤。"
    },
    {
      "indent": 3,
      "text": "Before processing any blocks, the H's are initialized as follows: in hex,",
      "zh-CHS": "在处理任何块之前，H的初始化如下：十六进制，"
    },
    {
      "indent": 6,
      "text": "H0 = 67452301",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "H1 = EFCDAB89",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "H2 = 98BADCFE",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "H3 = 10325476",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "H4 = C3D2E1F0.",
      "zh-CHS": "H4=C3D2E1F0。"
    },
    {
      "indent": 3,
      "text": "Now M(1), M(2), ... , M(n) are processed. To process M(i), we proceed as follows:",
      "zh-CHS": "现在M（1），M（2），M（n）被处理。为了处理M（i），我们按照以下步骤进行："
    },
    {
      "indent": 6,
      "text": "a. Divide M(i) into 16 words W(0), W(1), ... , W(15), where W(0) is the left-most word.",
      "zh-CHS": "a. 将M（i）分为16个单词W（0），W（1），W（15），其中W（0）是最左边的单词。"
    },
    {
      "indent": 6,
      "text": "b. For t = 16 to 79 let",
      "zh-CHS": "b. 对于t=16至79，让"
    },
    {
      "indent": 9,
      "text": "W(t) = S^1(W(t-3) XOR W(t-8) XOR W(t-14) XOR W(t-16)).",
      "zh-CHS": "W（t）=S^1（W（t-3）XOR W（t-8）XOR W（t-14）XOR W（t-16））。"
    },
    {
      "indent": 6,
      "text": "c. Let A = H0, B = H1, C = H2, D = H3, E = H4.",
      "zh-CHS": "c. 设A=H0，B=H1，C=H2，D=H3，E=H4。"
    },
    {
      "indent": 6,
      "text": "d. For t = 0 to 79 do",
      "zh-CHS": "d. 对于t=0至79 do"
    },
    {
      "indent": 9,
      "text": "TEMP = S^5(A) + f(t;B,C,D) + E + W(t) + K(t);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "E = D;  D = C;  C = S^30(B);  B = A; A = TEMP;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "e. Let H0 = H0 + A, H1 = H1 + B, H2 = H2 + C, H3 = H3 + D, H4 = H4 + E.",
      "zh-CHS": "e. 设H0=H0+A，H1=H1+B，H2=H2+C，H3=H3+D，H4=H4+E。"
    },
    {
      "indent": 3,
      "text": "After processing M(n), the message digest is the 160-bit string represented by the 5 words",
      "zh-CHS": "在处理M（n）之后，消息摘要是由5个字表示的160位字符串"
    },
    {
      "indent": 9,
      "text": "H0 H1 H2 H3 H4.",
      "zh-CHS": "h0h1h2h3h4。"
    },
    {
      "indent": 0,
      "text": "6.2 Method 2",
      "section_title": true,
      "zh-CHS": "6.2 方法2"
    },
    {
      "indent": 3,
      "text": "The method above assumes that the sequence W(0), ... , W(79) is\nimplemented as an array of eighty 32-bit words.  This is efficient\nfrom the standpoint of minimization of execution time, since the\naddresses of W(t-3), ...  ,W(t-16) in step (b) are easily computed.\nIf space is at a premium, an alternative is to regard { W(t) } as a",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "circular queue, which may be implemented using an array of sixteen 32-bit words W[0], ... W[15]. In this case, in hex let",
      "zh-CHS": "循环队列，可使用十六个32位字W[0]的数组实现。。。W[15]。在这种情况下，在hex-let中"
    },
    {
      "indent": 3,
      "text": "MASK = 0000000F. Then processing of M(i) is as follows:",
      "zh-CHS": "掩码=0000000 F。那么M（i）的处理如下："
    },
    {
      "indent": 6,
      "text": "a. Divide M(i) into 16 words W[0], ... , W[15], where W[0] is the left-most word.",
      "zh-CHS": "a. 将M（i）分成16个字W[0]，W[15]，其中W[0]是最左边的单词。"
    },
    {
      "indent": 6,
      "text": "b. Let A = H0, B = H1, C = H2, D = H3, E = H4.",
      "zh-CHS": "b. 设A=H0，B=H1，C=H2，D=H3，E=H4。"
    },
    {
      "indent": 6,
      "text": "c. For t = 0 to 79 do",
      "zh-CHS": "c. 对于t=0至79 do"
    },
    {
      "indent": 9,
      "text": "s = t AND MASK;",
      "zh-CHS": "s=t和掩模；"
    },
    {
      "indent": 9,
      "text": "if (t >= 16) W[s] = S^1(W[(s + 13) AND MASK] XOR W[(s + 8) AND\nMASK] XOR W[(s + 2) AND MASK] XOR W[s]);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "TEMP = S^5(A) + f(t;B,C,D) + E + W[s] + K(t);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "E = D; D = C; C = S^30(B); B = A; A = TEMP;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "d. Let H0 = H0 + A, H1 = H1 + B, H2 = H2 + C, H3 = H3 + D, H4 = H4 + E.",
      "zh-CHS": "d. 设H0=H0+A，H1=H1+B，H2=H2+C，H3=H3+D，H4=H4+E。"
    },
    {
      "indent": 0,
      "text": "7. C Code",
      "section_title": true,
      "zh-CHS": "7. C代码"
    },
    {
      "indent": 3,
      "text": "Below is a demonstration implementation of SHA-1 in C. Section 7.1 contains the header file, 7.2 the C code, and 7.3 a test driver.",
      "zh-CHS": "下面是C中SHA-1的演示实现。第7.1节包含头文件、7.2 C代码和7.3 a测试驱动程序。"
    },
    {
      "indent": 0,
      "text": "7.1 .h file",
      "section_title": true,
      "zh-CHS": "7.1 .h文件"
    },
    {
      "indent": 0,
      "text": "/*\n *  sha1.h\n *\n *  Description:\n *      This is the header file for code which implements the Secure\n *      Hashing Algorithm 1 as defined in FIPS PUB 180-1 published\n *      April 17, 1995.\n *\n *      Many of the variable names in this code, especially the\n *      single character names, were used because those were the names\n *      used in the publication.\n *\n *      Please read the file sha1.c for more information.\n *\n */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "#ifndef _SHA1_H_ #define _SHA1_H_",
      "zh-CHS": "#如果没有定义_"
    },
    {
      "indent": 0,
      "text": "#include <stdint.h>\n/*\n * If you do not have the ISO standard stdint.h header file, then you\n * must typdef the following:\n *    name              meaning\n *  uint32_t         unsigned 32 bit integer\n *  uint8_t          unsigned 8 bit integer (i.e., unsigned char)\n *  int_least16_t    integer of >= 16 bits\n *\n */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "#ifndef _SHA_enum_\n#define _SHA_enum_\nenum\n{\n    shaSuccess = 0,\n    shaNull,            /* Null pointer parameter */\n    shaInputTooLong,    /* input data too long */\n    shaStateError       /* called Input after Result */\n};\n#endif\n#define SHA1HashSize 20",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n *  This structure will hold context information for the SHA-1\n *  hashing operation\n */\ntypedef struct SHA1Context\n{\n    uint32_t Intermediate_Hash[SHA1HashSize/4]; /* Message Digest  */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "uint32_t Length_Low;            /* Message length in bits      */\nuint32_t Length_High;           /* Message length in bits      */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "                           /* Index into message block array   */\nint_least16_t Message_Block_Index;\nuint8_t Message_Block[64];      /* 512-bit message blocks      */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "    int Computed;               /* Is the digest computed?         */\n    int Corrupted;             /* Is the message digest corrupted? */\n} SHA1Context;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n *  Function Prototypes\n */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "int SHA1Reset(  SHA1Context *);\nint SHA1Input(  SHA1Context *,\n                const uint8_t *,\n                unsigned int);\nint SHA1Result( SHA1Context *,\n                uint8_t Message_Digest[SHA1HashSize]);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "#endif",
      "zh-CHS": "#恩迪夫"
    },
    {
      "indent": 0,
      "text": "7.2 .c file",
      "section_title": true,
      "zh-CHS": "7.2 .c文件"
    },
    {
      "indent": 0,
      "text": "/*\n *  sha1.c\n *\n *  Description:\n *      This file implements the Secure Hashing Algorithm 1 as\n *      defined in FIPS PUB 180-1 published April 17, 1995.\n *\n *      The SHA-1, produces a 160-bit message digest for a given\n *      data stream.  It should take about 2**n steps to find a\n *      message with the same digest as a given message and\n *      2**(n/2) to find any two messages with the same digest,\n *      when n is the digest size in bits.  Therefore, this\n *      algorithm can serve as a means of providing a\n *      \"fingerprint\" for a message.\n *\n *  Portability Issues:\n *      SHA-1 is defined in terms of 32-bit \"words\".  This code\n *      uses <stdint.h> (included via \"sha1.h\" to define 32 and 8\n *      bit unsigned integer types.  If your C compiler does not\n *      support 32 bit unsigned integers, this code is not\n *      appropriate.\n *\n *  Caveats:\n *      SHA-1 is designed to work with messages less than 2^64 bits\n *      long.  Although SHA-1 allows a message digest to be generated\n *      for messages of any number of bits less than 2^64, this\n *      implementation only works with messages with a length that is\n *      a multiple of the size of an 8-bit character.\n *\n */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "#include \"sha1.h\"",
      "zh-CHS": "#包括“sha1.h”"
    },
    {
      "indent": 0,
      "text": "/*\n *  Define the SHA1 circular left shift macro\n */\n#define SHA1CircularShift(bits,word) \\\n                (((word) << (bits)) | ((word) >> (32-(bits))))",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/* Local Function Prototyptes */\nvoid SHA1PadMessage(SHA1Context *);\nvoid SHA1ProcessMessageBlock(SHA1Context *);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n *  SHA1Reset\n *\n *  Description:\n *      This function will initialize the SHA1Context in preparation\n *      for computing a new SHA1 message digest.\n *\n *  Parameters:\n *      context: [in/out]\n *          The context to reset.\n *\n *  Returns:\n *      sha Error Code.\n *\n */\nint SHA1Reset(SHA1Context *context)\n{\n    if (!context)\n    {\n        return shaNull;\n    }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "context->Length_Low             = 0;\ncontext->Length_High            = 0;\ncontext->Message_Block_Index    = 0;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "context->Intermediate_Hash[0]   = 0x67452301;\ncontext->Intermediate_Hash[1]   = 0xEFCDAB89;\ncontext->Intermediate_Hash[2]   = 0x98BADCFE;\ncontext->Intermediate_Hash[3]   = 0x10325476;\ncontext->Intermediate_Hash[4]   = 0xC3D2E1F0;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "context->Computed   = 0;\ncontext->Corrupted  = 0;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "    return shaSuccess;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n *  SHA1Result\n *\n *  Description:\n *      This function will return the 160-bit message digest into the\n *      Message_Digest array  provided by the caller.\n *      NOTE: The first octet of hash is stored in the 0th element,\n *            the last octet of hash in the 19th element.\n *\n *  Parameters:\n *      context: [in/out]\n *          The context to use to calculate the SHA-1 hash.\n *      Message_Digest: [out]\n *          Where the digest is returned.\n *\n *  Returns:\n *      sha Error Code.\n *\n */\nint SHA1Result( SHA1Context *context,\n                uint8_t Message_Digest[SHA1HashSize])\n{\n    int i;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "if (!context || !Message_Digest)\n{\n    return shaNull;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "if (context->Corrupted)\n{\n    return context->Corrupted;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "if (!context->Computed)\n{\n    SHA1PadMessage(context);\n    for(i=0; i<64; ++i)\n    {\n        /* message may be sensitive, clear it out */\n        context->Message_Block[i] = 0;\n    }\n    context->Length_Low = 0;    /* and clear length */\n    context->Length_High = 0;\n    context->Computed = 1;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "}",
      "zh-CHS": "}"
    },
    {
      "indent": 4,
      "text": "for(i = 0; i < SHA1HashSize; ++i)\n{\n    Message_Digest[i] = context->Intermediate_Hash[i>>2]\n                        >> 8 * ( 3 - ( i & 0x03 ) );\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "    return shaSuccess;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n *  SHA1Input\n *\n *  Description:\n *      This function accepts an array of octets as the next portion\n *      of the message.\n *\n *  Parameters:\n *      context: [in/out]\n *          The SHA context to update\n *      message_array: [in]\n *          An array of characters representing the next portion of\n *          the message.\n *      length: [in]\n *          The length of the message in message_array\n *\n *  Returns:\n *      sha Error Code.\n *\n */\nint SHA1Input(    SHA1Context    *context,\n                  const uint8_t  *message_array,\n                  unsigned       length)\n{\n    if (!length)\n    {\n        return shaSuccess;\n    }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "if (!context || !message_array)\n{\n    return shaNull;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "if (context->Computed)\n{\n    context->Corrupted = shaStateError;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "    return shaStateError;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "if (context->Corrupted)\n{\n     return context->Corrupted;\n}\nwhile(length-- && !context->Corrupted)\n{\ncontext->Message_Block[context->Message_Block_Index++] =\n                (*message_array & 0xFF);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "context->Length_Low += 8;\nif (context->Length_Low == 0)\n{\n    context->Length_High++;\n    if (context->Length_High == 0)\n    {\n        /* Message is too long */\n        context->Corrupted = 1;\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "if (context->Message_Block_Index == 64)\n{\n    SHA1ProcessMessageBlock(context);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "message_array++;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "    return shaSuccess;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n *  SHA1ProcessMessageBlock\n *\n *  Description:\n *      This function will process the next 512 bits of the message\n *      stored in the Message_Block array.\n *\n *  Parameters:\n *      None.\n *\n *  Returns:\n *      Nothing.\n *\n *  Comments:",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": " *      Many of the variable names in this code, especially the\n *      single character names, were used because those were the\n *      names used in the publication.\n *\n *\n */\nvoid SHA1ProcessMessageBlock(SHA1Context *context)\n{\n    const uint32_t K[] =    {       /* Constants defined in SHA-1   */\n                            0x5A827999,\n                            0x6ED9EBA1,\n                            0x8F1BBCDC,\n                            0xCA62C1D6\n                            };\n    int           t;                 /* Loop counter                */\n    uint32_t      temp;              /* Temporary word value        */\n    uint32_t      W[80];             /* Word sequence               */\n    uint32_t      A, B, C, D, E;     /* Word buffers                */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "/*\n *  Initialize the first 16 words in the array W\n */\nfor(t = 0; t < 16; t++)\n{\n    W[t] = context->Message_Block[t * 4] << 24;\n    W[t] |= context->Message_Block[t * 4 + 1] << 16;\n    W[t] |= context->Message_Block[t * 4 + 2] << 8;\n    W[t] |= context->Message_Block[t * 4 + 3];\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "for(t = 16; t < 80; t++)\n{\n   W[t] = SHA1CircularShift(1,W[t-3] ^ W[t-8] ^ W[t-14] ^ W[t-16]);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "A = context->Intermediate_Hash[0];\nB = context->Intermediate_Hash[1];\nC = context->Intermediate_Hash[2];\nD = context->Intermediate_Hash[3];\nE = context->Intermediate_Hash[4];",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "for(t = 0; t < 20; t++)\n{\n    temp =  SHA1CircularShift(5,A) +\n            ((B & C) | ((~B) & D)) + E + W[t] + K[0];\n    E = D;\n    D = C;\n    C = SHA1CircularShift(30,B);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "    B = A;\n    A = temp;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "for(t = 20; t < 40; t++)\n{\n    temp = SHA1CircularShift(5,A) + (B ^ C ^ D) + E + W[t] + K[1];\n    E = D;\n    D = C;\n    C = SHA1CircularShift(30,B);\n    B = A;\n    A = temp;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "for(t = 40; t < 60; t++)\n{\n    temp = SHA1CircularShift(5,A) +\n           ((B & C) | (B & D) | (C & D)) + E + W[t] + K[2];\n    E = D;\n    D = C;\n    C = SHA1CircularShift(30,B);\n    B = A;\n    A = temp;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "for(t = 60; t < 80; t++)\n{\n    temp = SHA1CircularShift(5,A) + (B ^ C ^ D) + E + W[t] + K[3];\n    E = D;\n    D = C;\n    C = SHA1CircularShift(30,B);\n    B = A;\n    A = temp;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "context->Intermediate_Hash[0] += A;\ncontext->Intermediate_Hash[1] += B;\ncontext->Intermediate_Hash[2] += C;\ncontext->Intermediate_Hash[3] += D;\ncontext->Intermediate_Hash[4] += E;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "    context->Message_Block_Index = 0;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n *  SHA1PadMessage\n *",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 1,
      "text": "* Description: * According to the standard, the message must be padded to an even * 512 bits. The first padding bit must be a '1'. The last 64 * bits represent the length of the original message. All bits in * between should be 0. This function will pad the message * according to those rules by filling the Message_Block array * accordingly. It will also call the ProcessMessageBlock function * provided appropriately. When it returns, it can be assumed that * the message digest has been computed. * * Parameters: * context: [in/out] * The context to pad * ProcessMessageBlock: [in] * The appropriate SHA*ProcessMessageBlock function * Returns: * Nothing. * */",
      "zh-CHS": "* 描述：*根据标准，消息必须填充到偶数*512位。第一个填充位必须是“1”。最后64*位表示原始消息的长度。*之间的所有位应为0。此函数将根据这些规则填充消息块数组*，从而填充消息*。它还将调用适当提供的ProcessMessageBlock函数*。当它返回时，可以假定*消息摘要已计算。**参数：*上下文：[in/out]*要填充的上下文*ProcessMessageBlock:[in]*相应的SHA*ProcessMessageBlock函数*返回：*无。**/"
    },
    {
      "indent": 0,
      "text": "void SHA1PadMessage(SHA1Context *context)\n{\n    /*\n     *  Check to see if the current message block is too small to hold\n     *  the initial padding bits and length.  If so, we will pad the\n     *  block, process it, and then continue padding into a second\n     *  block.\n     */\n    if (context->Message_Block_Index > 55)\n    {\n        context->Message_Block[context->Message_Block_Index++] = 0x80;\n        while(context->Message_Block_Index < 64)\n        {\n            context->Message_Block[context->Message_Block_Index++] = 0;\n        }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 8,
      "text": "SHA1ProcessMessageBlock(context);",
      "zh-CHS": "SHA1ProcessMessageBlock（上下文）；"
    },
    {
      "indent": 4,
      "text": "    while(context->Message_Block_Index < 56)\n    {\n        context->Message_Block[context->Message_Block_Index++] = 0;\n    }\n}\nelse\n{\n    context->Message_Block[context->Message_Block_Index++] = 0x80;\n    while(context->Message_Block_Index < 56)\n    {",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "        context->Message_Block[context->Message_Block_Index++] = 0;\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "/*\n *  Store the message length as the last 8 octets\n */\ncontext->Message_Block[56] = context->Length_High >> 24;\ncontext->Message_Block[57] = context->Length_High >> 16;\ncontext->Message_Block[58] = context->Length_High >> 8;\ncontext->Message_Block[59] = context->Length_High;\ncontext->Message_Block[60] = context->Length_Low >> 24;\ncontext->Message_Block[61] = context->Length_Low >> 16;\ncontext->Message_Block[62] = context->Length_Low >> 8;\ncontext->Message_Block[63] = context->Length_Low;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "    SHA1ProcessMessageBlock(context);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.3 Test Driver",
      "section_title": true,
      "zh-CHS": "7.3 试驾"
    },
    {
      "indent": 3,
      "text": "The following code is a main program test driver to exercise the code in sha1.c.",
      "zh-CHS": "下面的代码是一个主程序测试驱动程序，用于练习sha1.c中的代码。"
    },
    {
      "indent": 0,
      "text": "/*\n *  sha1test.c\n *\n *  Description:\n *      This file will exercise the SHA-1 code performing the three\n *      tests documented in FIPS PUB 180-1 plus one which calls\n *      SHA1Input with an exact multiple of 512 bits, plus a few\n *      error test checks.\n *\n *  Portability Issues:\n *      None.\n *\n */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include \"sha1.h\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n *  Define patterns for testing\n */\n#define TEST1   \"abc\"\n#define TEST2a  \"abcdbcdecdefdefgefghfghighijhi\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "#define TEST2b  \"jkijkljklmklmnlmnomnopnopq\"\n#define TEST2   TEST2a TEST2b\n#define TEST3   \"a\"\n#define TEST4a  \"01234567012345670123456701234567\"\n#define TEST4b  \"01234567012345670123456701234567\"\n    /* an exact multiple of 512 bits */\n#define TEST4   TEST4a TEST4b\nchar *testarray[4] =\n{\n    TEST1,\n    TEST2,\n    TEST3,\n    TEST4\n};\nlong int repeatcount[4] = { 1, 1, 1000000, 10 };\nchar *resultarray[4] =\n{\n    \"A9 99 3E 36 47 06 81 6A BA 3E 25 71 78 50 C2 6C 9C D0 D8 9D\",\n    \"84 98 3E 44 1C 3B D2 6E BA AE 4A A1 F9 51 29 E5 E5 46 70 F1\",\n    \"34 AA 97 3C D4 C4 DA A4 F6 1E EB 2B DB AD 27 31 65 34 01 6F\",\n    \"DE A3 56 A2 CD DD 90 C7 A7 EC ED C5 EB B5 63 93 4F 46 04 52\"\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "int main()\n{\n    SHA1Context sha;\n    int i, j, err;\n    uint8_t Message_Digest[20];",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "/*\n *  Perform SHA-1 tests\n */\nfor(j = 0; j < 4; ++j)\n{\n    printf( \"\\nTest %d: %d, '%s'\\n\",\n            j+1,\n            repeatcount[j],\n            testarray[j]);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 8,
      "text": "err = SHA1Reset(&sha);\nif (err)\n{\n    fprintf(stderr, \"SHA1Reset Error %d.\\n\", err );\n    break;    /* out of for j loop */\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 8,
      "text": "for(i = 0; i < repeatcount[j]; ++i)\n{",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 8,
      "text": "    err = SHA1Input(&sha,\n          (const unsigned char *) testarray[j],\n          strlen(testarray[j]));\n    if (err)\n    {\n        fprintf(stderr, \"SHA1Input Error %d.\\n\", err );\n        break;    /* out of for i loop */\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "    err = SHA1Result(&sha, Message_Digest);\n    if (err)\n    {\n        fprintf(stderr,\n        \"SHA1Result Error %d, could not compute message digest.\\n\",\n        err );\n    }\n    else\n    {\n        printf(\"\\t\");\n        for(i = 0; i < 20 ; ++i)\n        {\n            printf(\"%02X \", Message_Digest[i]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"Should match:\\n\");\n    printf(\"\\t%s\\n\", resultarray[j]);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "    /* Test some error returns */\n    err = SHA1Input(&sha,(const unsigned char *) testarray[1], 1);\n    printf (\"\\nError %d. Should be %d.\\n\", err, shaStateError );\n    err = SHA1Reset(0);\n    printf (\"\\nError %d. Should be %d.\\n\", err, shaNull );\n    return 0;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "zh-CHS": "8. 安全考虑"
    },
    {
      "indent": 3,
      "text": "This document is intended to provide convenient open source access by the Internet community to the United States of America Federal Information Processing Standard Secure Hash Function SHA-1 [FIPS 180-1]. No independent assertion of the security of this hash function by the authors for any particular use is intended.",
      "zh-CHS": "本文件旨在为互联网社区提供方便的开放源码访问美利坚合众国联邦信息处理标准安全哈希函数SHA-1[FIPS 180-1]。作者无意为任何特定用途独立断言此哈希函数的安全性。"
    },
    {
      "indent": 0,
      "text": "References",
      "zh-CHS": "工具书类"
    },
    {
      "indent": 3,
      "text": "[FIPS 180-1] \"Secure Hash Standard\", United States of American, National Institute of Science and Technology, Federal Information Processing Standard (FIPS) 180-1, April 1993.",
      "zh-CHS": "[FIPS 180-1]“安全哈希标准”，美利坚合众国，国家科学技术研究所，联邦信息处理标准（FIPS）180-11993年4月。"
    },
    {
      "indent": 3,
      "text": "[MD4] \"The MD4 Message Digest Algorithm,\" Advances in Cryptology - CRYPTO '90 Proceedings, Springer-Verlag, 1991, pp. 303-311.",
      "zh-CHS": "[MD4]“MD4消息摘要算法”，密码学进展-加密'90会议记录，Springer Verlag，1991年，第303-311页。"
    },
    {
      "indent": 3,
      "text": "[RFC 1320] Rivest, R., \"The MD4 Message-Digest Algorithm\", RFC 1320, April 1992.",
      "zh-CHS": "[RFC 1320]Rivest，R.，“MD4消息摘要算法”，RFC 1320，1992年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC 1321] Rivest, R., \"The MD5 Message-Digest Algorithm\", RFC 1321, April 1992.",
      "zh-CHS": "[RFC 1321]Rivest，R.，“MD5消息摘要算法”，RFC 1321，1992年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC 1750] Eastlake, D., Crocker, S. and J. Schiller, \"Randomness Requirements for Security\", RFC 1750, December 1994.",
      "zh-CHS": "[RFC 1750]Eastlake，D.，Crocker，S.和J.Schiller，“安全的随机性要求”，RFC 1750，1994年12月。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "zh-CHS": "作者地址"
    },
    {
      "indent": 3,
      "text": "Donald E. Eastlake, 3rd Motorola 155 Beaver Street Milford, MA 01757 USA",
      "zh-CHS": "美国马萨诸塞州米尔福德海狸街155号摩托罗拉3号唐纳德E.伊斯特莱克01757"
    },
    {
      "indent": 3,
      "text": "Phone:   +1 508-634-2066 (h)\n         +1 508-261-5434 (w)\nFax:     +1 508-261-4777\nEMail:   Donald.Eastlake@motorola.com",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Paul E. Jones Cisco Systems, Inc. 7025 Kit Creek Road Research Triangle Park, NC 27709 USA",
      "zh-CHS": "Paul E.Jones Cisco Systems，Inc.美国北卡罗来纳州Kit Creek Road研究三角公园7025号，邮编：27709"
    },
    {
      "indent": 3,
      "text": "Phone:   +1 919 392 6948\nEMail:   paulej@packetizer.com",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "zh-CHS": "完整版权声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2001). All Rights Reserved.",
      "zh-CHS": "版权所有（C）互联网协会（2001年）。版权所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "zh-CHS": "本文件及其译本可复制并提供给他人，对其进行评论或解释或协助其实施的衍生作品可全部或部分编制、复制、出版和分发，不受任何限制，前提是上述版权声明和本段包含在所有此类副本和衍生作品中。但是，不得以任何方式修改本文件本身，例如删除版权通知或对互联网协会或其他互联网组织的引用，除非出于制定互联网标准的需要，在这种情况下，必须遵循互联网标准过程中定义的版权程序，或根据需要将其翻译成英语以外的其他语言。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "zh-CHS": "上述授予的有限许可是永久性的，互联网协会或其继承人或受让人不会撤销。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "zh-CHS": "本文件和其中包含的信息是按“原样”提供的，互联网协会和互联网工程任务组否认所有明示或暗示的保证，包括但不限于任何保证，即使用本文中的信息不会侵犯任何权利，或对适销性或特定用途适用性的任何默示保证。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "zh-CHS": "确认"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "zh-CHS": "RFC编辑功能的资金目前由互联网协会提供。"
    }
  ]
}