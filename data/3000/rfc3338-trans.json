{
  "title": {
    "text": "RFC 3338:  Dual Stack Hosts Using \"Bump-in-the-API\" (BIA) ",
    "zh-CHS": "RFC 3338"
  },
  "number": 3338,
  "created_at": "2021-10-26 19:32:34.364143+08:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                             S. Lee\nRequest for Comments: 3338                                     M-K. Shin\nCategory: Experimental                                          Y-J. Kim\n                                                                    ETRI\n                                                             E. Nordmark\n                                                               A. Durand\n                                                        Sun Microsystems\n                                                            October 2002",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 13,
      "text": "Dual Stack Hosts Using \"Bump-in-the-API\" (BIA)",
      "zh-CHS": "使用“API中的通气”（BIA）的双堆栈主机"
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "zh-CHS": "本备忘录的状况"
    },
    {
      "indent": 3,
      "text": "This memo defines an Experimental Protocol for the Internet community. It does not specify an Internet standard of any kind. Discussion and suggestions for improvement are requested. Distribution of this memo is unlimited.",
      "zh-CHS": "这份备忘录为互联网社区定义了一个实验性协议。它没有规定任何类型的互联网标准。要求进行讨论并提出改进建议。本备忘录的分发不受限制。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "zh-CHS": "版权公告"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2002). All Rights Reserved.",
      "zh-CHS": "版权所有（C）互联网协会（2002年）。版权所有。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "zh-CHS": "摘要"
    },
    {
      "indent": 3,
      "text": "This document specifies a mechanism of dual stack hosts using a technique called \"Bump-in-the-API\"(BIA) which allows for the hosts to communicate with other IPv6 hosts using existing IPv4 applications. The goal of this mechanism is the same as that of the Bump-in-the-stack mechanism, but this mechanism provides the translation method between the IPv4 APIs and IPv6 APIs. Thus, the goal is simply achieved without IP header translation.",
      "zh-CHS": "本文档使用一种称为“API中的凹凸”（BIA）的技术指定了双堆栈主机的机制，该技术允许主机使用现有IPv4应用程序与其他IPv6主机通信。该机制的目标与堆栈中的Bump机制的目标相同，但该机制提供了IPv4 API和IPv6 API之间的转换方法。因此，无需IP头转换即可简单实现目标。"
    },
    {
      "indent": 0,
      "text": "Table of Contents:",
      "zh-CHS": "目录："
    },
    {
      "indent": 3,
      "text": "1.  Introduction ................................................  2\n2.  Applicability and Disclaimer ................................  3\n2.1 Applicability ...............................................  3\n2.2 Disclaimer ..................................................  4\n3.  Dual Stack Host Architecture Using BIA ......................  4\n3.1 Function Mapper .............................................  4\n3.2 Name Resolver ...............................................  5\n3.3 Address Mapper ..............................................  5\n4.  Behavior Example ............................................  6\n4.1 Originator Behavior .........................................  6\n4.2 Recipient Behavior ..........................................  8\n5.  Considerations  ............................................. 10\n5.1 Socket API Conversion ....................................... 10\n5.2 ICMP Messages Handling ...................................... 10\n5.3 IPv4 Address Pool and Mapping Table ......................... 10\n5.4 Internally Assigned IPv4 Addresses .......................... 10\n5.5 Mismatch Between DNS Result and Peer Application Version .... 11\n5.6 Implementation Issues ....................................... 11\n6.  Limitations ................................................. 12\n7.  Security Considerations ..................................... 12\n8.  Acknowledgments ............................................. 12\n9.  References .................................................. 12\nAppendix:  API list intercepted by BIA .......................... 14\nAuthors Addresses ............................................... 16\nFull Copyright Statement ........................................ 17",
      "raw": true,
      "toc": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "zh-CHS": "1. 介绍"
    },
    {
      "indent": 3,
      "text": "RFC2767 [BIS] specifies a host translation mechanism using a technique called \"Bump-in-the-Stack\". It translates IPv4 into IPv6, and vice versa using the IP conversion mechanism defined in [SIIT]. BIS allows hosts to communicate with other IPv6 hosts using existing IPv4 applications. However, this approach is to use an API translator which is inserted between the TCP/IP module and network card driver, so that it has the same limitations as the [SIIT] based IP header translation methods. In addition, its implementation is dependent upon the network interface driver.",
      "zh-CHS": "RFC2767[BIS]使用称为“堆栈中的凹凸”的技术指定主机转换机制。它使用[SIIT]中定义的IP转换机制将IPv4转换为IPv6，反之亦然。BIS允许主机使用现有IPv4应用程序与其他IPv6主机通信。然而，这种方法是使用插入TCP/IP模块和网卡驱动程序之间的API转换器，因此它与基于[SIIT]的IP头转换方法具有相同的限制。此外，它的实现依赖于网络接口驱动程序。"
    },
    {
      "indent": 3,
      "text": "This document specifies a new mechanism of dual stack hosts called Bump-in-the-API(BIA) technique. The BIA technique inserts an API translator between the socket API module and the TCP/IP module in the dual stack hosts, so that it translates the IPv4 socket API function into IPv6 socket API function and vice versa. With this mechanism, the translation can be simplified without IP header translation.",
      "zh-CHS": "本文档指定了一种新的双堆栈主机机制，称为API（BIA）技术中的Bump。BIA技术在双堆栈主机中的套接字API模块和TCP/IP模块之间插入API转换器，以便将IPv4套接字API函数转换为IPv6套接字API函数，反之亦然。通过这种机制，可以简化翻译而无需IP头翻译。"
    },
    {
      "indent": 3,
      "text": "Using BIA, the dual stack host assumes that there exists both TCP(UDP)/IPv4 and TCP(UDP)/IPv6 stacks on the local node.",
      "zh-CHS": "使用BIA，双堆栈主机假定本地节点上同时存在TCP（UDP）/IPv4和TCP（UDP）/IPv6堆栈。"
    },
    {
      "indent": 3,
      "text": "When IPv4 applications on the dual stack communicate with other IPv6 hosts, the API translator detects the socket API functions from IPv4 applications and invokes the IPv6 socket API functions to communicate with the IPv6 hosts, and vice versa. In order to support communication between IPv4 applications and the target IPv6 hosts, pooled IPv4 addresses will be assigned through the name resolver in the API translator.",
      "zh-CHS": "当双堆栈上的IPv4应用程序与其他IPv6主机通信时，API转换器检测来自IPv4应用程序的套接字API函数，并调用IPv6套接字API函数与IPv6主机通信，反之亦然。为了支持IPv4应用程序和目标IPv6主机之间的通信，将通过API转换器中的名称解析程序分配池IPv4地址。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC 2119].",
      "zh-CHS": "本文件中的关键词“必须”、“不得”、“要求”、“应”、“不应”、“应”、“不应”、“建议”、“可”和“可选”应按照[RFC 2119]中所述进行解释。"
    },
    {
      "indent": 3,
      "text": "This document uses terms defined in [IPv6],[TRANS-MECH] and [BIS].",
      "zh-CHS": "本文件使用[IPv6]、[TRANS-MECH]和[BIS]中定义的术语。"
    },
    {
      "indent": 0,
      "text": "2. Applicability and Disclaimer",
      "section_title": true,
      "zh-CHS": "2. 适用性和免责声明"
    },
    {
      "indent": 0,
      "text": "2.1 Applicability",
      "section_title": true,
      "zh-CHS": "2.1 适用性"
    },
    {
      "indent": 3,
      "text": "The main purposes of BIA are the same as BIS [BIS]. It makes IPv4 applications communicate with IPv6 hosts without any modification of those IPv4 applications. However, while BIS is for systems with no IPv6 stack, BIA is for systems with an IPv6 stack, but on which some applications are not yet available on IPv6 and source code is not available preventing the application from being ported. It's good for early adopters who do not have all applications handy, but not for mainstream production usage.",
      "zh-CHS": "BIA的主要目的与BIS[BIS]相同。它使IPv4应用程序与IPv6主机通信，而无需对这些IPv4应用程序进行任何修改。但是，虽然BIS适用于没有IPv6堆栈的系统，但BIA适用于具有IPv6堆栈的系统，但其中一些应用程序在IPv6上尚不可用，并且源代码不可用，因此无法移植应用程序。这对那些没有所有应用程序可用的早期采用者来说是很好的，但对于主流生产使用来说却不是这样。"
    },
    {
      "indent": 3,
      "text": "There is an issue about a client node running BIA trying to contact a dual stack node on a port number that is only associated with an IPv4 application (see section 5.5). There are 2 approaches.",
      "zh-CHS": "运行BIA的客户端节点试图联系仅与IPv4应用程序关联的端口号上的双堆栈节点时出现问题（请参阅第5.5节）。有两种方法。"
    },
    {
      "indent": 3,
      "text": "- The client application SHOULD cycle through all the addresses and end up trying the IPv4 one.",
      "zh-CHS": "- 客户端应用程序应循环遍历所有地址，并最终尝试IPv4地址。"
    },
    {
      "indent": 3,
      "text": "- BIA SHOULD do the work.",
      "zh-CHS": "- BIA应该做这项工作。"
    },
    {
      "indent": 3,
      "text": "It is not clear at this time which behavior is desirable (it may very well be application dependent), so we need to get feedback from experimentation.",
      "zh-CHS": "目前还不清楚哪种行为是可取的（它很可能依赖于应用程序），因此我们需要从实验中获得反馈。"
    },
    {
      "indent": 0,
      "text": "2.2 Disclaimer",
      "section_title": true,
      "zh-CHS": "2.2 免责声明"
    },
    {
      "indent": 3,
      "text": "BIA SHOULD NOT be used for an IPv4 application for which source code is available. We strongly recommend that application programmers SHOULD NOT use this mechanism when application source code is available. As well, it SHOULD NOT be used as an excuse not to port software or delay porting.",
      "zh-CHS": "BIA不应用于源代码可用的IPv4应用程序。当应用程序源代码可用时，我们强烈建议应用程序程序员不要使用此机制。同样，它不应该被用作不移植软件或延迟移植的借口。"
    },
    {
      "indent": 0,
      "text": "3. Dual Stack Host Architecture Using BIA",
      "section_title": true,
      "zh-CHS": "3. 使用BIA的双栈主机体系结构"
    },
    {
      "indent": 3,
      "text": "Figure 1 shows the architecture of the host in which BIA is installed.",
      "zh-CHS": "图1显示了安装BIA的主机的体系结构。"
    },
    {
      "indent": 15,
      "text": "+----------------------------------------------+\n| +------------------------------------------+ |\n| |                                          | |\n| |             IPv4 applications            | |\n| |                                          | |\n| +------------------------------------------+ |\n| +------------------------------------------+ |\n| |           Socket API (IPv4, IPv6)        | |\n| +------------------------------------------+ |\n| +-[ API translator]------------------------+ |\n| | +-----------+ +---------+ +------------+ | |\n| | | Name      | | Address | | Function   | | |\n| | | Resolver  | | Mapper  | | Mapper     | | |\n| | +-----------+ +---------+ +------------+ | |\n| +------------------------------------------+ |\n| +--------------------+ +-------------------+ |\n| |                    | |                   | |\n| |    TCP(UDP)/IPv4   | |   TCP(UDP)/IPv6   | |\n| |                    | |                   | |\n| +--------------------+ +-------------------+ |\n+----------------------------------------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 12,
      "text": "Figure 1 Architecture of the dual stack host using BIA",
      "zh-CHS": "图1使用BIA的双堆栈主机的体系结构"
    },
    {
      "indent": 3,
      "text": "Dual stack hosts defined in RFC2893 [TRANS-MECH] need applications, TCP/IP modules and addresses for both IPv4 and IPv6. The proposed hosts in this document have an API translator to communicate with other IPv6 hosts using existing IPv4 applications. The API translator consists of 3 modules, a name resolver, an address mapper and a function mapper.",
      "zh-CHS": "RFC2893[TRANS-MECH]中定义的双栈主机需要IPv4和IPv6的应用程序、TCP/IP模块和地址。本文档中建议的主机具有API转换器，可使用现有IPv4应用程序与其他IPv6主机通信。API转换器由3个模块组成，一个名称解析器、一个地址映射器和一个函数映射器。"
    },
    {
      "indent": 0,
      "text": "3.1 Function Mapper",
      "section_title": true,
      "zh-CHS": "3.1 函数映射器"
    },
    {
      "indent": 3,
      "text": "It translates an IPv4 socket API function into an IPv6 socket API function, and vice versa.",
      "zh-CHS": "它将IPv4套接字API函数转换为IPv6套接字API函数，反之亦然。"
    },
    {
      "indent": 3,
      "text": "When detecting the IPv4 socket API functions from IPv4 applications, it intercepts the function call and invokes new IPv6 socket API functions which correspond to the IPv4 socket API functions. Those IPv6 API functions are used to communicate with the target IPv6 hosts. When detecting the IPv6 socket API functions from the data received from the IPv6 hosts, it works symmetrically in relation to the previous case.",
      "zh-CHS": "当从IPv4应用程序检测IPv4套接字API函数时，它会拦截函数调用并调用与IPv4套接字API函数相对应的新IPv6套接字API函数。这些IPv6 API函数用于与目标IPv6主机通信。当从IPv6主机接收的数据检测IPv6套接字API函数时，它的工作方式与前一种情况对称。"
    },
    {
      "indent": 0,
      "text": "3.2 Name Resolver",
      "section_title": true,
      "zh-CHS": "3.2 名称解析程序"
    },
    {
      "indent": 3,
      "text": "It returns a proper answer in response to the IPv4 application's request.",
      "zh-CHS": "它返回正确答案以响应IPv4应用程序的请求。"
    },
    {
      "indent": 3,
      "text": "When an IPv4 application tries to resolve names via the resolver library (e.g. gethostbyname()), BIA intercept the function call and instead call the IPv6 equivalent functions (e.g. getnameinfo()) that will resolve both A and AAAA records.",
      "zh-CHS": "当IPv4应用程序尝试通过解析程序库解析名称（例如gethostbyname（））时，BIA会截获函数调用，转而调用将解析A和AAAA记录的IPv6等效函数（例如getnameinfo（））。"
    },
    {
      "indent": 3,
      "text": "If the AAAA record is available, it requests the address mapper to assign an IPv4 address corresponding to the IPv6 address, then creates the A record for the assigned IPv4 address, and returns the A record to the application.",
      "zh-CHS": "如果AAAA记录可用，它会请求地址映射器分配与IPv6地址对应的IPv4地址，然后为分配的IPv4地址创建A记录，并将A记录返回给应用程序。"
    },
    {
      "indent": 0,
      "text": "3.3 Address Mapper",
      "section_title": true,
      "zh-CHS": "3.3 地址映射器"
    },
    {
      "indent": 3,
      "text": "It internally maintains a table of the pairs of an IPv4 address and an IPv6 address. The IPv4 addresses are assigned from an IPv4 address pool. It uses the unassigned IPv4 addresses (e.g., 0.0.0.1 ~ 0.0.0.255).",
      "zh-CHS": "它在内部维护IPv4地址和IPv6地址对的表。IPv4地址是从IPv4地址池分配的。它使用未分配的IPv4地址（例如，0.0.0.1~0.0.0.255）。"
    },
    {
      "indent": 3,
      "text": "When the name resolver or the function mapper requests it to assign an IPv4 address corresponding to an IPv6 address, it selects and returns an IPv4 address out of the pool, and registers a new entry into the table dynamically. The registration occurs in the following 2 cases:",
      "zh-CHS": "当名称解析程序或函数映射程序请求它分配与IPv6地址对应的IPv4地址时，它会从池中选择并返回一个IPv4地址，并在表中动态注册一个新条目。在以下两种情况下进行注册："
    },
    {
      "indent": 3,
      "text": "(1) When the name resolver gets only an 'AAAA' record for the target host name and there is not a mapping entry for the IPv6 address.",
      "zh-CHS": "(1) 当名称解析程序仅获取目标主机名的“AAAA”记录，并且没有IPv6地址的映射条目时。"
    },
    {
      "indent": 3,
      "text": "(2) When the function mapper gets a socket API function call from the data received and there is not a mapping entry for the IPv6 source address.",
      "zh-CHS": "(2) 当函数映射器从接收到的数据中获取套接字API函数调用，并且没有IPv6源地址的映射条目时。"
    },
    {
      "indent": 3,
      "text": "NOTE: This is the same as that of the Address Mapper in [BIS].",
      "zh-CHS": "注意：这与[BIS]中的地址映射器相同。"
    },
    {
      "indent": 0,
      "text": "4. Behavior Examples",
      "section_title": true,
      "zh-CHS": "4. 行为示例"
    },
    {
      "indent": 3,
      "text": "This section describes behaviors of the proposed dual stack host called \"dual stack\", which communicates with an IPv6 host called \"host6\" using an IPv4 application.",
      "zh-CHS": "本节描述了建议的名为“双堆栈”的双堆栈主机的行为，该主机使用IPv4应用程序与名为“host6”的IPv6主机进行通信。"
    },
    {
      "indent": 3,
      "text": "In this section, the meanings of arrows are as follows:",
      "zh-CHS": "在本节中，箭头的含义如下："
    },
    {
      "indent": 7,
      "text": "---> A DNS message for name resolving created by the applications\n     and the name resolver in the API translator.\n+++> An IPv4 address request to and reply from the address mapper\n     for the name resolver and the function mapper.\n===> Data flow by socket API functions created by the\n     applications and the function mapper in the API translator.",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "4.1 Originator Behavior",
      "section_title": true,
      "zh-CHS": "4.1 发起人行为"
    },
    {
      "indent": 3,
      "text": "This sub-section describes the behavior when the \"dual stack\" sends data to \"host6\".",
      "zh-CHS": "本小节描述“双堆栈”向“主机6”发送数据时的行为。"
    },
    {
      "indent": 3,
      "text": "When an IPv4 application sends a DNS query to its name server, the name resolver intercepts the query and then creates a new query to resolve both A and AAAA records. When only the AAAA record is resolved, the name resolver requests the address mapper to assign an IPv4 address corresponding to the IPv6 address.",
      "zh-CHS": "当IPv4应用程序向其名称服务器发送DNS查询时，名称解析程序将拦截该查询，然后创建新查询以解析a和AAAA记录。当仅解析AAAA记录时，名称解析程序请求地址映射程序分配与IPv6地址对应的IPv4地址。"
    },
    {
      "indent": 3,
      "text": "The name resolver creates an A record for the assigned IPv4 address and returns it to the IPv4 applications.",
      "zh-CHS": "名称解析程序为分配的IPv4地址创建A记录，并将其返回给IPv4应用程序。"
    },
    {
      "indent": 3,
      "text": "In order for the IPv4 application to send IPv4 packets to host6, it calls the IPv4 socket API function.",
      "zh-CHS": "为了让IPv4应用程序向host6发送IPv4数据包，它调用IPv4套接字API函数。"
    },
    {
      "indent": 3,
      "text": "The function mapper detects the socket API function from the application. If the result is from IPv6 applications, it skips the translation. In the case of IPv4 applications, it requires an IPv6 address to invoke the IPv6 socket API function, thus the function mapper requests an IPv6 address to the address mapper. The address mapper selects an IPv4 address from the table and returns the destination IPv6 address. Using this IPv6 address, the function mapper invokes an IPv6 socket API function corresponding to the IPv4 socket API function.",
      "zh-CHS": "函数映射器从应用程序检测套接字API函数。如果结果来自IPv6应用程序，它将跳过转换。对于IPv4应用程序，它需要IPv6地址来调用IPv6套接字API函数，因此函数映射器向地址映射器请求IPv6地址。地址映射器从表中选择IPv4地址并返回目标IPv6地址。使用此IPv6地址，函数映射器调用与IPv4套接字API函数对应的IPv6套接字API函数。"
    },
    {
      "indent": 3,
      "text": "When the function mapper receives an IPv6 function call,it requests the IPv4 address to the address mapper in order to translate the IPv6 socket API function into an IPv4 socket API function. Then, the function mapper invokes the socket API function for the IPv4 applications.",
      "zh-CHS": "当函数映射器接收到IPv6函数调用时，它向地址映射器请求IPv4地址，以便将IPv6套接字API函数转换为IPv4套接字API函数。然后，函数映射器调用IPv4应用程序的套接字API函数。"
    },
    {
      "indent": 3,
      "text": "Figure 2 illustrates the behavior described above:",
      "zh-CHS": "图2说明了上述行为："
    },
    {
      "indent": 0,
      "text": "\"dual stack\"                                                \"host6\"\nIPv4    Socket |     [ API Translator ]    | TCP(UDP)/IP          Name\nappli-  API    |Name      Address  Function| (v6/v4)             Server\ncation         |Resolver  Mapper   Mapper  |\n |        |        |        |        |         |              |       |\n<<Resolve an IPv4 address for \"host6\".>>       |              |       |\n |        |        |        |        |         |              |       |\n |--------|------->|  Query of 'A' records for host6.         |       |\n |        |        |        |        |         |              |       |\n |        |        |--------|--------|---------|--------------|------>|\n |        |        |  Query of 'A' records and 'AAAA' for host6       |\n |        |        |        |        |         |              |       |\n |        |        |<-------|--------|---------|--------------|-------|\n |        |        |  Reply with the 'AAAA' record.           |       |\n |        |        |        |        |         |              |\n |        |        |<<The 'AAAA' record is resolved.>>        |\n |        |        |        |        |         |              |\n |        |        |+++++++>|  Request one IPv4 address       |\n |        |        |        |  corresponding to the IPv6 address.\n |        |        |        |        |         |              |\n |        |        |        |<<Assign one IPv4 address.>>     |\n |        |        |        |        |         |              |\n |        |        |<+++++++|  Reply with the IPv4 address.   |\n |        |        |        |        |         |              |\n |        |        |<<Create 'A' record for the IPv4 address.>>\n |        |        |        |        |         |              |\n |<-------|--------| Reply with the 'A' record.|              |\n |        |        |        |        |         |              |",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 14,
      "text": "Figure 2 Behavior of the originator (1/2)",
      "zh-CHS": "图2发起人的行为（1/2）"
    },
    {
      "indent": 0,
      "text": "\"dual stack\"                                               \"host6\"\nIPv4    Socket |     [ API Translator ]    | TCP(UDP)/IP\nappli-  API    |Name      Address  Function| (v6/v4)\ncation         |Resolver  Mapper   Mapper  |\n |        |        |        |        |         |              |\n<<Call IPv4 Socket API function >>   |         |              |\n |        |        |        |        |         |              |\n |========|========|========|=======>|An IPv4 Socket API function Call\n |        |        |        |        |         |              |\n |        |        |        |<+++++++|  Request IPv6 addresses|\n |        |        |        |        |  corresponding to the  |\n |        |        |        |        |  IPv4 addresses.       |\n |        |        |        |        |         |              |\n |        |        |        |+++++++>| Reply with the IPv6 addresses.\n |        |        |        |        |         |              |\n |        |        |        |        |<<Translate IPv4 into IPv6.>>\n |        |        |        |        |         |              |\n |  An IPv6 Socket API function call.|=========|=============>|\n |        |        |        |        |         |              |\n |        |        |        |        |<<Reply an IPv6 data    |\n |        |        |        |        |  to dual stack.>>      |\n |        |        |        |        |         |              |\n |  An IPv6 Socket API function call.|<========|==============|\n |        |        |        |        |         |              |\n |        |        |        |        |<<Translate IPv6 into IPv4.>>\n |        |        |        |        |         |              |\n |        |        |        |<+++++++|  Request IPv4 addresses|\n |        |        |        |        |  corresponding to the  |\n |        |        |        |        |  IPv6 addresses.       |\n |        |        |        |        |         |              |\n |        |        |        |+++++++>| Reply with the IPv4 addresses.\n |        |        |        |        |         |              |\n |<=======|========|========|========|  An IPv4 Socket function call.\n |        |        |        |        |         |              |",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 14,
      "text": "Figure 2 Behavior of the originator (2/2)",
      "zh-CHS": "图2发起人的行为（2/2）"
    },
    {
      "indent": 0,
      "text": "4.2 Recipient Behavior",
      "section_title": true,
      "zh-CHS": "4.2 接受者行为"
    },
    {
      "indent": 3,
      "text": "This subsection describes the recipient behavior of \"dual stack\". The communication is triggered by \"host6\".",
      "zh-CHS": "本小节描述“双堆栈”的接收方行为。通信由“主机6”触发。"
    },
    {
      "indent": 3,
      "text": "\"host6\" resolves the address of \"dual stack\" with 'AAAA' records through its name server, and then sends an IPv6 packet to the \"dual stack\".",
      "zh-CHS": "“host6”通过其名称服务器解析“双堆栈”的地址和“AAAA”记录，然后向“双堆栈”发送IPv6数据包。"
    },
    {
      "indent": 3,
      "text": "The IPv6 packet reaches the \"dual stack\" and the function mapper detects it.",
      "zh-CHS": "IPv6数据包到达“双堆栈”，函数映射器检测到它。"
    },
    {
      "indent": 3,
      "text": "The function mapper requests the IPv4 address to the address mapper in order to invoke the IPv4 socket API function to communicate with the IPv4 application. Then the function mapper invokes the corresponding IPv4 socket API function for the IPv4 applications corresponding to the IPv6 functions.",
      "zh-CHS": "函数映射器向地址映射器请求IPv4地址，以便调用IPv4套接字API函数与IPv4应用程序通信。然后，函数映射器为与IPv6函数对应的IPv4应用程序调用相应的IPv4套接字API函数。"
    },
    {
      "indent": 3,
      "text": "Figure 3 illustrates the behavior described above:",
      "zh-CHS": "图3说明了上述行为："
    },
    {
      "indent": 3,
      "text": "\"dual stack\"                                               \"host6\"\nIPv4    Socket |     [ API Translator ]    | TCP(UDP)/IP\nappli-  API    |Name      Address  Function| (v6/v4)\ncation         |Resolver  Mapper   Mapper  |\n |        |        |        |        |         |              |\n<<Receive data from \"host6\".>>       |         |              |\n |        |        |        |        |         |              |\n |      An IPv6 Socket function call.|<========|==============|\n |        |        |        |        |         |              |\n |        |        |        |<+++++++|  Request IPv4 addresses|\n |        |        |        |        |  corresponding to the IPv6\n |        |        |        |        |  addresses.            |\n |        |        |        |        |         |              |\n |        |        |        |+++++++>| Reply with the IPv4 addresses.\n |        |        |        |        |         |              |\n |        |        |        |        |<<Translate IPv6 into IPv4.>>\n |        |        |        |        |         |              |\n |<=======|========|========|========|  An IPv4 function call |\n |        |        |        |        |         |              |\n<<Reply an IPv4 data to \"host6\".>>   |         |              |\n |        |        |        |        |         |              |\n |========|========|========|=======>|  An IPv4 function call |\n |        |        |        |        |         |              |\n |        |        |        |        |<<Translate IPv4 into IPv6.>>\n |        |        |        |        |         |              |\n |        |        |        |<+++++++|  Request IPv6 addresses|\n |        |        |        |        |  corresponding to the IPv4\n |        |        |        |        |  addresses.            |\n |        |        |        |        |         |              |\n |        |        |        |+++++++>| Reply with the IPv6 addresses.\n |        |        |        |        |         |              |\n |      An IPv6 Socket function call.|=========|=============>|\n |        |        |        |        |         |              |",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 13,
      "text": "Figure 3 Behavior of Receiving data from IPv6 host",
      "zh-CHS": "图3从IPv6主机接收数据的行为"
    },
    {
      "indent": 0,
      "text": "5. Considerations",
      "section_title": true,
      "zh-CHS": "5. 考虑"
    },
    {
      "indent": 0,
      "text": "5.1 Socket API Conversion",
      "section_title": true,
      "zh-CHS": "5.1 套接字API转换"
    },
    {
      "indent": 3,
      "text": "IPv4 socket API functions are translated into semantically the same IPv6 socket API functions and vice versa. See Appendix A for the API list intercepted by BIA. IP addresses embedded in application layer protocols (e.g., FTP) can be translated in API functions. Its implementation depends on operating systems.",
      "zh-CHS": "IPv4套接字API函数被转换为语义相同的IPv6套接字API函数，反之亦然。BIA截获的API清单见附录A。嵌入在应用层协议（如FTP）中的IP地址可以转换为API函数。它的实现依赖于操作系统。"
    },
    {
      "indent": 3,
      "text": "NOTE: Basically, IPv4 socket API functions are not fully compatible with IPv6 since the IPv6 has new advanced features.",
      "zh-CHS": "注意：基本上，IPv4套接字API函数与IPv6不完全兼容，因为IPv6具有新的高级功能。"
    },
    {
      "indent": 0,
      "text": "5.2 ICMP Message Handling",
      "section_title": true,
      "zh-CHS": "5.2 ICMP消息处理"
    },
    {
      "indent": 3,
      "text": "When an application needs ICMP messages values (e.g., Type, Code, etc.) sent from a network layer, ICMPv4 message values MAY be translated into ICMPv6 message values based on [SIIT], and vice versa. It can be implemented using raw socket.",
      "zh-CHS": "当应用程序需要从网络层发送ICMP消息值（例如，类型、代码等）时，ICMPv4消息值可以基于[SIIT]转换为ICMPv6消息值，反之亦然。它可以使用原始套接字实现。"
    },
    {
      "indent": 0,
      "text": "5.3 IPv4 Address Pool and Mapping Table",
      "section_title": true,
      "zh-CHS": "5.3 IPv4地址池和映射表"
    },
    {
      "indent": 3,
      "text": "The address pool consists of the unassigned IPv4 addresses. This pool can be implemented at different granularity in the node e.g., a single pool per node, or at some finer granularity such as per user or per process. However, if a number of IPv4 applications communicate with IPv6 hosts, the available address spaces will be exhausted. As a result, it will be impossible for IPv4 applications to communicate with IPv6 nodes. It requires smart management techniques for address pool. For example, it is desirable for the mapper to free the oldest entry and reuse the IPv4 address for creating a new entry. This issues is the same as [BIS]. In case of a per-node address mapping table, it MAY cause a larger risk of running out of address.",
      "zh-CHS": "地址池由未分配的IPv4地址组成。该池可以在节点中以不同的粒度实现，例如，每个节点一个池，或者以更精细的粒度实现，例如每个用户或每个进程。但是，如果许多IPv4应用程序与IPv6主机通信，则可用的地址空间将耗尽。因此，IPv4应用程序将无法与IPv6节点通信。它需要地址池的智能管理技术。例如，映射程序希望释放最旧的条目并重用IPv4地址来创建新条目。这一问题与[之二]相同。在每个节点地址映射表的情况下，它可能会导致地址不足的更大风险。"
    },
    {
      "indent": 0,
      "text": "5.4 Internally Assigned IPv4 Addresses",
      "section_title": true,
      "zh-CHS": "5.4 内部分配的IPv4地址"
    },
    {
      "indent": 3,
      "text": "The IPv4 addresses, which are internally assigned to IPv6 target hosts out of the pool, are the unassigned IPv4 addresses (e.g., 0.0.0.1 ~ 0.0.0.255). There is no potential collision with another use of the private address space when the IPv4 address flows out from the host.",
      "zh-CHS": "内部分配给池外IPv6目标主机的IPv4地址是未分配的IPv4地址（例如，0.0.0.1~0.0.0.255）。当IPv4地址从主机流出时，不会与私有地址空间的另一次使用发生潜在冲突。"
    },
    {
      "indent": 0,
      "text": "5.5 Mismatch between DNS result(AAAA) and Peer Application Version(v4)",
      "zh-CHS": "5.5 DNS结果（AAAA）和对等应用程序版本（v4）之间不匹配"
    },
    {
      "indent": 3,
      "text": "If a server application you are using does not support IPv6 yet, but runs on a machine that supports other IPv6 services and this is listed with a AAAA record in the DNS, a client IPv4 application using BIA might fail to connect to the server application, because there is a mismatch between DNS query result (i.e., AAAA) and a server application version(i.e., IPv4). A solution is to try all the addresses listed in the DNS and just not fail after the first attempt. We have two approaches: the client application itself SHOULD cycle through all the addresses and end up trying the IPv4 one. Or it SHOULD be done by some extensions of name resolver and API translator in BIA. For this, BIA SHOULD do iterated jobs for finding the working address used by the other application out of addresses returned by the extended name resolver. It may very well be application dependent. Note that BIA might be able to do the iteraction over all addresses for TCP sockets, since BIA can observe when the connect call fails. But for UDP sockets it is hard if not impossible for BIA to know which address worked, hence the application must do the iteraction over all addresses until it finds a working address.",
      "zh-CHS": "如果您正在使用的服务器应用程序尚不支持IPv6，但在支持其他IPv6服务的计算机上运行，并且此服务器应用程序在DNS中与AAAA记录一起列出，则使用BIA的客户端IPv4应用程序可能无法连接到服务器应用程序，因为DNS查询结果（即AAAA）之间不匹配以及服务器应用程序版本（即IPv4）。解决方案是尝试DNS中列出的所有地址，并且在第一次尝试后不会失败。我们有两种方法：客户端应用程序本身应该循环遍历所有地址，并最终尝试IPv4地址。或者它应该由BIA中名称解析器和API转换器的一些扩展来完成。为此，BIA应该执行迭代作业，从扩展名称解析器返回的地址中查找其他应用程序使用的工作地址。它很可能依赖于应用程序。请注意，BIA可能能够对TCP套接字的所有地址执行iTreaction，因为BIA可以在连接调用失败时进行观察。但是对于UDP套接字，BIA很难（如果不是不可能的话）知道哪个地址工作，因此应用程序必须对所有地址执行ITE操作，直到找到一个工作地址。"
    },
    {
      "indent": 3,
      "text": "Another way to avoid this type of problems is to make BIA only come into effect when no A records exist for the peer. Thus traffic from an application using BIA on a dual-stack host to a dual-stack host would use IPv4.",
      "zh-CHS": "避免此类问题的另一种方法是使BIA仅在对等方不存在A记录时生效。因此，从双堆栈主机上使用BIA的应用程序到双堆栈主机的流量将使用IPv4。"
    },
    {
      "indent": 0,
      "text": "5.6 Implementation Issues",
      "section_title": true,
      "zh-CHS": "5.6 执行问题"
    },
    {
      "indent": 3,
      "text": "Some operating systems support the preload library functions, so it is easy to implement the API translator by using it. For example, the user can replace all existing socket API functions with user-defined socket API functions which translate the socket API function. In this case, every IPv4 application has its own translation library using a preloaded library which will be bound into the application before executing it dynamically.",
      "zh-CHS": "一些操作系统支持预加载库函数，因此使用它可以很容易地实现API转换器。例如，用户可以用转换套接字API函数的用户定义的套接字API函数替换所有现有的套接字API函数。在这种情况下，每个IPv4应用程序都有自己的翻译库，使用预加载的库，该库将在动态执行应用程序之前绑定到应用程序中。"
    },
    {
      "indent": 3,
      "text": "Some other operating systems support the user-defined layered protocol allowing a user to develop some additional protocols and put them in the existing protocol stack. In this case, the API translator can be implemented as a layered protocol module.",
      "zh-CHS": "其他一些操作系统支持用户定义的分层协议，允许用户开发一些附加协议并将它们放入现有协议栈中。在这种情况下，API转换器可以实现为分层协议模块。"
    },
    {
      "indent": 3,
      "text": "In the above two approaches, it is assumed that there exists both TCP(UDP)/IPv4 and TCP(UDP)/IPv6 stacks and there is no need to modify or to add a new TCP-UDP/IPv6 stack.",
      "zh-CHS": "在上述两种方法中，假设存在TCP（UDP）/IPv4和TCP（UDP）/IPv6堆栈，并且不需要修改或添加新的TCP-UDP/IPv6堆栈。"
    },
    {
      "indent": 0,
      "text": "6. Limitations",
      "section_title": true,
      "zh-CHS": "6. 局限性"
    },
    {
      "indent": 3,
      "text": "In common with [NAT-PT], BIA needs to translate IP addresses embedded in application layer protocols, e.g., FTP. So it may not work for new applications which embed addresses in payloads.",
      "zh-CHS": "与[NAT-PT]一样，BIA需要翻译嵌入在应用层协议（如FTP）中的IP地址。因此，它可能不适用于在有效负载中嵌入地址的新应用程序。"
    },
    {
      "indent": 3,
      "text": "This mechanism supports unicast communications only. In order to support multicast functions, some other additional functionalities must be considered in the function mapper module.",
      "zh-CHS": "此机制仅支持单播通信。为了支持多播功能，必须在函数映射器模块中考虑一些其他附加功能。"
    },
    {
      "indent": 3,
      "text": "Since the IPv6 API has new advanced features, it is difficult to translate such kinds of IPv6 APIs into IPv4 APIs. Thus, IPv6 inbound communication with advanced features may be discarded.",
      "zh-CHS": "由于IPv6 API具有新的高级功能，因此很难将此类IPv6 API转换为IPv4 API。因此，具有高级功能的IPv6入站通信可能会被丢弃。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "zh-CHS": "7. 安全考虑"
    },
    {
      "indent": 3,
      "text": "The security consideration of BIA mostly relies on that of [NAT-PT]. The differences are due to the address translation occurring at the API and not in the network layer. That is, since the mechanism uses the API translator at the socket API level, hosts can utilize the security of the network layer (e.g., IPsec) when they communicate with IPv6 hosts using IPv4 applications via the mechanism. As well, there isn't a DNS ALG as in NAT-PT, so there is no interference with DNSSEC.",
      "zh-CHS": "BIA的安全考虑主要依赖于[NAT-PT]的安全考虑。这些差异是由于地址转换发生在API而不是网络层。也就是说，由于该机制在套接字API级别使用API转换器，因此当主机通过该机制使用IPv4应用程序与IPv6主机通信时，可以利用网络层（例如IPsec）的安全性。此外，NAT-PT中没有DNS ALG，因此不会干扰DNSSEC。"
    },
    {
      "indent": 3,
      "text": "The use of address pooling may open a denial of service attack vulnerability. So BIA should employ the same sort of protection techniques as [NAT-PT] does.",
      "zh-CHS": "使用地址池可能会打开拒绝服务攻击漏洞。因此，BIA应采用与[NAT-PT]相同的保护技术。"
    },
    {
      "indent": 0,
      "text": "8. Acknowledgments",
      "section_title": true,
      "zh-CHS": "8. 致谢"
    },
    {
      "indent": 3,
      "text": "We would like to acknowledge the implementation contributions by Wanjik Lee (wjlee@arang.miryang.ac.kr) and i2soft Corporation (www.i2soft.net).",
      "zh-CHS": "我们要感谢Wanjik Lee的实施贡献(wjlee@arang.miryang.ac.kr)和i2soft公司（www.i2soft.net）。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "zh-CHS": "9. 工具书类"
    },
    {
      "indent": 3,
      "text": "[TRANS-MECH] Gilligan, R. and E. Nordmark, \"Transition Mechanisms for IPv6 Hosts and Routers\", RFC 2893, August 2000.",
      "zh-CHS": "[TRANS-MECH]Gilligan，R.和E.Nordmark，“IPv6主机和路由器的过渡机制”，RFC 2893，2000年8月。"
    },
    {
      "indent": 3,
      "text": "[SIIT] Nordmark, E., \"Stateless IP/ICMP Translator (SIIT)\", RFC 2765, February 2000.",
      "zh-CHS": "[SIIT]Nordmark，E.“无状态IP/ICMP转换器（SIIT）”，RFC 27652000年2月。"
    },
    {
      "indent": 3,
      "text": "[FTP] Postel, J. and J. Reynolds, \"File Transfer Protocol\", STD 9, RFC 959, October 1985.",
      "zh-CHS": "[FTP]Postel，J.和J.Reynolds，“文件传输协议”，STD 9，RFC 959，1985年10月。"
    },
    {
      "indent": 3,
      "text": "[NAT] Srisuresh, P. and K. Egevang, \"Traditional IP Network Address Translator (Traditional NAT)\", RFC 3022, January 2001.",
      "zh-CHS": "[NAT]Srisuresh，P.和K.Egevang，“传统IP网络地址转换器（传统NAT）”，RFC 30222001年1月。"
    },
    {
      "indent": 3,
      "text": "[IPV4] Postel, J., \"Internet Protocol\", STD 5, RFC 791, September 1981.",
      "zh-CHS": "[IPV4]Postel，J.，“互联网协议”，STD 5，RFC 7911981年9月。"
    },
    {
      "indent": 3,
      "text": "[IPV6] Deering, S. and R. Hinden, \"Internet Protocol, Version 6 (IPv6) Specification\", RFC 2460, December 1998.",
      "zh-CHS": "[IPV6]Deering，S.和R.Hinden，“互联网协议，第6版（IPV6）规范”，RFC 2460，1998年12月。"
    },
    {
      "indent": 3,
      "text": "[NAT-PT] Tsirtsis, G. and P. Srisuresh, \"Network Address Translation - Protocol Translation (NAT-PT)\", RFC 2766, February 2000.",
      "zh-CHS": "[NAT-PT]Tsirtsis，G.和P.Srisuresh，“网络地址转换-协议转换（NAT-PT）”，RFC 2766，2000年2月。"
    },
    {
      "indent": 3,
      "text": "[BIS] Tsuchiya, K., Higuchi, H. and Y. Atarashi, \"Dual Stack Hosts using the \"Bump-In-the-Stack\" Technique (BIS)\", RFC 2767, February 2000.",
      "zh-CHS": "[BIS]Tsuchiya，K.，Higuchi，H.和Y.Atarashi，“使用“堆栈中的凹凸”技术（BIS）的双堆栈主机”，RFC 2767，2000年2月。"
    },
    {
      "indent": 3,
      "text": "[SOCK-EXT] Gilligan, R., Thomson, S., Bound, J. and W. Stevens, \"Basic Socket Interface Extensions for IPv6\", RFC 2553, March 1999.",
      "zh-CHS": "[SOCK-EXT]Gilligan，R.，Thomson，S.，Bound，J.和W.Stevens，“IPv6的基本套接字接口扩展”，RFC 25531999年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC 2119] Bradner S., \"Key words for use in RFCs to indicate Requirement Levels\", RFC 2119, March 1997.",
      "zh-CHS": "[RFC 2119]Bradner S，“RFC中用于表示需求水平的关键词”，RFC 2119，1997年3月。"
    },
    {
      "indent": 0,
      "text": "Appendix A : API list intercepted by BIA",
      "zh-CHS": "附录A：BIA截获的API清单"
    },
    {
      "indent": 3,
      "text": "The following functions are the API list which SHOULD be intercepted by BIA module.",
      "zh-CHS": "以下函数是BIA模块应该拦截的API列表。"
    },
    {
      "indent": 3,
      "text": "The functions that the application uses to pass addresses into the system are:",
      "zh-CHS": "应用程序用于将地址传递到系统的功能包括："
    },
    {
      "indent": 6,
      "text": "bind() connect() sendmsg() sendto()",
      "zh-CHS": "绑定（）连接（）发送消息（）发送到（）"
    },
    {
      "indent": 3,
      "text": "The functions that return an address from the system to an application are:",
      "zh-CHS": "从系统向应用程序返回地址的功能有："
    },
    {
      "indent": 6,
      "text": "accept() recvfrom() recvmsg() getpeername() getsockname()",
      "zh-CHS": "accept（）recvfrom（）recvmsg（）getpeername（）getsockname（）"
    },
    {
      "indent": 3,
      "text": "The functions that are related to socket options are:",
      "zh-CHS": "与套接字选项相关的功能包括："
    },
    {
      "indent": 6,
      "text": "getsocketopt() setsocketopt()",
      "zh-CHS": "getsocketopt（）setsocketopt（）"
    },
    {
      "indent": 3,
      "text": "The functions that are used for conversion of IP addresses embedded in application layer protocol (e.g., FTP, DNS, etc.) are:",
      "zh-CHS": "用于转换嵌入在应用层协议（如FTP、DNS等）中的IP地址的功能包括："
    },
    {
      "indent": 6,
      "text": "recv() send() read() write()",
      "zh-CHS": "recv（）发送（）读（）写（）"
    },
    {
      "indent": 3,
      "text": "As well, raw sockets for IPv4 and IPv6 MAY be intercepted.",
      "zh-CHS": "此外，IPv4和IPv6的原始套接字也可能被拦截。"
    },
    {
      "indent": 3,
      "text": "Most of the socket functions require a pointer to the socket address structure as an argument. Each IPv4 argument is mapped into corresponding an IPv6 argument, and vice versa.",
      "zh-CHS": "大多数套接字函数都需要指向套接字地址结构的指针作为参数。每个IPv4参数都映射到相应的IPv6参数，反之亦然。"
    },
    {
      "indent": 3,
      "text": "According to [SOCK-EXT], the following new IPv6 basic APIs and structures are required.",
      "zh-CHS": "根据[SOCK-EXT]，需要以下新的IPv6基本API和结构。"
    },
    {
      "indent": 6,
      "text": "IPv4                     new IPv6\n------------------------------------------------\nAF_INET                  AF_INET6\nsockaddr_in              sockaddr_in6\ngethostbyname()          getaddrinfo()\ngethostbyaddr()          getnameinfo()\ninet_ntoa()/inet_addr()  inet_pton()/inet_ntop()\nINADDR_ANY               in6addr_any",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "BIA MAY intercept inet_ntoa() and inet_addr() and use the address mapper for those. Doing that enables BIA to support literal IP addresses.",
      "zh-CHS": "BIA可能会截取inet_ntoa（）和inet_addr（），并使用地址映射器进行这些截取。这样做使BIA能够支持文字IP地址。"
    },
    {
      "indent": 3,
      "text": "The gethostbyname() call return a list of addresses. When the name resolver function invokes getaddrinfo() and getaddrinfo() returns multiple IP addresses, whether IPv4 or IPv6, they SHOULD all be represented in the addresses returned by gethostbyname(). Thus if getaddrinfo() returns multiple IPv6 addresses, this implies that multiple address mappings will be created; one for each IPv6 address.",
      "zh-CHS": "gethostbyname（）调用返回地址列表。当名称解析器函数调用getaddrinfo（）并且getaddrinfo（）返回多个IP地址（无论是IPv4还是IPv6）时，它们都应该在gethostbyname（）返回的地址中表示。因此，如果getaddrinfo（）返回多个IPv6地址，这意味着将创建多个地址映射；每个IPv6地址一个。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "zh-CHS": "作者地址"
    },
    {
      "indent": 3,
      "text": "Seungyun Lee ETRI PEC 161 Kajong-Dong, Yusong-Gu, Taejon 305-350, Korea Tel: +82 42 860 5508 Fax: +82 42 861 5404 EMail: syl@pec.etri.re.kr",
      "zh-CHS": "Seungyun Lee ETRI PEC 161 Kajong Dong，Yusong Gu，Taejon 305-350，Korea电话：+82 42 860 5508传真：+82 42 861 5404电子邮件：syl@pec.etri.re.kr"
    },
    {
      "indent": 3,
      "text": "Myung-Ki Shin ETRI PEC 161 Kajong-Dong, Yusong-Gu, Taejon 305-350, Korea Tel: +82 42 860 4847 Fax: +82 42 861 5404 EMail: mkshin@pec.etri.re.kr",
      "zh-CHS": "Myung Ki Shin ETRI PEC 161 Kajong Dong，Yusong Gu，Taejon 305-350，Korea电话：+82 42 860 4847传真：+82 42 861 5404电子邮件：mkshin@pec.etri.re.kr"
    },
    {
      "indent": 3,
      "text": "Yong-Jin Kim ETRI 161 Kajong-Dong, Yusong-Gu, Taejon 305-350, Korea Tel: +82 42 860 6564 Fax: +82 42 861 1033 EMail: yjkim@pec.etri.re.kr",
      "zh-CHS": "Yong Jin Kim ETRI 161 Kajong Dong，Yusong Gu，Taejon 305-350，Korea电话：+82 42 860 6564传真：+82 42 861 1033电子邮件：yjkim@pec.etri.re.kr"
    },
    {
      "indent": 3,
      "text": "Alain Durand Sun Microsystems, inc. 25 Network circle Menlo Park, CA 94025, USA Fax: +1 650 786 5896 EMail: Alain.Durand@sun.com",
      "zh-CHS": "Alain Durand Sun Microsystems，inc.25 Network circle Menlo Park，CA 94025，美国传真：+1 650 786 5896电子邮件：Alain。Durand@sun.com"
    },
    {
      "indent": 3,
      "text": "Erik Nordmark Sun Microsystems Laboratories 180, avenue de l'Europe 38334 SAINT ISMIER Cedex, France Tel: +33 (0)4 76 18 88 03 Fax: +33 (0)4 76 18 88 88 EMail: erik.nordmark@sun.com",
      "zh-CHS": "Erik Nordmark Sun Microsystems Laboratories 180，avenue de l'Europe 38334 SAINT ISMIER Cedex，France电话：+33（0）4 76 18 88 03传真：+33（0）4 76 18 88电子邮件：Erik。nordmark@sun.com"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "zh-CHS": "完整版权声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2002). All Rights Reserved.",
      "zh-CHS": "版权所有（C）互联网协会（2002年）。版权所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "zh-CHS": "本文件及其译本可复制并提供给他人，对其进行评论或解释或协助其实施的衍生作品可全部或部分编制、复制、出版和分发，不受任何限制，前提是上述版权声明和本段包含在所有此类副本和衍生作品中。但是，不得以任何方式修改本文件本身，例如删除版权通知或对互联网协会或其他互联网组织的引用，除非出于制定互联网标准的需要，在这种情况下，必须遵循互联网标准过程中定义的版权程序，或根据需要将其翻译成英语以外的其他语言。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "zh-CHS": "上述授予的有限许可是永久性的，互联网协会或其继承人或受让人不会撤销。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "zh-CHS": "本文件和其中包含的信息是按“原样”提供的，互联网协会和互联网工程任务组否认所有明示或暗示的保证，包括但不限于任何保证，即使用本文中的信息不会侵犯任何权利，或对适销性或特定用途适用性的任何默示保证。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "zh-CHS": "确认"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "zh-CHS": "RFC编辑功能的资金目前由互联网协会提供。"
    }
  ]
}