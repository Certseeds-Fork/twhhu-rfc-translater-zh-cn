{
  "title": {
    "text": "RFC 4911: Encoding Instructions for the Robust XML Encoding Rules (RXER)",
    "zh-CHS": "RFC 4911"
  },
  "number": 4911,
  "created_at": "2021-11-15 12:05:56.931351+08:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                            S. Legg\nRequest for Comments: 4911                                       eB2Bcom\nCategory: Experimental                                         July 2007",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 20,
      "text": " Encoding Instructions for the Robust XML Encoding Rules (RXER)",
      "zh-CHS": "健壮XML编码规则（RXER）的编码说明"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "zh-CHS": "关于下段备忘"
    },
    {
      "indent": 3,
      "text": "This memo defines an Experimental Protocol for the Internet community. It does not specify an Internet standard of any kind. Discussion and suggestions for improvement are requested. Distribution of this memo is unlimited.",
      "zh-CHS": "这份备忘录为互联网社区定义了一个实验性协议。它没有规定任何类型的互联网标准。要求进行讨论并提出改进建议。本备忘录的分发不受限制。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "zh-CHS": "版权公告"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The IETF Trust (2007).",
      "zh-CHS": "版权所有（C）IETF信托基金（2007年）。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "zh-CHS": "摘要"
    },
    {
      "indent": 3,
      "text": "This document defines encoding instructions that may be used in an Abstract Syntax Notation One (ASN.1) specification to alter how ASN.1 values are encoded by the Robust XML Encoding Rules (RXER) and Canonical Robust XML Encoding Rules (CRXER), for example, to encode a component of an ASN.1 value as an Extensible Markup Language (XML) attribute rather than as a child element. Some of these encoding instructions also affect how an ASN.1 specification is translated into an Abstract Syntax Notation X (ASN.X) specification. Encoding instructions that allow an ASN.1 specification to reference definitions in other XML schema languages are also defined.",
      "zh-CHS": "本文档定义了可在抽象语法表示法1（ASN.1）规范中使用的编码指令，以改变稳健XML编码规则（RXER）和规范稳健XML编码规则（CRXER）对ASN.1值进行编码的方式，例如，将ASN.1值的组件编码为可扩展标记语言（XML）属性，而不是作为子元素。其中一些编码指令还影响ASN.1规范如何转换为抽象语法符号X（ASN.X）规范。还定义了允许ASN.1规范引用其他XML模式语言中的定义的编码指令。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "zh-CHS": "目录"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n2. Conventions .....................................................3\n3. Definitions .....................................................4\n4. Notation for RXER Encoding Instructions .........................4\n5. Component Encoding Instructions .................................6\n6. Reference Encoding Instructions .................................8\n7. Expanded Names of Components ...................................10\n8. The ATTRIBUTE Encoding Instruction .............................11\n9. The ATTRIBUTE-REF Encoding Instruction .........................12\n10. The COMPONENT-REF Encoding Instruction ........................13\n11. The ELEMENT-REF Encoding Instruction ..........................16\n12. The LIST Encoding Instruction .................................17\n13. The NAME Encoding Instruction .................................19\n14. The REF-AS-ELEMENT Encoding Instruction .......................19\n15. The REF-AS-TYPE Encoding Instruction ..........................20\n16. The SCHEMA-IDENTITY Encoding Instruction ......................22\n17. The SIMPLE-CONTENT Encoding Instruction .......................22\n18. The TARGET-NAMESPACE Encoding Instruction .....................23\n19. The TYPE-AS-VERSION Encoding Instruction ......................24\n20. The TYPE-REF Encoding Instruction .............................25\n21. The UNION Encoding Instruction ................................26\n22. The VALUES Encoding Instruction ...............................27\n23. Insertion Encoding Instructions ...............................29\n24. The VERSION-INDICATOR Encoding Instruction ....................32\n25. The GROUP Encoding Instruction ................................34\n   25.1. Unambiguous Encodings ....................................36\n        25.1.1. Grammar Construction ..............................37\n        25.1.2. Unique Component Attribution ......................47\n        25.1.3. Deterministic Grammars ............................52\n        25.1.4. Attributes in Unknown Extensions ..................54\n26. Security Considerations .......................................56\n27. References ....................................................56\n   27.1. Normative References .....................................56\n   27.2. Informative References ...................................57\nAppendix A. GROUP Encoding Instruction Examples ...................58\nAppendix B. Insertion Encoding Instruction Examples ...............74\nAppendix C. Extension and Versioning Examples .....................87",
      "raw": true,
      "toc": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "zh-CHS": "1. 介绍"
    },
    {
      "indent": 3,
      "text": "This document defines encoding instructions [X.680-1] that may be used in an Abstract Syntax Notation One (ASN.1) [X.680] specification to alter how ASN.1 values are encoded by the Robust XML Encoding Rules (RXER) [RXER] and Canonical Robust XML Encoding Rules (CRXER) [RXER], for example, to encode a component of an ASN.1 value as an Extensible Markup Language (XML) [XML10] attribute rather than as a child element. Some of these encoding instructions also affect how an ASN.1 specification is translated into an Abstract Syntax Notation X (ASN.X) specification [ASN.X].",
      "zh-CHS": "本文档定义了编码指令[X.680-1]，该指令可在抽象语法符号1（ASN.1）[X.680]规范中使用，以改变稳健XML编码规则（RXER）[RXER]和规范稳健XML编码规则（CRXER）[RXER]对ASN.1值的编码方式，将ASN.1值的组件编码为可扩展标记语言（XML）[XML10]属性，而不是子元素。其中一些编码指令还影响ASN.1规范如何转换为抽象语法符号X（ASN.X）规范[ASN.X]。"
    },
    {
      "indent": 3,
      "text": "This document also defines encoding instructions that allow an ASN.1 specification to incorporate the definitions of types, elements, and attributes in specifications written in other XML schema languages. References to XML Schema [XSD1] types, elements, and attributes, RELAX NG [RNG] named patterns and elements, and XML document type definition (DTD) [XML10] element types are supported.",
      "zh-CHS": "本文档还定义了编码指令，允许ASN.1规范将类型、元素和属性的定义合并到用其他XML模式语言编写的规范中。支持对XML模式[XSD1]类型、元素和属性、RELAXNG[RNG]命名模式和元素以及XML文档类型定义（DTD）[XML10]元素类型的引用。"
    },
    {
      "indent": 3,
      "text": "In most cases, the effect of an encoding instruction is only briefly mentioned in this document. The precise effects of these encoding instructions are described fully in the specifications for RXER [RXER] and ASN.X [ASN.X], at the points where they apply.",
      "zh-CHS": "在大多数情况下，本文档仅简要介绍编码指令的效果。这些编码指令的精确效果在RXER[RXER]和ASN.X[ASN.X]的规范中的适用点进行了详细描述。"
    },
    {
      "indent": 0,
      "text": "2. Conventions",
      "section_title": true,
      "zh-CHS": "2. 习俗"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\" and \"MAY\" in this document are to be interpreted as described in BCP 14, RFC 2119 [BCP14]. The key word \"OPTIONAL\" is exclusively used with its ASN.1 meaning.",
      "zh-CHS": "本文件中的关键词“必须”、“不得”、“要求”、“应”、“不得”、“应”、“不应”、“建议”和“可”应按照BCP 14、RFC 2119[BCP14]中的说明进行解释。关键词“可选”仅用于其ASN.1含义。"
    },
    {
      "indent": 3,
      "text": "Throughout this document \"type\" shall be taken to mean an ASN.1 type, and \"value\" shall be taken to mean an ASN.1 abstract value, unless qualified otherwise.",
      "zh-CHS": "在本文件中，“类型”应被视为ASN.1类型，“值”应被视为ASN.1抽象值，除非另有限定。"
    },
    {
      "indent": 3,
      "text": "A reference to an ASN.1 production [X.680] (e.g., Type, NamedType) is a reference to text in an ASN.1 specification corresponding to that production. Throughout this document, \"component\" is synonymous with NamedType.",
      "zh-CHS": "对ASN.1产品[X.680]（例如，Type，NamedType）的引用是对与该产品对应的ASN.1规范中文本的引用。在本文档中，“组件”与NamedType同义。"
    },
    {
      "indent": 3,
      "text": "This document uses the namespace prefix \"xsi:\" to stand for the namespace name [XMLNS10] \"http://www.w3.org/2001/XMLSchema-instance\".",
      "zh-CHS": "本文档使用名称空间前缀“xsi:”表示名称空间名称[XMLNS10]”http://www.w3.org/2001/XMLSchema-instance\"."
    },
    {
      "indent": 3,
      "text": "Example ASN.1 definitions in this document are assumed to be defined in an ASN.1 module with a TagDefault of \"AUTOMATIC TAGS\" and an EncodingReferenceDefault [X.680-1] of \"RXER INSTRUCTIONS\".",
      "zh-CHS": "本文档中的示例ASN.1定义假定在ASN.1模块中定义，标记默认值为“自动标记”，编码参考默认值为“RXER指令”。"
    },
    {
      "indent": 0,
      "text": "3. Definitions",
      "section_title": true,
      "zh-CHS": "3. 定义"
    },
    {
      "indent": 3,
      "text": "The following definition of base type is used in specifying a number of encoding instructions.",
      "zh-CHS": "下面的基类型定义用于指定许多编码指令。"
    },
    {
      "indent": 3,
      "text": "Definition (base type): If a type, T, is a constrained type, then the base type of T is the base type of the type that is constrained; else if T is a prefixed type, then the base type of T is the base type of the type that is prefixed; else if T is a type notation that references or denotes another type (i.e., DefinedType, ObjectClassFieldType, SelectionType, TypeFromObject, or ValueSetFromObjects), then the base type of T is the base type of the type that is referenced or denoted; otherwise, the base type of T is T itself.",
      "zh-CHS": "定义（基类型）：如果类型T是受约束类型，则T的基类型是受约束类型的基类型；否则，如果T是前缀类型，则T的基类型是前缀类型的基类型；否则，如果T是引用或表示另一类型（即DefinedType、ObjectClassFieldType、SelectionType、TypeFromObject或ValueSetFromObjects）的类型表示法，则T的基类型是被引用或表示的类型的基类型；否则，T的基类型就是T本身。"
    },
    {
      "indent": 6,
      "text": "Aside: A tagged type is a special case of a prefixed type.",
      "zh-CHS": "旁白：标记类型是前缀类型的特例。"
    },
    {
      "indent": 0,
      "text": "4. Notation for RXER Encoding Instructions",
      "section_title": true,
      "zh-CHS": "4. RXER编码指令的符号"
    },
    {
      "indent": 3,
      "text": "The grammar of ASN.1 permits the application of encoding instructions [X.680-1], through type prefixes and encoding control sections, that modify how abstract values are encoded by nominated encoding rules.",
      "zh-CHS": "ASN.1的语法允许应用编码指令[X.680-1]，通过类型前缀和编码控制部分修改指定编码规则对抽象值的编码方式。"
    },
    {
      "indent": 3,
      "text": "The generic notation for type prefixes and encoding control sections is defined by the ASN.1 basic notation [X.680] [X.680-1], and includes an encoding reference to identify the specific encoding rules that are affected by the encoding instruction.",
      "zh-CHS": "类型前缀和编码控制部分的通用表示法由ASN.1基本表示法[X.680][X.680-1]定义，并包括一个编码引用，用于标识受编码指令影响的特定编码规则。"
    },
    {
      "indent": 3,
      "text": "The encoding reference that identifies the Robust XML Encoding rules is literally RXER. An RXER encoding instruction applies equally to both RXER and CRXER encodings.",
      "zh-CHS": "标识健壮XML编码规则的编码引用实际上是RXER。RXER编码指令同样适用于RXER和CRXER编码。"
    },
    {
      "indent": 3,
      "text": "The specific notation for an encoding instruction for a specific set of encoding rules is left to the specification of those encoding rules. Consequently, this companion document to the RXER specification [RXER] defines the notation for RXER encoding instructions. Specifically, it elaborates the EncodingInstruction and EncodingInstructionAssignmentList placeholder productions of the ASN.1 basic notation.",
      "zh-CHS": "对于一组特定的编码规则，编码指令的特定符号由这些编码规则的规范决定。因此，RXER规范[RXER]的本配套文件定义了RXER编码指令的符号。具体来说，它阐述了ASN.1基本符号的EncodingInstruction和EncodingInstructionAssignmentList占位符产品。"
    },
    {
      "indent": 3,
      "text": "In the context of the RXER encoding reference, the EncodingInstruction production is defined as follows, using the conventions of the ASN.1 basic notation:",
      "zh-CHS": "在RXER编码参考的上下文中，使用ASN.1基本符号的约定，编码指令生成定义如下："
    },
    {
      "indent": 6,
      "text": "EncodingInstruction ::=\n    AttributeInstruction |\n    AttributeRefInstruction |\n    ComponentRefInstruction |\n    ElementRefInstruction |\n    GroupInstruction |\n    InsertionsInstruction |\n    ListInstruction |\n    NameInstruction |\n    RefAsElementInstruction |\n    RefAsTypeInstruction |\n    SimpleContentInstruction |\n    TypeAsVersionInstruction |\n    TypeRefInstruction |\n    UnionInstruction |\n    ValuesInstruction |\n    VersionIndicatorInstruction",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "In the context of the RXER encoding reference, the EncodingInstructionAssignmentList production (which only appears in an encoding control section) is defined as follows:",
      "zh-CHS": "在RXER编码引用的上下文中，EncodingInstructionAssignmentList产品（仅出现在编码控制部分）定义如下："
    },
    {
      "indent": 6,
      "text": "EncodingInstructionAssignmentList ::=\n    SchemaIdentityInstruction ?\n    TargetNamespaceInstruction ?\n    TopLevelComponents ?",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "TopLevelComponents ::= TopLevelComponent TopLevelComponents ?",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "TopLevelComponent ::= \"COMPONENT\" NamedType",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Definition (top-level NamedType): A NamedType is a top-level NamedType (equivalently, a top-level component) if and only if it is the NamedType in a TopLevelComponent. A NamedType nested within the Type of the NamedType of a TopLevelComponent is not itself a top-level NamedType.",
      "zh-CHS": "定义（顶级NamedType）：NamedType是顶级NamedType（相当于顶级组件），当且仅当它是TopLevelComponent中的NamedType时。嵌套在TopLevelComponent的NamedType类型中的NamedType本身不是顶级NamedType。"
    },
    {
      "indent": 6,
      "text": "Aside: Specification writers should note that non-trivial types defined within a top-level NamedType will not be visible to ASN.1 tools that do not understand RXER.",
      "zh-CHS": "旁白：规范编写者应该注意，顶级NamedType中定义的非平凡类型对于不理解RXER的ASN.1工具将不可见。"
    },
    {
      "indent": 3,
      "text": "Although a top-level NamedType only appears in an RXER encoding control section, the default encoding reference for the module [X.680-1] still applies when parsing a top-level NamedType.",
      "zh-CHS": "尽管顶级NamedType仅出现在RXER编码控制部分中，但在解析顶级NamedType时，模块[X.680-1]的默认编码参考仍然适用。"
    },
    {
      "indent": 3,
      "text": "Each top-level NamedType within a module SHALL have a distinct identifier.",
      "zh-CHS": "模块内的每个顶级命名类型应具有不同的标识符。"
    },
    {
      "indent": 3,
      "text": "The NamedType production is defined by the ASN.1 basic notation. The other productions are described in subsequent sections and make use of the following productions:",
      "zh-CHS": "NamedType产品由ASN.1基本符号定义。其他产品将在后续章节中介绍，并使用以下产品："
    },
    {
      "indent": 6,
      "text": "NCNameValue ::= Value",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "AnyURIValue ::= Value",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "QNameValue ::= Value",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "NameValue ::= Value",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The Value production is defined by the ASN.1 basic notation.",
      "zh-CHS": "价值生产由ASN.1基本符号定义。"
    },
    {
      "indent": 3,
      "text": "The governing type for the Value in an NCNameValue is the NCName type from the AdditionalBasicDefinitions module [RXER].",
      "zh-CHS": "NCNameValue中值的控制类型是AdditionalBasicDefinitions模块[RXER]中的NCName类型。"
    },
    {
      "indent": 3,
      "text": "The governing type for the Value in an AnyURIValue is the AnyURI type from the AdditionalBasicDefinitions module.",
      "zh-CHS": "AnyURIValue中值的控制类型是AdditionalBasicDefinitions模块中的AnyURI类型。"
    },
    {
      "indent": 3,
      "text": "The governing type for the Value in a QNameValue is the QName type from the AdditionalBasicDefinitions module.",
      "zh-CHS": "QNameValue中值的控制类型是AdditionalBasicDefinitions模块中的QName类型。"
    },
    {
      "indent": 3,
      "text": "The governing type for the Value in a NameValue is the Name type from the AdditionalBasicDefinitions module.",
      "zh-CHS": "NameValue中值的控制类型是AdditionalBasicDefinitions模块中的名称类型。"
    },
    {
      "indent": 3,
      "text": "The Value in an NCNameValue, AnyURIValue, QNameValue, or NameValue SHALL NOT be a DummyReference [X.683] and SHALL NOT textually contain a nested DummyReference.",
      "zh-CHS": "NCNameValue、AnyURIValue、QNameValue或NameValue中的值不得为DummyReference[X.683]，且不得在文本中包含嵌套的DummyReference。"
    },
    {
      "indent": 6,
      "text": "Aside: Thus, encoding instructions are not permitted to be parameterized in any way. This restriction will become important if a future specification for ASN.X explicitly represents parameterized definitions and parameterized references instead of expanding out parameterized references as in the current specification. A parameterized definition could not be directly translated into ASN.X if it contained encoding instructions that were not fully specified.",
      "zh-CHS": "旁白：因此，编码指令不允许以任何方式参数化。如果ASN.X的未来规范显式表示参数化定义和参数化引用，而不是像当前规范那样扩展参数化引用，则此限制将变得非常重要。如果参数化定义包含未完全指定的编码指令，则无法将其直接转换为ASN.X。"
    },
    {
      "indent": 0,
      "text": "5. Component Encoding Instructions",
      "section_title": true,
      "zh-CHS": "5. 组件编码指令"
    },
    {
      "indent": 3,
      "text": "Certain of the RXER encoding instructions are categorized as component encoding instructions. The component encoding instructions are the ATTRIBUTE, ATTRIBUTE-REF, COMPONENT-REF, GROUP, ELEMENT-REF, NAME, REF-AS-ELEMENT, SIMPLE-CONTENT, TYPE-AS-VERSION, and VERSION-INDICATOR encoding instructions (whose notations are described respectively by AttributeInstruction, AttributeRefInstruction, ComponentRefInstruction, GroupInstruction,",
      "zh-CHS": "某些RXER编码指令被归类为组件编码指令。组件编码指令是ATTRIBUTE、ATTRIBUTE-REF、component-REF、GROUP、ELEMENT-REF、NAME、REF-AS-ELEMENT、SIMPLE-CONTENT、TYPE-AS-VERSION和VERSION-INDICATOR编码指令（其符号分别由AttributeInstruction、AttributeRefInstruction、ComponentRefInstruction、GroupInstruction、，"
    },
    {
      "indent": 3,
      "text": "ElementRefInstruction, NameInstruction, RefAsElementInstruction, SimpleContentInstruction, TypeAsVersionInstruction, and VersionIndicatorInstruction).",
      "zh-CHS": "ElementRefInstruction、NameInstruction、RefAsElementInstruction、SimpleContentInstruction、TypeAsVersionInstruction和VersionIndicatorInstruction）。"
    },
    {
      "indent": 3,
      "text": "The Type in the EncodingPrefixedType for a component encoding instruction SHALL be either:",
      "zh-CHS": "组件编码指令的EncodingPrefixedType中的类型应为："
    },
    {
      "indent": 3,
      "text": "(1) the Type in a NamedType, or",
      "zh-CHS": "(1) NamedType中的类型，或"
    },
    {
      "indent": 3,
      "text": "(2) the Type in an EncodingPrefixedType in a PrefixedType in a BuiltinType in a Type that is one of (1) to (4), or",
      "zh-CHS": "(2) EncodingPrefixedType中的类型PrefixedType中的类型在类型为（1）到（4）之一的内置类型中，或"
    },
    {
      "indent": 3,
      "text": "(3) the Type in an TaggedType in a PrefixedType in a BuiltinType in a Type that is one of (1) to (4), or",
      "zh-CHS": "(3) 类型为（1）到（4）之一的内置类型中的PrefixedType中的TaggedType中的类型，或"
    },
    {
      "indent": 3,
      "text": "(4) the Type in a ConstrainedType (excluding a TypeWithConstraint) in a Type that is one of (1) to (4).",
      "zh-CHS": "(4) 属于（1）到（4）之一的类型中的ConstrainedType（不包括TypeWithConstraint）中的类型。"
    },
    {
      "indent": 6,
      "text": "Aside: The effect of this condition is to force the component encoding instructions to be textually within the NamedType to which they apply. Only case (2) can be true on the first iteration as the Type belongs to an EncodingPrefixedType; however, any of (1) to (4) can be true on subsequent iterations.",
      "zh-CHS": "旁白：此条件的效果是强制组件编码指令以文本形式在其应用的NamedType中。在第一次迭代中，只有情况（2）可以为真，因为该类型属于EncodingPrefixedType；但是，在后续迭代中，（1）到（4）中的任何一个都可能为真。"
    },
    {
      "indent": 3,
      "text": "Case (4) is not permitted when the encoding instruction is the ATTRIBUTE-REF, COMPONENT-REF, ELEMENT-REF, or REF-AS-ELEMENT encoding instruction.",
      "zh-CHS": "当编码指令是ATTRIBUTE-REF、COMPONENT-REF、ELEMENT-REF或REF-AS-ELEMENT编码指令时，不允许使用情况（4）。"
    },
    {
      "indent": 3,
      "text": "The NamedType in case (1) is said to be \"subject to\" the component encoding instruction.",
      "zh-CHS": "案例（1）中的NamedType被称为“服从”组件编码指令。"
    },
    {
      "indent": 3,
      "text": "A top-level NamedType SHALL NOT be subject to an ATTRIBUTE-REF, COMPONENT-REF, GROUP, ELEMENT-REF, REF-AS-ELEMENT, or SIMPLE-CONTENT encoding instruction.",
      "zh-CHS": "顶级命名类型不受ATTRIBUTE-REF、COMPONENT-REF、GROUP、ELEMENT-REF、REF-AS-ELEMENT或SIMPLE-CONTENT编码指令的约束。"
    },
    {
      "indent": 6,
      "text": "Aside: This condition does not preclude these encoding instructions being used on a nested NamedType.",
      "zh-CHS": "旁白：此条件不排除在嵌套NamedType上使用这些编码指令。"
    },
    {
      "indent": 3,
      "text": "A NamedType SHALL NOT be subject to two or more component encoding instructions of the same kind, e.g., a NamedType is not permitted to be subject to two NAME encoding instructions.",
      "zh-CHS": "一个命名类型不受两个或两个以上同类组件编码指令的约束，例如，一个命名类型不允许受两个名称编码指令的约束。"
    },
    {
      "indent": 3,
      "text": "The ATTRIBUTE, ATTRIBUTE-REF, COMPONENT-REF, GROUP, ELEMENT-REF, REF-AS-ELEMENT, SIMPLE-CONTENT, and TYPE-AS-VERSION encoding instructions are mutually exclusive. The NAME, ATTRIBUTE-REF, COMPONENT-REF, ELEMENT-REF, and REF-AS-ELEMENT encoding instructions are mutually exclusive. A NamedType SHALL NOT be subject to two or more encoding instructions that are mutually exclusive.",
      "zh-CHS": "ATTRIBUTE、ATTRIBUTE-REF、COMPONENT-REF、GROUP、ELEMENT-REF、REF-AS-ELEMENT、SIMPLE-CONTENT和TYPE-AS-VERSION编码指令是互斥的。名称、ATTRIBUTE-REF、COMPONENT-REF、ELEMENT-REF和REF-AS-ELEMENT编码指令是互斥的。命名类型不受两个或多个相互排斥的编码指令的约束。"
    },
    {
      "indent": 3,
      "text": "A SelectionType [X.680] SHALL NOT be used to select the Type from a NamedType that is subject to an ATTRIBUTE-REF, COMPONENT-REF, ELEMENT-REF or REF-AS-ELEMENT encoding instruction. The other component encoding instructions are not inherited by the type denoted by a SelectionType.",
      "zh-CHS": "SelectionType[X.680]不得用于从受ATTRIBUTE-REF、COMPONENT-REF、ELEMENT-REF或REF-AS-ELEMENT编码指令约束的NamedType中选择类型。由SelectionType表示的类型不会继承其他组件编码指令。"
    },
    {
      "indent": 3,
      "text": "Definition (attribute component): An attribute component is a NamedType that is subject to an ATTRIBUTE or ATTRIBUTE-REF encoding instruction, or subject to a COMPONENT-REF encoding instruction that references a top-level NamedType that is subject to an ATTRIBUTE encoding instruction.",
      "zh-CHS": "定义（属性组件）：属性组件是服从属性或属性-REF编码指令的NamedType，或服从引用服从属性编码指令的顶级NamedType的component-REF编码指令。"
    },
    {
      "indent": 3,
      "text": "Definition (element component): An element component is a NamedType that is not subject to an ATTRIBUTE, ATTRIBUTE-REF, GROUP, or SIMPLE-CONTENT encoding instruction, and not subject to a COMPONENT-REF encoding instruction that references a top-level NamedType that is subject to an ATTRIBUTE encoding instruction.",
      "zh-CHS": "该元素是一个简单的属性组，而不是一个简单的属性组。"
    },
    {
      "indent": 6,
      "text": "Aside: A NamedType subject to a GROUP or SIMPLE-CONTENT encoding instruction is neither an attribute component nor an element component.",
      "zh-CHS": "旁白：服从组或简单内容编码指令的NamedType既不是属性组件，也不是元素组件。"
    },
    {
      "indent": 0,
      "text": "6. Reference Encoding Instructions",
      "section_title": true,
      "zh-CHS": "6. 参考编码指令"
    },
    {
      "indent": 3,
      "text": "Certain of the RXER encoding instructions are categorized as reference encoding instructions. The reference encoding instructions are the ATTRIBUTE-REF, COMPONENT-REF, ELEMENT-REF, REF-AS-ELEMENT, REF-AS-TYPE, and TYPE-REF encoding instructions (whose notations are described respectively by AttributeRefInstruction, ComponentRefInstruction, ElementRefInstruction, RefAsElementInstruction, RefAsTypeInstruction, and TypeRefInstruction). These encoding instructions (except COMPONENT-REF) allow an ASN.1 specification to incorporate the definitions of types, elements, and attributes in specifications written in other XML schema languages, through implied constraints on the markup that may appear in values of the Markup ASN.1 type from the AdditionalBasicDefinitions module [RXER] (for ELEMENT-REF, REF-AS-ELEMENT, REF-AS-TYPE, and TYPE-REF) or the UTF8String type (for ATTRIBUTE-REF). References to XML Schema [XSD1] types, elements, and attributes, RELAX NG [RNG] named patterns and elements, and XML document type definition (DTD) [XML10] element types are supported. References to ASN.1 types and top-level components are also permitted. The COMPONENT-REF encoding instruction provides a more direct method of referencing a top-level component.",
      "zh-CHS": "某些RXER编码指令被归类为参考编码指令。引用编码指令是ATTRIBUTE-REF、COMPONENT-REF、ELEMENT-REF、REF-AS-ELEMENT、REF-AS-TYPE和TYPE-REF编码指令（其符号分别由attributerefininstruction、ComponentRefInstruction、ElementRefInstruction、RefAsElementInstruction、RefAsTypeInstruction和TypeRefInstruction描述）。这些编码指令（COMPONENT-REF除外）允许ASN.1规范通过对标记的隐含约束（可能出现在AdditionalBasicDefinitions模块[RXER]中的标记ASN.1类型的值中）合并以其他XML模式语言编写的规范中的类型、元素和属性的定义（对于ELEMENT-REF、REF-AS-ELEMENT、REF-AS-TYPE和TYPE-REF）或UTF8String类型（对于ATTRIBUTE-REF）。对XML模式[XSD1]类型、元素和属性、RELAXNG[RNG]命名模式和元素以及XML文档类型定义（DTD）[XML10]的引用支持元素类型。还允许引用ASN.1类型和顶级组件。COMPONENT-REF编码指令提供了引用顶级组件的更直接方法。"
    },
    {
      "indent": 3,
      "text": "The Type in the EncodingPrefixedType for an ELEMENT-REF, REF-AS-ELEMENT, REF-AS-TYPE, or TYPE-REF encoding instruction SHALL be either:",
      "zh-CHS": "ELEMENT-REF、REF-AS-ELEMENT、REF-AS-Type或Type-REF编码指令的EncodingPrefixedType中的类型应为："
    },
    {
      "indent": 3,
      "text": "(1) a ReferencedType that is a DefinedType that is a typereference (not a DummyReference) or ExternalTypeReference that references the Markup ASN.1 type from the AdditionalBasicDefinitions module [RXER], or",
      "zh-CHS": "(1) ReferencedType是一个定义类型，它是一个typereference（不是DummyReference）或ExternalTypeReference，它引用AdditionalBasicDefinitions模块[RXER]中的标记ASN.1类型，或者"
    },
    {
      "indent": 3,
      "text": "(2) a BuiltinType that is a PrefixedType that is a TaggedType where the Type in the TaggedType is one of (1) to (3), or",
      "zh-CHS": "(2) 一种内置类型，其前缀类型为TaggedType，其中TaggedType中的类型为（1）到（3）之一，或"
    },
    {
      "indent": 3,
      "text": "(3) a BuiltinType that is a PrefixedType that is an EncodingPrefixedType where the Type in the EncodingPrefixedType is one of (1) to (3) and the EncodingPrefix in the EncodingPrefixedType does not contain a reference encoding instruction.",
      "zh-CHS": "(3) PrefixedType是EncodingPrefixedType的内置类型，其中EncodingPrefixedType中的类型是（1）到（3）之一，EncodingPrefixedType中的EncodingPrefix不包含引用编码指令。"
    },
    {
      "indent": 6,
      "text": "Aside: Case (3) and similar cases for the ATTRIBUTE-REF and COMPONENT-REF encoding instructions have the effect of making the reference encoding instructions mutually exclusive as well as singly occurring.",
      "zh-CHS": "旁白：ATTRIBUTE-REF和COMPONENT-REF编码指令的情况（3）和类似情况具有使参考编码指令相互排斥以及单独出现的效果。"
    },
    {
      "indent": 3,
      "text": "With respect to the REF-AS-TYPE and TYPE-REF encoding instructions, the DefinedType in case (1) is said to be \"subject to\" the encoding instruction.",
      "zh-CHS": "关于REF-AS-TYPE和TYPE-REF编码指令，情况（1）中定义的类型被称为“服从”编码指令。"
    },
    {
      "indent": 3,
      "text": "The restrictions on the Type in the EncodingPrefixedType for an ATTRIBUTE-REF encoding instruction are specified in Section 9. The restrictions on the Type in the EncodingPrefixedType for a COMPONENT-REF encoding instruction are specified in Section 10.",
      "zh-CHS": "第9节规定了对ATTRIBUTE-REF编码指令的EncodingPrefixedType中的类型的限制。第10节规定了对COMPONENT-REF编码指令的EncodingPrefixedType中的类型的限制。"
    },
    {
      "indent": 3,
      "text": "The reference encoding instructions make use of a common production defined as follows:",
      "zh-CHS": "参考编码指令使用如下定义的通用产品："
    },
    {
      "indent": 6,
      "text": "RefParameters ::= ContextParameter ?",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "ContextParameter ::= \"CONTEXT\" AnyURIValue",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "A RefParameters instance provides extra information about a reference to a definition. A ContextParameter is used when a reference is ambiguous, i.e., refers to definitions in more than one schema document or external DTD subset. This situation would occur, for example, when importing types with the same name from independently developed XML Schemas defined without a target namespace [XSD1]. When used in conjunction with a reference to an element type in an external DTD subset, the AnyURIValue in the ContextParameter is the system identifier (a Uniform Resource Identifier or URI [URI]) of the external DTD subset; otherwise, the AnyURIValue is a URI that indicates the intended schema document, either an XML Schema specification, a RELAX NG specification, or an ASN.1 or ASN.X specification.",
      "zh-CHS": "RefParameters实例提供有关对定义的引用的额外信息。当引用不明确时，即引用多个模式文档或外部DTD子集中的定义时，使用ContextParameter。例如，当从未定义目标命名空间[XSD1]的独立开发的XML模式中导入具有相同名称的类型时，就会出现这种情况。当与对外部DTD子集中的元素类型的引用一起使用时，ContextParameter中的AnyURIValue是外部DTD子集的系统标识符（统一资源标识符或URI[URI]）；否则，AnyURIValue是一个URI，它指示预期的模式文档，可以是XML模式规范、RELAXNG规范，也可以是ASN.1或ASN.X规范。"
    },
    {
      "indent": 0,
      "text": "7. Expanded Names of Components",
      "section_title": true,
      "zh-CHS": "7. 组件的扩展名称"
    },
    {
      "indent": 3,
      "text": "Each NamedType has an associated expanded name [XMLNS10], determined as follows:",
      "zh-CHS": "每个NamedType都有一个关联的扩展名[XMLNS10]，确定如下："
    },
    {
      "indent": 3,
      "text": "(1) if the NamedType is subject to a NAME encoding instruction, then the local name of the expanded name is the character string specified by the NCNameValue of the NAME encoding instruction,",
      "zh-CHS": "(1) 如果NamedType受名称编码指令约束，则扩展名称的本地名称是名称编码指令的NCNameValue指定的字符串，"
    },
    {
      "indent": 3,
      "text": "(2) else if the NamedType is subject to a COMPONENT-REF encoding instruction, then the expanded name is the same as the expanded name of the referenced top-level NamedType,",
      "zh-CHS": "(2) 否则，如果NamedType遵循COMPONENT-REF编码指令，则扩展名与引用的顶级NamedType的扩展名相同，"
    },
    {
      "indent": 3,
      "text": "(3) else if the NamedType is subject to an ATTRIBUTE-REF or ELEMENT-REF encoding instruction, then the namespace name of the expanded name is equal to the namespace-name component of the QNameValue of the encoding instruction, and the local name is equal to the local-name component of the QNameValue,",
      "zh-CHS": "(3) 否则，如果NamedType受ATTRIBUTE-REF或ELEMENT-REF编码指令的约束，则扩展名称的名称空间名称等于编码指令的QNameValue的名称空间名称组件，本地名称等于QNameValue的本地名称组件，"
    },
    {
      "indent": 3,
      "text": "(4) else if the NamedType is subject to a REF-AS-ELEMENT encoding instruction, then the local name of the expanded name is the LocalPart [XMLNS10] of the qualified name specified by the NameValue of the encoding instruction,",
      "zh-CHS": "(4) 否则，如果NamedType受REF-AS-ELEMENT编码指令约束，则扩展名称的本地名称是编码指令的NameValue指定的限定名称的LocalPart[XMLNS10]，"
    },
    {
      "indent": 3,
      "text": "(5) otherwise, the local name of the expanded name is the identifier of the NamedType.",
      "zh-CHS": "(5) 否则，扩展名称的本地名称就是NamedType的标识符。"
    },
    {
      "indent": 3,
      "text": "In cases (1) and (5), if the NamedType is a top-level NamedType and the module containing the NamedType has a TARGET-NAMESPACE encoding instruction, then the namespace name of the expanded name is the character string specified by the AnyURIValue of the TARGET-NAMESPACE encoding instruction; otherwise, the namespace name has no value.",
      "zh-CHS": "在情况（1）和（5）中，如果NamedType是顶级NamedType，并且包含NamedType的模块具有目标名称空间编码指令，则扩展名称的名称空间名称是目标名称空间编码指令的AnyURIValue指定的字符串；否则，名称空间名称没有值。"
    },
    {
      "indent": 6,
      "text": "Aside: Thus, the TARGET-NAMESPACE encoding instruction applies to a top-level NamedType but not to any other NamedType.",
      "zh-CHS": "旁白：因此，TARGET-NAMESPACE编码指令适用于顶级NamedType，但不适用于任何其他NamedType。"
    },
    {
      "indent": 3,
      "text": "In case (4), if the encoding instruction contains a Namespace, then the namespace name of the expanded name is the character string specified by the AnyURIValue of the Namespace; otherwise, the namespace name has no value.",
      "zh-CHS": "在案例（4）中，如果编码指令包含名称空间，则扩展名称的名称空间名称是由名称空间的AnyURIValue指定的字符串；否则，名称空间名称没有值。"
    },
    {
      "indent": 3,
      "text": "The expanded names for the attribute components of a CHOICE, SEQUENCE, or SET type MUST be distinct. The expanded names for the components of a CHOICE, SEQUENCE, or SET type that are not attribute components MUST be distinct. These tests are applied after the COMPONENTS OF transformation specified in X.680, Clause 24.4 [X.680].",
      "zh-CHS": "选项、序列或集合类型的属性组件的扩展名称必须是不同的。非属性组件的选项、序列或集合类型的组件的扩展名称必须是不同的。这些试验在X.680第24.4条[X.680]中规定的转换组件之后进行。"
    },
    {
      "indent": 6,
      "text": "Aside: Two components of the same CHOICE, SEQUENCE, or SET type may have the same expanded name if one of them is an attribute component and the other is not. Note that the \"not\" case includes components that are subject to a GROUP or SIMPLE-CONTENT encoding instruction.",
      "zh-CHS": "旁白：相同选择、序列或集合类型的两个组件可能具有相同的扩展名，如果其中一个是属性组件，而另一个不是。注意，“not”情况包括服从分组或简单内容编码指令的组件。"
    },
    {
      "indent": 3,
      "text": "The expanded name of a top-level NamedType subject to an ATTRIBUTE encoding instruction MUST be distinct from the expanded name of every other top-level NamedType subject to an ATTRIBUTE encoding instruction in the same module.",
      "zh-CHS": "属性编码指令的顶级NamedType主题的扩展名必须不同于同一模块中属性编码指令的其他所有顶级NamedType主题的扩展名。"
    },
    {
      "indent": 3,
      "text": "The expanded name of a top-level NamedType not subject to an ATTRIBUTE encoding instruction MUST be distinct from the expanded name of every other top-level NamedType not subject to an ATTRIBUTE encoding instruction in the same module.",
      "zh-CHS": "不受属性编码指令约束的顶级NamedType的扩展名必须与同一模块中所有其他不受属性编码指令约束的顶级NamedType的扩展名不同。"
    },
    {
      "indent": 6,
      "text": "Aside: Two top-level components may have the same expanded name if one of them is an attribute component and the other is not.",
      "zh-CHS": "旁白：如果两个顶级组件中的一个是属性组件，而另一个不是属性组件，则它们可能具有相同的扩展名。"
    },
    {
      "indent": 0,
      "text": "8. The ATTRIBUTE Encoding Instruction",
      "section_title": true,
      "zh-CHS": "8. 属性编码指令"
    },
    {
      "indent": 3,
      "text": "The ATTRIBUTE encoding instruction causes an RXER encoder to encode a value of the component to which it is applied as an XML attribute instead of as a child element.",
      "zh-CHS": "属性编码指令使RXER编码器将应用它的组件的值编码为XML属性，而不是子元素。"
    },
    {
      "indent": 3,
      "text": "The notation for an ATTRIBUTE encoding instruction is defined as follows:",
      "zh-CHS": "属性编码指令的符号定义如下："
    },
    {
      "indent": 6,
      "text": "AttributeInstruction ::= \"ATTRIBUTE\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The base type of the type of a NamedType that is subject to an ATTRIBUTE encoding instruction SHALL NOT be:",
      "zh-CHS": "受属性编码指令约束的NamedType类型的基本类型不得为："
    },
    {
      "indent": 3,
      "text": "(1) a CHOICE, SET, or SET OF type, or",
      "zh-CHS": "(1) 类型的选择、集合或集合，或"
    },
    {
      "indent": 3,
      "text": "(2) a SEQUENCE type other than the one defining the QName type from the AdditionalBasicDefinitions module [RXER] (i.e., QName is allowed), or",
      "zh-CHS": "(2) 序列类型，而不是从AdditionalBasicDefinitions模块[RXER]定义QName类型的序列类型（即，允许使用QName），或"
    },
    {
      "indent": 3,
      "text": "(3) a SEQUENCE OF type where the SequenceOfType is not subject to a LIST encoding instruction, or",
      "zh-CHS": "(3) 一种类型序列，其中SequenceOfType不受列表编码指令的约束，或"
    },
    {
      "indent": 3,
      "text": "(4) an open type.",
      "zh-CHS": "(4) 开放式。"
    },
    {
      "indent": 3,
      "text": "Example",
      "zh-CHS": "实例"
    },
    {
      "indent": 6,
      "text": "PersonalDetails ::= SEQUENCE {\n    firstName   [ATTRIBUTE] UTF8String,\n    middleName  [ATTRIBUTE] UTF8String,\n    surname     [ATTRIBUTE] UTF8String\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "9. The ATTRIBUTE-REF Encoding Instruction",
      "section_title": true,
      "zh-CHS": "9. ATTRIBUTE-REF编码指令"
    },
    {
      "indent": 3,
      "text": "The ATTRIBUTE-REF encoding instruction causes an RXER encoder to encode a value of the component to which it is applied as an XML attribute instead of as a child element, where the attribute's name is a qualified name of the attribute declaration referenced by the encoding instruction. In addition, the ATTRIBUTE-REF encoding instruction causes values of the UTF8String type to be restricted to conform to the type of the attribute declaration.",
      "zh-CHS": "ATTRIBUTE-REF编码指令使RXER编码器将其应用到的组件的值编码为XML属性，而不是子元素，其中属性名称是编码指令引用的属性声明的限定名称。此外，ATTRIBUTE-REF编码指令会限制UTF8String类型的值，以符合属性声明的类型。"
    },
    {
      "indent": 3,
      "text": "The notation for an ATTRIBUTE-REF encoding instruction is defined as follows:",
      "zh-CHS": "ATTRIBUTE-REF编码指令的符号定义如下："
    },
    {
      "indent": 6,
      "text": "AttributeRefInstruction ::=\n    \"ATTRIBUTE-REF\" QNameValue RefParameters",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Taken together, the QNameValue and the ContextParameter in the RefParameters (if present) MUST reference an XML Schema attribute declaration or a top-level NamedType that is subject to an ATTRIBUTE encoding instruction.",
      "zh-CHS": "总之，RefParameters（如果存在）中的QNameValue和ContextParameter必须引用XML架构属性声明或受属性编码指令约束的顶级NamedType。"
    },
    {
      "indent": 3,
      "text": "The type of a referenced XML Schema attribute declaration SHALL NOT be, either directly or by derivation, the XML Schema type QName, NOTATION, ENTITY, ENTITIES, or anySimpleType.",
      "zh-CHS": "引用的XML模式属性声明的类型不得直接或通过派生方式为XML模式类型QName、NOTATION、ENTITY、ENTITIES或anySimpleType。"
    },
    {
      "indent": 6,
      "text": "Aside: Values of these types require information from the context of the attribute for interpretation. Because an ATTRIBUTE-REF encoding instruction is restricted to prefixing the ASN.1 UTF8String type, there is no mechanism to capture such context.",
      "zh-CHS": "旁白：这些类型的值需要来自属性上下文的信息进行解释。由于ATTRIBUTE-REF编码指令仅限于作为ASN.1 UTF8String类型的前缀，因此没有捕获此类上下文的机制。"
    },
    {
      "indent": 3,
      "text": "The type of a referenced top-level NamedType SHALL NOT be, either directly or by subtyping, the QName type from the AdditionalBasicDefinitions module [RXER].",
      "zh-CHS": "引用的顶级NamedType的类型不得直接或通过子类型与AdditionalBasicDefinitions模块[RXER]中的QName类型相同。"
    },
    {
      "indent": 3,
      "text": "The Type in the EncodingPrefixedType for an ATTRIBUTE-REF encoding instruction SHALL be either:",
      "zh-CHS": "ATTRIBUTE-REF编码指令的EncodingPrefixedType中的类型应为："
    },
    {
      "indent": 3,
      "text": "(1) the UTF8String type, or",
      "zh-CHS": "(1) UTF8String类型，或"
    },
    {
      "indent": 3,
      "text": "(2) a BuiltinType that is a PrefixedType that is a TaggedType where the Type in the TaggedType is one of (1) to (3), or",
      "zh-CHS": "(2) 一种内置类型，其前缀类型为TaggedType，其中TaggedType中的类型为（1）到（3）之一，或"
    },
    {
      "indent": 3,
      "text": "(3) a BuiltinType that is a PrefixedType that is an EncodingPrefixedType where the Type in the EncodingPrefixedType is one of (1) to (3) and the EncodingPrefix in the EncodingPrefixedType does not contain a reference encoding instruction.",
      "zh-CHS": "(3) PrefixedType是EncodingPrefixedType的内置类型，其中EncodingPrefixedType中的类型是（1）到（3）之一，EncodingPrefixedType中的EncodingPrefix不包含引用编码指令。"
    },
    {
      "indent": 3,
      "text": "The identifier of a NamedType subject to an ATTRIBUTE-REF encoding instruction does not contribute to the name of attributes in an RXER encoding. For the sake of consistency, the identifier SHOULD, where possible, be the same as the local name of the referenced attribute declaration.",
      "zh-CHS": "受ATTRIBUTE-REF编码指令约束的NamedType的标识符不影响RXER编码中的属性名称。为保持一致性，标识符应尽可能与被引用属性声明的本地名称相同。"
    },
    {
      "indent": 0,
      "text": "10. The COMPONENT-REF Encoding Instruction",
      "section_title": true,
      "zh-CHS": "10. COMPONENT-REF编码指令"
    },
    {
      "indent": 3,
      "text": "The ASN.1 basic notation does not have a concept of a top-level NamedType and therefore does not have a mechanism to reference a top-level NamedType. The COMPONENT-REF encoding instruction provides a way to specify that a NamedType within a combining type definition is equivalent to a referenced top-level NamedType.",
      "zh-CHS": "ASN.1基本表示法没有顶级NamedType的概念，因此没有引用顶级NamedType的机制。COMPONENT-REF编码指令提供了一种方法，用于指定组合类型定义中的NamedType等同于引用的顶级NamedType。"
    },
    {
      "indent": 3,
      "text": "The notation for a COMPONENT-REF encoding instruction is defined as follows:",
      "zh-CHS": "COMPONENT-REF编码指令的符号定义如下："
    },
    {
      "indent": 6,
      "text": "ComponentRefInstruction ::= \"COMPONENT-REF\" ComponentReference",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "ComponentReference ::=\n    InternalComponentReference |\n    ExternalComponentReference",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "InternalComponentReference ::= identifier FromModule ?",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "FromModule ::= \"FROM\" GlobalModuleReference",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "ExternalComponentReference ::= modulereference \".\" identifier",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The GlobalModuleReference production is defined by the ASN.1 basic notation [X.680]. If the GlobalModuleReference is absent from an InternalComponentReference, then the identifier MUST be the identifier of a top-level NamedType in the same module. If the GlobalModuleReference is present in an InternalComponentReference, then the identifier MUST be the identifier of a top-level NamedType in the referenced module.",
      "zh-CHS": "GlobalModuleReference产品由ASN.1基本符号[X.680]定义。如果InternalComponentReference中缺少GlobalModuleReference，则该标识符必须是同一模块中顶级NamedType的标识符。如果GlobalModuleReference存在于InternalComponentReference中，则该标识符必须是被引用模块中顶级NamedType的标识符。"
    },
    {
      "indent": 3,
      "text": "The modulereference in an ExternalComponentReference is used in the same way as a modulereference in an ExternalTypeReference. The identifier in an ExternalComponentReference MUST be the identifier of a top-level NamedType in the referenced module.",
      "zh-CHS": "ExternalComponentReference中的modulereference与ExternalTypeReference中的modulereference的使用方式相同。ExternalComponentReference中的标识符必须是所引用模块中顶级NamedType的标识符。"
    },
    {
      "indent": 3,
      "text": "The Type in the EncodingPrefixedType for a COMPONENT-REF encoding instruction SHALL be either:",
      "zh-CHS": "COMPONENT-REF编码指令的EncodingPrefixedType中的类型应为："
    },
    {
      "indent": 3,
      "text": "(1) a ReferencedType that is a DefinedType that is a typereference (not a DummyReference) or an ExternalTypeReference, or",
      "zh-CHS": "(1) ReferencedType是一个定义类型，它是一个类型引用（不是DummyReference）或一个ExternalTypeReference，或者"
    },
    {
      "indent": 3,
      "text": "(2) a BuiltinType or ReferencedType that is one of the productions in Table 1 in Section 5 of the specification for RXER [RXER], or",
      "zh-CHS": "(2) RXER[RXER]规范第5节表1中的产品之一的内置类型或引用类型，或"
    },
    {
      "indent": 3,
      "text": "(3) a BuiltinType that is a PrefixedType that is a TaggedType where the Type in the TaggedType is one of (1) to (4), or",
      "zh-CHS": "(3) 一种内置类型，其前缀类型为TaggedType，其中TaggedType中的类型为（1）到（4）之一，或"
    },
    {
      "indent": 3,
      "text": "(4) a BuiltinType that is a PrefixedType that is an EncodingPrefixedType where the Type in the EncodingPrefixedType is one of (1) to (4) and the EncodingPrefix in the EncodingPrefixedType does not contain a reference encoding instruction.",
      "zh-CHS": "(4) PrefixedType是EncodingPrefixedType的内置类型，其中EncodingPrefixedType中的类型是（1）到（4）之一，EncodingPrefixedType中的EncodingPrefix不包含引用编码指令。"
    },
    {
      "indent": 3,
      "text": "The restrictions on the use of RXER encoding instructions are such that no other RXER encoding instruction is permitted within a NamedType if the NamedType is subject to a COMPONENT-REF encoding instruction.",
      "zh-CHS": "使用RXER编码指令的限制是，如果NamedType受COMPONENT-REF编码指令的约束，则NamedType中不允许使用其他RXER编码指令。"
    },
    {
      "indent": 3,
      "text": "The Type in the top-level NamedType referenced by the COMPONENT-REF encoding instruction MUST be either:",
      "zh-CHS": "COMPONENT-REF编码指令引用的顶级NamedType中的类型必须为："
    },
    {
      "indent": 3,
      "text": "(a) if the preceding case (1) is used, a ReferencedType that is a DefinedType that is a typereference or ExternalTypeReference that references the same type as the DefinedType in case (1), or",
      "zh-CHS": "(a) 如果使用前一种情况（1），则为定义类型的ReferencedType，该定义类型为typereference或ExternalTypeReference，其引用的类型与情况（1）中定义类型相同，或"
    },
    {
      "indent": 3,
      "text": "(b) if the preceding case (2) is used, a BuiltinType or ReferencedType that is the same as the BuiltinType or ReferencedType in case (2), or",
      "zh-CHS": "(b) 如果使用前一种情况（2），则为与情况（2）中的内置类型或ReferencedType相同的内置类型或ReferencedType，或"
    },
    {
      "indent": 3,
      "text": "(c) a BuiltinType that is a PrefixedType that is an EncodingPrefixedType where the Type in the EncodingPrefixedType is one of (a) to (c), and the EncodingPrefix in the EncodingPrefixedType contains an RXER encoding instruction.",
      "zh-CHS": "(c) PrefixedType是EncodingPrefixedType的内置类型，其中EncodingPrefixedType中的类型是（a）到（c）之一，EncodingPrefixedType中的EncodingPrefix包含RXER编码指令。"
    },
    {
      "indent": 3,
      "text": "In principle, the COMPONENT-REF encoding instruction creates a notional NamedType where the expanded name is that of the referenced top-level NamedType and the Type in case (1) or (2) is substituted by the Type of the referenced top-level NamedType.",
      "zh-CHS": "原则上，COMPONENT-REF编码指令创建一个概念性的NamedType，其中扩展名称是引用的顶级NamedType的名称，而案例（1）或（2）中的类型被引用的顶级NamedType的类型替换。"
    },
    {
      "indent": 3,
      "text": "In practice, it is sufficient for non-RXER encoders and decoders to use the original NamedType rather than the notional NamedType because the Type in case (1) or (2) can only differ from the Type of the referenced top-level NamedType by having fewer RXER encoding instructions, and RXER encoding instructions are ignored by non-RXER encoders and decoders.",
      "zh-CHS": "实际上，非RXER编码器和解码器使用原始NamedType而不是名义上的NamedType就足够了，因为情况（1）或（2）中的类型只能通过较少的RXER编码指令与引用的顶级NamedType的类型不同，非RXER编码器和解码器忽略RXER编码指令。"
    },
    {
      "indent": 3,
      "text": "Although any prefixes for the Type in case (1) or (2) would be bypassed, it is sufficient for RXER encoders and decoders to use the referenced top-level NamedType instead of the notional NamedType because these prefixes cannot be RXER encoding instructions (except, of course, for the COMPONENT-REF encoding instruction) and can have no effect on an RXER encoding.",
      "zh-CHS": "虽然（1）或（2）中类型的任何前缀都将被绕过，但RXER编码器和解码器使用引用的顶级NamedType而不是名义上的NamedType就足够了，因为这些前缀不能是RXER编码指令（当然，对于COMPONENT-REF编码指令除外）并且对RXER编码没有影响。"
    },
    {
      "indent": 3,
      "text": "Example",
      "zh-CHS": "实例"
    },
    {
      "indent": 6,
      "text": "Modules ::= SEQUENCE OF\n    module [COMPONENT-REF module\n               FROM AbstractSyntaxNotation-X\n                   { 1 3 6 1 4 1 21472 1 0 1 }]\n               ModuleDefinition",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "Note that the \"module\" top-level NamedType in the AbstractSyntaxNotation-X module is defined like so:",
      "zh-CHS": "请注意，AbstractSyntaxNotation-X模块中的“模块”顶级NamedType定义如下："
    },
    {
      "indent": 9,
      "text": "COMPONENT module ModuleDefinition",
      "zh-CHS": "组件模块定义"
    },
    {
      "indent": 6,
      "text": "The ASN.X translation of the SEQUENCE OF type definition provides a more natural representation:",
      "zh-CHS": "类型定义序列的ASN.X转换提供了更自然的表示："
    },
    {
      "indent": 9,
      "text": "<namedType xmlns:asnx=\"urn:ietf:params:xml:ns:asnx\"\n           name=\"Modules\">\n <sequenceOf>\n  <element ref=\"asnx:module\"/>\n </sequenceOf>\n</namedType>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "Aside: The <namedType> element in ASN.X corresponds to a TypeAssignment, not a NamedType.",
      "zh-CHS": "旁白：ASN.X中的<namedType>元素对应于类型分配，而不是namedType。"
    },
    {
      "indent": 3,
      "text": "The identifier of a NamedType subject to a COMPONENT-REF encoding instruction does not contribute to an RXER encoding. For the sake of consistency with other encoding rules, the identifier SHOULD be the same as the identifier in the ComponentRefInstruction.",
      "zh-CHS": "受COMPONENT-REF编码指令约束的NamedType的标识符不支持RXER编码。为了与其他编码规则保持一致，标识符应与ComponentRef指令中的标识符相同。"
    },
    {
      "indent": 0,
      "text": "11. The ELEMENT-REF Encoding Instruction",
      "section_title": true,
      "zh-CHS": "11. ELEMENT-REF编码指令"
    },
    {
      "indent": 3,
      "text": "The ELEMENT-REF encoding instruction causes an RXER encoder to encode a value of the component to which it is applied as an element where the element's name is a qualified name of the element declaration referenced by the encoding instruction. In addition, the ELEMENT-REF encoding instruction causes values of the Markup ASN.1 type to be restricted to conform to the type of the element declaration.",
      "zh-CHS": "ELEMENT-REF编码指令使RXER编码器将其应用到的组件的值编码为元素，其中元素名称是编码指令引用的元素声明的限定名称。此外，ELEMENT-REF编码指令会限制标记ASN.1类型的值，以符合元素声明的类型。"
    },
    {
      "indent": 3,
      "text": "The notation for an ELEMENT-REF encoding instruction is defined as follows:",
      "zh-CHS": "ELEMENT-REF编码指令的符号定义如下："
    },
    {
      "indent": 6,
      "text": "ElementRefInstruction ::= \"ELEMENT-REF\" QNameValue RefParameters",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Taken together, the QNameValue and the ContextParameter in the RefParameters (if present) MUST reference an XML Schema element declaration, a RELAX NG element definition, or a top-level NamedType that is not subject to an ATTRIBUTE encoding instruction.",
      "zh-CHS": "总之，RefParameters（如果存在）中的QNameValue和ContextParameter必须引用XML架构元素声明、RELAX NG元素定义或不受属性编码指令约束的顶级NamedType。"
    },
    {
      "indent": 3,
      "text": "A referenced XML Schema element declaration MUST NOT have a type that requires the presence of values for the XML Schema ENTITY or ENTITIES types.",
      "zh-CHS": "引用的XML架构元素声明的类型不能要求存在XML架构实体或实体类型的值。"
    },
    {
      "indent": 6,
      "text": "Aside: Entity declarations are not supported by CRXER.",
      "zh-CHS": "旁白：CRXER不支持实体声明。"
    },
    {
      "indent": 3,
      "text": "Example",
      "zh-CHS": "实例"
    },
    {
      "indent": 6,
      "text": "AnySchema ::= CHOICE {\n    module   [ELEMENT-REF {\n                 namespace-name\n                     \"urn:ietf:params:xml:ns:asnx\",\n                 local-name \"module\" }]\n             Markup,\n    schema   [ELEMENT-REF {\n                 namespace-name\n                     \"http://www.w3.org/2001/XMLSchema\",\n                 local-name \"schema\" }]\n             Markup,\n    grammar  [ELEMENT-REF {\n                 namespace-name\n                     \"http://relaxng.org/ns/structure/1.0\",\n                 local-name \"grammar\" }]\n             Markup\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "The ASN.X translation of the choice type definition provides a more natural representation:",
      "zh-CHS": "选择类型定义的ASN.X翻译提供了更自然的表示："
    },
    {
      "indent": 9,
      "text": "<namedType xmlns:asnx=\"urn:ietf:params:xml:ns:asnx\"\n           xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"\n           xmlns:rng=\"http://relaxng.org/ns/structure/1.0\"\n           name=\"AnySchema\">\n <choice>\n  <element ref=\"asnx:module\" embedded=\"true\"/>\n  <element ref=\"xs:schema\" embedded=\"true\"/>\n  <element ref=\"rng:grammar\" embedded=\"true\"/>\n </choice>\n</namedType>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The identifier of a NamedType subject to an ELEMENT-REF encoding instruction does not contribute to the name of an element in an RXER encoding. For the sake of consistency, the identifier SHOULD, where possible, be the same as the local name of the referenced element declaration.",
      "zh-CHS": "受ELEMENT-REF编码指令约束的NamedType的标识符不会对RXER编码中的元素名称起作用。为保持一致性，标识符应尽可能与被引用元素声明的本地名称相同。"
    },
    {
      "indent": 0,
      "text": "12. The LIST Encoding Instruction",
      "section_title": true,
      "zh-CHS": "12. 列表编码指令"
    },
    {
      "indent": 3,
      "text": "The LIST encoding instruction causes an RXER encoder to encode a value of a SEQUENCE OF type as a white-space-separated list of the component values.",
      "zh-CHS": "列表编码指令使RXER编码器将类型序列的值编码为以空格分隔的组件值列表。"
    },
    {
      "indent": 3,
      "text": "The notation for a LIST encoding instruction is defined as follows:",
      "zh-CHS": "列表编码指令的符号定义如下："
    },
    {
      "indent": 6,
      "text": "ListInstruction ::= \"LIST\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The Type in an EncodingPrefixedType for a LIST encoding instruction SHALL be either:",
      "zh-CHS": "列表编码指令的EncodingPrefixedType中的类型应为："
    },
    {
      "indent": 3,
      "text": "(1) a BuiltinType that is a SequenceOfType of the \"SEQUENCE OF NamedType\" form, or",
      "zh-CHS": "(1) 一种内置类型，它是“NamedType序列”表单的SequenceOfType，或"
    },
    {
      "indent": 3,
      "text": "(2) a ConstrainedType that is a TypeWithConstraint of the \"SEQUENCE Constraint OF NamedType\" form or \"SEQUENCE SizeConstraint OF NamedType\" form, or",
      "zh-CHS": "(2) 是“NamedType的序列约束”形式或“NamedType的序列大小约束”形式的TypeWithConstraint的ConstrainedType，或"
    },
    {
      "indent": 3,
      "text": "(3) a ConstrainedType that is not a TypeWithConstraint where the Type in the ConstrainedType is one of (1) to (5), or",
      "zh-CHS": "(3) 不是TypeWithConstraint的ConstrainedType，其中ConstrainedType中的类型为（1）到（5）之一，或"
    },
    {
      "indent": 3,
      "text": "(4) a BuiltinType that is a PrefixedType that is a TaggedType where the Type in the TaggedType is one of (1) to (5), or",
      "zh-CHS": "(4) 一种内置类型，其前缀类型为TaggedType，其中TaggedType中的类型为（1）到（5）之一，或"
    },
    {
      "indent": 3,
      "text": "(5) a BuiltinType that is a PrefixedType that is an EncodingPrefixedType where the Type in the EncodingPrefixedType is one of (1) to (5).",
      "zh-CHS": "(5) PrefixedType是EncodingPrefixedType的内置类型，其中EncodingPrefixedType中的类型为（1）到（5）之一。"
    },
    {
      "indent": 3,
      "text": "The effect of this condition is to force the LIST encoding instruction to be textually co-located with the SequenceOfType or TypeWithConstraint to which it applies.",
      "zh-CHS": "此条件的效果是强制列表编码指令与应用该指令的SequenceOfType或TypeWithConstraint在文本上共存。"
    },
    {
      "indent": 6,
      "text": "Aside: This makes it clear to a reader that the encoding instruction applies to every use of the type no matter how it might be referenced.",
      "zh-CHS": "旁白：这向读者清楚地表明，编码指令适用于类型的每一次使用，无论它如何被引用。"
    },
    {
      "indent": 3,
      "text": "The SequenceOfType in case (1) and the TypeWithConstraint in case (2) are said to be \"subject to\" the LIST encoding instruction.",
      "zh-CHS": "案例（1）中的类型序列和案例（2）中的类型WithConstraint被称为“服从”列表编码指令。"
    },
    {
      "indent": 3,
      "text": "A SequenceOfType or TypeWithConstraint SHALL NOT be subject to more than one LIST encoding instruction.",
      "zh-CHS": "类型序列或带有约束的类型不得受一个以上列表编码指令的约束。"
    },
    {
      "indent": 3,
      "text": "The base type of the component type of a SequenceOfType or TypeWithConstraint that is subject to a LIST encoding instruction MUST be one of the following:",
      "zh-CHS": "受列表编码指令约束的SequenceOfType或TypeWithConstraint的组件类型的基类型必须是以下类型之一："
    },
    {
      "indent": 3,
      "text": "(1) the BOOLEAN, INTEGER, ENUMERATED, REAL, OBJECT IDENTIFIER, RELATIVE-OID, GeneralizedTime, or UTCTime type, or",
      "zh-CHS": "(1) 布尔、整数、枚举、实数、对象标识符、相对OID、泛化时间或UTCTime类型，或"
    },
    {
      "indent": 3,
      "text": "(2) the NCName, AnyURI, Name, or QName type from the AdditionalBasicDefinitions module [RXER].",
      "zh-CHS": "(2) AdditionalBasicDefinitions模块[RXER]中的NCName、AnyURI、Name或QName类型。"
    },
    {
      "indent": 6,
      "text": "Aside: While it would be feasible to allow the component type to also be any character string type that is constrained such that all its abstract values have a length greater than zero and none of its abstract values contain any white space characters, testing whether this condition is satisfied can be quite involved. For the sake of simplicity, only certain immediately useful constrained UTF8String types, which are known to be suitable, are permitted (i.e., NCName, AnyURI, and Name).",
      "zh-CHS": "旁白：虽然允许组件类型也是任何字符串类型都是可行的，但它的所有抽象值的长度都大于零，并且它的抽象值都不包含任何空白字符，测试是否满足此条件可能会非常复杂。为了简单起见，只允许某些已知适合的立即有用的受约束UTF8String类型（即NCName、AnyURI和Name）。"
    },
    {
      "indent": 3,
      "text": "The NamedType in a SequenceOfType or TypeWithConstraint that is subject to a LIST encoding instruction MUST NOT be subject to an ATTRIBUTE, ATTRIBUTE-REF, COMPONENT-REF, GROUP, ELEMENT-REF, REF-AS-ELEMENT, SIMPLE-CONTENT, or TYPE-AS-VERSION encoding instruction.",
      "zh-CHS": "SequenceOfType或TypeWithConstraint中受列表编码指令约束的NamedType不能受属性、属性-REF、组件-REF、组、元素-REF、引用为元素、简单内容或类型为版本编码指令的约束。"
    },
    {
      "indent": 3,
      "text": "Example",
      "zh-CHS": "实例"
    },
    {
      "indent": 6,
      "text": "UpdateTimes ::= [LIST] SEQUENCE OF updateTime GeneralizedTime",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "13. The NAME Encoding Instruction",
      "section_title": true,
      "zh-CHS": "13. 名称编码指令"
    },
    {
      "indent": 3,
      "text": "The NAME encoding instruction causes an RXER encoder to use a nominated character string instead of a component's identifier wherever that identifier would otherwise appear in the encoding (e.g., as an element or attribute name).",
      "zh-CHS": "名称编码指令使RXER编码器使用指定的字符串，而不是组件的标识符，否则该标识符将出现在编码中（例如，作为元素或属性名称）。"
    },
    {
      "indent": 3,
      "text": "The notation for a NAME encoding instruction is defined as follows:",
      "zh-CHS": "名称编码指令的符号定义如下："
    },
    {
      "indent": 6,
      "text": "NameInstruction ::= \"NAME\" \"AS\"? NCNameValue",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Example",
      "zh-CHS": "实例"
    },
    {
      "indent": 6,
      "text": "CHOICE {\n    foo-att   [ATTRIBUTE] [NAME AS \"Foo\"] INTEGER,\n    foo-elem  [NAME \"Foo\"] INTEGER\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "14. The REF-AS-ELEMENT Encoding Instruction",
      "section_title": true,
      "zh-CHS": "14. REF-AS-ELEMENT编码指令"
    },
    {
      "indent": 3,
      "text": "The REF-AS-ELEMENT encoding instruction causes an RXER encoder to encode a value of the component to which it is applied as an element where the element's name is the name of the external DTD subset element type declaration referenced by the encoding instruction. In addition, the REF-AS-ELEMENT encoding instruction causes values of the Markup ASN.1 type to be restricted to conform to the content and attributes permitted by that element type declaration and its associated attribute-list declarations.",
      "zh-CHS": "REF-AS-ELEMENT编码指令使RXER编码器将其应用到的组件的值编码为元素，其中元素的名称是编码指令引用的外部DTD子集元素类型声明的名称。此外，REF-AS-ELEMENT编码指令会限制标记ASN.1类型的值，以符合该元素类型声明及其关联属性列表声明所允许的内容和属性。"
    },
    {
      "indent": 3,
      "text": "The notation for a REF-AS-ELEMENT encoding instruction is defined as follows:",
      "zh-CHS": "REF-AS-ELEMENT编码指令的符号定义如下："
    },
    {
      "indent": 6,
      "text": "RefAsElementInstruction ::=\n    \"REF-AS-ELEMENT\" NameValue Namespace ? RefParameters",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "Namespace ::= \"NAMESPACE\" AnyURIValue",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Taken together, the NameValue and the ContextParameter in the RefParameters (if present) MUST reference an element type declaration in an external DTD subset that is conformant with Namespaces in XML 1.0 [XMLNS10].",
      "zh-CHS": "总之，RefParameters（如果存在）中的NameValue和ContextParameter必须引用外部DTD子集中的元素类型声明，该子集符合XML 1.0[XMLNS10]中的名称空间。"
    },
    {
      "indent": 3,
      "text": "The Namespace is present if and only if the Name of the referenced element type declaration conforms to a PrefixedName (a QName) [XMLNS10], in which case the Namespace specifies the namespace name to be associated with the Prefix of the PrefixedName.",
      "zh-CHS": "当且仅当引用的元素类型声明的名称符合PrefixedName（QName）[XMLNS10]时，才存在名称空间，在这种情况下，名称空间指定要与PrefixedName的前缀关联的名称空间名称。"
    },
    {
      "indent": 3,
      "text": "The referenced element type declaration MUST NOT require the presence of attributes of type ENTITY or ENTITIES.",
      "zh-CHS": "引用的元素类型声明不得要求存在一个或多个实体类型的属性。"
    },
    {
      "indent": 6,
      "text": "Aside: Entity declarations are not supported by CRXER.",
      "zh-CHS": "旁白：CRXER不支持实体声明。"
    },
    {
      "indent": 3,
      "text": "Example",
      "zh-CHS": "实例"
    },
    {
      "indent": 6,
      "text": "Suppose that the following external DTD subset has been defined with a system identifier of \"http://www.example.com/inventory\":",
      "zh-CHS": "假设以下外部DTD子集已定义为系统标识符“http://www.example.com/inventory\":"
    },
    {
      "indent": 9,
      "text": "<?xml version='1.0'?>\n<!ELEMENT product EMPTY>\n<!ATTLIST product\n    name       CDATA #IMPLIED\n    partNumber CDATA #REQUIRED\n    quantity   CDATA #REQUIRED >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "The product element type declaration can be referenced as an element in an ASN.1 type definition:",
      "zh-CHS": "产品元素类型声明可以作为ASN.1类型定义中的元素引用："
    },
    {
      "indent": 9,
      "text": "CHOICE {\n    product  [REF-AS-ELEMENT \"product\"\n                 CONTEXT \"http://www.example.com/inventory\"]\n             Markup\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "Here is the ASN.X translation of this ASN.1 type definition:",
      "zh-CHS": "以下是此ASN.1类型定义的ASN.X翻译："
    },
    {
      "indent": 9,
      "text": "<type>\n <choice>\n  <element elementType=\"product\"\n           context=\"http://www.example.com/inventory\"/>\n </choice>\n</type>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The identifier of a NamedType subject to a REF-AS-ELEMENT encoding instruction does not contribute to the name of an element in an RXER encoding. For the sake of consistency, the identifier SHOULD, where possible, be the same as the Name of the referenced element type declaration (or the LocalPart if the Name conforms to a PrefixedName).",
      "zh-CHS": "受REF-AS-ELEMENT编码指令约束的NamedType的标识符不影响RXER编码中的元素名称。为保持一致性，标识符应尽可能与引用的元素类型声明的名称相同（如果名称符合前缀名称，则与LocalPart相同）。"
    },
    {
      "indent": 0,
      "text": "15. The REF-AS-TYPE Encoding Instruction",
      "section_title": true,
      "zh-CHS": "15. REF-AS-TYPE编码指令"
    },
    {
      "indent": 3,
      "text": "The REF-AS-TYPE encoding instruction causes values of the Markup ASN.1 type to be restricted to conform to the content and attributes permitted by a nominated element type declaration and its associated attribute-list declarations in an external DTD subset.",
      "zh-CHS": "REF-AS-TYPE编码指令使标记ASN.1类型的值受到限制，以符合外部DTD子集中指定元素类型声明及其关联属性列表声明所允许的内容和属性。"
    },
    {
      "indent": 3,
      "text": "The notation for a REF-AS-TYPE encoding instruction is defined as follows:",
      "zh-CHS": "REF-AS-TYPE编码指令的符号定义如下："
    },
    {
      "indent": 6,
      "text": "RefAsTypeInstruction ::= \"REF-AS-TYPE\" NameValue RefParameters",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Taken together, the NameValue and the ContextParameter of the RefParameters (if present) MUST reference an element type declaration in an external DTD subset that is conformant with Namespaces in XML 1.0 [XMLNS10].",
      "zh-CHS": "总之，RefParameters（如果存在）的NameValue和ContextParameter必须引用外部DTD子集中的元素类型声明，该子集符合XML 1.0[XMLNS10]中的名称空间。"
    },
    {
      "indent": 3,
      "text": "The referenced element type declaration MUST NOT require the presence of attributes of type ENTITY or ENTITIES.",
      "zh-CHS": "引用的元素类型声明不得要求存在一个或多个实体类型的属性。"
    },
    {
      "indent": 6,
      "text": "Aside: Entity declarations are not supported by CRXER.",
      "zh-CHS": "旁白：CRXER不支持实体声明。"
    },
    {
      "indent": 3,
      "text": "Example",
      "zh-CHS": "实例"
    },
    {
      "indent": 6,
      "text": "The product element type declaration can be referenced as a type in an ASN.1 definition:",
      "zh-CHS": "产品元素类型声明可以作为ASN.1定义中的类型引用："
    },
    {
      "indent": 9,
      "text": "SEQUENCE OF inventoryItem [REF-AS-TYPE \"product\" CONTEXT \"http://www.example.com/inventory\"] Markup",
      "zh-CHS": "库存项目的顺序[REF-AS-TYPE“产品”上下文”http://www.example.com/inventory“]标记"
    },
    {
      "indent": 6,
      "text": "Here is the ASN.X translation of this definition:",
      "zh-CHS": "以下是该定义的ASN.X翻译："
    },
    {
      "indent": 9,
      "text": "<sequenceOf>\n <element name=\"inventoryItem\">\n  <type elementType=\"product\"\n        context=\"http://www.example.com/inventory\"/>\n </element>\n</sequenceOf>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "Note that when an element type declaration is referenced as a type, the Name of the element type declaration does not contribute to RXER encodings. For example, child elements in the RXER encoding of values of the above SEQUENCE OF type would resemble the following:",
      "zh-CHS": "请注意，当元素类型声明被引用为类型时，元素类型声明的名称不会影响RXER编码。例如，上述类型序列值的RXER编码中的子元素类似于以下内容："
    },
    {
      "indent": 9,
      "text": "<inventoryItem name=\"hammer\" partNumber=\"1543\" quantity=\"29\"/>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "16. The SCHEMA-IDENTITY Encoding Instruction",
      "section_title": true,
      "zh-CHS": "16. SCHEMA-IDENTITY编码指令"
    },
    {
      "indent": 3,
      "text": "The SCHEMA-IDENTITY encoding instruction associates a unique identifier, a URI [URI], with the ASN.1 module containing the encoding instruction. This encoding instruction has no effect on an RXER encoder but does have an effect on the translation of an ASN.1 specification into an ASN.X representation.",
      "zh-CHS": "SCHEMA-IDENTITY编码指令将唯一标识符URI[URI]与包含编码指令的ASN.1模块相关联。此编码指令对RXER编码器没有影响，但对ASN.1规范转换为ASN.X表示有影响。"
    },
    {
      "indent": 3,
      "text": "The notation for a SCHEMA-IDENTITY encoding instruction is defined as follows:",
      "zh-CHS": "模式标识编码指令的符号定义如下："
    },
    {
      "indent": 6,
      "text": "SchemaIdentityInstruction ::= \"SCHEMA-IDENTITY\" AnyURIValue",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The character string specified by the AnyURIValue of each SCHEMA-IDENTITY encoding instruction MUST be distinct. In particular, successive versions of an ASN.1 module must each have a different schema identity URI value.",
      "zh-CHS": "每个SCHEMA-IDENTITY编码指令的AnyURIValue指定的字符串必须是不同的。特别是，ASN.1模块的后续版本必须具有不同的模式标识URI值。"
    },
    {
      "indent": 0,
      "text": "17. The SIMPLE-CONTENT Encoding Instruction",
      "section_title": true,
      "zh-CHS": "17. 简单内容编码指令"
    },
    {
      "indent": 3,
      "text": "The SIMPLE-CONTENT encoding instruction causes an RXER encoder to encode a value of a component of a SEQUENCE or SET type without encapsulation in a child element.",
      "zh-CHS": "简单内容编码指令使RXER编码器对序列或集合类型的组件的值进行编码，而不封装在子元素中。"
    },
    {
      "indent": 3,
      "text": "The notation for a SIMPLE-CONTENT encoding instruction is defined as follows:",
      "zh-CHS": "简单内容编码指令的符号定义如下："
    },
    {
      "indent": 6,
      "text": "SimpleContentInstruction ::= \"SIMPLE-CONTENT\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "A NamedType subject to a SIMPLE-CONTENT encoding instruction SHALL be in a ComponentType in a ComponentTypeList in a RootComponentTypeList. At most one such NamedType of a SEQUENCE or SET type is permitted to be subject to a SIMPLE-CONTENT encoding instruction. If any component is subject to a SIMPLE-CONTENT encoding instruction, then all other components in the same SEQUENCE or SET type definition MUST be attribute components. These tests are applied after the COMPONENTS OF transformation specified in X.680, Clause 24.4 [X.680].",
      "zh-CHS": "受简单内容编码指令约束的命名类型应位于根ComponentTypeList中ComponentTypeList中的ComponentType中。序列或集合类型中最多允许有一个这样的NamedType接受简单内容编码指令。如果任何组件受简单内容编码指令的约束，则相同序列或集合类型定义中的所有其他组件都必须是属性组件。这些试验在X.680第24.4条[X.680]中规定的转换组件之后进行。"
    },
    {
      "indent": 6,
      "text": "Aside: Child elements and simple content are mutually exclusive. Specification writers should note that use of the SIMPLE-CONTENT encoding instruction on a component of an extensible SEQUENCE or SET type means that all future extensions to the SEQUENCE or SET type are restricted to being attribute components with the limited set of types that are permitted for attribute components. Using an ATTRIBUTE encoding instruction instead of a SIMPLE-CONTENT encoding instruction avoids this limitation.",
      "zh-CHS": "旁白：子元素和简单内容是相互排斥的。规范编写者应该注意，在可扩展序列或集合类型的组件上使用简单内容编码指令意味着序列或集合类型的所有未来扩展都被限制为具有属性组件所允许的有限类型集的属性组件。使用属性编码指令而不是简单内容编码指令可以避免此限制。"
    },
    {
      "indent": 3,
      "text": "The base type of the type of a NamedType that is subject to a SIMPLE-CONTENT encoding instruction SHALL NOT be:",
      "zh-CHS": "受简单内容编码指令约束的NamedType类型的基本类型不得为："
    },
    {
      "indent": 3,
      "text": "(1) a SET or SET OF type, or",
      "zh-CHS": "(1) 一套或一套类型，或"
    },
    {
      "indent": 3,
      "text": "(2) a CHOICE type where the ChoiceType is not subject to a UNION encoding instruction, or",
      "zh-CHS": "(2) 选择类型不受联合编码指令约束的选择类型，或"
    },
    {
      "indent": 3,
      "text": "(3) a SEQUENCE type other than the one defining the QName type from the AdditionalBasicDefinitions module [RXER] (i.e., QName is allowed), or",
      "zh-CHS": "(3) 序列类型，而不是从AdditionalBasicDefinitions模块[RXER]定义QName类型的序列类型（即，允许使用QName），或"
    },
    {
      "indent": 3,
      "text": "(4) a SEQUENCE OF type where the SequenceOfType is not subject to a LIST encoding instruction, or",
      "zh-CHS": "(4) 一种类型序列，其中SequenceOfType不受列表编码指令的约束，或"
    },
    {
      "indent": 3,
      "text": "(5) an open type.",
      "zh-CHS": "(5) 开放式。"
    },
    {
      "indent": 3,
      "text": "If the type of a NamedType subject to a SIMPLE-CONTENT encoding instruction has abstract values with an empty character data translation [RXER] (i.e., an empty encoding), then the NamedType SHALL NOT be marked OPTIONAL or DEFAULT.",
      "zh-CHS": "如果受简单内容编码指令约束的NamedType类型具有空字符数据转换[RXER]（即空编码）的抽象值，则NamedType不应标记为可选或默认。"
    },
    {
      "indent": 3,
      "text": "Example",
      "zh-CHS": "实例"
    },
    {
      "indent": 6,
      "text": "SEQUENCE {\n    units   [ATTRIBUTE] UTF8String,\n    amount  [SIMPLE-CONTENT] INTEGER\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "18. The TARGET-NAMESPACE Encoding Instruction",
      "section_title": true,
      "zh-CHS": "18. 目标命名空间编码指令"
    },
    {
      "indent": 3,
      "text": "The TARGET-NAMESPACE encoding instruction associates an XML namespace name [XMLNS10], a URI [URI], with the type, object class, value, object, and object set references defined in the ASN.1 module containing the encoding instruction. In addition, it associates the namespace name with each top-level NamedType in the RXER encoding control section.",
      "zh-CHS": "TARGET-NAMESPACE编码指令将XML命名空间名称[XMLNS10]、URI[URI]与包含编码指令的ASN.1模块中定义的类型、对象类、值、对象和对象集引用相关联。此外，它将名称空间名称与RXER编码控制部分中的每个顶级NamedType相关联。"
    },
    {
      "indent": 3,
      "text": "The notation for a TARGET-NAMESPACE encoding instruction is defined as follows:",
      "zh-CHS": "目标命名空间编码指令的符号定义如下："
    },
    {
      "indent": 6,
      "text": "TargetNamespaceInstruction ::=\n    \"TARGET-NAMESPACE\" AnyURIValue Prefix ?",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "Prefix ::= \"PREFIX\" NCNameValue",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The AnyURIValue SHALL NOT specify an empty string.",
      "zh-CHS": "AnyURIValue不应指定空字符串。"
    },
    {
      "indent": 3,
      "text": "Definition (target namespace): If an ASN.1 module contains a TARGET-NAMESPACE encoding instruction, then the target namespace of the module is the character string specified by the AnyURIValue of the TARGET-NAMESPACE encoding instruction; otherwise, the target namespace of the module is said to be absent.",
      "zh-CHS": "定义（目标名称空间）：如果ASN.1模块包含目标名称空间编码指令，则模块的目标名称空间是由目标名称空间编码指令的AnyURIValue指定的字符串；否则，称模块的目标命名空间不存在。"
    },
    {
      "indent": 3,
      "text": "Two or more ASN.1 modules MAY have the same non-absent target namespace if and only if the expanded names of the top-level attribute components are distinct across all those modules, the expanded names of the top-level element components are distinct across all those modules, and the defined type, object class, value, object, and object set references are distinct in their category across all those modules.",
      "zh-CHS": "两个或多个ASN.1模块可能具有相同的非缺失目标命名空间，当且仅当顶级属性组件的扩展名称在所有这些模块中是不同的，顶级元素组件的扩展名称在所有这些模块中是不同的，并且定义的类型、对象类、值、对象、，对象集引用在所有这些模块中的类别是不同的。"
    },
    {
      "indent": 3,
      "text": "The Prefix, if present, suggests an NCName to use as the namespace prefix in namespace declarations involving the target namespace. An RXER encoder is not obligated to use the nominated namespace prefix.",
      "zh-CHS": "前缀（如果存在）建议在涉及目标命名空间的命名空间声明中使用NCName作为命名空间前缀。RXER编码器没有义务使用指定的名称空间前缀。"
    },
    {
      "indent": 3,
      "text": "If there are no top-level components, then the RXER encodings produced using a module with a TARGET-NAMESPACE encoding instruction are backward compatible with the RXER encodings produced by the same module without the TARGET-NAMESPACE encoding instruction.",
      "zh-CHS": "如果没有顶级组件，则使用带有目标命名空间编码指令的模块生成的RXER编码与不带目标命名空间编码指令的相同模块生成的RXER编码向后兼容。"
    },
    {
      "indent": 0,
      "text": "19. The TYPE-AS-VERSION Encoding Instruction",
      "section_title": true,
      "zh-CHS": "19. TYPE-AS-VERSION编码指令"
    },
    {
      "indent": 3,
      "text": "The TYPE-AS-VERSION encoding instruction causes an RXER encoder to include an xsi:type attribute in the encoding of a value of the component to which the encoding instruction is applied. This attribute allows an XML Schema [XSD1] validator to select, if available, the appropriate XML Schema translation for the version of the ASN.1 specification used to create the encoding.",
      "zh-CHS": "TYPE-AS-VERSION编码指令使RXER编码器在对应用编码指令的组件的值进行编码时包含xsi:TYPE属性。此属性允许XMLSchema[XSD1]验证器为用于创建编码的ASN.1规范版本选择适当的XML模式转换（如果可用）。"
    },
    {
      "indent": 6,
      "text": "Aside: Translations of an ASN.1 specification into a compatible XML Schema are expected to be slightly different across versions because of progressive extensions to the ASN.1 specification. Any incompatibilities between these translations can be accommodated if each version uses a different target namespace. The target namespace will be evident in the value of the xsi:type attribute and will cause an XML Schema validator to use the appropriate version. This mechanism also accommodates an ASN.1 type that is renamed in a later version of the ASN.1 specification.",
      "zh-CHS": "旁白：ASN.1规范到兼容的XML模式的转换在不同版本之间预计会略有不同，因为ASN.1规范的渐进扩展。如果每个版本使用不同的目标名称空间，则可以解决这些翻译之间的任何不兼容问题。目标名称空间将在xsi:type属性的值中显示，并将导致XML模式验证器使用适当的版本。该机制还支持在ASN.1规范的更高版本中重命名的ASN.1类型。"
    },
    {
      "indent": 3,
      "text": "The notation for a TYPE-AS-VERSION encoding instruction is defined as follows:",
      "zh-CHS": "TYPE-AS-VERSION编码指令的符号定义如下："
    },
    {
      "indent": 6,
      "text": "TypeAsVersionInstruction ::= \"TYPE-AS-VERSION\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The Type in a NamedType that is subject to a TYPE-AS-VERSION encoding instruction MUST be a namespace-qualified reference [RXER].",
      "zh-CHS": "NamedType中服从“类型为版本”编码指令的类型必须是命名空间限定引用[RXER]。"
    },
    {
      "indent": 3,
      "text": "The addition of a TYPE-AS-VERSION encoding instruction does not affect the backward compatibility of RXER encodings.",
      "zh-CHS": "添加类型转换编码指令不会影响RXER编码的向后兼容性。"
    },
    {
      "indent": 6,
      "text": "Aside: In a translation of an ASN.1 specification into XML Schema, any Type in a NamedType that is subject to a TYPE-AS-VERSION encoding instruction is expected to be translated into the XML Schema anyType so that the xsi:type attribute acts as a switch to select the appropriate version.",
      "zh-CHS": "旁白：在将ASN.1规范转换为XML模式时，NamedType中受Type-AS-VERSION编码指令约束的任何类型都应转换为XML模式anyType，以便xsi:Type属性充当选择适当版本的开关。"
    },
    {
      "indent": 0,
      "text": "20. The TYPE-REF Encoding Instruction",
      "section_title": true,
      "zh-CHS": "20. TYPE-REF编码指令"
    },
    {
      "indent": 3,
      "text": "The TYPE-REF encoding instruction causes values of the Markup ASN.1 type to be restricted to conform to a specific XML Schema named type, RELAX NG named pattern or an ASN.1 defined type.",
      "zh-CHS": "TYPE-REF编码指令导致标记ASN.1类型的值被限制为符合名为TYPE、RELAX-NG-named-pattern或ASN.1定义类型的特定XML模式。"
    },
    {
      "indent": 6,
      "text": "Aside: Referencing an ASN.1 type in a TYPE-REF encoding instruction does not have the effect of imposing a requirement to preserve the Infoset [INFOSET] representation of the RXER encoding of an abstract value of the type. It is still sufficient to preserve just the abstract value.",
      "zh-CHS": "旁白：在type-REF编码指令中引用ASN.1类型不会产生强制要求保留该类型抽象值的RXER编码的Infoset[Infoset]表示的效果。仅保留抽象值就足够了。"
    },
    {
      "indent": 3,
      "text": "The notation for a TYPE-REF encoding instruction is defined as follows:",
      "zh-CHS": "TYPE-REF编码指令的符号定义如下："
    },
    {
      "indent": 6,
      "text": "TypeRefInstruction ::= \"TYPE-REF\" QNameValue RefParameters",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Taken together, the QNameValue and the ContextParameter of the RefParameters (if present) MUST reference an XML Schema named type, a RELAX NG named pattern, or an ASN.1 defined type.",
      "zh-CHS": "总之，RefParameters的QNameValue和ContextParameter（如果存在）必须引用名为type的XML模式、名为RELAXNG的模式或ASN.1定义的类型。"
    },
    {
      "indent": 3,
      "text": "A referenced XML Schema type MUST NOT require the presence of values for the XML Schema ENTITY or ENTITIES types.",
      "zh-CHS": "引用的XML架构类型不得要求存在XML架构实体或实体类型的值。"
    },
    {
      "indent": 6,
      "text": "Aside: Entity declarations are not supported by CRXER.",
      "zh-CHS": "旁白：CRXER不支持实体声明。"
    },
    {
      "indent": 3,
      "text": "The QNameValue SHALL NOT be a direct reference to the XML Schema NOTATION type [XSD2] (i.e., the namespace name \"http://www.w3.org/2001/XMLSchema\" and local name \"NOTATION\"); however, a reference to an XML Schema type derived from the NOTATION type is permitted.",
      "zh-CHS": "QNameValue不能直接引用XML模式表示法类型[XSD2]（即名称空间名称）http://www.w3.org/2001/XMLSchema“和本地名称”符号）；但是，允许引用从标记类型派生的XML模式类型。"
    },
    {
      "indent": 6,
      "text": "Aside: This restriction is to ensure that the lexical space [XSD2] of the referenced type is actually populated with the names of notations [XSD1].",
      "zh-CHS": "旁白：此限制是为了确保引用类型的词法空间[XSD2]实际上填充了符号[XSD1]的名称。"
    },
    {
      "indent": 3,
      "text": "Example",
      "zh-CHS": "实例"
    },
    {
      "indent": 6,
      "text": "MyDecimal ::=\n    [TYPE-REF {\n        namespace-name \"http://www.w3.org/2001/XMLSchema\",\n        local-name     \"decimal\" }]\n    Markup",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "Note that the ASN.X translation of this ASN.1 type definition provides a more natural way to reference the XML Schema decimal type:",
      "zh-CHS": "请注意，此ASN.1类型定义的ASN.X转换提供了一种更自然的方式来引用XML模式十进制类型："
    },
    {
      "indent": 9,
      "text": "<namedType xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"\n           name=\"MyDecimal\">\n <type ref=\"xs:decimal\" embedded=\"true\"/>\n</namedType>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "21. The UNION Encoding Instruction",
      "section_title": true,
      "zh-CHS": "21. 联合编码指令"
    },
    {
      "indent": 3,
      "text": "The UNION encoding instruction causes an RXER encoder to encode the value of an alternative of a CHOICE type without encapsulation in a child element. The chosen alternative is optionally indicated with a member attribute. The optional PrecedenceList also allows a specification writer to alter the order in which an RXER decoder will consider the alternatives of the CHOICE as it determines which alternative has been used (if the actual alternative has not been specified through the member attribute).",
      "zh-CHS": "UNION encoding指令使RXER编码器对选择类型的替代值进行编码，而不封装在子元素中。所选备选方案可选地用成员属性表示。可选的优先权也允许规范写入器改变RXER解码器将考虑选择的替代品的顺序，因为它决定了使用了哪个替代品（如果实际的替代品没有通过成员属性指定）。"
    },
    {
      "indent": 3,
      "text": "The notation for a UNION encoding instruction is defined as follows:",
      "zh-CHS": "联合编码指令的符号定义如下："
    },
    {
      "indent": 6,
      "text": "UnionInstruction ::= \"UNION\" AlternativesPrecedence ?",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "AlternativesPrecedence ::= \"PRECEDENCE\" PrecedenceList",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "PrecedenceList ::= identifier PrecedenceList ?",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The Type in the EncodingPrefixedType for a UNION encoding instruction SHALL be either:",
      "zh-CHS": "联合编码指令的EncodingPrefixedType中的类型应为："
    },
    {
      "indent": 3,
      "text": "(1) a BuiltinType that is a ChoiceType, or",
      "zh-CHS": "(1) 选择类型的内置类型，或"
    },
    {
      "indent": 3,
      "text": "(2) a ConstrainedType that is not a TypeWithConstraint where the Type in the ConstrainedType is one of (1) to (4), or",
      "zh-CHS": "(2) 不是TypeWithConstraint的ConstrainedType，其中ConstrainedType中的类型为（1）到（4）之一，或"
    },
    {
      "indent": 3,
      "text": "(3) a BuiltinType that is a PrefixedType that is a TaggedType where the Type in the TaggedType is one of (1) to (4), or",
      "zh-CHS": "(3) 一种内置类型，其前缀类型为TaggedType，其中TaggedType中的类型为（1）到（4）之一，或"
    },
    {
      "indent": 3,
      "text": "(4) a BuiltinType that is a PrefixedType that is an EncodingPrefixedType where the Type in the EncodingPrefixedType is one of (1) to (4).",
      "zh-CHS": "(4) PrefixedType的内置类型，该类型是EncodingPrefixedType，其中EncodingPrefixedType中的类型是（1）到（4）之一。"
    },
    {
      "indent": 3,
      "text": "The ChoiceType in case (1) is said to be \"subject to\" the UNION encoding instruction.",
      "zh-CHS": "案例（1）中的ChoiceType被称为“服从”联合编码指令。"
    },
    {
      "indent": 3,
      "text": "The base type of the type of each alternative of a ChoiceType that is subject to a UNION encoding instruction SHALL NOT be:",
      "zh-CHS": "受联合编码指令约束的ChoiceType的每个备选类型的基本类型不得为："
    },
    {
      "indent": 3,
      "text": "(1) a CHOICE, SET, or SET OF type, or",
      "zh-CHS": "(1) 类型的选择、集合或集合，或"
    },
    {
      "indent": 3,
      "text": "(2) a SEQUENCE type other than the one defining the QName type from the AdditionalBasicDefinitions module [RXER] (i.e., QName is allowed), or",
      "zh-CHS": "(2) 序列类型，而不是从AdditionalBasicDefinitions模块[RXER]定义QName类型的序列类型（即，允许使用QName），或"
    },
    {
      "indent": 3,
      "text": "(3) a SEQUENCE OF type where the SequenceOfType is not subject to a LIST encoding instruction, or",
      "zh-CHS": "(3) 一种类型序列，其中SequenceOfType不受列表编码指令的约束，或"
    },
    {
      "indent": 3,
      "text": "(4) an open type.",
      "zh-CHS": "(4) 开放式。"
    },
    {
      "indent": 3,
      "text": "Each identifier in the PrecedenceList MUST be the identifier of a NamedType in the ChoiceType.",
      "zh-CHS": "PrecenceList中的每个标识符都必须是ChoiceType中NamedType的标识符。"
    },
    {
      "indent": 3,
      "text": "A particular identifier SHALL NOT appear more than once in the same PrecedenceList.",
      "zh-CHS": "特定标识符在同一优先列表中不得出现多次。"
    },
    {
      "indent": 3,
      "text": "Every NamedType in a ChoiceType that is subject to a UNION encoding instruction MUST NOT be subject to an ATTRIBUTE, ATTRIBUTE-REF, COMPONENT-REF, GROUP, ELEMENT-REF, REF-AS-ELEMENT, SIMPLE-CONTENT, or TYPE-AS-VERSION encoding instruction.",
      "zh-CHS": "ChoiceType中受联合编码指令约束的每个NamedType不得受属性、属性-REF、组件-REF、组、元素-REF、REF-AS-ELEMENT、简单内容或类型-AS-VERSION编码指令约束。"
    },
    {
      "indent": 3,
      "text": "Example",
      "zh-CHS": "实例"
    },
    {
      "indent": 6,
      "text": "[UNION PRECEDENCE basicName] CHOICE {\n    extendedName  UTF8String,\n    basicName     PrintableString\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "22. The VALUES Encoding Instruction",
      "section_title": true,
      "zh-CHS": "22. 值编码指令"
    },
    {
      "indent": 3,
      "text": "The VALUES encoding instruction causes an RXER encoder to use nominated names instead of the identifiers that would otherwise appear in the encoding of a value of a BIT STRING, ENUMERATED, or INTEGER type.",
      "zh-CHS": "VALUES encoding指令使RXER编码器使用指定名称，而不是在编码位字符串、枚举或整数类型的值时出现的标识符。"
    },
    {
      "indent": 3,
      "text": "The notation for a VALUES encoding instruction is defined as follows:",
      "zh-CHS": "值编码指令的符号定义如下："
    },
    {
      "indent": 6,
      "text": "ValuesInstruction ::=\n    \"VALUES\" AllValuesMapped ? ValueMappingList ?",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "AllValuesMapped ::= AllCapitalized | AllUppercased",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "AllCapitalized ::= \"ALL\" \"CAPITALIZED\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "AllUppercased ::= \"ALL\" \"UPPERCASED\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "ValueMappingList ::= ValueMapping ValueMappingList ?",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "ValueMapping ::= \",\" identifier \"AS\" NCNameValue",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The Type in the EncodingPrefixedType for a VALUES encoding instruction SHALL be either:",
      "zh-CHS": "值编码指令的EncodingPrefixedType中的类型应为："
    },
    {
      "indent": 3,
      "text": "(1) a BuiltinType that is a BitStringType with a NamedBitList, or",
      "zh-CHS": "(1) 一种内置类型，它是具有NamedBitList的BitStringType，或"
    },
    {
      "indent": 3,
      "text": "(2) a BuiltinType that is an EnumeratedType, or",
      "zh-CHS": "(2) EnumeratedType的内置类型，或"
    },
    {
      "indent": 3,
      "text": "(3) a BuiltinType that is an IntegerType with a NamedNumberList, or",
      "zh-CHS": "(3) 一种内置类型，它是名为Number List的IntegerType，或"
    },
    {
      "indent": 3,
      "text": "(4) a ConstrainedType that is not a TypeWithConstraint where the Type in the ConstrainedType is one of (1) to (6), or",
      "zh-CHS": "(4) 不是TypeWithConstraint的ConstrainedType，其中ConstrainedType中的类型为（1）到（6）之一，或"
    },
    {
      "indent": 3,
      "text": "(5) a BuiltinType that is a PrefixedType that is a TaggedType where the Type in the TaggedType is one of (1) to (6), or",
      "zh-CHS": "(5) 一种内置类型，其前缀类型为TaggedType，其中TaggedType中的类型为（1）到（6）之一，或"
    },
    {
      "indent": 3,
      "text": "(6) a BuiltinType that is a PrefixedType that is an EncodingPrefixedType where the Type in the EncodingPrefixedType is one of (1) to (6).",
      "zh-CHS": "(6) PrefixedType的内置类型，该类型是EncodingPrefixedType，其中EncodingPrefixedType中的类型是（1）到（6）之一。"
    },
    {
      "indent": 3,
      "text": "The effect of this condition is to force the VALUES encoding instruction to be textually co-located with the type definition to which it applies.",
      "zh-CHS": "此条件的效果是强制值编码指令在文本上与其应用的类型定义位于同一位置。"
    },
    {
      "indent": 3,
      "text": "The BitStringType, EnumeratedType, or IntegerType in case (1), (2), or (3), respectively, is said to be \"subject to\" the VALUES encoding instruction.",
      "zh-CHS": "在第（1）、（2）或（3）种情况下，BitStringType、EnumeratedType或IntegerType分别被称为“服从”值编码指令。"
    },
    {
      "indent": 3,
      "text": "A BitStringType, EnumeratedType, or IntegerType SHALL NOT be subject to more than one VALUES encoding instruction.",
      "zh-CHS": "BitStringType、EnumeratedType或IntegerType不得接受多个值编码指令。"
    },
    {
      "indent": 3,
      "text": "Each identifier in a ValueMapping MUST be an identifier appearing in the NamedBitList, Enumerations, or NamedNumberList, as the case may be.",
      "zh-CHS": "ValueMapping中的每个标识符都必须是出现在NamedBitList、Enumerations或NamedNumber列表中的标识符（视情况而定）。"
    },
    {
      "indent": 3,
      "text": "The identifier in a ValueMapping SHALL NOT be the same as the identifier in any other ValueMapping for the same ValueMappingList.",
      "zh-CHS": "ValueMappingList的ValueMapping中的标识符不得与任何其他ValueMapping中的标识符相同。"
    },
    {
      "indent": 3,
      "text": "Definition (replacement name): Each identifier in a BitStringType, EnumeratedType, or IntegerType subject to a VALUES encoding instruction has a replacement name. If there is a ValueMapping for the identifier, then the replacement name is the character string specified by the NCNameValue in the ValueMapping; else if AllCapitalized is used, then the replacement name is the identifier with the first character uppercased; else if AllUppercased is used, then the replacement name is the identifier with all its characters uppercased; otherwise, the replacement name is the identifier.",
      "zh-CHS": "定义（替换名称）：受值编码指令约束的BitStringType、EnumeratedType或IntegerType中的每个标识符都有一个替换名称。如果标识符存在ValueMapping，则替换名称为ValueMapping中NCNameValue指定的字符串；否则，如果使用AllCapitalized，则替换名称是第一个字符大写的标识符；否则，如果使用AllUppercased，则替换名称是标识符，其所有字符都大写；否则，替换名称就是标识符。"
    },
    {
      "indent": 3,
      "text": "The replacement names for the identifiers in a BitStringType subject to a VALUES encoding instruction MUST be distinct.",
      "zh-CHS": "受值编码指令约束的BitStringType中标识符的替换名称必须是不同的。"
    },
    {
      "indent": 3,
      "text": "The replacement names for the identifiers in an EnumeratedType subject to a VALUES encoding instruction MUST be distinct.",
      "zh-CHS": "受值编码指令约束的EnumeratedType中标识符的替换名称必须是不同的。"
    },
    {
      "indent": 3,
      "text": "The replacement names for the identifiers in an IntegerType subject to a VALUES encoding instruction MUST be distinct.",
      "zh-CHS": "服从值编码指令的IntegerType中标识符的替换名称必须是不同的。"
    },
    {
      "indent": 3,
      "text": "Example",
      "zh-CHS": "实例"
    },
    {
      "indent": 6,
      "text": "Traffic-Light ::= [VALUES ALL CAPITALIZED, red AS \"RED\"]\n    ENUMERATED {\n        red,    -- Replacement name is RED.\n        amber,  -- Replacement name is Amber.\n        green   -- Replacement name is Green.\n    }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "23. Insertion Encoding Instructions",
      "section_title": true,
      "zh-CHS": "23. 插入编码指令"
    },
    {
      "indent": 3,
      "text": "Certain of the RXER encoding instructions are categorized as insertion encoding instructions. The insertion encoding instructions are the NO-INSERTIONS, HOLLOW-INSERTIONS, SINGULAR-INSERTIONS, UNIFORM-INSERTIONS, and MULTIFORM-INSERTIONS encoding instructions (whose notations are described respectively by NoInsertionsInstruction, HollowInsertionsInstruction, SingularInsertionsInstruction, UniformInsertionsInstruction, and MultiformInsertionsInstruction).",
      "zh-CHS": "某些RXER编码指令被归类为插入编码指令。插入编码指令有无插入、空插入、单插入、均匀插入和多形式插入编码指令（其符号分别由NOINSERTIONS指令、HOLLOWINSERTIONS指令、SingularInsERTIONS指令、UniformInsERTIONS指令和MultiformInsERTIONS指令描述）。"
    },
    {
      "indent": 3,
      "text": "The notation for the insertion encoding instructions is defined as follows:",
      "zh-CHS": "插入编码指令的符号定义如下："
    },
    {
      "indent": 6,
      "text": "InsertionsInstruction ::=\n    NoInsertionsInstruction |\n    HollowInsertionsInstruction |\n    SingularInsertionsInstruction |\n    UniformInsertionsInstruction |\n    MultiformInsertionsInstruction",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "NoInsertionsInstruction ::= \"NO-INSERTIONS\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "HollowInsertionsInstruction ::= \"HOLLOW-INSERTIONS\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "SingularInsertionsInstruction ::= \"SINGULAR-INSERTIONS\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "UniformInsertionsInstruction ::= \"UNIFORM-INSERTIONS\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "MultiformInsertionsInstruction ::= \"MULTIFORM-INSERTIONS\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Using the GROUP encoding instruction on components with extensible types can lead to situations where an unknown extension could be associated with more than one extension insertion point. The insertion encoding instructions remove this ambiguity by limiting the form that extensions can take. That is, the insertion encoding instructions indicate what extensions can be made to an ASN.1 specification without breaking forward compatibility for RXER encodings.",
      "zh-CHS": "在具有可扩展类型的组件上使用组编码指令可能会导致未知扩展可能与多个扩展插入点关联的情况。插入编码指令通过限制扩展可以采用的形式来消除这种歧义。也就是说，插入编码指令指示可以对ASN.1规范进行哪些扩展，而不会破坏RXER编码的前向兼容性。"
    },
    {
      "indent": 6,
      "text": "Aside: Forward compatibility means the ability for a decoder to successfully decode an encoding containing extensions introduced into a version of the specification that is more recent than the one used by the decoder.",
      "zh-CHS": "旁白：前向兼容性是指解码器能够成功解码包含引入规范版本的扩展的编码，该版本比解码器使用的版本更新。"
    },
    {
      "indent": 3,
      "text": "In the most general case, an extension to a CHOICE, SET, or SEQUENCE type will generate zero or more attributes and zero or more elements, due to the potential use of the GROUP and ATTRIBUTE encoding instructions by the extension.",
      "zh-CHS": "在最一般的情况下，由于扩展可能使用组和属性编码指令，对选项、集合或序列类型的扩展将生成零个或多个属性以及零个或多个元素。"
    },
    {
      "indent": 3,
      "text": "The MULTIFORM-INSERTIONS encoding instruction indicates that the RXER encodings produced by forward-compatible extensions to a type will always consist of one or more elements and zero or more attributes. No restriction is placed on the names of the elements.",
      "zh-CHS": "MULTIFORM-INSERTIONS编码指令表示，由类型的前向兼容扩展生成的RXER编码将始终由一个或多个元素以及零个或多个属性组成。元素的名称没有限制。"
    },
    {
      "indent": 6,
      "text": "Aside: Of necessity, the names of the attributes will all be different in any given encoding.",
      "zh-CHS": "旁白：当然，属性的名称在任何给定的编码中都是不同的。"
    },
    {
      "indent": 3,
      "text": "The UNIFORM-INSERTIONS encoding instruction indicates that the RXER encodings produced by forward-compatible extensions to a type will always consist of one or more elements having the same expanded name, and zero or more attributes. The expanded name shared by the",
      "zh-CHS": "UNIFORM-INSERTIONS编码指令表示，由类型的前向兼容扩展生成的RXER编码将始终由一个或多个具有相同扩展名的元素以及零个或多个属性组成。用户共享的扩展名称"
    },
    {
      "indent": 3,
      "text": "elements in one particular encoding is not required to be the same as the expanded name shared by the elements in any other encoding of the extension. For example, in one encoding of the extension the elements might all be called \"foo\", while in another encoding of the extension they might all be called \"bar\".",
      "zh-CHS": "一种特定编码中的元素不需要与扩展的任何其他编码中的元素共享的扩展名相同。例如，在扩展的一种编码中，元素可能全部称为“foo”，而在扩展的另一种编码中，元素可能全部称为“bar”。"
    },
    {
      "indent": 3,
      "text": "The SINGULAR-INSERTIONS encoding instruction indicates that the RXER encodings produced by forward-compatible extensions to a type will always consist of a single element and zero or more attributes. The name of the single element is not required to be the same in every possible encoding of the extension.",
      "zh-CHS": "SINGULAR-INSERTIONS编码指令表示由类型的前向兼容扩展生成的RXER编码将始终由单个元素和零个或多个属性组成。在扩展的每个可能编码中，单个元素的名称不必相同。"
    },
    {
      "indent": 3,
      "text": "The HOLLOW-INSERTIONS encoding instruction indicates that the RXER encodings produced by forward-compatible extensions to a type will always consist of zero elements and zero or more attributes.",
      "zh-CHS": "HOLLOW-INSERTIONS编码指令表示由类型的前向兼容扩展生成的RXER编码将始终由零个元素和零个或多个属性组成。"
    },
    {
      "indent": 3,
      "text": "The NO-INSERTIONS encoding instruction indicates that no forward-compatible extensions can be made to a type.",
      "zh-CHS": "NO-INSERTIONS编码指令表示不能对类型进行前向兼容扩展。"
    },
    {
      "indent": 3,
      "text": "Examples of forward-compatible extensions are provided in Appendix C.",
      "zh-CHS": "附录C中提供了向前兼容扩展的示例。"
    },
    {
      "indent": 3,
      "text": "The Type in the EncodingPrefixedType for an insertion encoding instruction SHALL be either:",
      "zh-CHS": "插入编码指令的EncodingPrefixedType中的类型应为："
    },
    {
      "indent": 3,
      "text": "(1) a BuiltinType that is a ChoiceType where the ChoiceType is not subject to a UNION encoding instruction, or",
      "zh-CHS": "(1) ChoiceType不受联合编码指令约束的内置类型，或"
    },
    {
      "indent": 3,
      "text": "(2) a BuiltinType that is a SequenceType or SetType, or",
      "zh-CHS": "(2) SequenceType或SetType的内置类型，或"
    },
    {
      "indent": 3,
      "text": "(3) a ConstrainedType that is not a TypeWithConstraint where the Type in the ConstrainedType is one of (1) to (5), or",
      "zh-CHS": "(3) 不是TypeWithConstraint的ConstrainedType，其中ConstrainedType中的类型为（1）到（5）之一，或"
    },
    {
      "indent": 3,
      "text": "(4) a BuiltinType that is a PrefixedType that is a TaggedType where the Type in the TaggedType is one of (1) to (5), or",
      "zh-CHS": "(4) 一种内置类型，其前缀类型为TaggedType，其中TaggedType中的类型为（1）到（5）之一，或"
    },
    {
      "indent": 3,
      "text": "(5) a BuiltinType that is a PrefixedType that is an EncodingPrefixedType where the Type in the EncodingPrefixedType is one of (1) to (5).",
      "zh-CHS": "(5) PrefixedType是EncodingPrefixedType的内置类型，其中EncodingPrefixedType中的类型为（1）到（5）之一。"
    },
    {
      "indent": 3,
      "text": "Case (2) is not permitted when the insertion encoding instruction is the SINGULAR-INSERTIONS, UNIFORM-INSERTIONS, or MULTIFORM-INSERTIONS encoding instruction.",
      "zh-CHS": "当插入编码指令是单数插入、均匀插入或多形式插入编码指令时，不允许出现情况（2）。"
    },
    {
      "indent": 6,
      "text": "Aside: Because extensions to a SET or SEQUENCE type are serial and effectively optional, the SINGULAR-INSERTIONS, UNIFORM-INSERTIONS, and MULTIFORM-INSERTIONS encoding instructions offer no advantage over unrestricted extensions (for a SET or SEQUENCE). For example, an optional series of singular insertions generates zero or more elements and zero or more attributes, just like an unrestricted extension.",
      "zh-CHS": "旁白：由于集合或序列类型的扩展是串行的，并且实际上是可选的，因此单数插入、统一插入和多形式插入编码指令与不受限制的扩展（对于集合或序列）相比没有优势。例如，一系列可选的单数插入生成零个或多个元素和零个或多个属性，就像无限制扩展一样。"
    },
    {
      "indent": 3,
      "text": "The Type in case (1) or case (2) is said to be \"subject to\" the insertion encoding instruction.",
      "zh-CHS": "情况（1）或情况（2）中的类型被称为“服从”插入编码指令。"
    },
    {
      "indent": 3,
      "text": "The Type in case (1) or case (2) MUST be extensible, either explicitly or by default.",
      "zh-CHS": "案例（1）或案例（2）中的类型必须是可扩展的，可以是显式的，也可以是默认的。"
    },
    {
      "indent": 3,
      "text": "A Type SHALL NOT be subject to more than one insertion encoding instruction.",
      "zh-CHS": "一个类型不得受多个插入编码指令的约束。"
    },
    {
      "indent": 3,
      "text": "The insertion encoding instructions indicate what kinds of extensions can be made to a type without breaking forward compatibility, but they do not prohibit extensions that do break forward compatibility. That is, it is not an error for a type's base type to contain extensions that do not satisfy an insertion encoding instruction affecting the type. However, if any such extensions are made, then a new value SHOULD be introduced into the extensible set of permitted values for a version indicator attribute, or attributes (see Section 24), whose scope encompasses the extensions. An example is provided in Appendix C.",
      "zh-CHS": "插入编码指令指示在不破坏前向兼容性的情况下可以对类型进行哪些类型的扩展，但它们并不禁止破坏前向兼容性的扩展。也就是说，类型的基类型包含不满足影响该类型的插入编码指令的扩展不是错误。但是，如果进行了任何此类扩展，则应在版本指示器属性的可扩展允许值集中引入新值（参见第24节），其范围包括扩展。附录C中提供了一个示例。"
    },
    {
      "indent": 0,
      "text": "24. The VERSION-INDICATOR Encoding Instruction",
      "section_title": true,
      "zh-CHS": "24. 版本指示符编码指令"
    },
    {
      "indent": 3,
      "text": "The VERSION-INDICATOR encoding instruction provides a mechanism for RXER decoders to be alerted that an encoding contains extensions that break forward compatibility (see the preceding section).",
      "zh-CHS": "VERSION-INDICATOR编码指令提供了一种机制，用于提醒RXER解码器编码包含破坏前向兼容性的扩展（请参阅上一节）。"
    },
    {
      "indent": 3,
      "text": "The notation for a VERSION-INDICATOR encoding instruction is defined as follows:",
      "zh-CHS": "版本指示符编码指令的符号定义如下："
    },
    {
      "indent": 6,
      "text": "VersionIndicatorInstruction ::= \"VERSION-INDICATOR\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "A NamedType that is subject to a VERSION-INDICATOR encoding instruction MUST also be subject to an ATTRIBUTE encoding instruction.",
      "zh-CHS": "受版本指示符编码指令约束的NamedType也必须受属性编码指令约束。"
    },
    {
      "indent": 3,
      "text": "The type of the NamedType that is subject to the VERSION-INDICATOR encoding instruction MUST be directly or indirectly a constrained type where the set of permitted values is defined to be extensible. Each value represents a different version of the ASN.1 specification. Ordinarily, an application will set the value of a version indicator",
      "zh-CHS": "受版本指示符编码指令约束的NamedType的类型必须直接或间接为约束类型，其中允许的值集定义为可扩展的。每个值代表ASN.1规范的不同版本。通常，应用程序将设置版本指示符的值"
    },
    {
      "indent": 3,
      "text": "attribute to be the last of these permitted values. An application MAY set the value of the version indicator attribute to the value corresponding to an earlier version of the specification if it has not used any of the extensions added in a subsequent version.",
      "zh-CHS": "属性是这些允许值中的最后一个。如果应用程序没有使用在后续版本中添加的任何扩展，则可以将version indicator属性的值设置为与规范的早期版本相对应的值。"
    },
    {
      "indent": 3,
      "text": "If an RXER decoder encounters a value of the type that is not one of the root values or extension additions (but that is still allowed since the set of permitted values is extensible), then this indicates that the decoder is using a version of the ASN.1 specification that is not compatible with the version used to produce the encoding. In such cases, the decoder SHOULD treat the element containing the attribute as having an unknown ASN.1 type.",
      "zh-CHS": "如果RXER解码器遇到的类型值不是根值或扩展附加值之一（但由于允许的值集是可扩展的，因此仍然允许），则这表示解码器使用的ASN.1规范版本与用于生成编码的版本不兼容。在这种情况下，解码器应将包含属性的元素视为具有未知ASN.1类型。"
    },
    {
      "indent": 6,
      "text": "Aside: A version indicator attribute only indicates an incompatibility with respect to RXER encodings. Other encodings are not affected because the GROUP encoding instruction does not apply to them.",
      "zh-CHS": "旁白：版本指示符属性仅表示RXER编码不兼容。其他编码不受影响，因为组编码指令不适用于它们。"
    },
    {
      "indent": 3,
      "text": "Examples",
      "zh-CHS": "例子"
    },
    {
      "indent": 6,
      "text": "In this first example, the decoder is using an incompatible older version if the value of the version attribute in a received RXER encoding is not 1, 2, or 3.",
      "zh-CHS": "在第一个示例中，如果接收到的RXER编码中的version属性的值不是1、2或3，则解码器正在使用不兼容的旧版本。"
    },
    {
      "indent": 9,
      "text": "SEQUENCE {\n    version  [ATTRIBUTE] [VERSION-INDICATOR]\n                 INTEGER (1, ..., 2..3),\n    message  MessageType\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "In this second example, the decoder is using an incompatible older version if the value of the format attribute in a received RXER encoding is not \"1.0\", \"1.1\", or \"2.0\".",
      "zh-CHS": "在第二个示例中，如果接收到的RXER编码中的format属性的值不是“1.0”、“1.1”或“2.0”，则解码器正在使用不兼容的旧版本。"
    },
    {
      "indent": 9,
      "text": "SEQUENCE {\n    format   [ATTRIBUTE] [VERSION-INDICATOR]\n                 UTF8String (\"1.0\", ..., \"1.1\" | \"2.0\"),\n    message  MessageType\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "An extensive example is provided in Appendix C.",
      "zh-CHS": "附录C中提供了一个广泛的示例。"
    },
    {
      "indent": 3,
      "text": "It is not necessary for every extensible type to have its own version indicator attribute. It would be typical for only the types of top-level element components to include a version indicator attribute, which would serve as the version indicator for all of the nested components.",
      "zh-CHS": "并非每个可扩展类型都有自己的版本指示符属性。典型的情况是，只有顶级元素组件的类型才包含版本指示符属性，该属性将用作所有嵌套组件的版本指示符。"
    },
    {
      "indent": 0,
      "text": "25. The GROUP Encoding Instruction",
      "section_title": true,
      "zh-CHS": "25. 分组编码指令"
    },
    {
      "indent": 3,
      "text": "The GROUP encoding instruction causes an RXER encoder to encode a value of the component to which it is applied without encapsulation as an element. It allows the construction of non-trivial content models for element content.",
      "zh-CHS": "组编码指令使RXER编码器对其应用的组件的值进行编码，而不封装为元素。它允许为元素内容构建非平凡的内容模型。"
    },
    {
      "indent": 3,
      "text": "The notation for a GROUP encoding instruction is defined as follows:",
      "zh-CHS": "组编码指令的符号定义如下："
    },
    {
      "indent": 6,
      "text": "GroupInstruction ::= \"GROUP\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The base type of the type of a NamedType that is subject to a GROUP encoding instruction SHALL be either:",
      "zh-CHS": "受组编码指令约束的NamedType类型的基本类型应为："
    },
    {
      "indent": 3,
      "text": "(1) a SEQUENCE, SET, or SET OF type, or",
      "zh-CHS": "(1) 序列类型的序列、集合或集合，或"
    },
    {
      "indent": 3,
      "text": "(2) a CHOICE type where the ChoiceType is not subject to a UNION encoding instruction, or",
      "zh-CHS": "(2) 选择类型不受联合编码指令约束的选择类型，或"
    },
    {
      "indent": 3,
      "text": "(3) a SEQUENCE OF type where the SequenceOfType is not subject to a LIST encoding instruction.",
      "zh-CHS": "(3) 一种类型序列，其中SequenceOfType不受列表编码指令的约束。"
    },
    {
      "indent": 3,
      "text": "The SEQUENCE type in case (1) SHALL NOT be the associated type for a built-in type, SHALL NOT be a type from the AdditionalBasicDefinitions module [RXER], and SHALL NOT contain a component that is subject to a SIMPLE-CONTENT encoding instruction.",
      "zh-CHS": "案例（1）中的序列类型不得为内置类型的关联类型，不得为AdditionalBasicDefinitions模块[RXER]中的类型，且不得包含受简单内容编码指令约束的组件。"
    },
    {
      "indent": 6,
      "text": "Aside: Thus, the CHARACTER STRING, EMBEDDED PDV, EXTERNAL, REAL, and QName types are excluded.",
      "zh-CHS": "旁白：因此，不包括字符串、嵌入式PDV、外部、实数和QName类型。"
    },
    {
      "indent": 3,
      "text": "The CHOICE type in case (2) SHALL NOT be a type from the AdditionalBasicDefinitions module.",
      "zh-CHS": "案例（2）中的选择类型不得为AdditionalBasicDefinitions模块中的类型。"
    },
    {
      "indent": 6,
      "text": "Aside: Thus, the Markup type is excluded.",
      "zh-CHS": "旁白：因此，标记类型被排除。"
    },
    {
      "indent": 3,
      "text": "Definition (visible component): Ignoring all type constraints, the visible components for a type that is directly or indirectly a combining ASN.1 type (i.e., SEQUENCE, SET, CHOICE, SEQUENCE OF, or SET OF) is the set of components of the combining type definition plus, for each NamedType (of the combining type definition) that is subject to a GROUP encoding instruction, the visible components for the type of the NamedType. The visible components are determined after the COMPONENTS OF transformation specified in X.680, Clause 24.4 [X.680].",
      "zh-CHS": "定义（可见组件）：忽略所有类型约束，直接或间接为组合ASN类型的类型的可见组件。1类型（即，序列、集合、选择、序列或集合）是组合类型定义的组件集，加上每个NamedType（组合类型定义的）它受组编码指令的约束，即NamedType类型的可见组件。可见成分在X.680第24.4条[X.680]中规定的变换成分后确定。"
    },
    {
      "indent": 6,
      "text": "Aside: The set of visible attribute and element components for a type is the set of all the components of the type, and any nested types, that describe attributes and child elements appearing in the RXER encodings of values of the outer type.",
      "zh-CHS": "旁白：类型的可见属性和元素组件集是该类型的所有组件以及任何嵌套类型的集合，这些组件描述了外部类型值的RXER编码中出现的属性和子元素。"
    },
    {
      "indent": 3,
      "text": "A GROUP encoding instruction MUST NOT be used where it would cause a NamedType to be a visible component of the type of that same NamedType (which is only possible if the type definition is recursive).",
      "zh-CHS": "如果组编码指令会导致NamedType成为同一NamedType类型的可见组件，则不得使用该指令（仅当类型定义为递归时才可能）。"
    },
    {
      "indent": 6,
      "text": "Aside: Components subject to a GROUP encoding instruction might be translated into a compatible XML Schema [XSD1] as group definitions. A NamedType that is visible to its own type is analogous to a circular group, which XML Schema disallows.",
      "zh-CHS": "旁白：受组编码指令约束的组件可以作为组定义转换为兼容的XML模式[XSD1]。对自己的类型可见的NamedType类似于循环组，XML模式不允许循环组。"
    },
    {
      "indent": 3,
      "text": "Section 25.1 imposes additional conditions on the use of the GROUP encoding instruction.",
      "zh-CHS": "第25.1节对组编码指令的使用施加了附加条件。"
    },
    {
      "indent": 3,
      "text": "In any use of the GROUP encoding instruction, there is a type, the including type, that contains the component subject to the GROUP encoding instruction, and a type, the included type, that is the base type of that component. Either type can have an extensible content model, either by directly using ASN.1 extensibility or by including through another GROUP encoding instruction some other type that is extensible.",
      "zh-CHS": "在组编码指令的任何使用中，都有一个类型（包括类型）包含服从组编码指令的组件，还有一个类型（包括类型）是该组件的基本类型。这两种类型都可以有一个可扩展的内容模型，可以直接使用ASN.1可扩展性，也可以通过另一个组编码指令包含其他可扩展的类型。"
    },
    {
      "indent": 3,
      "text": "The including and included types may be defined in different ASN.1 modules, in which case the owner of the including type, i.e., the person or organization having the authority to add extensions to the including type's definition, may be different from the owner of the included type.",
      "zh-CHS": "包含类型和包含类型可以在不同的ASN.1模块中定义，在这种情况下，包含类型的所有者，即有权向包含类型的定义添加扩展的人员或组织，可能与包含类型的所有者不同。"
    },
    {
      "indent": 3,
      "text": "If the owner of the including type is not using the most recent version of the included type's definition, then the owner of the including type might add an extension to the including type that is valid with respect to the older version of the included type, but is later found to be invalid when the latest versions of the including and included type definitions are brought together (perhaps by a third party). Although the owner of the including type must necessarily be aware of the existence of the included type, the reverse is not necessarily true. The owner of the included type could add an extension to the included type without realizing that it invalidates someone else's including type.",
      "zh-CHS": "如果包含类型的所有者未使用包含类型定义的最新版本，则包含类型的所有者可能会向包含类型添加一个扩展，该扩展对包含类型的旧版本有效，但是，当include和included类型定义的最新版本汇集在一起时（可能是由第三方提供的），发现它是无效的。尽管包含类型的所有者必须知道包含类型的存在，但情况并非如此。包含类型的所有者可以向包含类型添加扩展，而不会意识到它会使其他人的包含类型无效。"
    },
    {
      "indent": 3,
      "text": "To avoid these problems, a GROUP encoding instruction MUST NOT be used if:",
      "zh-CHS": "为避免这些问题，在以下情况下，不得使用组编码指令："
    },
    {
      "indent": 3,
      "text": "(1) the included type is defined in a different module from the including type, and",
      "zh-CHS": "(1) 包含类型在与包含类型不同的模块中定义，并且"
    },
    {
      "indent": 3,
      "text": "(2) the included type has an extensible content model, and",
      "zh-CHS": "(2) 包含的类型具有可扩展的内容模型，并且"
    },
    {
      "indent": 3,
      "text": "(3) changes to the included type are not coordinated with the owner of the including type.",
      "zh-CHS": "(3) 对包含类型的更改不与包含类型的所有者协调。"
    },
    {
      "indent": 3,
      "text": "Changes in the included type are coordinated with the owner of the including type if:",
      "zh-CHS": "包括类型的变更应与包括类型的所有者协调，前提是："
    },
    {
      "indent": 3,
      "text": "(1) the owner of the included type is also the owner of the including type, or",
      "zh-CHS": "(1) 包含类型的所有者也是包含类型的所有者，或"
    },
    {
      "indent": 3,
      "text": "(2) the owner of the including type is collaborating with the owner of the included type, or",
      "zh-CHS": "(2) 包含类型的所有者正在与包含类型的所有者协作，或"
    },
    {
      "indent": 3,
      "text": "(3) all changes will be vetted by a common third party before being approved and published.",
      "zh-CHS": "(3) 在批准和发布之前，所有变更将由共同的第三方进行审查。"
    },
    {
      "indent": 0,
      "text": "25.1. Unambiguous Encodings",
      "section_title": true,
      "zh-CHS": "25.1. 明确的编码"
    },
    {
      "indent": 3,
      "text": "Unregulated use of the GROUP encoding instruction can easily lead to specifications in which distinct abstract values have indistinguishable RXER encodings, i.e., ambiguous encodings. This section imposes restrictions on the use of the GROUP encoding instruction to ensure that distinct abstract values have distinct RXER encodings. In addition, these restrictions ensure that an abstract value can be easily decoded in a single pass without back-tracking.",
      "zh-CHS": "不受管制地使用组编码指令很容易导致不同的抽象值具有不可区分的RXER编码的规范，即不明确的编码。本节对组编码指令的使用施加限制，以确保不同的抽象值具有不同的RXER编码。此外，这些限制确保了抽象值可以在一次传递中轻松解码，而无需回溯。"
    },
    {
      "indent": 3,
      "text": "An RXER decoder for an ASN.1 type can be abstracted as a recognizer for a notional language, consisting of element and attribute expanded names, where the type definition describes the grammar for that language (in fact it is a context-free grammar). The restrictions on a type definition to ensure easy, unambiguous decoding are more conveniently, completely, and simply expressed as conditions on this associated grammar. Implementations are not expected to verify type definitions exactly in the manner to be described; however, the procedure used MUST produce the same result.",
      "zh-CHS": "ASN.1类型的RXER解码器可以抽象为概念语言的识别器，由元素和属性扩展名组成，其中类型定义描述了该语言的语法（实际上它是一种上下文无关语法）。对类型定义的限制可以确保轻松、明确的解码，这些限制可以更方便、完整、简单地表示为该关联语法的条件。实现不希望以描述的方式准确地验证类型定义；但是，使用的程序必须产生相同的结果。"
    },
    {
      "indent": 3,
      "text": "Section 25.1.1 describes the procedure for recasting as a grammar a type definition containing components subject to the GROUP encoding instruction. Sections 25.1.2 and 25.1.3 specify conditions that the",
      "zh-CHS": "第25.1.1节描述了将包含受分组编码指令约束的组件的类型定义重铸为语法的过程。第25.1.2节和第25.1.3节规定了以下条件："
    },
    {
      "indent": 3,
      "text": "grammar must satisfy for the type definition to be valid. Section 25.1.4 describes how unrecognized attributes are accepted by the grammar for an extensible type.",
      "zh-CHS": "语法必须满足才能使类型定义有效。第25.1.4节描述了语法如何接受可扩展类型的未识别属性。"
    },
    {
      "indent": 3,
      "text": "Appendices A and B have extensive examples.",
      "zh-CHS": "附录A和B有大量的例子。"
    },
    {
      "indent": 0,
      "text": "25.1.1. Grammar Construction",
      "section_title": true,
      "zh-CHS": "25.1.1. 语法结构"
    },
    {
      "indent": 3,
      "text": "A grammar consists of a collection of productions.  A production has\na left-hand side and a right-hand side (in this document, separated\nby the \"::=\" symbol).  The left-hand side (in a context-free grammar)\nis a single non-terminal symbol.  The right-hand side is a sequence\nof non-terminal and terminal symbols.  The terminal symbols are the\nlexical items of the language that the grammar describes.  One of the\nnon-terminals is nominated to be the start symbol.  A valid sequence\nof terminals for the language can be generated from the grammar by\nbeginning with the start symbol and repeatedly replacing any\nnon-terminal with the right-hand side of one of the productions where\nthat non-terminal is on the production's left-hand side.  The final\nsequence of terminals is achieved when there are no remaining\nnon-terminals to replace.",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "Aside: X.680 describes the ASN.1 basic notation using a context-free grammar.",
      "zh-CHS": "旁白：X.680使用上下文无关语法描述了ASN.1基本符号。"
    },
    {
      "indent": 3,
      "text": "Each NamedType has an associated primary and secondary non-terminal.",
      "zh-CHS": "每个NamedType都有一个关联的主非终结符和辅助非终结符。"
    },
    {
      "indent": 6,
      "text": "Aside: The secondary non-terminal for a NamedType is used when the base type of the type in the NamedType is a SEQUENCE OF type or SET OF type.",
      "zh-CHS": "旁白：当NamedType中类型的基类型是类型序列或类型集时，使用NamedType的次要非终结符。"
    },
    {
      "indent": 3,
      "text": "Each ExtensionAddition and ExtensionAdditionAlternative has an associated non-terminal. There is a non-terminal associated with the extension insertion point of each extensible type. There is also a primary start non-terminal (this is the start symbol) and a secondary start non-terminal. The exact nature of the non-terminals is not important, however all the non-terminals MUST be mutually distinct.",
      "zh-CHS": "每个ExtensionAddition和ExtensionAdditionalAlternative都有一个关联的非终端。每个可扩展类型的扩展插入点都有一个非终端。还有一个主启动非终端（这是启动符号）和一个辅助启动非终端。非端子的确切性质并不重要，但所有非端子必须相互区别。"
    },
    {
      "indent": 3,
      "text": "It is adequate for most of the examples in this document (though not in the most general case) for the primary non-terminal for a NamedType to be the identifier of the NamedType, for the primary start non-terminal to be S, for the non-terminals for the instances of ExtensionAddition and ExtensionAdditionAlternative to be E1, E2, E3, and so on, and for the non-terminals for the extension insertion points to be I1, I2, I3, and so on. The secondary non-terminals are labelled by appending a \"'\" character to the primary non-terminal label, e.g., the primary and secondary start non-terminals are S and S', respectively.",
      "zh-CHS": "对于本文档中的大多数示例（尽管不是在最一般的情况下），对于NamedType作为NamedType标识符的主要非终端，对于S作为主要起始非终端，对于E1、E2、E3等作为ExtensionAddition和ExtensionAdditionalAlternative实例的非终端，这是足够的，对于非端子，扩展插入点为I1、I2、I3等。通过在主非端子标签上附加“'”字符来标记辅助非端子，例如，主和辅助启动非端子分别为S和S'。"
    },
    {
      "indent": 3,
      "text": "Each NamedType and extension insertion point has an associated\nterminal.  There exists a terminal called the general extension\nterminal that is not associated with any specific notation.  The\ngeneral extension terminal and the terminals for the extension\ninsertion points are used to represent elements in unknown\nextensions.  The exact nature of the terminals is not important;\nhowever, the aforementioned terminals MUST be mutually distinct.  The\nterminals are further categorized as either element terminals or\nattribute terminals.  A terminal for a NamedType is an attribute\nterminal if its associated NamedType is an attribute component;\notherwise, it is an element terminal.  The general extension terminal\nand the terminals for the extension insertion points are categorized\nas element terminals.",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Terminals for attributes in unknown extensions are not explicitly provided in the grammar. Certain productions in the grammar are categorized as insertion point productions, and their role in accepting unknown attributes is described in Section 25.1.4.",
      "zh-CHS": "语法中未明确提供未知扩展中属性的终端。语法中的某些产品被归类为插入点产品，第25.1.4节描述了它们在接受未知属性方面的作用。"
    },
    {
      "indent": 3,
      "text": "In the examples in this document, the terminal for a component other than an attribute component will be represented as the local name of the expanded name of the component enclosed in double quotes, and the terminal for an attribute component will be represented as the local name of the expanded name of the component prefixed by the '@' character and enclosed in double quotes. The general extension terminal will be represented as \"*\" and the terminals for the extension insertion points will be represented as \"*1\", \"*2\", \"*3\", and so on.",
      "zh-CHS": "在本文档中的示例中，属性组件以外的组件的终端将表示为双引号中包含的组件扩展名称的本地名称，属性组件的终端将表示为组件扩展名的本地名，前缀为“@”，并用双引号括起来。通用扩展终端将表示为“*”，扩展插入点的终端将表示为“*1”、“*2”、“*3”等。"
    },
    {
      "indent": 3,
      "text": "The productions generated from a NamedType depend on the base type of the type of the NamedType. The productions for the start non-terminals depend on the combining type definition being tested. In either case, the procedure for generating productions takes a primary non-terminal, a secondary non-terminal (sometimes), and a type definition.",
      "zh-CHS": "从NamedType生成的产品取决于NamedType类型的基类型。开始非终端的产品取决于正在测试的组合类型定义。在这两种情况下，生成产品的过程都采用主非终结符、次非终结符（有时）和类型定义。"
    },
    {
      "indent": 3,
      "text": "The grammar is constructed beginning with the start non-terminals and the combining type definition being tested.",
      "zh-CHS": "语法是从start非终结符和正在测试的组合类型定义开始构建的。"
    },
    {
      "indent": 3,
      "text": "A grammar is constructed after the COMPONENTS OF transformation specified in X.680, Clause 24.4 [X.680].",
      "zh-CHS": "语法是在X.680第24.4条[X.680]中规定的转换成分之后构造的。"
    },
    {
      "indent": 3,
      "text": "Given a primary non-terminal, N, and a type where the base type is a SEQUENCE or SET type, a production is added to the grammar with N as the left-hand side. The right-hand side is constructed from an initial empty state according to the following cases considered in order:",
      "zh-CHS": "给定一个主非终结符N，以及一个基类型为序列或集合类型的类型，则在语法中添加一个产生式，其中N为左侧。根据以下顺序考虑的情况，从初始空状态构造右侧："
    },
    {
      "indent": 3,
      "text": "(1) If an initial RootComponentTypeList is present in the base type, then the sequence of primary non-terminals for the components nested in that RootComponentTypeList are appended to the right-hand side in the order of their definition.",
      "zh-CHS": "(1) 如果基类型中存在初始的RootComponentTypeList，则嵌套在该RootComponentTypeList中的组件的主非终结符序列将按照其定义的顺序追加到右侧。"
    },
    {
      "indent": 3,
      "text": "(2) If an ExtensionAdditions instance is present in the base type and not empty, then the non-terminal for the first ExtensionAddition nested in the ExtensionAdditions instance is appended to the right-hand side.",
      "zh-CHS": "(2) 如果基类型中存在ExtensionAdditions实例且该实例不为空，则将ExtensionAdditions实例中嵌套的第一个ExtensionAddition的非终端追加到右侧。"
    },
    {
      "indent": 3,
      "text": "(3) If an ExtensionAdditions instance is empty or not present in the base type, and the base type is extensible (explicitly or by default), and the base type is not subject to a NO-INSERTIONS or HOLLOW-INSERTIONS encoding instruction, then the non-terminal for the extension insertion point of the base type is appended to the right-hand side.",
      "zh-CHS": "(3) 如果ExtensionAdditions实例为空或在基类型中不存在，并且基类型是可扩展的（显式或默认），并且基类型不受NO-INSERTIONS或HOLLOWL-INSERTIONS编码指令的约束，则基类型的扩展插入点的非终端将追加到右侧。"
    },
    {
      "indent": 3,
      "text": "(4) If a final RootComponentTypeList is present in the base type, then the primary non-terminals for the components nested in that RootComponentTypeList are appended to the right-hand side in the order of their definition.",
      "zh-CHS": "(4) 如果基类型中存在最终的RootComponentTypeList，则嵌套在该RootComponentTypeList中的组件的主非终结符将按照其定义的顺序追加到右侧。"
    },
    {
      "indent": 3,
      "text": "The production is an insertion point production if an ExtensionAdditions instance is empty or not present in the base type, and the base type is extensible (explicitly or by default), and the base type is not subject to a NO-INSERTIONS encoding instruction.",
      "zh-CHS": "如果ExtensionAdditions实例为空或在基类型中不存在，并且基类型是可扩展的（显式或默认），并且基类型不受无插入编码指令的约束，则生产是插入点生产。"
    },
    {
      "indent": 3,
      "text": "If a component in a ComponentTypeList (in either a RootComponentTypeList or an ExtensionAdditionGroup) is marked OPTIONAL or DEFAULT, then a production with the primary non-terminal of the component as the left-hand side and an empty right-hand side is added to the grammar.",
      "zh-CHS": "如果ComponentTypeList（在RootComponentTypeList或ExtensionAdditionGroup中）中的某个组件被标记为可选或默认，则会将该组件的主要非末端作为左侧，右侧为空的产品添加到语法中。"
    },
    {
      "indent": 3,
      "text": "If a component (regardless of the ASN.1 combining type containing it) is subject to a GROUP encoding instruction, then one or more productions constructed according to the component's type are added to the grammar. Each of these productions has the primary non-terminal of the component as the left-hand side.",
      "zh-CHS": "如果一个组件（不管包含它的ASN.1组合类型如何）受组编码指令的约束，那么根据该组件的类型构造的一个或多个产品将添加到语法中。每个产品的左侧都有组件的主要非末端。"
    },
    {
      "indent": 3,
      "text": "If a component (regardless of the ASN.1 combining type containing it) is not subject to a GROUP encoding instruction, then a production is added to the grammar with the primary non-terminal of the component as the left-hand side and the terminal of the component as the right-hand side.",
      "zh-CHS": "如果一个组件（不管包含它的ASN.1组合类型如何）不受组编码指令的约束，则会将一个产生式添加到语法中，将该组件的主要非终端作为左侧，将该组件的终端作为右侧。"
    },
    {
      "indent": 3,
      "text": "Example",
      "zh-CHS": "实例"
    },
    {
      "indent": 6,
      "text": "Consider the following ASN.1 type definition:",
      "zh-CHS": "考虑下面的ASN . 1类型定义："
    },
    {
      "indent": 9,
      "text": "SEQUENCE {\n    -- Start of initial RootComponentTypeList.\n    one    [ATTRIBUTE] UTF8String,\n    two    BOOLEAN OPTIONAL,\n    three  INTEGER\n    -- End of initial RootComponentTypeList.\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "Here is the grammar derived from this type:",
      "zh-CHS": "以下是从该类型派生的语法："
    },
    {
      "indent": 9,
      "text": "S ::= one two three\none ::= \"@one\"\ntwo ::= \"two\"\ntwo ::=\nthree ::= \"three\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "For each ExtensionAddition (of a SEQUENCE or SET base type), a production is added to the grammar where the left-hand side is the non-terminal for the ExtensionAddition and the right-hand side is initially empty. If the ExtensionAddition is a ComponentType, then the primary non-terminal for the NamedType in the ComponentType is appended to the right-hand side; otherwise (an ExtensionAdditionGroup), the sequence of primary non-terminals for the components nested in the ComponentTypeList in the ExtensionAdditionGroup are appended to the right-hand side in the order of their definition. If the ExtensionAddition is followed by another ExtensionAddition, then the non-terminal for the next ExtensionAddition is appended to the right-hand side; otherwise, if the base type is not subject to a NO-INSERTIONS or HOLLOW-INSERTIONS encoding instruction, then the non-terminal for the extension insertion point of the base type is appended to the right-hand side. If the ExtensionAddition is not followed by another ExtensionAddition and the base type is not subject to a NO-INSERTIONS encoding instruction, then the production is an insertion point production. If the empty sequence of terminals cannot be generated from the production (it may be necessary to wait until the grammar is otherwise complete before making this determination), then another production is added to the grammar where the left-hand side is the non-terminal for the ExtensionAddition and the right-hand side is empty.",
      "zh-CHS": "对于每个ExtensionAddition（序列或集合基类型），将向语法中添加一个产品，其中左侧是ExtensionAddition的非终端，右侧最初为空。如果ExtensionAddition是ComponentType，则ComponentType中NamedType的主非终结符将追加到右侧；否则（ExtensionAdditionGroup），嵌套在ExtensionAdditionGroup中ComponentTypeList中的组件的主非端子序列将按照其定义顺序追加到右侧。如果ExtensionAddition后面紧跟着另一个ExtensionAddition，则下一个ExtensionAddition的非终端将附加到右侧；否则，如果基类型不受无插入或空插入编码指令的约束，则基类型的扩展插入点的非端子被附加到右侧。如果ExtensionAddition后面没有另一个ExtensionAddition，并且基类型不受NO-INSERTIONS编码指令的约束，则生成是插入点生成。如果不能从生产中生成终端的空序列（可能需要等到语法完成后再进行此确定），则将另一个生产添加到语法中，其中左侧为扩展添加的非终端，右侧为空。"
    },
    {
      "indent": 6,
      "text": "Aside: An extension is always effectively optional since a sender may be using an earlier version of the ASN.1 specification where none, or only some, of the extensions have been defined.",
      "zh-CHS": "旁白：扩展始终是有效的可选的，因为发送方可能正在使用ASN.1规范的早期版本，其中未定义或仅定义了部分扩展。"
    },
    {
      "indent": 6,
      "text": "Aside: The grammar generated for ExtensionAdditions is structured to take account of the condition that an extension can only be used if all the earlier extensions are also used [X.680].",
      "zh-CHS": "旁白：为ExtensionAdditions生成的语法在结构上考虑了一个条件，即只有在同时使用所有早期扩展时才能使用扩展[X.680]。"
    },
    {
      "indent": 3,
      "text": "If a SEQUENCE or SET base type is extensible (explicitly or by default) and is not subject to a NO-INSERTIONS or HOLLOW-INSERTIONS encoding instruction, then:",
      "zh-CHS": "如果序列或集合基类型是可扩展的（显式或默认），并且不受无插入或空插入编码指令的约束，则："
    },
    {
      "indent": 3,
      "text": "(1) a production is added to the grammar where the left-hand side is the non-terminal for the extension insertion point of the base type and the right-hand side is the general extension terminal followed by the non-terminal for the extension insertion point, and",
      "zh-CHS": "(1) 向语法中添加了一个结果，其中左侧是基类型的扩展插入点的非端子，右侧是通用扩展端子，后面是扩展插入点的非端子，以及"
    },
    {
      "indent": 3,
      "text": "(2) a production is added to the grammar where the left-hand side is the non-terminal for the extension insertion point and the right-hand side is empty.",
      "zh-CHS": "(2) 一个结果被添加到语法中，其中左侧是扩展插入点的非端点，右侧为空。"
    },
    {
      "indent": 3,
      "text": "Example",
      "zh-CHS": "实例"
    },
    {
      "indent": 6,
      "text": "Consider the following ASN.1 type definition:",
      "zh-CHS": "考虑下面的ASN . 1类型定义："
    },
    {
      "indent": 9,
      "text": "SEQUENCE {\n    -- Start of initial RootComponentTypeList.\n    one    BOOLEAN,\n    two    INTEGER OPTIONAL,\n    -- End of initial RootComponentTypeList.\n    ...,\n    -- Start of ExtensionAdditions.\n    four  INTEGER,  -- First ExtensionAddition (E1).\n    five  BOOLEAN OPTIONAL,  -- Second ExtensionAddition (E2).\n    [[ -- An ExtensionAdditionGroup.\n        six    UTF8String,\n        seven  INTEGER OPTIONAL\n    ]], -- Third ExtensionAddition (E3).\n    -- End of ExtensionAdditions.\n    -- The extension insertion point is here (I1).\n    ...,\n    -- Start of final RootComponentTypeList.\n    three  INTEGER\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "Here is the grammar derived from this type:",
      "zh-CHS": "以下是从该类型派生的语法："
    },
    {
      "indent": 9,
      "text": "S ::= one two E1 three",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "E1 ::= four E2\nE1 ::=",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "E2 ::= five E3\nE3 ::= six seven I1\nE3 ::=",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "I1 ::= \"*\" I1\nI1 ::=",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "one ::= \"one\"\ntwo ::= \"two\"\ntwo ::=\nthree ::= \"three\"\nfour ::= \"four\"\nfive ::= \"five\"\nfive ::=\nsix ::= \"six\"\nseven ::= \"seven\"\nseven ::=",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "If the SEQUENCE type were subject to a NO-INSERTIONS or HOLLOW-INSERTIONS encoding instruction, then the productions for I1 would not appear, and the first production for E3 would be:",
      "zh-CHS": "如果序列类型服从无插入或空插入编码指令，则I1的产品将不会出现，E3的第一个产品将是："
    },
    {
      "indent": 9,
      "text": "E3 ::= six seven",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Given a primary non-terminal, N, and a type where the base type is a CHOICE type:",
      "zh-CHS": "给定一个主非端子N和一个类型，其中基类型为选择类型："
    },
    {
      "indent": 3,
      "text": "(1) A production is added to the grammar for each NamedType nested in the RootAlternativeTypeList of the base type, where the left-hand side is N and the right-hand side is the primary non-terminal for the NamedType.",
      "zh-CHS": "(1) 对于嵌套在基类型的RootAlternativeTypeList中的每个NamedType，将在语法中添加一个产品，其中左侧为N，右侧为NamedType的主要非终结符。"
    },
    {
      "indent": 3,
      "text": "(2) A production is added to the grammar for each ExtensionAdditionAlternative of the base type, where the left-hand side is N and the right-hand side is the non-terminal for the ExtensionAdditionAlternative.",
      "zh-CHS": "(2) 为基类型的每个ExtensionAdditionalAlternative向语法中添加一个结果，其中左侧为N，右侧为ExtensionAdditionalAlternative的非终端。"
    },
    {
      "indent": 3,
      "text": "(3) If the base type is extensible (explicitly or by default) and the base type is not subject to an insertion encoding instruction, then:",
      "zh-CHS": "(3) 如果基类型是可扩展的（显式或默认），并且基类型不受插入编码指令的约束，则："
    },
    {
      "indent": 7,
      "text": "(a) A production is added to the grammar where the left-hand side is N and the right-hand side is the non-terminal for the extension insertion point of the base type. This production is an insertion point production.",
      "zh-CHS": "(a) 生成式被添加到语法中，其中左侧为N，右侧为基类型的扩展插入点的非端点。此产品是插入点产品。"
    },
    {
      "indent": 7,
      "text": "(b) A production is added to the grammar where the left-hand side is the non-terminal for the extension insertion point of the base type and the right-hand side is the general extension terminal followed by the non-terminal for the extension insertion point.",
      "zh-CHS": "(b) 将生成项添加到语法中，其中左侧是基类型的扩展插入点的非端子，右侧是通用扩展端子，后面是扩展插入点的非端子。"
    },
    {
      "indent": 7,
      "text": "(c) A production is added to the grammar where the left-hand side is the non-terminal for the extension insertion point of the base type and the right-hand side is empty.",
      "zh-CHS": "(c) 将向语法中添加一个结果，其中左侧是基类型的扩展插入点的非端点，右侧为空。"
    },
    {
      "indent": 3,
      "text": "(4) If the base type is subject to a HOLLOW-INSERTIONS encoding instruction, then a production is added to the grammar where the left-hand side is N and the right-hand side is empty. This production is an insertion point production.",
      "zh-CHS": "(4) 如果基类型受空插入编码指令的约束，则会向语法中添加一个结果，其中左侧为N，右侧为空。此产品是插入点产品。"
    },
    {
      "indent": 3,
      "text": "(5) If the base type is subject to a SINGULAR-INSERTIONS encoding instruction, then a production is added to the grammar where the left-hand side is N and the right-hand side is the general extension terminal. This production is an insertion point production.",
      "zh-CHS": "(5) 如果基类型服从单数插入编码指令，则向语法中添加一个产生式，其中左侧为N，右侧为通用扩展终端。此产品是插入点产品。"
    },
    {
      "indent": 3,
      "text": "(6) If the base type is subject to a UNIFORM-INSERTIONS encoding instruction, then:",
      "zh-CHS": "(6) 如果基类型受统一插入编码指令的约束，则："
    },
    {
      "indent": 7,
      "text": "(a) A production is added to the grammar where the left-hand side is N and the right-hand side is the general extension terminal.",
      "zh-CHS": "(a) 生成式被添加到语法中，其中左侧为N，右侧为通用扩展终端。"
    },
    {
      "indent": 14,
      "text": "Aside: This production is used to verify the correctness of an ASN.1 type definition, but would not be used in the implementation of an RXER decoder. The next production takes precedence over it for accepting an unknown element.",
      "zh-CHS": "旁白：此产品用于验证ASN.1类型定义的正确性，但不会用于RXER解码器的实现。下一个产品优先于它接受未知元素。"
    },
    {
      "indent": 7,
      "text": "(b) A production is added to the grammar where the left-hand side is N and the right-hand side is the terminal for the extension insertion point of the base type followed by the non-terminal for the extension insertion point. This production is an insertion point production.",
      "zh-CHS": "(b) 生成式被添加到语法中，其中左侧是N，右侧是基类型的扩展插入点的端子，后面是扩展插入点的非端子。此产品是插入点产品。"
    },
    {
      "indent": 7,
      "text": "(c) A production is added to the grammar where the left-hand side is the non-terminal for the extension insertion point of the base type and the right-hand side is the terminal for the extension insertion point followed by the non-terminal for the extension insertion point.",
      "zh-CHS": "(c) 将生成项添加到语法中，其中左侧是基类型的扩展插入点的非端子，右侧是扩展插入点的端子，后面是扩展插入点的非端子。"
    },
    {
      "indent": 7,
      "text": "(d) A production is added to the grammar where the left-hand side is the non-terminal for the extension insertion point of the base type and the right-hand side is empty.",
      "zh-CHS": "(d) 将向语法中添加一个结果，其中左侧是基类型的扩展插入点的非端点，右侧为空。"
    },
    {
      "indent": 3,
      "text": "(7) If the base type is subject to a MULTIFORM-INSERTIONS encoding instruction, then:",
      "zh-CHS": "(7) 如果基类型受多种形式插入编码指令的约束，则："
    },
    {
      "indent": 7,
      "text": "(a) A production is added to the grammar where the left-hand side is N and the right-hand side is the general extension terminal followed by the non-terminal for the extension insertion point of the base type. This production is an insertion point production.",
      "zh-CHS": "(a) 生成式被添加到语法中，其中左侧是N，右侧是通用扩展终端，后面是基类型的扩展插入点的非终端。此产品是插入点产品。"
    },
    {
      "indent": 7,
      "text": "(b) A production is added to the grammar where the left-hand side is the non-terminal for the extension insertion point of the base type and the right-hand side is the general extension terminal followed by the non-terminal for the extension insertion point.",
      "zh-CHS": "(b) 将生成项添加到语法中，其中左侧是基类型的扩展插入点的非端子，右侧是通用扩展端子，后面是扩展插入点的非端子。"
    },
    {
      "indent": 7,
      "text": "(c) A production is added to the grammar where the left-hand side is the non-terminal for the extension insertion point of the base type and the right-hand side is empty.",
      "zh-CHS": "(c) 将向语法中添加一个结果，其中左侧是基类型的扩展插入点的非端点，右侧为空。"
    },
    {
      "indent": 3,
      "text": "If an ExtensionAdditionAlternative is a NamedType, then a production is added to the grammar where the left-hand side is the non-terminal for the ExtensionAdditionAlternative and the right-hand side is the primary non-terminal for the NamedType.",
      "zh-CHS": "如果extensionAdditionalAlternative是NamedType，则会向语法中添加一个结果，其中左侧是extensionAdditionalAlternative的非终结符，右侧是NamedType的主要非终结符。"
    },
    {
      "indent": 3,
      "text": "If an ExtensionAdditionAlternative is an ExtensionAdditionAlternativesGroup, then a production is added to the grammar for each NamedType nested in the ExtensionAdditionAlternativesGroup, where the left-hand side is the non-terminal for the ExtensionAdditionAlternative and the right-hand side is the primary non-terminal for the NamedType.",
      "zh-CHS": "如果extensionAdditionalAlternative是extensionAdditionalAlternativeGroup，则会向extensionAdditionalAlternativeGroup中嵌套的每个NamedType的语法中添加一个结果，其中左侧是extensionAdditionalAlternative的非终结符，右侧是NamedType的主要非终结符。"
    },
    {
      "indent": 3,
      "text": "Example",
      "zh-CHS": "实例"
    },
    {
      "indent": 6,
      "text": "Consider the following ASN.1 type definition:",
      "zh-CHS": "考虑下面的ASN . 1类型定义："
    },
    {
      "indent": 9,
      "text": "CHOICE {\n    -- Start of RootAlternativeTypeList.\n    one    BOOLEAN,\n    two    INTEGER,\n    -- End of RootAlternativeTypeList.\n    ...,\n    -- Start of ExtensionAdditionAlternatives.\n    three  INTEGER, -- First ExtensionAdditionAlternative (E1).\n    [[ -- An ExtensionAdditionAlternativesGroup.\n        four  UTF8String,\n        five  INTEGER\n    ]] -- Second ExtensionAdditionAlternative (E2).\n    -- The extension insertion point is here (I1).\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "Here is the grammar derived from this type:",
      "zh-CHS": "以下是从该类型派生的语法："
    },
    {
      "indent": 9,
      "text": "S ::= one\nS ::= two\nS ::= E1\nS ::= E2\nS ::= I1",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "I1 ::= \"*\" I1\nI1 ::=",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "E1 ::= three\nE2 ::= four\nE2 ::= five",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "one ::= \"one\"\ntwo ::= \"two\"\nthree ::= \"three\"\nfour ::= \"four\"\nfive ::= \"five\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "If the CHOICE type were subject to a NO-INSERTIONS encoding instruction, then the fifth, sixth, and seventh productions would be removed.",
      "zh-CHS": "如果选择类型受无插入编码指令的约束，则第五、第六和第七个产品将被删除。"
    },
    {
      "indent": 6,
      "text": "If the CHOICE type were subject to a HOLLOW-INSERTIONS encoding instruction, then the fifth, sixth, and seventh productions would be replaced by:",
      "zh-CHS": "如果选择类型受空插入编码指令的约束，则第五、第六和第七个产品将替换为："
    },
    {
      "indent": 9,
      "text": "S ::=",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "If the CHOICE type were subject to a SINGULAR-INSERTIONS encoding instruction, then the fifth, sixth, and seventh productions would be replaced by:",
      "zh-CHS": "如果选择类型服从单数插入编码指令，则第五、第六和第七个产品将替换为："
    },
    {
      "indent": 9,
      "text": "S ::= \"*\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "If the CHOICE type were subject to a UNIFORM-INSERTIONS encoding instruction, then the fifth and sixth productions would be replaced by:",
      "zh-CHS": "如果选择类型服从统一插入编码指令，则第五和第六个产品将替换为："
    },
    {
      "indent": 9,
      "text": "S ::= \"*\"\nS ::= \"*1\" I1",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "I1 ::= \"*1\" I1",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "If the CHOICE type were subject to a MULTIFORM-INSERTIONS encoding instruction, then the fifth production would be replaced by:",
      "zh-CHS": "如果选择类型受多种形式插入编码指令的约束，则第五个产品将替换为："
    },
    {
      "indent": 9,
      "text": "S ::= \"*\" I1",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Constraints on a SEQUENCE, SET, or CHOICE type are ignored. They do not affect the grammar being generated.",
      "zh-CHS": "忽略序列、集合或选择类型上的约束。它们不会影响正在生成的语法。"
    },
    {
      "indent": 6,
      "text": "Aside: This avoids an awkward situation where values of a subtype have to be decoded differently from values of the parent type. It also simplifies the verification procedure.",
      "zh-CHS": "旁白：这避免了一种尴尬的情况，即子类型的值必须与父类型的值进行不同的解码。它还简化了验证程序。"
    },
    {
      "indent": 3,
      "text": "Given a primary non-terminal, N, and a type that has a SEQUENCE OF or SET OF base type and that permits a value of size zero (i.e., an empty sequence or set):",
      "zh-CHS": "给定一个主非端子N和一个具有基类型序列或基类型集且允许大小为零的类型（即，空序列或基类型集）："
    },
    {
      "indent": 3,
      "text": "(1) a production is added to the grammar where the left-hand side of the production is N and the right-hand side is the primary non-terminal for the NamedType of the component of the SEQUENCE OF or SET OF base type, followed by N, and",
      "zh-CHS": "(1) 将产品添加到语法中，其中产品的左侧为N，右侧为基类型序列或基类型集的组件的NamedType的主要非终结符，后跟N，以及"
    },
    {
      "indent": 3,
      "text": "(2) a production is added to the grammar where the left-hand side of the production is N and the right-hand side is empty.",
      "zh-CHS": "(2) 一个产品被添加到语法中，其中产品的左侧为N，右侧为空。"
    },
    {
      "indent": 3,
      "text": "Given a primary non-terminal, N, a secondary non-terminal, N', and a type that has a SEQUENCE OF or SET OF base type and that does not permit a value of size zero:",
      "zh-CHS": "给定主非端子N、次非端子N’，以及具有基类型序列或基类型集且不允许大小为零的类型："
    },
    {
      "indent": 3,
      "text": "(1) a production is added to the grammar where the left-hand side of the production is N and the right-hand side is the primary non-terminal for the NamedType of the component of the SEQUENCE OF or SET OF base type, followed by N', and",
      "zh-CHS": "(1) 对于产生式类型，N是一个非产生式类型，N后面是一个非产生式类型，N后面是非产生式类型的基"
    },
    {
      "indent": 3,
      "text": "(2) a production is added to the grammar where the left-hand side of the production is N' and the right-hand side is the primary non-terminal for the NamedType of the component of the SEQUENCE OF or SET OF base type, followed by N', and",
      "zh-CHS": "(2) 将产品添加到语法中，其中产品的左侧为N'，右侧为基类型序列或基类型集组件的NamedType的主要非终端，后跟N'，和"
    },
    {
      "indent": 3,
      "text": "(3) a production is added to the grammar where the left-hand side of the production is N' and the right-hand side is empty.",
      "zh-CHS": "(3) 将一个产品添加到语法中，其中产品的左侧为N'，右侧为空。"
    },
    {
      "indent": 3,
      "text": "Example",
      "zh-CHS": "实例"
    },
    {
      "indent": 6,
      "text": "Consider the following ASN.1 type definition:",
      "zh-CHS": "考虑下面的ASN . 1类型定义："
    },
    {
      "indent": 9,
      "text": "SEQUENCE SIZE(1..MAX) OF number INTEGER",
      "zh-CHS": "整数的序列大小（1..MAX）"
    },
    {
      "indent": 6,
      "text": "Here is the grammar derived from this type:",
      "zh-CHS": "以下是从该类型派生的语法："
    },
    {
      "indent": 9,
      "text": "S ::= number S'\nS' ::= number S'\nS' ::=",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "number ::= \"number\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "All inner subtyping (InnerTypeContraints) is ignored for the purposes of deciding whether a value of size zero is permitted by a SEQUENCE OF or SET OF type.",
      "zh-CHS": "为了决定类型序列或类型集是否允许大小为零的值，将忽略所有内部子类型（InnerTypeContracts）。"
    },
    {
      "indent": 3,
      "text": "This completes the description of the transformation of ASN.1 combining type definitions into a grammar.",
      "zh-CHS": "这就完成了ASN.1将类型定义组合到语法中的转换描述。"
    },
    {
      "indent": 0,
      "text": "25.1.2. Unique Component Attribution",
      "section_title": true,
      "zh-CHS": "25.1.2. 唯一组件属性"
    },
    {
      "indent": 3,
      "text": "This section describes conditions that the grammar must satisfy so that each element and attribute in a received RXER encoding can be uniquely associated with an ASN.1 component definition.",
      "zh-CHS": "本节描述语法必须满足的条件，以便接收到的RXER编码中的每个元素和属性都可以与ASN.1组件定义唯一关联。"
    },
    {
      "indent": 3,
      "text": "Definition (used by the grammar): A non-terminal, N, is used by the grammar if:",
      "zh-CHS": "定义（语法使用）：语法使用非终结符N，如果："
    },
    {
      "indent": 3,
      "text": "(1) N is the start symbol or",
      "zh-CHS": "(1) N是开始符号或"
    },
    {
      "indent": 3,
      "text": "(2) N appears on the right-hand side of a production where the non-terminal on the left-hand side is used by the grammar.",
      "zh-CHS": "(2) N出现在产品的右侧，语法使用左侧的非终结符。"
    },
    {
      "indent": 3,
      "text": "Definition (multiple derivation paths): A non-terminal, N, has multiple derivation paths if:",
      "zh-CHS": "定义（多个派生路径）：非终端N具有多个派生路径，如果："
    },
    {
      "indent": 3,
      "text": "(1) N appears on the right-hand side of a production where the non-terminal on the left-hand side has multiple derivation paths, or",
      "zh-CHS": "(1) N出现在产品的右侧，其中左侧的非终端具有多个派生路径，或者"
    },
    {
      "indent": 3,
      "text": "(2) N appears on the right-hand side of more than one production where the non-terminal on the left-hand side is used by the grammar, or",
      "zh-CHS": "(2) N出现在多个产品的右侧，其中语法使用左侧的非终结符，或"
    },
    {
      "indent": 3,
      "text": "(3) N is the start symbol and it appears on the right-hand side of a production where the non-terminal on the left-hand side is used by the grammar.",
      "zh-CHS": "(3) N是开始符号，它出现在产品的右侧，语法使用左侧的非终结符。"
    },
    {
      "indent": 3,
      "text": "For every ASN.1 type with a base type containing components that are subject to a GROUP encoding instruction, the grammar derived by the method described in this document MUST NOT have:",
      "zh-CHS": "对于每个ASN.1类型，其基类型包含受组编码指令约束的组件，通过本文档中描述的方法派生的语法不得具有："
    },
    {
      "indent": 3,
      "text": "(1) two or more primary non-terminals that are used by the grammar and are associated with element components having the same expanded name, or",
      "zh-CHS": "(1) 语法使用的两个或多个主非终结符，它们与具有相同扩展名的元素组件关联，或"
    },
    {
      "indent": 3,
      "text": "(2) two or more primary non-terminals that are used by the grammar and are associated with attribute components having the same expanded name, or",
      "zh-CHS": "(2) 语法使用的两个或多个主非终结符，它们与具有相同扩展名的属性组件关联，或"
    },
    {
      "indent": 3,
      "text": "(3) a primary non-terminal that has multiple derivation paths and is associated with an attribute component.",
      "zh-CHS": "(3) 具有多个派生路径并与属性组件关联的主非终端。"
    },
    {
      "indent": 6,
      "text": "Aside: Case (1) is in response to component referencing notations that are evaluated with respect to the XML encoding of an abstract value. Case (1) guarantees, without having to do extensive testing (which would necessarily have to take account of encoding instructions for all other encoding rules), that all sibling elements with the same expanded name will be associated with equivalent type definitions. Such equivalence allows a component referenced by element name to be re-encoded using a different set of ASN.1 encoding rules without ambiguity as to which type definition and encoding instructions apply.",
      "zh-CHS": "旁白：案例（1）是对组件引用符号的响应，这些符号是根据抽象值的XML编码进行评估的。案例（1）保证，在不必进行大量测试（必须考虑所有其他编码规则的编码指令）的情况下，具有相同扩展名的所有同级元素都将与等效类型定义相关联。这种等价性允许使用一组不同的ASN.1编码规则对元素名引用的组件进行重新编码，而不会对应用的类型定义和编码指令产生歧义。"
    },
    {
      "indent": 6,
      "text": "Cases (2) and (3) ensure that an attribute name is always uniquely associated with one component that can occur at most once and is always nested in the same part of an abstract value.",
      "zh-CHS": "案例（2）和（3）确保属性名始终与最多出现一次的组件唯一关联，并且始终嵌套在抽象值的同一部分中。"
    },
    {
      "indent": 3,
      "text": "Example",
      "zh-CHS": "实例"
    },
    {
      "indent": 6,
      "text": "The following example types illustrate various uses and misuses of the GROUP encoding instruction with respect to unique component attribution:",
      "zh-CHS": "以下示例类型说明了组编码指令在唯一组件属性方面的各种使用和误用："
    },
    {
      "indent": 9,
      "text": "TA ::= SEQUENCE {\n    a  [GROUP] TB,\n    b  [GROUP] CHOICE {\n        a  [GROUP] TB,\n        b  [NAME AS \"c\"] [ATTRIBUTE] INTEGER,\n        c  INTEGER,\n        d  TB,\n        e  [GROUP] TD,\n        f  [ATTRIBUTE] UTF8String\n    },\n    c  [ATTRIBUTE] INTEGER,\n    d  [GROUP] SEQUENCE OF\n        a [GROUP] SEQUENCE {\n            a  [ATTRIBUTE] OBJECT IDENTIFIER,\n            b  INTEGER\n        },\n    e  [NAME AS \"c\"] INTEGER,\n    COMPONENTS OF TD\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "TB ::= SEQUENCE {\n    a  INTEGER,\n    b  [ATTRIBUTE] BOOLEAN,\n    COMPONENTS OF TC\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "TC ::= SEQUENCE {\n    f  OBJECT IDENTIFIER\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "TD ::= SEQUENCE {\n    g  OBJECT IDENTIFIER\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "The grammar for TA is constructed after performing the COMPONENTS OF transformation. The result of this transformation is shown next. This example will depart from the usual convention of using just the identifier of a NamedType to represent the primary non-terminal for that NamedType. A label relative to the outermost type will be used instead to better illustrate unique component attribution. The labels used for the non-terminals are shown down the right-hand side.",
      "zh-CHS": "TA的语法是在执行转换组件之后构建的。下面显示此转换的结果。本例将偏离通常的惯例，即仅使用NamedType的标识符来表示该NamedType的主要非终端。将使用相对于最外层类型的标签来更好地说明唯一组件属性。用于非端子的标签显示在右侧下方。"
    },
    {
      "indent": 9,
      "text": "TA ::= SEQUENCE {\n    a  [GROUP] TB,                             -- TA.a\n    b  [GROUP] CHOICE {                        -- TA.b\n        a  [GROUP] TB,                         -- TA.b.a\n        b  [NAME AS \"c\"] [ATTRIBUTE] INTEGER,  -- TA.b.b\n        c  INTEGER,                            -- TA.b.c\n        d  TB,                                 -- TA.b.d\n        e  [GROUP] TD,                         -- TA.b.e\n        f  [ATTRIBUTE] UTF8String              -- TA.b.f\n    },\n    c  [ATTRIBUTE] INTEGER,                    -- TA.c\n    d  [GROUP] SEQUENCE OF                     -- TA.d\n        a [GROUP] SEQUENCE {                   -- TA.d.a\n            a  [ATTRIBUTE] OBJECT IDENTIFIER,  -- TA.d.a.a\n            b  INTEGER                         -- TA.d.a.b\n        },\n    e  [NAME AS \"c\"] INTEGER,                  -- TA.e\n    g  OBJECT IDENTIFIER                       -- TA.g\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "TB ::= SEQUENCE {\n    a  INTEGER,                                -- TB.a\n    b  [ATTRIBUTE] BOOLEAN,                    -- TB.b\n    f  OBJECT IDENTIFIER                       -- TB.f\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "-- Type TC is no longer of interest. --",
      "zh-CHS": "--类型TC不再感兴趣--"
    },
    {
      "indent": 9,
      "text": "TD ::= SEQUENCE {\n    g  OBJECT IDENTIFIER                       -- TD.g\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "The associated grammar is:",
      "zh-CHS": "相关语法为："
    },
    {
      "indent": 9,
      "text": "S ::= TA.a TA.b TA.c TA.d TA.e TA.g",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "TA.a ::= TB.a TB.b TB.f",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "TB.a ::= \"a\"\nTB.b ::= \"@b\"\nTB.f ::= \"f\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "TA.b ::= TA.b.a\nTA.b ::= TA.b.b\nTA.b ::= TA.b.c\nTA.b ::= TA.b.d\nTA.b ::= TA.b.e\nTA.b ::= TA.b.f",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "TA.b.a ::= TB.a TB.b TB.f\nTA.b.b ::= \"@c\"\nTA.b.c ::= \"c\"\nTA.b.d ::= \"d\"\nTA.b.e ::= TD.g\nTA.b.f ::= \"@f\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "TD.g ::= \"g\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "TA.c ::= \"@c\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "TA.d ::= TA.d.a TA.d\nTA.d ::=",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "TA.d.a ::= TA.d.a.a TA.d.a.b",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "TA.d.a.a := \"@a\"\nTA.d.a.b ::= \"b\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "TA.e ::= \"c\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "TA.g ::= \"g\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "All the non-terminals are used by the grammar.",
      "zh-CHS": "语法使用所有非终结符。"
    },
    {
      "indent": 6,
      "text": "The type definition for TA is invalid because there are two instances where two or more primary non-terminals are associated with element components having the same expanded name:",
      "zh-CHS": "TA的类型定义无效，因为存在两个实例，其中两个或多个主非端子与具有相同扩展名的元素组件相关联："
    },
    {
      "indent": 6,
      "text": "(1) TA.b.c and TA.e (both generate the terminal \"c\"), and",
      "zh-CHS": "(1) TA.b.c和TA.e（均生成终端“c”），以及"
    },
    {
      "indent": 6,
      "text": "(2) TD.g and TA.g (both generate the terminal \"g\").",
      "zh-CHS": "(2) TD.g和TA.g（都生成终端“g”）。"
    },
    {
      "indent": 6,
      "text": "In case (2), TD.g and TA.g are derived from the same instance of NamedType notation, but become distinct components following the COMPONENTS OF transformation. AUTOMATIC tagging is applied after the COMPONENTS OF transformation, which means that the types of the components corresponding to TD.g and TA.g will end up with different tags, and therefore the types will not be equivalent.",
      "zh-CHS": "在案例（2）中，TD.g和TA.g是从NamedType表示法的同一个实例派生的，但在转换组件之后成为不同的组件。在转换的组件之后应用自动标记，这意味着与TD.g和TA.g相对应的组件类型将以不同的标记结束，因此类型将不相等。"
    },
    {
      "indent": 6,
      "text": "The type definition for TA is also invalid because there is one instance where two or more primary non-terminals are associated with attribute components having the same expanded name: TA.b.b and TA.c (both generate the terminal \"@c\").",
      "zh-CHS": "TA的类型定义也无效，因为存在一个实例，其中两个或多个主要非终端与具有相同扩展名的属性组件关联：TA.b.b和TA.c（两者都生成终端“@c”）。"
    },
    {
      "indent": 6,
      "text": "The non-terminals with multiple derivation paths are: TA.d, TA.d.a, TA.d.a.a, TA.d.a.b, TB.a, TB.b, and TB.f. The type definition for TA is also invalid because TA.d.a.a and TB.b are primary non-terminals that are associated with an attribute component.",
      "zh-CHS": "具有多个派生路径的非终端有：TA.d、TA.d.a、TA.d.a.a、TA.d.a.b、TB.a、TB.b和TB.f。TA的类型定义也无效，因为TA.d.a.a和TB.b是与属性组件关联的主要非终端。"
    },
    {
      "indent": 0,
      "text": "25.1.3. Deterministic Grammars",
      "section_title": true,
      "zh-CHS": "25.1.3. 确定性语法"
    },
    {
      "indent": 3,
      "text": "Let the First Set of a production P, denoted First(P), be the set of all element terminals T where T is the first element terminal in a sequence of terminals that can be generated from the right-hand side of P. There can be any number of leading attribute terminals before T.",
      "zh-CHS": "假设生产P的第一组，表示为第一（P），是所有元素端子T的集合，其中T是从P的右侧生成的端子序列中的第一个元素端子。T之前可以有任意数量的前导属性端子。"
    },
    {
      "indent": 3,
      "text": "Let the Follow Set of a non-terminal N, denoted Follow(N), be the set of all element terminals T where T is the first element terminal following N in a sequence of non-terminals and terminals that can be generated from the grammar. There can be any number of attribute terminals between N and T. If a sequence of non-terminals and terminals can be generated from the grammar where N is not followed by any element terminals, then Follow(N) also contains a special end terminal, denoted by \"$\".",
      "zh-CHS": "设非端子N的跟随集，表示为跟随（N），是所有元素端子T的集合，其中T是非端子和端子序列中N之后的第一个元素端子，可以从语法生成。在N和T之间可以有任意数量的属性终端。如果可以从语法生成非终端和终端的序列，其中N后面没有任何元素终端，那么Follow（N）还包含一个特殊的终端，用“$”表示。"
    },
    {
      "indent": 6,
      "text": "Aside: If N does not appear on the right-hand side of any production, then Follow(N) will be empty.",
      "zh-CHS": "旁白：如果N没有出现在任何产品的右侧，则Follow（N）将为空。"
    },
    {
      "indent": 3,
      "text": "For a production P, let the predicate Empty(P) be true if and only if the empty sequence of terminals can be generated from P. Otherwise, Empty(P) is false.",
      "zh-CHS": "对于生产P，当且仅当终端的空序列可以从P生成时，让谓词Empty（P）为true。否则，Empty（P）为false。"
    },
    {
      "indent": 3,
      "text": "Definition (base grammar): The base grammar is a rewriting of the grammar in which the non-terminals for every ExtensionAddition and ExtensionAdditionAlternative are removed from the right-hand side of all productions.",
      "zh-CHS": "定义（基本语法）：基本语法是对语法的重写，其中每个ExtensionAddition和ExtensionAdditionalAlternative的非终结符都从所有产品的右侧删除。"
    },
    {
      "indent": 3,
      "text": "For a production P, let the predicate Preselected(P) be true if and only if every sequence of terminals that can be generated from the right-hand side of P using only the base grammar contains at least one attribute terminal. Otherwise, Preselected(P) is false.",
      "zh-CHS": "对于产品P，当且仅当仅使用基本语法从P的右侧生成的每个端子序列至少包含一个属性端子时，才让谓词预选（P）为真。否则，预选（P）为假。"
    },
    {
      "indent": 3,
      "text": "The Select Set of a production P, denoted Select(P), is empty if Preselected(P) is true; otherwise, it contains First(P). Let N be the non-terminal on the left-hand side of P. If Empty(P) is true, then Select(P) also contains Follow(N).",
      "zh-CHS": "如果预选（P）为真，则表示为Select（P）的生产P的选择集为空；否则，它包含第一个（P）。设N为P左侧的非端子。如果为空（P），则选择（P）也包含Follow（N）。"
    },
    {
      "indent": 6,
      "text": "Aside: It may appear somewhat dubious to include the attribute components in the grammar because, in reality, attributes appear unordered within the start tag of an element, and not interspersed with the child elements as the grammar would suggest. This is why attribute terminals are ignored in composing the First Sets and Follow Sets. However, the attribute terminals are important in composing the Select Sets because they can preselect a production and can prevent a production from being able to generate an empty sequence of terminals. In real terms, this corresponds to an RXER decoder using the attributes to determine the presence or absence of optional components and to select between the alternatives of a CHOICE, even before considering the child elements.",
      "zh-CHS": "旁白：在语法中包含属性组件似乎有点可疑，因为事实上，属性在元素的开始标记中看起来是无序的，而不是像语法所建议的那样散布在子元素中。这就是为什么在组成第一组和后续组时忽略属性端子的原因。但是，属性端子在组成选择集时很重要，因为它们可以预先选择产品，并可以防止产品生成空的端子序列。实际上，这相当于RXER解码器使用属性来确定可选组件的存在或不存在，并在选择的备选方案之间进行选择，甚至在考虑子元素之前。"
    },
    {
      "indent": 6,
      "text": "An attribute appearing in an extension isn't used to preselect a production since, in general, a decoder using an earlier version of the specification would not be able to associate the attribute with any particular extension insertion point.",
      "zh-CHS": "扩展中出现的属性不用于预选产品，因为通常情况下，使用早期版本规范的解码器无法将该属性与任何特定扩展插入点关联。"
    },
    {
      "indent": 3,
      "text": "Let the Reach Set of a non-terminal N, denoted Reach(N), be the set of all element terminals T where T appears in a sequence of terminals that can be generated from N.",
      "zh-CHS": "设非端子N的到达集，表示为到达（N），是所有元件端子T的集合，其中T出现在可由N生成的端子序列中。"
    },
    {
      "indent": 6,
      "text": "Aside: It can be readily shown that all the optional attribute components and all but one of the mandatory attribute components of a SEQUENCE or SET type can be ignored in constructing the grammar because their omission does not alter the First, Follow, Select, or Reach Sets, or the evaluation of the Preselected and Empty predicates.",
      "zh-CHS": "旁白：可以很容易地证明，在构造语法时，可以忽略序列或集合类型的所有可选属性组件和除一个之外的所有必需属性组件，因为它们的省略不会改变第一个、跟随、选择或到达集合，也不会改变预选和空谓词的计算。"
    },
    {
      "indent": 3,
      "text": "A grammar is deterministic (for the purposes of an RXER decoder) if and only if:",
      "zh-CHS": "语法是确定性的（对于RXER解码器而言），当且仅当："
    },
    {
      "indent": 3,
      "text": "(1) there do not exist two productions P and Q, with the same non-terminal on the left-hand side, where the intersection of Select(P) and Select(Q) is not empty, and",
      "zh-CHS": "(1) 不存在两个产品P和Q，在左侧具有相同的非端子，其中Select（P）和Select（Q）的交点不为空，并且"
    },
    {
      "indent": 3,
      "text": "(2) there does not exist a non-terminal E for an ExtensionAddition or ExtensionAdditionAlternative where the intersection of Reach(E) and Follow(E) is not empty.",
      "zh-CHS": "(2) 当到达（E）和跟随（E）的交点不为空时，不存在扩展加法或扩展加法替代的非终端E。"
    },
    {
      "indent": 6,
      "text": "Aside: In case (1), if the intersection is not empty, then a decoder would have two or more possible ways to attempt to decode the input into an abstract value. In case (2), if the intersection is not empty, then a decoder using an earlier version of the ASN.1 specification would confuse an element in an unknown (to that decoder) extension with a known component following the extension.",
      "zh-CHS": "旁白：在案例（1）中，如果交集不是空的，那么解码器将有两种或两种以上可能的方法尝试将输入解码为抽象值。在案例（2）中，如果交集不是空的，那么使用ASN.1规范早期版本的解码器会将未知（该解码器）扩展中的元素与扩展后的已知组件混淆。"
    },
    {
      "indent": 6,
      "text": "Aside: In the absence of any attribute components, case (1) is the test for an LL(1) grammar.",
      "zh-CHS": "旁白：在没有任何属性组件的情况下，case（1）是对LL（1）语法的测试。"
    },
    {
      "indent": 3,
      "text": "For every ASN.1 type with a base type containing components that are subject to a GROUP encoding instruction, the grammar derived by the method described in this document MUST be deterministic.",
      "zh-CHS": "对于每个ASN.1类型，其基类型包含受组编码指令约束的组件，由本文档中描述的方法派生的语法必须是确定性的。"
    },
    {
      "indent": 0,
      "text": "25.1.4. Attributes in Unknown Extensions",
      "section_title": true,
      "zh-CHS": "25.1.4. 未知扩展中的属性"
    },
    {
      "indent": 3,
      "text": "An insertion point production is able to accept unknown attributes if the non-terminal on the left-hand side of the production does not have multiple derivation paths.",
      "zh-CHS": "如果产品左侧的非终端没有多个派生路径，则插入点产品能够接受未知属性。"
    },
    {
      "indent": 6,
      "text": "Aside: If the non-terminal has multiple derivation paths, then any future extension cannot possibly contain an attribute component because that would violate the requirements of Section 25.1.2.",
      "zh-CHS": "旁白：如果非终端具有多个派生路径，则任何未来扩展都不可能包含属性组件，因为这将违反第25.1.2节的要求。"
    },
    {
      "indent": 3,
      "text": "For a deterministic grammar, there is only one possible way to construct a sequence of element terminals matching the element content of an element in a correctly formed RXER encoding. Any unknown attributes of the element are accepted if at least one insertion point production that is able to accept unknown attributes is used in that construction.",
      "zh-CHS": "对于确定性语法，只有一种可能的方法来构造元素终端序列，该序列与正确格式的RXER编码中元素的元素内容相匹配。如果在该构造中使用了至少一个能够接受未知属性的插入点产品，则接受该元素的任何未知属性。"
    },
    {
      "indent": 3,
      "text": "Example",
      "zh-CHS": "实例"
    },
    {
      "indent": 6,
      "text": "Consider this type definition:",
      "zh-CHS": "考虑这种类型定义："
    },
    {
      "indent": 9,
      "text": "CHOICE {\n    one  UTF8String,\n    two  [GROUP] SEQUENCE {\n         three  INTEGER,\n         ...\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "The associated grammar is:",
      "zh-CHS": "相关语法为："
    },
    {
      "indent": 9,
      "text": "S ::= one\nS ::= two",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "two ::= three I1",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "I1 ::= \"*\" I1\nI1 ::=",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "one ::= \"one\"\nthree ::= \"three\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "The third production is an insertion point production, and it is able to accept unknown attributes.",
      "zh-CHS": "第三个产品是插入点产品，它能够接受未知属性。"
    },
    {
      "indent": 6,
      "text": "When decoding a value of this type, if the element content contains a <one> child element, then any unrecognized attribute would be illegal as the insertion point production would not be used to recognize the input (the \"one\" alternative does not admit an extension insertion point). If the element content contains a <three> element, then an unrecognized attribute would be accepted because the insertion point production would be used to recognize the input (the \"two\" alternative that generates the <three> element has an extensible type).",
      "zh-CHS": "解码此类型的值时，如果元素内容包含<一>子元素，则任何无法识别的属性都将是非法的，因为插入点产品将不用于识别输入（“一”选项不允许扩展插入点）。如果元素内容包含<three>元素，则将接受无法识别的属性，因为插入点产品将用于识别输入（生成<three>元素的“两个”备选方案具有可扩展类型）。"
    },
    {
      "indent": 6,
      "text": "If the SEQUENCE type were prefixed by a NO-INSERTIONS encoding instruction, then the third, fourth, and fifth productions would be replaced by:",
      "zh-CHS": "如果序列类型的前缀为无插入编码指令，则第三、第四和第五个结果将替换为："
    },
    {
      "indent": 9,
      "text": "two ::= three",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "With this change, any unrecognized attribute would be illegal for the \"two\" alternative also, since the replacement production is not an insertion point production.",
      "zh-CHS": "通过此更改，任何无法识别的属性对于“两个”备选方案也是非法的，因为替换产品不是插入点产品。"
    },
    {
      "indent": 3,
      "text": "If more than one insertion point production that is able to accept unknown attributes is used in constructing a matching sequence of element terminals, then a decoder is free to associate an unrecognized attribute with any one of the extension insertion points corresponding to those insertion point productions. The justification for doing so comes from the following two observations:",
      "zh-CHS": "如果在构造元素终端的匹配序列时使用了多个能够接受未知属性的插入点产品，则解码器可以自由地将未识别的属性与对应于这些插入点产品的任何一个扩展插入点相关联。这样做的理由来自以下两个观察结果："
    },
    {
      "indent": 3,
      "text": "(1) If the encoding of an abstract value contains an extension where the type of the extension is unknown to the receiver, then it is generally impossible to re-encode the value using a different set of encoding rules, including the canonical variant of the received encoding. This is true no matter which encoding rules are being used. It is desirable for a decoder to be able to accept and store the raw encoding of an extension without raising an error, and to re-insert the raw encoding of the extension when re-encoding the abstract value using the same non-canonical encoding rules. However, there is little more that an application can do with an unknown extension.",
      "zh-CHS": "(1) 如果抽象值的编码包含接收方不知道扩展类型的扩展，则通常不可能使用不同的编码规则集（包括所接收编码的规范变量）对该值进行重新编码。无论使用哪种编码规则，这都是正确的。解码器希望能够在不引起错误的情况下接受和存储扩展的原始编码，并且在使用相同的非规范编码规则重新编码抽象值时重新插入扩展的原始编码。然而，对于未知的扩展，应用程序只能做很少的事情。"
    },
    {
      "indent": 7,
      "text": "An application using RXER can successfully accept, store, and re-encode an unrecognized attribute regardless of which extension insertion point it might be ascribed to.",
      "zh-CHS": "使用RXER的应用程序可以成功地接受、存储和重新编码无法识别的属性，而不管该属性属于哪个扩展插入点。"
    },
    {
      "indent": 3,
      "text": "(2) Even if there is a single extension insertion point, an unknown extension could still be the encoding of a value of any one of an infinite number of valid type definitions. For example, an attribute or element component could be nested to any arbitrary depth within CHOICEs whose components are subject to GROUP encoding instructions.",
      "zh-CHS": "(2) 即使只有一个扩展插入点，未知扩展仍然可以是无限多个有效类型定义中任意一个的值的编码。例如，属性或元素组件可以嵌套到其组件受组编码指令约束的选项中的任意深度。"
    },
    {
      "indent": 10,
      "text": "Aside: A similar series of nested CHOICEs could describe an unknown extension in a Basic Encoding Rules (BER) encoding [X.690].",
      "zh-CHS": "旁白：类似的一系列嵌套选择可以描述基本编码规则（BER）编码[X.690]中的未知扩展。"
    },
    {
      "indent": 0,
      "text": "26. Security Considerations",
      "section_title": true,
      "zh-CHS": "26. 安全考虑"
    },
    {
      "indent": 3,
      "text": "ASN.1 compiler implementors should take special care to be thorough in checking that the GROUP encoding instruction has been correctly used; otherwise, ASN.1 specifications with ambiguous RXER encodings could be deployed.",
      "zh-CHS": "ASN.1编译器实现人员应特别注意彻底检查组编码指令是否已正确使用；否则，可以部署带有不明确RXER编码的ASN.1规范。"
    },
    {
      "indent": 3,
      "text": "Ambiguous encodings mean that the abstract value recovered by a decoder may differ from the original abstract value that was encoded. If that is the case, then a digital signature generated with respect to the original abstract value (using a canonical encoding other than CRXER) will not be successfully verified by a receiver using the decoded abstract value. Also, an abstract value may have security-sensitive fields, and in particular, fields used to grant or deny access. If the decoded abstract value differs from the encoded abstract value, then a receiver using the decoded abstract value will be applying different security policy than that embodied in the original abstract value.",
      "zh-CHS": "模糊编码意味着解码器恢复的抽象值可能不同于编码的原始抽象值。如果是这种情况，则接收器将无法使用解码的抽象值成功验证针对原始抽象值（使用CRXER以外的规范编码）生成的数字签名。此外，抽象值可能具有安全敏感字段，特别是用于授予或拒绝访问的字段。如果解码的抽象值不同于编码的抽象值，则使用解码的抽象值的接收器将应用不同于原始抽象值中体现的安全策略。"
    },
    {
      "indent": 0,
      "text": "27. References",
      "section_title": true,
      "zh-CHS": "27. 工具书类"
    },
    {
      "indent": 0,
      "text": "27.1. Normative References",
      "section_title": true,
      "zh-CHS": "27.1. 规范性引用文件"
    },
    {
      "indent": 3,
      "text": "[BCP14] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "zh-CHS": "[BCP14]Bradner，S.，“RFC中用于表示需求水平的关键词”，BCP 14，RFC 2119，1997年3月。"
    },
    {
      "indent": 3,
      "text": "[URI] Berners-Lee, T., Fielding, R. and L. Masinter, \"Uniform Resource Identifiers (URI): Generic Syntax\", STD 66, RFC 3986, January 2005.",
      "zh-CHS": "[URI]Berners Lee，T.，Fielding，R.和L.Masinter，“统一资源标识符（URI）：通用语法”，STD 66，RFC 3986，2005年1月。"
    },
    {
      "indent": 3,
      "text": "[RXER] Legg, S. and D. Prager, \"Robust XML Encoding Rules (RXER) for Abstract Syntax Notation One (ASN.1)\", RFC 4910, July 2007.",
      "zh-CHS": "[RXER]Legg，S.和D.Prager，“抽象语法表示法1（ASN.1）的健壮XML编码规则（RXER）”，RFC 4910，2007年7月。"
    },
    {
      "indent": 3,
      "text": "[ASN.X] Legg, S., \"Abstract Syntax Notation X (ASN.X)\", RFC 4912, July 2007.",
      "zh-CHS": "[ASN.X]Legg，S.，“抽象语法符号X（ASN.X）”，RFC 4912，2007年7月。"
    },
    {
      "indent": 3,
      "text": "[X.680] ITU-T Recommendation X.680 (07/02) | ISO/IEC 8824-1, Information technology - Abstract Syntax Notation One (ASN.1): Specification of basic notation.",
      "zh-CHS": "[X.680]ITU-T建议X.680（07/02）| ISO/IEC 8824-1，信息技术-抽象语法符号一（ASN.1）：基本符号规范。"
    },
    {
      "indent": 3,
      "text": "[X.680-1] ITU-T Recommendation X.680 (2002) Amendment 1 (10/03) | ISO/IEC 8824-1:2002/Amd 1:2004, Support for EXTENDED-XER.",
      "zh-CHS": "[X.680-1]ITU-T建议X.680（2002）修改件1（10/03）| ISO/IEC 8824-1:2002/Amd 1:2004，对扩展XER的支持。"
    },
    {
      "indent": 3,
      "text": "[X.683] ITU-T Recommendation X.683 (07/02) | ISO/IEC 8824-4, Information technology - Abstract Syntax Notation One (ASN.1): Parameterization of ASN.1 specifications.",
      "zh-CHS": "[X.683]ITU-T建议X.683（07/02）| ISO/IEC 8824-4，信息技术-抽象语法符号1（ASN.1）：ASN.1规范的参数化。"
    },
    {
      "indent": 3,
      "text": "[XML10] Bray, T., Paoli, J., Sperberg-McQueen, C., Maler, E. and F. Yergeau, \"Extensible Markup Language (XML) 1.0 (Fourth Edition)\", W3C Recommendation, http://www.w3.org/TR/2006/REC-xml-20060816, August 2006.",
      "zh-CHS": "[XML10]Bray，T.，Paoli，J.，Sperberg McQueen，C.，Maler，E.和F.Yergeau，“可扩展标记语言（XML）1.0（第四版）”，W3C建议，http://www.w3.org/TR/2006/REC-xml-20060816，2006年8月。"
    },
    {
      "indent": 3,
      "text": "[XMLNS10] Bray, T., Hollander, D., Layman, A., and R. Tobin, \"Namespaces in XML 1.0 (Second Edition)\", W3C Recommendation, http://www.w3.org/TR/2006/REC-xml-names-20060816, August 2006.",
      "zh-CHS": "[XMLNS10]Bray，T.，Hollander，D.，Layman，A.，和R.Tobin，“XML 1.0中的名称空间（第二版）”，W3C建议，http://www.w3.org/TR/2006/REC-xml-names-20060816，2006年8月。"
    },
    {
      "indent": 3,
      "text": "[XSD1] Thompson, H., Beech, D., Maloney, M. and N. Mendelsohn, \"XML Schema Part 1: Structures Second Edition\", W3C Recommendation, http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/, October 2004.",
      "zh-CHS": "[XSD1]Thompson，H.，Beech，D.，Maloney，M.和N.Mendelsohn，“XML模式第1部分：结构第二版”，W3C建议，http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/，2004年10月。"
    },
    {
      "indent": 3,
      "text": "[XSD2] Biron, P. and A. Malhotra, \"XML Schema Part 2: Datatypes Second Edition\", W3C Recommendation, http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/, October 2004.",
      "zh-CHS": "[XSD2]Biron，P.和A.Malhotra，“XML模式第2部分：数据类型第二版”，W3C建议，http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/，2004年10月。"
    },
    {
      "indent": 3,
      "text": "[RNG] Clark, J. and M. Makoto, \"RELAX NG Tutorial\", OASIS Committee Specification, http://www.oasis-open.org/ committees/relax-ng/tutorial-20011203.html, December 2001.",
      "zh-CHS": "[RNG]Clark，J.和M.Makoto，“放松NG教程”，绿洲委员会规范，http://www.oasis-open.org/ committees/relax ng/tutorial-20011203.html，2001年12月。"
    },
    {
      "indent": 0,
      "text": "27.2. Informative References",
      "section_title": true,
      "zh-CHS": "27.2. 资料性引用"
    },
    {
      "indent": 3,
      "text": "[INFOSET] Cowan, J. and R. Tobin, \"XML Information Set (Second Edition)\", W3C Recommendation, http://www.w3.org/ TR/2004/REC-xml-infoset-20040204, February 2004.",
      "zh-CHS": "[INFOSET]Cowan，J.和R.Tobin，“XML信息集（第二版）”，W3C建议，http://www.w3.org/ TR/2004/REC-xml-infoset-200402042004年2月。"
    },
    {
      "indent": 3,
      "text": "[X.690] ITU-T Recommendation X.690 (07/02) | ISO/IEC 8825-1, Information technology - ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER).",
      "zh-CHS": "[X.690]ITU-T建议X.690（07/02）| ISO/IEC 8825-1，信息技术-ASN.1编码规则：基本编码规则（BER）、规范编码规则（CER）和区分编码规则（DER）规范。"
    },
    {
      "indent": 0,
      "text": "Appendix A. GROUP Encoding Instruction Examples",
      "section_title": true,
      "zh-CHS": "附录A.分组编码说明示例"
    },
    {
      "indent": 3,
      "text": "This appendix is non-normative.",
      "zh-CHS": "本附录为非规范性附录。"
    },
    {
      "indent": 3,
      "text": "This appendix contains examples of both correct and incorrect use of the GROUP encoding instruction, determined with respect to the grammars derived from the example type definitions. The productions of the grammars are labeled for convenience. Sets and predicates for non-terminals with only one production will be omitted from the examples since they never indicate non-determinism.",
      "zh-CHS": "本附录包含正确和不正确使用分组编码指令的示例，根据示例类型定义派生的语法确定。为了方便起见，这些语法的产物都贴上了标签。示例中将省略仅具有一个结果的非终端的集合和谓词，因为它们从不表示非确定性。"
    },
    {
      "indent": 3,
      "text": "The requirements of Section 25.1.2 (\"Unique Component Attribution\") are satisfied by all the examples in this appendix and the appendices that follow it.",
      "zh-CHS": "本附录及其后续附录中的所有示例均满足第25.1.2节（“独特组件属性”）的要求。"
    },
    {
      "indent": 0,
      "text": "A.1. Example 1",
      "section_title": true,
      "zh-CHS": "A.1. 例1"
    },
    {
      "indent": 3,
      "text": "Consider this type definition:",
      "zh-CHS": "考虑这种类型定义："
    },
    {
      "indent": 6,
      "text": "SEQUENCE {\n    one    [GROUP] SEQUENCE {\n        two    UTF8String OPTIONAL\n    } OPTIONAL,\n    three  INTEGER\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The associated grammar is:",
      "zh-CHS": "相关语法为："
    },
    {
      "indent": 6,
      "text": "P1:  S ::= one three\nP2:  one ::= two\nP3:  one ::=\nP4:  two ::= \"two\"\nP5:  two ::=\nP6:  three ::= \"three\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Select Sets have to be evaluated to test the validity of the type definition. The grammar leads to the following sets and predicates:",
      "zh-CHS": "必须评估选择集以测试类型定义的有效性。语法导致以下集合和谓词："
    },
    {
      "indent": 6,
      "text": "First(P2) = { \"two\" }\nFirst(P3) = { }\nPreselected(P2) = Preselected(P3) = false\nEmpty(P2) = Empty(P3) = true\nFollow(one) = { \"three\" }\nSelect(P2) = First(P2) + Follow(one) = { \"two\", \"three\" }\nSelect(P3) = First(P3) + Follow(one) = { \"three\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "First(P4) = { \"two\" }\nFirst(P5) = { }\nPreselected(P4) = Preselected(P5) = Empty(P4) = false\nEmpty(P5) = true\nFollow(two) = { \"three\" }\nSelect(P4) = First(P4) = { \"two\" }\nSelect(P5) = First(P5) + Follow(two) = { \"three\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The intersection of Select(P2) and Select(P3) is not empty; hence, the grammar is not deterministic, and the type definition is not valid. If the RXER encoding of a value of the type does not have a child element <two>, then it is not possible to determine whether the \"one\" component is present or absent in the value.",
      "zh-CHS": "Select（P2）和Select（P3）的交点不为空；因此，语法是不确定的，类型定义是无效的。如果该类型值的RXER编码没有子元素<two>，则无法确定该值中是否存在“一”组件。"
    },
    {
      "indent": 3,
      "text": "Now consider this type definition with attributes in the \"one\" component:",
      "zh-CHS": "现在在“一”组件中考虑具有这种属性的类型定义："
    },
    {
      "indent": 6,
      "text": "SEQUENCE {\n    one    [GROUP] SEQUENCE {\n        two    UTF8String OPTIONAL,\n        four   [ATTRIBUTE] BOOLEAN,\n        five   [ATTRIBUTE] BOOLEAN OPTIONAL\n    } OPTIONAL,\n    three  INTEGER\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The associated grammar is:",
      "zh-CHS": "相关语法为："
    },
    {
      "indent": 6,
      "text": "P1:  S ::= one three\nP2:  one ::= two four five\nP3:  one ::=\nP4:  two ::= \"two\"\nP5:  two ::=\nP6:  four ::= \"@four\"\nP7:  five ::= \"@five\"\nP8:  five ::=\nP9:  three ::= \"three\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "This grammar leads to the following sets and predicates:",
      "zh-CHS": "此语法将生成以下集合和谓词："
    },
    {
      "indent": 6,
      "text": "First(P2) = { \"two\" }\nFirst(P3) = { }\nPreselected(P3) = Empty(P2) = false\nPreselected(P2) = Empty(P3) = true\nFollow(one) = { \"three\" }\nSelect(P2) = { }\nSelect(P3) = First(P3) + Follow(one) = { \"three\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "First(P4) = { \"two\" }\nFirst(P5) = { }\nPreselected(P4) = Preselected(P5) = Empty(P4) = false\nEmpty(P5) = true\nFollow(two) = { \"three\" }\nSelect(P4) = First(P4) = { \"two\" }\nSelect(P5) = First(P5) + Follow(two) = { \"three\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "First(P7) = { }\nFirst(P8) = { }\nPreselected(P8) = Empty(P7) = false\nPreselected(P7) = Empty(P8) = true\nFollow(five) = { \"three\" }\nSelect(P7) = { }\nSelect(P8) = First(P8) + Follow(five) = { \"three\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The intersection of Select(P2) and Select(P3) is empty, as is the intersection of Select(P4) and Select(P5) and the intersection of Select(P7) and Select(P8); hence, the grammar is deterministic, and the type definition is valid. In a correct RXER encoding, the \"one\" component will be present if and only if the \"four\" attribute is present.",
      "zh-CHS": "Select（P2）和Select（P3）的交点为空，Select（P4）和Select（P5）的交点为空，Select（P7）和Select（P8）的交点为空；因此，语法是确定性的，类型定义是有效的。在正确的RXER编码中，当且仅当“四”属性存在时，“一”组件才会存在。"
    },
    {
      "indent": 0,
      "text": "A.2. Example 2",
      "section_title": true,
      "zh-CHS": "A.2. 例2"
    },
    {
      "indent": 3,
      "text": "Consider this type definition:",
      "zh-CHS": "考虑这种类型定义："
    },
    {
      "indent": 6,
      "text": "CHOICE {\n    one    [GROUP] SEQUENCE {\n        two    [ATTRIBUTE] BOOLEAN OPTIONAL\n    },\n    three  INTEGER,\n    four   [GROUP] SEQUENCE {\n        five   BOOLEAN OPTIONAL\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The associated grammar is:",
      "zh-CHS": "相关语法为："
    },
    {
      "indent": 6,
      "text": "P1:  S ::= one\nP2:  S ::= three\nP3:  S ::= four\nP4:  one ::= two\nP5:  two ::= \"@two\"\nP6:  two ::=\nP7:  three ::= \"three\"\nP8:  four ::= five\nP9:  five ::= \"five\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "P10: five ::=",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "This grammar leads to the following sets and predicates:",
      "zh-CHS": "此语法将生成以下集合和谓词："
    },
    {
      "indent": 6,
      "text": "First(P1) = { }\nFirst(P2) = { \"three\" }\nFirst(P3) = { \"five\" }\nPreselected(P1) = Preselected(P2) = Preselected(P3) = false\nEmpty(P2) = false\nEmpty(P1) = Empty(P3) = true\nFollow(S) = { \"$\" }\nSelect(P1) = First(P1) + Follow(S) = { \"$\" }\nSelect(P2) = First(P2) = { \"three\" }\nSelect(P3) = First(P3) + Follow(S) = { \"five\", \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "First(P5) = { }\nFirst(P6) = { }\nPreselected(P6) = Empty(P5) = false\nPreselected(P5) = Empty(P6) = true\nFollow(two) = { \"$\" }\nSelect(P5) = { }\nSelect(P6) = First(P6) + Follow(two) = { \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "First(P9) = { \"five\" }\nFirst(P10) = { }\nPreselected(P9) = Preselected(P10) = Empty(P9) = false\nEmpty(P10) = true\nFollow(five) = { \"$\" }\nSelect(P9) = First(P9) = { \"five\" }\nSelect(P10) = First(P10) + Follow(five) = { \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The intersection of Select(P1) and Select(P3) is not empty; hence, the grammar is not deterministic, and the type definition is not valid. If the RXER encoding of a value of the type is empty, then it is not possible to determine whether the \"one\" alternative or the \"four\" alternative has been chosen.",
      "zh-CHS": "Select（P1）和Select（P3）的交点不为空；因此，语法是不确定的，类型定义是无效的。如果类型值的RXER编码为空，则无法确定选择了“一”备选方案还是“四”备选方案。"
    },
    {
      "indent": 3,
      "text": "Now consider this slightly different type definition:",
      "zh-CHS": "现在考虑一下稍微不同的类型定义："
    },
    {
      "indent": 6,
      "text": "CHOICE {\n    one    [GROUP] SEQUENCE {\n        two    [ATTRIBUTE] BOOLEAN\n    },\n    three  INTEGER,\n    four   [GROUP] SEQUENCE {\n        five   BOOLEAN OPTIONAL\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The associated grammar is:",
      "zh-CHS": "相关语法为："
    },
    {
      "indent": 6,
      "text": "P1:  S ::= one\nP2:  S ::= three\nP3:  S ::= four\nP4:  one ::= two\nP5:  two ::= \"@two\"\nP6:  three ::= \"three\"\nP7:  four ::= five\nP8:  five ::= \"five\"\nP9:  five ::=",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "This grammar leads to the following sets and predicates:",
      "zh-CHS": "此语法将生成以下集合和谓词："
    },
    {
      "indent": 6,
      "text": "First(P1) = { }\nFirst(P2) = { \"three\" }\nFirst(P3) = { \"five\" }\nPreselected(P2) = Preselected(P3) = false\nEmpty(P1) = Empty(P2) = false\nPreselected(P1) = Empty(P3) = true\nFollow(S) = { \"$\" }\nSelect(P1) = { }\nSelect(P2) = First(P2) = { \"three\" }\nSelect(P3) = First(P3) + Follow(S) = { \"five\", \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "First(P8) = { \"five\" }\nFirst(P9) = { }\nPreselected(P8) = Preselected(P9) = Empty(P8) = false\nEmpty(P9) = true\nFollow(five) = { \"$\" }\nSelect(P8) = First(P8) = { \"five\" }\nSelect(P9) = First(P9) + Follow(five) = { \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The intersection of Select(P1) and Select(P2) is empty, the intersection of Select(P1) and Select(P3) is empty, the intersection of Select(P2) and Select(P3) is empty, and the intersection of Select(P8) and Select(P9) is empty; hence, the grammar is deterministic, and the type definition is valid. The \"one\" and \"four\" alternatives can be distinguished because the \"one\" alternative has a mandatory attribute.",
      "zh-CHS": "选择（P1）和选择（P2）的交点为空，选择（P1）和选择（P3）的交点为空，选择（P2）和选择（P3）的交点为空，选择（P8）和选择（P9）的交点为空；因此，语法是确定性的，类型定义是有效的。“一”和“四”备选方案可以区分，因为“一”备选方案具有强制性属性。"
    },
    {
      "indent": 0,
      "text": "A.3. Example 3",
      "section_title": true,
      "zh-CHS": "A.3. 例3"
    },
    {
      "indent": 3,
      "text": "Consider this type definition:",
      "zh-CHS": "考虑这种类型定义："
    },
    {
      "indent": 6,
      "text": "SEQUENCE {\n    one  [GROUP] CHOICE {\n        two    [ATTRIBUTE] BOOLEAN,\n        three  [GROUP] SEQUENCE OF number INTEGER\n    } OPTIONAL\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The associated grammar is:",
      "zh-CHS": "相关语法为："
    },
    {
      "indent": 6,
      "text": "P1:  S ::= one\nP2:  one ::= two\nP3:  one ::= three\nP4:  one ::=\nP5:  two ::= \"@two\"\nP6:  three ::= number three\nP7:  three ::=\nP8:  number ::= \"number\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "This grammar leads to the following sets and predicates:",
      "zh-CHS": "此语法将生成以下集合和谓词："
    },
    {
      "indent": 6,
      "text": "First(P2) = { }\nFirst(P3) = { \"number\" }\nFirst(P4) = { }\nPreselected(P3) = Preselected(P4) = Empty(P2) = false\nPreselected(P2) = Empty(P3) = Empty(P4) = true\nFollow(one) = { \"$\" }\nSelect(P2) = { }\nSelect(P3) = First(P3) + Follow(one) = { \"number\", \"$\" }\nSelect(P4) = First(P4) + Follow(one) = { \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "First(P6) = { \"number\" }\nFirst(P7) = { }\nPreselected(P6) = Preselected(P7) = Empty(P6) = false\nEmpty(P7) = true\nFollow(three) = { \"$\" }\nSelect(P6) = First(P6) = { \"number\" }\nSelect(P7) = First(P7) + Follow(three) = { \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The intersection of Select(P3) and Select(P4) is not empty; hence, the grammar is not deterministic, and the type definition is not valid. If the RXER encoding of a value of the type is empty, then it is not possible to determine whether the \"one\" component is absent or the empty \"three\" alternative has been chosen.",
      "zh-CHS": "Select（P3）和Select（P4）的交点不为空；因此，语法是不确定的，类型定义是无效的。如果类型值的RXER编码为空，则无法确定是否缺少“一”组件或是否选择了空的“三”备选方案。"
    },
    {
      "indent": 0,
      "text": "A.4. Example 4",
      "section_title": true,
      "zh-CHS": "A.4. 例4"
    },
    {
      "indent": 3,
      "text": "Consider this type definition:",
      "zh-CHS": "考虑这种类型定义："
    },
    {
      "indent": 6,
      "text": "SEQUENCE {\n    one  [GROUP] CHOICE {\n        two    [ATTRIBUTE] BOOLEAN,\n        three  [ATTRIBUTE] BOOLEAN\n    } OPTIONAL\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The associated grammar is:",
      "zh-CHS": "相关语法为："
    },
    {
      "indent": 6,
      "text": "P1:  S ::= one\nP2:  one ::= two\nP3:  one ::= three\nP4:  one ::=\nP5:  two ::= \"@two\"\nP6:  three ::= \"@three\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "This grammar leads to the following sets and predicates:",
      "zh-CHS": "此语法将生成以下集合和谓词："
    },
    {
      "indent": 6,
      "text": "First(P2) = { }\nFirst(P3) = { }\nFirst(P4) = { }\nPreselected(P4) = Empty(P2) = Empty(P3) = false\nPreselected(P2) = Preselected(P3) = Empty(P4) = true\nFollow(one) = { \"$\" }\nSelect(P2) = { }\nSelect(P3) = { }\nSelect(P4) = First(P4) + Follow(one) = { \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The intersection of Select(P2) and Select(P3) is empty, the intersection of Select(P2) and Select(P4) is empty, and the intersection of Select(P3) and Select(P4) is empty; hence, the grammar is deterministic, and the type definition is valid.",
      "zh-CHS": "选择（P2）和选择（P3）的交点为空，选择（P2）和选择（P4）的交点为空，选择（P3）和选择（P4）的交点为空；因此，语法是确定性的，类型定义是有效的。"
    },
    {
      "indent": 0,
      "text": "A.5. Example 5",
      "section_title": true,
      "zh-CHS": "A.5. 例5"
    },
    {
      "indent": 3,
      "text": "Consider this type definition:",
      "zh-CHS": "考虑这种类型定义："
    },
    {
      "indent": 6,
      "text": "SEQUENCE {\n    one  [GROUP] SEQUENCE OF number INTEGER OPTIONAL\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The associated grammar is:",
      "zh-CHS": "相关语法为："
    },
    {
      "indent": 6,
      "text": "P1:  S ::= one\nP2:  one ::= number one\nP3:  one ::=\nP4:  one ::=\nP5:  number ::= \"number\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "P3 is generated during the processing of the SEQUENCE OF type. P4 is generated because the \"one\" component is optional.",
      "zh-CHS": "P3在处理类型序列的过程中生成。生成P4是因为“一”组件是可选的。"
    },
    {
      "indent": 3,
      "text": "This grammar leads to the following sets and predicates:",
      "zh-CHS": "此语法将生成以下集合和谓词："
    },
    {
      "indent": 6,
      "text": "First(P2) = { \"number\" }\nFirst(P3) = { }\nFirst(P4) = { }\nPreselected(P2) = Preselected(P3) = Preselected(P4) = false\nEmpty(P2) = false\nEmpty(P3) = Empty(P4) = true\nFollow(one) = { \"$\" }\nSelect(P2) = First(P2) = { \"number\" }\nSelect(P3) = First(P3) + Follow(one) = { \"$\" }\nSelect(P4) = First(P4) + Follow(one) = { \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The intersection of Select(P3) and Select(P4) is not empty; hence, the grammar is not deterministic, and the type definition is not valid. If the RXER encoding of a value of the type does not have any <number> child elements, then it is not possible to determine whether the \"one\" component is present or absent in the value.",
      "zh-CHS": "Select（P3）和Select（P4）的交点不为空；因此，语法是不确定的，类型定义是无效的。如果类型值的RXER编码没有任何<number>子元素，则无法确定值中是否存在“一”组件。"
    },
    {
      "indent": 3,
      "text": "Consider this similar type definition with a SIZE constraint:",
      "zh-CHS": "考虑具有大小约束的类似类型定义："
    },
    {
      "indent": 6,
      "text": "SEQUENCE {\n    one  [GROUP] SEQUENCE SIZE(1..MAX) OF number INTEGER OPTIONAL\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The associated grammar is:",
      "zh-CHS": "相关语法为："
    },
    {
      "indent": 6,
      "text": "P1:  S ::= one\nP2:  one ::= number one'\nP3:  one' ::= number one'\nP4:  one' ::=\nP5:  one ::=\nP6:  number ::= \"number\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "This grammar leads to the following sets and predicates:",
      "zh-CHS": "此语法将生成以下集合和谓词："
    },
    {
      "indent": 6,
      "text": "First(P2) = { \"number\" }\nFirst(P5) = { }\nPreselected(P2) = Preselected(P5) = Empty(P2) = false\nEmpty(P5) = true\nFollow(one) = { \"$\" }\nSelect(P2) = First(P2) = { \"number\" }\nSelect(P5) = First(P5) + Follow(one) = { \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "First(P3) = { \"number\" }\nFirst(P4) = { }\nPreselected(P3) = Preselected(P4) = Empty(P3) = false\nEmpty(P4) = true\nFollow(one') = { \"$\" }\nSelect(P3) = First(P3) = { \"number\" }\nSelect(P4) = First(P4) + Follow(one') = { \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The intersection of Select(P2) and Select(P5) is empty, as is the intersection of Select(P3) and Select(P4); hence, the grammar is deterministic, and the type definition is valid. If there are no <number> child elements, then the \"one\" component is necessarily absent and there is no ambiguity.",
      "zh-CHS": "Select（P2）和Select（P5）的交点为空，Select（P3）和Select（P4）的交点也是空的；因此，语法是确定性的，类型定义是有效的。如果没有<number>子元素，则“一”组件必然不存在，并且不存在歧义。"
    },
    {
      "indent": 0,
      "text": "A.6. Example 6",
      "section_title": true,
      "zh-CHS": "A.6. 例6"
    },
    {
      "indent": 3,
      "text": "Consider this type definition:",
      "zh-CHS": "考虑这种类型定义："
    },
    {
      "indent": 6,
      "text": "SEQUENCE {\n    beginning  [GROUP] List,\n    middle     UTF8String OPTIONAL,\n    end        [GROUP] List\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "List ::= SEQUENCE OF string UTF8String",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The associated grammar is:",
      "zh-CHS": "相关语法为："
    },
    {
      "indent": 6,
      "text": "P1:  S ::= beginning middle end\nP2:  beginning ::= string beginning\nP3:  beginning ::=\nP4:  middle ::= \"middle\"\nP5:  middle ::=\nP6:  end ::= string end\nP7:  end ::=\nP8:  string ::= \"string\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "This grammar leads to the following sets and predicates:",
      "zh-CHS": "此语法将生成以下集合和谓词："
    },
    {
      "indent": 6,
      "text": "First(P2) = { \"string\" }\nFirst(P3) = { }\nPreselected(P2) = Preselected(P3) = Empty(P2) = false\nEmpty(P3) = true\nFollow(beginning) = { \"middle\", \"string\", \"$\" }\nSelect(P2) = First(P2) = { \"string\" }\nSelect(P3) = First(P3) + Follow(beginning)\n           = { \"middle\", \"string\", \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "First(P4) = { \"middle\" }\nFirst(P5) = { }\nPreselected(P4) = Preselected(P5) = Empty(P4) = false\nEmpty(P5) = true\nFollow(middle) = { \"string\", \"$\" }\nSelect(P4) = First(P4) = { \"middle\" }\nSelect(P5) = First(P5) + Follow(middle) = { \"string\", \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "First(P6) = { \"string\" }\nFirst(P7) = { }\nPreselected(P6) = Preselected(P7) = Empty(P6) = false\nEmpty(P7) = true\nFollow(end) = { \"$\" }\nSelect(P6) = First(P6) = { \"string\" }\nSelect(P7) = First(P7) + Follow(end) = { \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The intersection of Select(P2) and Select(P3) is not empty; hence, the grammar is not deterministic, and the type definition is not valid.",
      "zh-CHS": "Select（P2）和Select（P3）的交点不为空；因此，语法是不确定的，类型定义是无效的。"
    },
    {
      "indent": 3,
      "text": "Now consider the following type definition:",
      "zh-CHS": "现在考虑下面的类型定义："
    },
    {
      "indent": 6,
      "text": "SEQUENCE {\n    beginning     [GROUP] List,\n    middleAndEnd  [GROUP] SEQUENCE {\n        middle        UTF8String,\n        end           [GROUP] List\n    } OPTIONAL\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The associated grammar is:",
      "zh-CHS": "相关语法为："
    },
    {
      "indent": 6,
      "text": "P1:  S ::= beginning middleAndEnd\nP2:  beginning ::= string beginning\nP3:  beginning ::=\nP4:  middleAndEnd ::= middle end\nP5:  middleAndEnd ::=",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "P6:  middle ::= \"middle\"\nP7:  end ::= string end\nP8:  end ::=\nP9:  string ::= \"string\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "This grammar leads to the following sets and predicates:",
      "zh-CHS": "此语法将生成以下集合和谓词："
    },
    {
      "indent": 6,
      "text": "First(P2) = { \"string\" }\nFirst(P3) = { }\nPreselected(P2) = Preselected(P3) = Empty(P2) = false\nEmpty(P3) = true\nFollow(beginning) = { \"middle\", \"$\" }\nSelect(P2) = First(P2) = { \"string\" }\nSelect(P3) = First(P3) + Follow(beginning) = { \"middle\", \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "First(P4) = { \"middle\" }\nFirst(P5) = { }\nPreselected(P4) = Preselected(P5) = Empty(P4) = false\nEmpty(P5) = true\nFollow(middleAndEnd) = { \"$\" }\nSelect(P4) = First(P4) = { \"middle\" }\nSelect(P5) = First(P5) + Follow(middleAndEnd) = { \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "First(P7) = { \"string\" }\nFirst(P8) = { }\nPreselected(P7) = Preselected(P8) = Empty(P7) = false\nEmpty(P8) = true\nFollow(end) = { \"$\" }\nSelect(P7) = First(P7) = { \"string\" }\nSelect(P8) = First(P8) + Follow(end) = { \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The intersection of Select(P2) and Select(P3) is empty, as is the intersection of Select(P4) and Select(P5) and the intersection of Select(P7) and Select(P8); hence, the grammar is deterministic, and the type definition is valid.",
      "zh-CHS": "Select（P2）和Select（P3）的交点为空，Select（P4）和Select（P5）的交点为空，Select（P7）和Select（P8）的交点为空；因此，语法是确定性的，类型定义是有效的。"
    },
    {
      "indent": 0,
      "text": "A.7. Example 7",
      "section_title": true,
      "zh-CHS": "A.7. 例7"
    },
    {
      "indent": 3,
      "text": "Consider the following type definition:",
      "zh-CHS": "考虑下面的类型定义："
    },
    {
      "indent": 6,
      "text": "SEQUENCE SIZE(1..MAX) OF\n    one  [GROUP] SEQUENCE {\n        two    INTEGER OPTIONAL\n    }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The associated grammar is:",
      "zh-CHS": "相关语法为："
    },
    {
      "indent": 6,
      "text": "P1:  S ::= one S'\nP2:  S' ::= one S'\nP3:  S' ::=\nP4:  one ::= two\nP5:  two ::= \"two\"\nP6:  two ::=",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "This grammar leads to the following sets and predicates:",
      "zh-CHS": "此语法将生成以下集合和谓词："
    },
    {
      "indent": 6,
      "text": "First(P2) = { \"two\" }\nFirst(P3) = { }\nPreselected(P2) = Preselected(P3) = false\nEmpty(P2) = Empty(P3) = true\nFollow(S') = { \"$\" }\nSelect(P2) = First(P2) + Follow(S') = { \"two\", \"$\" }\nSelect(P3) = First(P3) + Follow(S') = { \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "First(P5) = { \"two\" }\nFirst(P6) = { }\nPreselected(P5) = Preselected(P6) = Empty(P5) = false\nEmpty(P6) = true\nFollow(two) = { \"two\", \"$\" }\nSelect(P5) = First(P5) = { \"two\" }\nSelect(P6) = First(P6) + Follow(two) = { \"two\", \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The intersection of Select(P2) and Select(P3) is not empty and the intersection of Select(P5) and Select(P6) is not empty; hence, the grammar is not deterministic, and the type definition is not valid. The encoding of a value of the type contains an indeterminate number of empty instances of the component type.",
      "zh-CHS": "Select（P2）和Select（P3）的交点不为空，Select（P5）和Select（P6）的交点不为空；因此，语法是不确定的，类型定义是无效的。类型值的编码包含不确定数量的组件类型空实例。"
    },
    {
      "indent": 0,
      "text": "A.8. Example 8",
      "section_title": true,
      "zh-CHS": "A.8. 例8"
    },
    {
      "indent": 3,
      "text": "Consider the following type definition:",
      "zh-CHS": "考虑下面的类型定义："
    },
    {
      "indent": 6,
      "text": "SEQUENCE OF list [GROUP] SEQUENCE SIZE(1..MAX) OF number INTEGER",
      "zh-CHS": "数字整数的列表[组]序列大小（1..MAX）的序列"
    },
    {
      "indent": 3,
      "text": "The associated grammar is:",
      "zh-CHS": "相关语法为："
    },
    {
      "indent": 6,
      "text": "P1:  S ::= list S\nP2:  S ::=\nP3:  list ::= number list'\nP4:  list' ::= number list'\nP5:  list' ::=\nP6:  number ::= \"number\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "This grammar leads to the following sets and predicates:",
      "zh-CHS": "此语法将生成以下集合和谓词："
    },
    {
      "indent": 6,
      "text": "First(P1) = { \"number\" }\nFirst(P2) = { }\nPreselected(P1) = Preselected(P2) = Empty(P1) = false\nEmpty(P2) = true\nFollow(S) = { \"$\" }\nSelect(P1) = First(P1) = { \"number\" }\nSelect(P2) = First(P2) + Follow(S) = { \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "First(P4) = { \"number\" }\nFirst(P5) = { }\nPreselected(P4) = Preselected(P5) = Empty(P4) = false\nEmpty(P5) = true\nFollow(list') = { \"number\", \"$\" }\nSelect(P4) = First(P4) = { \"number\" }\nSelect(P5) = First(P5) + Follow(list') = { \"number\", \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The intersection of Select(P4) and Select(P5) is not empty; hence, the grammar is not deterministic, and the type definition is not valid. The type describes a list of lists, but it is not possible for a decoder to determine where the outer lists begin and end.",
      "zh-CHS": "Select（P4）和Select（P5）的交点不为空；因此，语法是不确定的，类型定义是无效的。该类型描述列表列表，但解码器无法确定外部列表的开始和结束位置。"
    },
    {
      "indent": 0,
      "text": "A.9. Example 9",
      "section_title": true,
      "zh-CHS": "A.9. 例9"
    },
    {
      "indent": 3,
      "text": "Consider the following type definition:",
      "zh-CHS": "考虑下面的类型定义："
    },
    {
      "indent": 6,
      "text": "SEQUENCE OF item [GROUP] SEQUENCE {\n    before  [GROUP] OneAndTwo,\n    core    UTF8String,\n    after   [GROUP] OneAndTwo OPTIONAL\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "OneAndTwo ::= SEQUENCE {\n    non-core  UTF8String\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The associated grammar is:",
      "zh-CHS": "相关语法为："
    },
    {
      "indent": 6,
      "text": "P1:  S ::= item S\nP2:  S ::=\nP3:  item ::= before core after\nP4:  before ::= non-core\nP5:  non-core ::= \"non-core\"\nP6:  core ::= \"core\"\nP7:  after ::= non-core\nP8:  after ::=",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "This grammar leads to the following sets and predicates:",
      "zh-CHS": "此语法将生成以下集合和谓词："
    },
    {
      "indent": 6,
      "text": "First(P1) = { \"non-core\" }\nFirst(P2) = { }\nPreselected(P1) = Preselected(P2) = Empty(P1) = false\nEmpty(P2) = true\nFollow(S) = { \"$\" }\nSelect(P1) = First(P1) = { \"non-core\" }\nSelect(P2) = First(P2) + Follow(S) = { \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "First(P7) = { \"non-core\" }\nFirst(P8) = { }\nPreselected(P7) = Preselected(P8) = Empty(P7) = false\nEmpty(P8) = true\nFollow(after) = { \"non-core\", \"$\" }\nSelect(P7) = First(P7) = { \"non-core\" }\nSelect(P8) = First(P8) + Follow(after) = { \"non-core\", \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The intersection of Select(P7) and Select(P8) is not empty; hence, the grammar is not deterministic, and the type definition is not valid. There is ambiguity between the end of one item and the start of the next. Without looking ahead in an encoding, it is not possible to determine whether a <non-core> element belongs with the preceding or following <core> element.",
      "zh-CHS": "Select（P7）和Select（P8）的交点不为空；因此，语法是不确定的，类型定义是无效的。一个项目的结束和下一个项目的开始之间存在模糊性。如果不在编码中向前看，就不可能确定<non-core>元素是属于前面的<core>元素还是后面的<core>元素。"
    },
    {
      "indent": 0,
      "text": "A.10. Example 10",
      "section_title": true,
      "zh-CHS": "A.10. 例10"
    },
    {
      "indent": 3,
      "text": "Consider the following type definition:",
      "zh-CHS": "考虑下面的类型定义："
    },
    {
      "indent": 6,
      "text": "CHOICE {\n    one   [GROUP] List,\n    two   [GROUP] SEQUENCE {\n        three  [ATTRIBUTE] UTF8String,\n        four   [GROUP] List\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "List ::= SEQUENCE OF string UTF8String",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The associated grammar is:",
      "zh-CHS": "相关语法为："
    },
    {
      "indent": 6,
      "text": "P1:  S ::= one\nP2:  S ::= two\nP3:  one ::= string one\nP4:  one ::=\nP5:  two ::= three four\nP6:  three ::= \"@three\"\nP7:  four ::= string four",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "P8:  four ::=\nP9:  string ::= \"string\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "This grammar leads to the following sets and predicates:",
      "zh-CHS": "此语法将生成以下集合和谓词："
    },
    {
      "indent": 6,
      "text": "First(P1) = { \"string\" }\nFirst(P2) = { \"string\" }\nPreselected(P1) = Empty(P2) = false\nPreselected(P2) = Empty(P1) = true\nFollow(S) = { \"$\" }\nSelect(P1) = First(P1) + Follow(S) = { \"string\", \"$\" }\nSelect(P2) = { }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "First(P3) = { \"string\" }\nFirst(P4) = { }\nPreselected(P3) = Preselected(P4) = Empty(P3) = false\nEmpty(P4) = true\nFollow(one) = { \"$\" }\nSelect(P3) = First(P3) = { \"string\" }\nSelect(P4) = First(P4) + Follow(one) = { \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "First(P7) = { \"string\" }\nFirst(P8) = { }\nPreselected(P7) = Preselected(P8) = Empty(P7) = false\nEmpty(P8) = true\nFollow(four) = { \"$\" }\nSelect(P7) = First(P7) = { \"string\" }\nSelect(P8) = First(P8) + Follow(four) = { \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The intersection of Select(P1) and Select(P2) is empty, as is the intersection of Select(P3) and Select(P4) and the intersection of Select(P7) and Select(P8); hence, the grammar is deterministic, and the type definition is valid. Although both alternatives of the CHOICE can begin with a <string> element, an RXER decoder would use the presence of a \"three\" attribute to decide whether to select or disregard the \"two\" alternative.",
      "zh-CHS": "Select（P1）和Select（P2）的交点为空，Select（P3）和Select（P4）的交点为空，Select（P7）和Select（P8）的交点为空；因此，语法是确定性的，类型定义是有效的。尽管选择的两个备选方案都可以从<string>元素开始，但RXER解码器将使用“三”属性的存在来决定是选择还是忽略“两”备选方案。"
    },
    {
      "indent": 3,
      "text": "However, an attribute in an extension cannot be used to select between alternatives. Consider the following type definition:",
      "zh-CHS": "但是，扩展中的属性不能用于在备选方案之间进行选择。考虑下面的类型定义："
    },
    {
      "indent": 6,
      "text": "[SINGULAR-INSERTIONS] CHOICE {\n    one   [GROUP] List,\n    ...,\n    two   [GROUP] SEQUENCE {\n        three  [ATTRIBUTE] UTF8String,\n        four   [GROUP] List\n    } -- ExtensionAdditionAlternative (E1).\n    -- The extension insertion point is here (I1).\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "List ::= SEQUENCE OF string UTF8String",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The associated grammar is:",
      "zh-CHS": "相关语法为："
    },
    {
      "indent": 6,
      "text": "P1:  S ::= one\nP10: S ::= E1\nP11: S ::= \"*\"\nP12: E1 ::= two\nP3:  one ::= string one\nP4:  one ::=\nP5:  two ::= three four\nP6:  three ::= \"@three\"\nP7:  four ::= string four\nP8:  four ::=\nP9:  string ::= \"string\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "This grammar leads to the following sets and predicates for P1, P10 and P11:",
      "zh-CHS": "该语法为P1、P10和P11生成以下集合和谓词："
    },
    {
      "indent": 6,
      "text": "First(P1) = { \"string\" }\nFirst(P10) = { \"string\" }\nFirst(P11) = { \"*\" }\nPreselected(P1) = Preselected(P10) = Preselected(P11) = false\nEmpty(P10) = Empty(P11) = false\nEmpty(P1) = true\nFollow(S) = { \"$\" }\nSelect(P1) = First(P1) + Follow(S) = { \"string\", \"$\" }\nSelect(P10) = First(P10) = { \"string\" }\nSelect(P11) = First(P11) = { \"*\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Preselected(P10) evaluates to false because Preselected(P10) is evaluated on the base grammar, wherein P10 is rewritten as:",
      "zh-CHS": "Preselected（P10）计算结果为false，因为Preselected（P10）是在基本语法上计算的，其中P10被重写为："
    },
    {
      "indent": 6,
      "text": "P10: S ::=",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The intersection of Select(P1) and Select(P10) is not empty; hence, the grammar is not deterministic, and the type definition is not valid. An RXER decoder using the original, unextended version of the definition would not know that the \"three\" attribute selects between the \"one\" alternative and the extension.",
      "zh-CHS": "Select（P1）和Select（P10）的交点不为空；因此，语法是不确定的，类型定义是无效的。使用原始未扩展版本的定义的RXER解码器将不知道“三”属性在“一”选项和扩展之间进行选择。"
    },
    {
      "indent": 0,
      "text": "Appendix B. Insertion Encoding Instruction Examples",
      "section_title": true,
      "zh-CHS": "附录B.插入编码指令示例"
    },
    {
      "indent": 3,
      "text": "This appendix is non-normative.",
      "zh-CHS": "本附录为非规范性附录。"
    },
    {
      "indent": 3,
      "text": "This appendix contains examples showing the use of insertion encoding instructions to remove extension ambiguity arising from use of the GROUP encoding instruction.",
      "zh-CHS": "本附录包含使用插入编码指令消除因使用组编码指令而产生的扩展歧义的示例。"
    },
    {
      "indent": 0,
      "text": "B.1. Example 1",
      "section_title": true,
      "zh-CHS": "B.1. 例1"
    },
    {
      "indent": 3,
      "text": "Consider the following type definition:",
      "zh-CHS": "考虑下面的类型定义："
    },
    {
      "indent": 6,
      "text": "SEQUENCE {\n    one    [GROUP] SEQUENCE {\n        two    UTF8String,\n        ... -- Extension insertion point (I1).\n    },\n    three  INTEGER OPTIONAL,\n    ... -- Extension insertion point (I2).\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The associated grammar is:",
      "zh-CHS": "相关语法为："
    },
    {
      "indent": 6,
      "text": "P1:  S ::= one three I2\nP2:  one ::= two I1\nP3:  two ::= \"two\"\nP4:  I1 ::= \"*\" I1\nP5:  I1 ::=\nP6:  three ::= \"three\"\nP7:  three ::=\nP8:  I2 ::= \"*\" I2\nP9:  I2 ::=",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "This grammar leads to the following sets and predicates:",
      "zh-CHS": "此语法将生成以下集合和谓词："
    },
    {
      "indent": 6,
      "text": "First(P4) = { \"*\" }\nFirst(P5) = { }\nPreselected(P4) = Preselected(P5) = Empty(P4) = false\nEmpty(P5) = true\nFollow(I1) = { \"three\", \"*\", \"$\" }\nSelect(P4) = First(P4) = { \"*\" }\nSelect(P5) = First(P5) + Follow(I1) = { \"three\", \"*\", \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "First(P6) = { \"three\" }\nFirst(P7) = { }\nPreselected(P6) = Preselected(P7) = Empty(P6) = false\nEmpty(P7) = true\nFollow(three) = { \"*\", \"$\" }\nSelect(P6) = First(P6) = { \"three\" }\nSelect(P7) = First(P7) + Follow(three) = { \"*\", \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "First(P8) = { \"*\" }\nFirst(P9) = { }\nPreselected(P8) = Preselected(P9) = Empty(P8) = false\nEmpty(P9) = true\nFollow(I2) = { \"$\" }\nSelect(P8) = First(P8) = { \"*\" }\nSelect(P9) = First(P9) + Follow(I2) = { \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The intersection of Select(P4) and Select(P5) is not empty; hence, the grammar is not deterministic, and the type definition is not valid. If an RXER decoder encounters an unrecognized element immediately after a <two> element, then it will not know whether to associate it with extension insertion point I1 or I2.",
      "zh-CHS": "Select（P4）和Select（P5）的交点不为空；因此，语法是不确定的，类型定义是无效的。如果RXER解码器在<two>元素之后立即遇到无法识别的元素，那么它将不知道是否将其与扩展插入点I1或I2关联。"
    },
    {
      "indent": 3,
      "text": "The non-determinism can be resolved with either a NO-INSERTIONS or HOLLOW-INSERTIONS encoding instruction. Consider this revised type definition:",
      "zh-CHS": "非确定性可以通过无插入或空插入编码指令来解决。考虑修改后的类型定义："
    },
    {
      "indent": 6,
      "text": "SEQUENCE {\n    one    [GROUP] [HOLLOW-INSERTIONS] SEQUENCE {\n        two    UTF8String,\n        ... -- Extension insertion point (I1).\n    },\n    three  INTEGER OPTIONAL,\n    ... -- Extension insertion point (I2).\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The associated grammar is:",
      "zh-CHS": "相关语法为："
    },
    {
      "indent": 6,
      "text": "P1:  S ::= one three I2\nP10: one ::= two\nP3:  two ::= \"two\"\nP6:  three ::= \"three\"\nP7:  three ::=\nP8:  I2 ::= \"*\" I2\nP9:  I2 ::=",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "With the addition of the HOLLOW-INSERTIONS encoding instruction, the P4 and P5 productions are no longer generated, and the conflict between Select(P4) and Select(P5) no longer exists. The Select Sets",
      "zh-CHS": "随着空心插入编码指令的添加，不再生成P4和P5生成，Select（P4）和Select（P5）之间的冲突也不再存在。选择集"
    },
    {
      "indent": 3,
      "text": "for P6, P7, P8, and P9 are unchanged. A decoder will now assume that an unrecognized element is to be associated with extension insertion point I2. It is still free to associate an unrecognized attribute with either extension insertion point. If a NO-INSERTIONS encoding instruction had been used, then an unrecognized attribute could only be associated with extension insertion point I2.",
      "zh-CHS": "对于P6、P8和P7，它们是不变的。解码器现在将假定未识别的元素与扩展插入点I2相关联。仍然可以将无法识别的属性与任一扩展插入点关联。如果使用了非插入编码指令，则无法识别的属性只能与扩展插入点I2关联。"
    },
    {
      "indent": 3,
      "text": "The non-determinism could also be resolved by adding a NO-INSERTIONS or HOLLOW-INSERTIONS encoding instruction to the outer SEQUENCE:",
      "zh-CHS": "非确定性也可以通过向外部序列添加无插入或空插入编码指令来解决："
    },
    {
      "indent": 6,
      "text": "[HOLLOW-INSERTIONS] SEQUENCE {\n    one    [GROUP] SEQUENCE {\n        two    UTF8String,\n        ... -- Extension insertion point (I1).\n    },\n    three  INTEGER OPTIONAL,\n    ... -- Extension insertion point (I2).\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The associated grammar is:",
      "zh-CHS": "相关语法为："
    },
    {
      "indent": 6,
      "text": "P11: S ::= one three\nP2:  one ::= two I1\nP3:  two ::= \"two\"\nP4:  I1 ::= \"*\" I1\nP5:  I1 ::=\nP6:  three ::= \"three\"\nP7:  three ::=",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "This grammar leads to the following sets and predicates:",
      "zh-CHS": "此语法将生成以下集合和谓词："
    },
    {
      "indent": 6,
      "text": "First(P4) = { \"*\" }\nFirst(P5) = { }\nPreselected(P4) = Preselected(P5) = Empty(P4) = false\nEmpty(P5) = true\nFollow(I1) = { \"three\", \"$\" }\nSelect(P4) = First(P4) = { \"*\" }\nSelect(P5) = First(P5) + Follow(I1) = { \"three\", \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "First(P6) = { \"three\" }\nFirst(P7) = { }\nPreselected(P6) = Preselected(P7) = Empty(P6) = false\nEmpty(P7) = true\nFollow(three) = { \"$\" }\nSelect(P6) = First(P6) = { \"three\" }\nSelect(P7) = First(P7) + Follow(three) = { \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The intersection of Select(P4) and Select(P5) is empty, as is the intersection of Select(P6) and Select(P7); hence, the grammar is deterministic, and the type definition is valid. A decoder will now assume that an unrecognized element is to be associated with extension insertion point I1. It is still free to associate an unrecognized attribute with either extension insertion point. If a NO-INSERTIONS encoding instruction had been used, then an unrecognized attribute could only be associated with extension insertion point I1.",
      "zh-CHS": "Select（P4）和Select（P5）的交点为空，Select（P6）和Select（P7）的交点也是空的；因此，语法是确定性的，类型定义是有效的。解码器现在将假定未识别的元素与扩展插入点I1相关联。仍然可以将无法识别的属性与任一扩展插入点关联。如果使用了非插入编码指令，则无法识别的属性只能与扩展插入点I1关联。"
    },
    {
      "indent": 0,
      "text": "B.2. Example 2",
      "section_title": true,
      "zh-CHS": "B.2. 例2"
    },
    {
      "indent": 3,
      "text": "Consider the following type definition:",
      "zh-CHS": "考虑下面的类型定义："
    },
    {
      "indent": 6,
      "text": "SEQUENCE {\n    one  [GROUP] CHOICE {\n        two  UTF8String,\n        ... -- Extension insertion point (I1).\n    } OPTIONAL\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The associated grammar is:",
      "zh-CHS": "相关语法为："
    },
    {
      "indent": 6,
      "text": "P1:  S ::= one\nP2:  one ::= two\nP3:  one ::= I1\nP4:  one ::=\nP5:  two ::= \"two\"\nP6:  I1 ::= \"*\" I1\nP7:  I1 ::=",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "This grammar leads to the following sets and predicates:",
      "zh-CHS": "此语法将生成以下集合和谓词："
    },
    {
      "indent": 6,
      "text": "First(P2) = { \"two\" }\nFirst(P3) = { \"*\" }\nFirst(P4) = { }\nPreselected(P2) = Preselected(P3) = Preselected(P4) = false\nEmpty(P2) = false\nEmpty(P3) = Empty(P4) = true\nFollow(one) = { \"$\" }\nSelect(P2) = First(P2) = { \"two\" }\nSelect(P3) = First(P3) + Follow(one) = { \"*\", \"$\" }\nSelect(P4) = First(P4) + Follow(one) = { \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "First(P6) = { \"*\" }\nFirst(P7) = { }\nPreselected(P6) = Preselected(P7) = Empty(P6) = false\nEmpty(P7) = true",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "Follow(I1) = { \"$\" }\nSelect(P6) = First(P6) = { \"*\" }\nSelect(P7) = First(P7) + Follow(I1) = { \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The intersection of Select(P3) and Select(P4) is not empty; hence, the grammar is not deterministic, and the type definition is not valid. If the <two> element is not present, then a decoder cannot determine whether the \"one\" alternative is absent, or present with an unknown extension that generates no elements.",
      "zh-CHS": "Select（P3）和Select（P4）的交点不为空；因此，语法是不确定的，类型定义是无效的。如果<two>元素不存在，则解码器无法确定是否缺少“一”备选方案，或者是否存在不生成任何元素的未知扩展。"
    },
    {
      "indent": 3,
      "text": "The non-determinism can be resolved with either a SINGULAR-INSERTIONS, UNIFORM-INSERTIONS, or MULTIFORM-INSERTIONS encoding instruction. The MULTIFORM-INSERTIONS encoding instruction is the least restrictive. Consider this revised type definition:",
      "zh-CHS": "非确定性可以通过单数插入、均匀插入或多形式插入编码指令来解决。多形式插入编码指令的限制性最小。考虑修改后的类型定义："
    },
    {
      "indent": 6,
      "text": "SEQUENCE {\n    one  [GROUP] [MULTIFORM-INSERTIONS] CHOICE {\n        two  UTF8String,\n        ... -- Extension insertion point (I1).\n    } OPTIONAL\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The associated grammar is:",
      "zh-CHS": "相关语法为："
    },
    {
      "indent": 6,
      "text": "P1:  S ::= one\nP2:  one ::= two\nP8:  one ::= \"*\" I1\nP4:  one ::=\nP5:  two ::= \"two\"\nP6:  I1 ::= \"*\" I1\nP7:  I1 ::=",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "This grammar leads to the following sets and predicates:",
      "zh-CHS": "此语法将生成以下集合和谓词："
    },
    {
      "indent": 6,
      "text": "First(P2) = { \"two\" }\nFirst(P8) = { \"*\" }\nFirst(P4) = { }\nPreselected(P2) = Preselected(P8) = Preselected(P4) = false\nEmpty(P2) = Empty(P8) = false\nEmpty(P4) = true\nFollow(one) = { \"$\" }\nSelect(P2) = First(P2) = { \"two\" }\nSelect(P8) = First(P8) = { \"*\" }\nSelect(P4) = First(P4) + Follow(one) = { \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "First(P6) = { \"*\" }\nFirst(P7) = { }\nPreselected(P6) = Preselected(P7) = Empty(P6) = false",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "Empty(P7) = true\nFollow(I1) = { \"$\" }\nSelect(P6) = First(P6) = { \"*\" }\nSelect(P7) = First(P7) + Follow(I1) = { \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The intersection of Select(P2) and Select(P8) is empty, as is the intersection of Select(P2) and Select(P4), the intersection of Select(P8) and Select(P4), and the intersection of Select(P6) and Select(P7); hence, the grammar is deterministic, and the type definition is valid. A decoder will now assume the \"one\" alternative is present if it sees at least one unrecognized element, and absent otherwise.",
      "zh-CHS": "Select（P2）和Select（P8）的交点为空，Select（P2）和Select（P4）的交点为空，Select（P8）和Select（P4）的交点为空，Select（P6）和Select（P7）的交点为空；因此，语法是确定性的，类型定义是有效的。如果解码器看到至少一个不可识别的元素，则现在将假定存在“一”备选方案，否则将不存在。"
    },
    {
      "indent": 0,
      "text": "B.3. Example 3",
      "section_title": true,
      "zh-CHS": "B.3. 例3"
    },
    {
      "indent": 3,
      "text": "Consider the following type definition:",
      "zh-CHS": "考虑下面的类型定义："
    },
    {
      "indent": 6,
      "text": "SEQUENCE {\n    one    [GROUP] CHOICE {\n        two    UTF8String,\n        ... -- Extension insertion point (I1).\n    },\n    three  [GROUP] CHOICE {\n        four   UTF8String,\n        ... -- Extension insertion point (I2).\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The associated grammar is:",
      "zh-CHS": "相关语法为："
    },
    {
      "indent": 6,
      "text": "P1:  S ::= one three\nP2:  one ::= two\nP3:  one ::= I1\nP4:  two ::= \"two\"\nP5:  I1 ::= \"*\" I1\nP6:  I1 ::=\nP7:  three ::= four\nP8:  three ::= I2\nP9:  four ::= \"four\"\nP10: I2 ::= \"*\" I2\nP11: I2 ::=",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "This grammar leads to the following sets and predicates:",
      "zh-CHS": "此语法将生成以下集合和谓词："
    },
    {
      "indent": 6,
      "text": "First(P2) = { \"two\" }\nFirst(P3) = { \"*\" }\nPreselected(P2) = Preselected(P3) = Empty(P2) = false\nEmpty(P3) = true",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "Follow(one) = { \"four\", \"*\", \"$\" }\nSelect(P2) = First(P2) = { \"two\" }\nSelect(P3) = First(P3) + Follow(one) = { \"*\", \"four\", \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "First(P5) = { \"*\" }\nFirst(P6) = { }\nPreselected(P5) = Preselected(P6) = Empty(P5) = false\nEmpty(P6) = true\nFollow(I1) = { \"four\", \"*\", \"$\" }\nSelect(P5) = First(P5) = { \"*\" }\nSelect(P6) = First(P6) + Follow(I1) = { \"four\", \"*\", \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "First(P7) = { \"four\" }\nFirst(P8) = { \"*\" }\nPreselected(P7) = Preselected(P8) = Empty(P7) = false\nEmpty(P8) = true\nFollow(three) = { \"$\" }\nSelect(P7) = First(P7) = { \"four\" }\nSelect(P8) = First(P8) + Follow(three) = { \"*\", \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "First(P10) = { \"*\" }\nFirst(P11) = { }\nPreselected(P10) = Preselected(P11) = Empty(P10) = false\nEmpty(P11) = true\nFollow(I2) = { \"$\" }\nSelect(P10) = First(P10) = { \"*\" }\nSelect(P11) = First(P11) + Follow(I2) = { \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The intersection of Select(P5) and Select(P6) is not empty; hence, the grammar is not deterministic, and the type definition is not valid. If the first child element is an unrecognized element, then a decoder cannot determine whether to associate it with extension insertion point I1, or to associate it with extension insertion point I2 by assuming that the \"one\" component has an unknown extension that generates no elements.",
      "zh-CHS": "Select（P5）和Select（P6）的交点不为空；因此，语法是不确定的，类型定义是无效的。如果第一个子元素是无法识别的元素，则解码器无法通过假设“一”组件具有不生成元素的未知扩展来确定是将其与扩展插入点I1关联，还是将其与扩展插入点I2关联。"
    },
    {
      "indent": 3,
      "text": "The non-determinism can be resolved with either a SINGULAR-INSERTIONS or UNIFORM-INSERTIONS encoding instruction. Consider this revised type definition using the SINGULAR-INSERTIONS encoding instruction:",
      "zh-CHS": "非确定性可以通过单数插入或统一插入编码指令来解决。使用奇数插入编码指令考虑此修订类型定义："
    },
    {
      "indent": 6,
      "text": "SEQUENCE {\n    one    [GROUP] [SINGULAR-INSERTIONS] CHOICE {\n        two    UTF8String,\n        ... -- Extension insertion point (I1).\n    },\n    three  [GROUP] CHOICE {\n        four   UTF8String,\n        ... -- Extension insertion point (I2).\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The associated grammar is:",
      "zh-CHS": "相关语法为："
    },
    {
      "indent": 6,
      "text": "P1:  S ::= one three\nP2:  one ::= two\nP12: one ::= \"*\"\nP4:  two ::= \"two\"\nP7:  three ::= four\nP8:  three ::= I2\nP9:  four ::= \"four\"\nP10: I2 ::= \"*\" I2\nP11: I2 ::=",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "With the addition of the SINGULAR-INSERTIONS encoding instruction, the P5 and P6 productions are no longer generated. The grammar leads to the following sets and predicates for the P2 and P12 productions:",
      "zh-CHS": "通过添加SINGULAR-INSERTIONS编码指令，不再生成P5和P6产品。该语法为P2和P12产品提供以下集合和谓词："
    },
    {
      "indent": 6,
      "text": "First(P2) = { \"two\" }\nFirst(P12) = { \"*\" }\nPreselected(P2) = Preselected(P12) = false\nEmpty(P2) = Empty(P12) = false\nFollow(one) = { \"four\", \"*\", \"$\" }\nSelect(P2) = First(P2) = { \"two\" }\nSelect(P12) = First(P12) = { \"*\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The sets for P5 and P6 are no longer generated, and the remaining sets are unchanged.",
      "zh-CHS": "不再生成P5和P6的集合，其余集合不变。"
    },
    {
      "indent": 3,
      "text": "The intersection of Select(P2) and Select(P12) is empty, as is the intersection of Select(P7) and Select(P8) and the intersection of Select(P10) and Select(P11); hence, the grammar is deterministic, and the type definition is valid. If the first child element is an unrecognized element, then a decoder will now assume that it is associated with extension insertion point I1. Whatever follows, possibly including another unrecognized element, will belong to the \"three\" component.",
      "zh-CHS": "Select（P2）和Select（P12）的交点为空，Select（P7）和Select（P8）的交点为空，Select（P10）和Select（P11）的交点为空；因此，语法是确定性的，类型定义是有效的。如果第一个子元素是无法识别的元素，那么解码器现在将假定它与扩展插入点I1关联。接下来的任何内容，可能包括另一个无法识别的元素，都将属于“三”部分。"
    },
    {
      "indent": 3,
      "text": "Now consider the type definition using the UNIFORM-INSERTIONS encoding instruction instead:",
      "zh-CHS": "现在，使用统一插入编码指令来考虑类型定义，而不是："
    },
    {
      "indent": 6,
      "text": "SEQUENCE {\n    one    [GROUP] [UNIFORM-INSERTIONS] CHOICE {\n        two    UTF8String,\n        ... -- Extension insertion point (I1).\n    },\n    three  [GROUP] CHOICE {\n        four   UTF8String,\n        ... -- Extension insertion point (I2).\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The associated grammar is:",
      "zh-CHS": "相关语法为："
    },
    {
      "indent": 6,
      "text": "P1:  S ::= one three\nP2:  one ::= two\nP13: one ::= \"*\"\nP14: one ::= \"*1\" I1\nP4:  two ::= \"two\"\nP15: I1 ::= \"*1\" I1\nP6:  I1 ::=\nP7:  three ::= four\nP8:  three ::= I2\nP9:  four ::= \"four\"\nP10: I2 ::= \"*\" I2\nP11: I2 ::=",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "This grammar leads to the following sets and predicates for the P2, P13, P14, P15, and P6 productions:",
      "zh-CHS": "此语法为P2、P13、P14、P15和P6产品生成以下集合和谓词："
    },
    {
      "indent": 6,
      "text": "First(P2) = { \"two\" }\nFirst(P13) = { \"*\" }\nFirst(P14) = { \"*1\" }\nPreselected(P2) = Preselected(P13) = Preselected(P14) = false\nEmpty(P2) = Empty(P13) = Empty(P14) = false\nFollow(one) = { \"four\", \"*\", \"$\" }\nSelect(P2) = First(P2) = { \"two\" }\nSelect(P13) = First(P13) = { \"*\" }\nSelect(P14) = First(P14) = { \"*1\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "First(P15) = { \"*1\" }\nFirst(P6) = { }\nPreselected(P15) = Preselected(P6) = Empty(P15) = false\nEmpty(P6) = true\nFollow(I1) = { \"four\", \"*\", \"$\" }\nSelect(P15) = First(P15) = { \"*1\" }\nSelect(P6) = First(P6) + Follow(I1) = { \"four\", \"*\", \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The remaining sets are unchanged.",
      "zh-CHS": "其余的几组没有变化。"
    },
    {
      "indent": 3,
      "text": "The intersection of Select(P2) and Select(P13) is empty, as is the intersection of Select(P2) and Select(P14), the intersection of Select(P13) and Select(P14) and the intersection of Select(P15) and Select(P6); hence, the grammar is deterministic, and the type definition is valid. If the first child element is an unrecognized element, then a decoder will now assume that it and every subsequent unrecognized element with the same name are associated with I1. Whatever follows, possibly including another unrecognized element with a different name, will belong to the \"three\" component.",
      "zh-CHS": "选择（P2）和选择（P13）的交点为空，选择（P2）和选择（P14）的交点为空，选择（P13）和选择（P14）的交点为空，选择（P15）和选择（P6）的交点为空；因此，语法是确定性的，类型定义是有效的。如果第一个子元素是一个无法识别的元素，那么解码器现在将假定它和每个具有相同名称的后续无法识别的元素都与I1关联。接下来的任何内容，可能包括另一个名称不同的无法识别的元素，都将属于“三”组件。"
    },
    {
      "indent": 3,
      "text": "A consequence of using the UNIFORM-INSERTIONS encoding instruction is that any future extension to the \"three\" component will be required to generate elements with names that are different from the names of the elements generated by the \"one\" component. With the SINGULAR-INSERTIONS encoding instruction, extensions to the \"three\" component are permitted to generate elements with names that are the same as the names of the elements generated by the \"one\" component.",
      "zh-CHS": "使用UNIFORM-INSERTIONS编码指令的结果是，将来对“三”组件的任何扩展都需要生成名称不同于“一”组件生成的元素名称的元素。使用SINGULAR-INSERTIONS编码指令，允许对“三”组件的扩展生成名称与“一”组件生成的元素名称相同的元素。"
    },
    {
      "indent": 0,
      "text": "B.4. Example 4",
      "section_title": true,
      "zh-CHS": "B.4. 例4"
    },
    {
      "indent": 3,
      "text": "Consider the following type definition:",
      "zh-CHS": "考虑下面的类型定义："
    },
    {
      "indent": 6,
      "text": "SEQUENCE OF one [GROUP] CHOICE {\n    two    UTF8String,\n    ... -- Extension insertion point (I1).\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The associated grammar is:",
      "zh-CHS": "相关语法为："
    },
    {
      "indent": 6,
      "text": "P1:  S ::= one S\nP2:  S ::=\nP3:  one ::= two\nP4:  one ::= I1\nP5:  two ::= \"two\"\nP6:  I1 ::= \"*\" I1\nP7:  I1 ::=",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "This grammar leads to the following sets and predicates:",
      "zh-CHS": "此语法将生成以下集合和谓词："
    },
    {
      "indent": 6,
      "text": "First(P1) = { \"two\", \"*\" }\nFirst(P2) = { }\nPreselected(P1) = Preselected(P2) = false\nEmpty(P1) = Empty(P2) = true\nFollow(S) = { \"$\" }\nSelect(P1) = First(P1) + Follow(S) = { \"two\", \"*\", \"$\" }\nSelect(P2) = First(P2) + Follow(S) = { \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "First(P3) = { \"two\" }\nFirst(P4) = { \"*\" }\nPreselected(P3) = Preselected(P4) = Empty(P3) = false\nEmpty(P4) = true\nFollow(one) = { \"two\", \"*\", \"$\" }\nSelect(P3) = First(P3) = { \"two\" }\nSelect(P4) = First(P4) + Follow(one) = { \"*\", \"two\", \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "First(P6) = { \"*\" }\nFirst(P7) = { }\nPreselected(P6) = Preselected(P7) = Empty(P6) = false\nEmpty(P7) = true\nFollow(I1) = { \"two\", \"*\", \"$\" }\nSelect(P6) = First(P6) = { \"*\" }\nSelect(P7) = First(P7) + Follow(I1) = { \"two\", \"*\", \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The intersection of Select(P1) and Select(P2) is not empty, as is the intersection of Select(P3) and Select(P4) and the intersection of Select(P6) and Select(P7); hence, the grammar is not deterministic, and the type definition is not valid. If a decoder encounters two or more unrecognized elements in a row, then it cannot determine whether this represents one instance or more than one instance of the \"one\" component. Even without unrecognized elements, there is still a problem that an encoding could contain an indeterminate number of \"one\" components using an extension that generates no elements.",
      "zh-CHS": "Select（P1）和Select（P2）的交点不是空的，Select（P3）和Select（P4）的交点以及Select（P6）和Select（P7）的交点也是空的；因此，语法是不确定的，类型定义是无效的。如果解码器在一行中遇到两个或多个无法识别的元素，则无法确定这是表示“一”组件的一个实例还是多个实例。即使没有无法识别的元素，仍然存在一个问题，即使用不生成元素的扩展，编码可能包含数量不确定的“一”组件。"
    },
    {
      "indent": 3,
      "text": "The non-determinism cannot be resolved with a UNIFORM-INSERTIONS encoding instruction. Consider this revised type definition using the UNIFORM-INSERTIONS encoding instruction:",
      "zh-CHS": "非确定性不能用统一插入编码指令来解决。使用统一插入编码指令考虑此修订类型定义："
    },
    {
      "indent": 6,
      "text": "SEQUENCE OF one [GROUP] [UNIFORM-INSERTIONS] CHOICE {\n    two    UTF8String,\n    ... -- Extension insertion point (I1).\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The associated grammar is:",
      "zh-CHS": "相关语法为："
    },
    {
      "indent": 6,
      "text": "P1:  S ::= one S\nP2:  S ::=\nP3:  one ::= two\nP8:  one ::= \"*\"\nP9:  one ::= \"*1\" I1\nP5:  two ::= \"two\"\nP10: I1 ::= \"*1\" I1\nP7:  I1 ::=",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "This grammar leads to the following sets and predicates:",
      "zh-CHS": "此语法将生成以下集合和谓词："
    },
    {
      "indent": 6,
      "text": "First(P1) = { \"two\", \"*\", \"*1\" }\nFirst(P2) = { }\nPreselected(P1) = Preselected(P2) = Empty(P1) = false\nEmpty(P2) = true\nFollow(S) = { \"$\" }\nSelect(P1) = First(P1) = { \"two\", \"*\", \"*1\" }\nSelect(P2) = First(P2) + Follow(S) = { \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "First(P3) = { \"two\" }\nFirst(P8) = { \"*\" }\nFirst(P9) = { \"*1\" }\nPreselected(P3) = Preselected(P8) = Preselected(P9) = false\nEmpty(P3) = Empty(P8) = Empty(P9) = false\nFollow(one) = { \"two\", \"*\", \"*1\", \"$\" }\nSelect(P3) = First(P3) = { \"two\" }\nSelect(P8) = First(P8) = { \"*\" }\nSelect(P9) = First(P9) = { \"*1\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "First(P10) = { \"*1\" }\nFirst(P7) = { }\nPreselected(P10) = Preselected(P7) = Empty(P10) = false\nEmpty(P7) = true\nFollow(I1) = { \"two\", \"*\", \"*1\", \"$\" }\nSelect(P10) = First(P10) = { \"*1\" }\nSelect(P7) = First(P7) + Follow(I1) = { \"two\", \"*\", \"*1\", \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The intersection of Select(P1) and Select(P2) is now empty, but the intersection of Select(P10) and Select(P7) is not; hence, the grammar is not deterministic, and the type definition is not valid. The problem of an indeterminate number of \"one\" components from an extension that generates no elements has been solved. However, if a decoder encounters a series of elements with the same name, it cannot determine whether this represents one instance or more than one instance of the \"one\" component.",
      "zh-CHS": "选择（P1）和选择（P2）的交点现在为空，但选择（P10）和选择（P7）的交点不为空；因此，语法是不确定的，类型定义是无效的。从一个不生成任何元素的扩展中得到数量不确定的“一”个组件的问题已经得到解决。但是，如果解码器遇到一系列具有相同名称的元素，则无法确定这是表示“一”组件的一个实例还是多个实例。"
    },
    {
      "indent": 3,
      "text": "The non-determinism can be fully resolved with a SINGULAR-INSERTIONS encoding instruction. Consider this revised type definition:",
      "zh-CHS": "非确定性可以通过单数插入编码指令完全解决。考虑修改后的类型定义："
    },
    {
      "indent": 6,
      "text": "SEQUENCE OF one [GROUP] [SINGULAR-INSERTIONS] CHOICE {\n    two    UTF8String,\n    ... -- Extension insertion point (I1).\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The associated grammar is:",
      "zh-CHS": "相关语法为："
    },
    {
      "indent": 6,
      "text": "P1:  S ::= one S\nP2:  S ::=\nP3:  one ::= two\nP8:  one ::= \"*\"\nP5:  two ::= \"two\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "This grammar leads to the following sets and predicates:",
      "zh-CHS": "此语法将生成以下集合和谓词："
    },
    {
      "indent": 6,
      "text": "First(P1) = { \"two\", \"*\" }\nFirst(P2) = { }\nPreselected(P1) = Preselected(P2) = Empty(P1) = false\nEmpty(P2) = true\nFollow(S) = { \"$\" }\nSelect(P1) = First(P1) = { \"two\", \"*\" }\nSelect(P2) = First(P2) + Follow(S) = { \"$\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "First(P3) = { \"two\" }\nFirst(P8) = { \"*\" }\nPreselected(P3) = Preselected(P8) = false\nEmpty(P3) = Empty(P8) = false\nFollow(one) = { \"two\", \"*\", \"$\" }\nSelect(P3) = First(P3) = { \"two\" }\nSelect(P8) = First(P8) = { \"*\" }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The intersection of Select(P1) and Select(P2) is empty, as is the intersection of Select(P3) and Select(P8); hence, the grammar is deterministic, and the type definition is valid. A decoder now knows that every extension to the \"one\" component will generate a single element, so the correct number of \"one\" components will be decoded.",
      "zh-CHS": "Select（P1）和Select（P2）的交点为空，Select（P3）和Select（P8）的交点也是空的；因此，语法是确定性的，类型定义是有效的。解码器现在知道“一”组件的每个扩展都将生成一个元素，因此正确数量的“一”组件将被解码。"
    },
    {
      "indent": 0,
      "text": "Appendix C. Extension and Versioning Examples",
      "section_title": true,
      "zh-CHS": "附录C.扩展和版本控制示例"
    },
    {
      "indent": 3,
      "text": "This appendix is non-normative.",
      "zh-CHS": "本附录为非规范性附录。"
    },
    {
      "indent": 0,
      "text": "C.1. Valid Extensions for Insertion Encoding Instructions",
      "section_title": true,
      "zh-CHS": "C.1. 插入编码指令的有效扩展"
    },
    {
      "indent": 3,
      "text": "The first example shows extensions that satisfy the HOLLOW-INSERTIONS encoding instruction.",
      "zh-CHS": "第一个示例显示了满足空心插入编码指令的扩展。"
    },
    {
      "indent": 6,
      "text": "[HOLLOW-INSERTIONS] CHOICE {\n    one    BOOLEAN,\n    ...,\n    two    [ATTRIBUTE] INTEGER,\n    three  [GROUP] SEQUENCE {\n        four  [ATTRIBUTE] UTF8String,\n        five  [ATTRIBUTE] INTEGER OPTIONAL,\n        ...\n    },\n    six    [GROUP] CHOICE {\n        seven  [ATTRIBUTE] BOOLEAN,\n        eight  [ATTRIBUTE] INTEGER\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The \"two\" and \"six\" components generate only attributes.",
      "zh-CHS": "“两个”和“六个”组件仅生成属性。"
    },
    {
      "indent": 3,
      "text": "The \"three\" component in its current form does not generate elements. Any extension to the \"three\" component will need to do likewise to avoid breaking forward compatibility.",
      "zh-CHS": "当前形式的“三”组件不生成元素。对“三个”组件的任何扩展都需要这样做，以避免破坏前向兼容性。"
    },
    {
      "indent": 3,
      "text": "The second example shows extensions that satisfy the SINGULAR-INSERTIONS encoding instruction.",
      "zh-CHS": "第二个示例显示了满足SINGULAR-INSERTIONS编码指令的扩展。"
    },
    {
      "indent": 6,
      "text": "[SINGULAR-INSERTIONS] CHOICE {\n    one    BOOLEAN,\n    ...,\n    two    INTEGER,\n    three  [GROUP] SEQUENCE {\n        four   [ATTRIBUTE] UTF8String,\n        five   INTEGER\n    },\n    six    [GROUP] CHOICE {\n        seven  BOOLEAN,\n        eight  INTEGER\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The \"two\" component will always generate a single <two> element.",
      "zh-CHS": "“两个”组件将始终生成一个<two>元素。"
    },
    {
      "indent": 3,
      "text": "The \"three\" component will always generate a single <five> element. It will also generate a \"four\" attribute, but any number of attributes is allowed by the SINGULAR-INSERTIONS encoding instruction.",
      "zh-CHS": "“三”组件将始终生成一个<5>元素。它还将生成一个“四”属性，但SINGULAR-INSERTIONS编码指令允许任何数量的属性。"
    },
    {
      "indent": 3,
      "text": "The \"six\" component will either generate a single <seven> element or a single <eight> element. Either case will satisfy the requirement that there will be a single element in any given encoding of the extension.",
      "zh-CHS": "“六”组件将生成单个<seven>元素或单个<seek>元素。任何一种情况都将满足在扩展的任何给定编码中都有一个元素的要求。"
    },
    {
      "indent": 3,
      "text": "The third example shows extensions that satisfy the UNIFORM-INSERTIONS encoding instruction.",
      "zh-CHS": "第三个示例显示了满足统一插入编码指令的扩展。"
    },
    {
      "indent": 6,
      "text": "[UNIFORM-INSERTIONS] CHOICE {\n    one    BOOLEAN,\n    ...,\n    two    INTEGER,\n    three  [GROUP] SEQUENCE SIZE(1..MAX) OF four INTEGER,\n    five   [GROUP] SEQUENCE {\n        six    [ATTRIBUTE] UTF8String OPTIONAL,\n        seven  INTEGER\n    },\n    eight  [GROUP] CHOICE {\n        nine   BOOLEAN,\n        ten    [GROUP] SEQUENCE SIZE(1..MAX) OF eleven INTEGER\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The \"two\" component will always generate a single <two> element.",
      "zh-CHS": "“两个”组件将始终生成一个<two>元素。"
    },
    {
      "indent": 3,
      "text": "The \"three\" component will always generate one or more <four> elements.",
      "zh-CHS": "“三”组件将始终生成一个或多个<four>元素。"
    },
    {
      "indent": 3,
      "text": "The \"five\" component will always generate a single <seven> element. It may also generate a \"six\" attribute, but any number of attributes is allowed by the UNIFORM-INSERTIONS encoding instruction.",
      "zh-CHS": "“五”组件将始终生成一个<seven>元素。它还可以生成一个“六”属性，但统一插入编码指令允许任何数量的属性。"
    },
    {
      "indent": 3,
      "text": "The \"eight\" component will either generate a single <nine> element or one or more <eleven> elements. Either case will satisfy the requirement that there must be one or more elements with the same name in any given encoding of the extension.",
      "zh-CHS": "“8”组件将生成单个<9>元素或一个或多个<11>元素。任何一种情况都将满足以下要求：在扩展的任何给定编码中，必须有一个或多个同名元素。"
    },
    {
      "indent": 0,
      "text": "C.2. Versioning Example",
      "section_title": true,
      "zh-CHS": "C.2. 版本控制示例"
    },
    {
      "indent": 3,
      "text": "Making extensions that are not forward compatible is permitted provided that the incompatibility is signalled with a version indicator attribute.",
      "zh-CHS": "允许生成不向前兼容的扩展，前提是使用版本指示符属性表示不兼容。"
    },
    {
      "indent": 3,
      "text": "Suppose that version 1.0 of a specification contains the following type definition:",
      "zh-CHS": "假设规范的1.0版包含以下类型定义："
    },
    {
      "indent": 6,
      "text": "MyMessageType ::= SEQUENCE {\n   version  [ATTRIBUTE] [VERSION-INDICATOR]\n                UTF8String (\"1.0\", ...) DEFAULT \"1.0\",\n   one      [GROUP] [SINGULAR-INSERTIONS] CHOICE {\n       two  BOOLEAN,\n       ...\n   },\n   ...\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "An attribute is to be added to the CHOICE for version 1.1. This change is not forward compatible since it does not satisfy the SINGULAR-INSERTIONS encoding instruction. Therefore, the version indicator attribute must be updated at the same time (or added if it wasn't already present). This results in the following new type definition for version 1.1:",
      "zh-CHS": "将在版本1.1的选项中添加一个属性。此更改不向前兼容，因为它不满足SINGULAR-INSERTIONS编码指令。因此，版本指示符属性必须同时更新（如果还不存在，则添加）。这将导致版本1.1的以下新类型定义："
    },
    {
      "indent": 6,
      "text": "MyMessageType ::= SEQUENCE {\n   version  [ATTRIBUTE] [VERSION-INDICATOR]\n                UTF8String (\"1.0\", ..., \"1.1\") DEFAULT \"1.0\",\n   one      [GROUP] [SINGULAR-INSERTIONS] CHOICE {\n       two    BOOLEAN,\n       ...,\n       three  [ATTRIBUTE] INTEGER -- Added in Version 1.1\n   },\n   ...\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "If a version 1.1 conformant application hasn't used the version 1.1 extension in a value of MyMessageType, then it is allowed to set the value of the version attribute to \"1.0\".",
      "zh-CHS": "如果符合版本1.1的应用程序没有在MyMessageType的值中使用版本1.1扩展，则允许将版本属性的值设置为“1.0”。"
    },
    {
      "indent": 3,
      "text": "A pair of elements is added to the CHOICE for version 1.2. Again the change does not satisfy the SINGULAR-INSERTIONS encoding instruction. The type definition for version 1.2 is:",
      "zh-CHS": "版本1.2的选项中添加了一对元素。同样，该更改不满足SINGULAR-INSERTIONS编码指令。版本1.2的类型定义为："
    },
    {
      "indent": 6,
      "text": "MyMessageType ::= SEQUENCE {\n   version  [ATTRIBUTE] [VERSION-INDICATOR]\n                UTF8String (\"1.0\", ..., \"1.1\" | \"1.2\")\n                    DEFAULT \"1.0\",\n   one      [GROUP] [SINGULAR-INSERTIONS] CHOICE {\n       two    BOOLEAN,\n       ...,\n       three  [ATTRIBUTE] INTEGER, -- Added in Version 1.1\n       four   [GROUP] SEQUENCE {\n           five  UTF8String,\n           six   GeneralizedTime\n       } -- Added in version 1.2\n   },\n   ...\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "If a version 1.2 conformant application hasn't used the version 1.2 extension in a value of MyMessageType, then it is allowed to set the value of the version attribute to \"1.1\". If it hasn't used either of the extensions, then it is allowed to set the value of the version attribute to \"1.0\".",
      "zh-CHS": "如果符合版本1.2的应用程序没有在MyMessageType的值中使用版本1.2扩展，则允许将版本属性的值设置为“1.1”。如果未使用任何一个扩展，则允许将version属性的值设置为“1.0”。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "zh-CHS": "作者地址"
    },
    {
      "indent": 3,
      "text": "Dr. Steven Legg eB2Bcom Suite 3, Woodhouse Corporate Centre 935 Station Street Box Hill North, Victoria 3129 AUSTRALIA",
      "zh-CHS": "Steven Legg博士eB2Bcom澳大利亚维多利亚州博克斯山北站街935号伍德豪斯企业中心3号套房，邮编：3129"
    },
    {
      "indent": 3,
      "text": "Phone: +61 3 9896 7830\nFax:   +61 3 9896 7801\nEMail: steven.legg@eb2bcom.com",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "zh-CHS": "完整版权声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The IETF Trust (2007).",
      "zh-CHS": "版权所有（C）IETF信托基金（2007年）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "zh-CHS": "本文件受BCP 78中包含的权利、许可和限制的约束，除其中规定外，作者保留其所有权利。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "zh-CHS": "本文件及其包含的信息以“原样”为基础提供，贡献者、他/她所代表或赞助的组织（如有）、互联网协会、IETF信托基金和互联网工程任务组不承担任何明示或暗示的担保，包括但不限于任何保证，即使用本文中的信息不会侵犯任何权利，或对适销性或特定用途适用性的任何默示保证。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "zh-CHS": "知识产权"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "zh-CHS": "IETF对可能声称与本文件所述技术的实施或使用有关的任何知识产权或其他权利的有效性或范围，或此类权利下的任何许可可能或可能不可用的程度，不采取任何立场；它也不表示它已作出任何独立努力来确定任何此类权利。有关RFC文件中权利的程序信息，请参见BCP 78和BCP 79。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "zh-CHS": "向IETF秘书处披露的知识产权副本和任何许可证保证，或本规范实施者或用户试图获得使用此类专有权利的一般许可证或许可的结果，可从IETF在线知识产权存储库获取，网址为http://www.ietf.org/ipr."
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "zh-CHS": "IETF邀请任何相关方提请其注意任何版权、专利或专利申请，或其他可能涵盖实施本标准所需技术的专有权利。请将信息发送至IETF的IETF-ipr@ietf.org."
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "zh-CHS": "确认"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "zh-CHS": "RFC编辑功能的资金目前由互联网协会提供。"
    }
  ]
}