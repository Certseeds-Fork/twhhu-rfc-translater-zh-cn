{
  "title": {
    "text": "RFC 5219: A More Loss-Tolerant RTP Payload Format for MP3 Audio",
    "zh-CHS": "RFC 5219"
  },
  "number": 5219,
  "created_at": "2021-11-10 13:07:51.001825+08:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                       R. Finlayson\nRequest for Comments: 5219                           Live Networks, Inc.\nObsoletes: 3119                                            February 2008\nCategory: Standard Track",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "A More Loss-Tolerant RTP Payload Format for MP3 Audio",
      "zh-CHS": "一种更具容错性的MP3音频RTP有效负载格式"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "zh-CHS": "关于下段备忘"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "zh-CHS": "本文件规定了互联网社区的互联网标准跟踪协议，并要求进行讨论和提出改进建议。有关本协议的标准化状态和状态，请参考当前版本的“互联网官方协议标准”（STD 1）。本备忘录的分发不受限制。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "zh-CHS": "摘要"
    },
    {
      "indent": 3,
      "text": "This document describes an RTP (Real-Time Protocol) payload format for transporting MPEG (Moving Picture Experts Group) 1 or 2, layer III audio (commonly known as \"MP3\"). This format is an alternative to that described in RFC 2250, and performs better if there is packet loss. This document obsoletes RFC 3119, correcting typographical errors in the \"SDP usage\" section and pseudo-code appendices.",
      "zh-CHS": "本文档描述了用于传输MPEG（运动图像专家组）1或2第三层音频（通常称为“MP3”）的RTP（实时协议）有效载荷格式。该格式是RFC 2250中描述的格式的替代，并且在存在数据包丢失的情况下性能更好。本文件废除了RFC3119，纠正了“SDP使用”部分和伪代码附录中的印刷错误。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "zh-CHS": "目录"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................2\n2. Terminology .....................................................3\n3. The Structure of MP3 Frames .....................................3\n4. A New Payload Format ............................................4\n   4.1. ADU Frames .................................................4\n   4.2. ADU Descriptors ............................................4\n   4.3. Packing Rules ..............................................5\n   4.4. RTP Header Fields ..........................................6\n   4.5. Handling Received Data .....................................6\n5. Handling Multiple MPEG Audio Layers .............................6\n6. Frame Packetizing and Depacketizing .............................7\n7. ADU Frame Interleaving ..........................................8\n8. IANA Considerations ............................................10\n9. SDP Usage ......................................................11\n10. Security Considerations .......................................11\n11. Acknowledgements ..............................................11\n12. Normative References ..........................................12\nAppendix A. Translating between \"MP3 Frames\" and \"ADU Frames\" .....13\n   A.1. Converting a Sequence of \"MP3 Frames\"\n        to a Sequence of \"ADU Frames\" .............................14\n   A.2. Converting a Sequence of \"ADU Frames\"\n        to a Sequence of \"MP3 Frames\" .............................15\nAppendix B. Interleaving and Deinterleaving .......................18\n   B.1. Interleaving a Sequence of \"ADU Frames\" ...................18\n   B.2. Deinterleaving a Sequence of (Interleaved) \"ADU Frames\" ...19\nAppendix C. Changes from RFC 3119 .................................20",
      "raw": true,
      "toc": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "zh-CHS": "1. 介绍"
    },
    {
      "indent": 3,
      "text": "While the RTP payload format defined in RFC 2250 [1] is generally applicable to all forms of MPEG audio or video, it is sub-optimal for MPEG-1 or 2, layer III audio (commonly known as \"MP3\"). The reason for this is that an MP3 frame is not a true \"Application Data Unit\" -- it contains a back-pointer to data in earlier frames, and so cannot be decoded independently of these earlier frames. Because RFC 2250 defines that packet boundaries coincide with frame boundaries, it handles packet loss inefficiently when carrying MP3 data. The loss of an MP3 frame will render some data in previous (or future) frames useless, even if they are received without loss.",
      "zh-CHS": "虽然RFC 2250[1]中定义的RTP有效载荷格式通常适用于所有形式的MPEG音频或视频，但对于MPEG-1或2第三层音频（通常称为“MP3”）而言，它是次优的。原因是MP3帧不是真正的“应用程序数据单元”——它包含指向早期帧中数据的反向指针，因此无法独立于这些早期帧进行解码。因为RFC2250定义了包边界与帧边界重合，所以在携带MP3数据时，它处理包丢失的效率很低。丢失MP3帧会使以前（或将来）帧中的某些数据变得无用，即使这些数据接收时没有丢失。"
    },
    {
      "indent": 3,
      "text": "In this document, we define an alternative RTP payload format for MP3 audio. This format uses a data-preserving rearrangement of the original MPEG frames, so that packet boundaries now coincide with true MP3 \"Application Data Units\", which can also (optionally) be rearranged in an interleaving pattern. This new format is therefore more data efficient than RFC 2250 in the face of packet loss.",
      "zh-CHS": "在本文档中，我们为MP3音频定义了另一种RTP有效负载格式。这种格式使用原始MPEG帧的数据保留重排，使得分组边界现在与真正的MP3“应用数据单元”重合，也可以（可选地）以交错模式重排。因此，面对数据包丢失，这种新格式比RFC2250更有效。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "zh-CHS": "2. 术语"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [2].",
      "zh-CHS": "本文件中的关键词“必须”、“不得”、“要求”、“应”、“不应”、“应”、“不应”、“建议”、“可”和“可选”应按照RFC 2119[2]中所述进行解释。"
    },
    {
      "indent": 0,
      "text": "3. The Structure of MP3 Frames",
      "section_title": true,
      "zh-CHS": "3. MP3帧的结构"
    },
    {
      "indent": 3,
      "text": "In this section we give a brief overview of the structure of an MP3 frame. (For a more detailed description, see the MPEG-1 audio [3] and MPEG-2 audio [4] specifications.)",
      "zh-CHS": "在本节中，我们将简要概述MP3框架的结构。（有关更详细的说明，请参阅MPEG-1音频[3]和MPEG-2音频[4]规范。）"
    },
    {
      "indent": 3,
      "text": "Each MPEG audio frame begins with a 4-byte header. Information defined by this header includes:",
      "zh-CHS": "每个MPEG音频帧都以一个4字节的头开始。此标题定义的信息包括："
    },
    {
      "indent": 3,
      "text": "- Whether the audio is MPEG-1 or MPEG-2. - Whether the audio is layer I, II, or III. (The remainder of this document assumes layer III, i.e., \"MP3\" frames.) - Whether the audio is mono or stereo. - Whether or not there is a 2-byte CRC field following the header. - (indirectly) The size of the frame.",
      "zh-CHS": "- 音频是MPEG-1还是MPEG-2。-音频是第一层、第二层还是第三层（本文档其余部分采用第三层，即“MP3”帧）-音频是单声道还是立体声。-标头后面是否有2字节CRC字段。-（间接）框架的大小。"
    },
    {
      "indent": 3,
      "text": "The following structures appear after the header:",
      "zh-CHS": "标题后显示以下结构："
    },
    {
      "indent": 3,
      "text": "- (optionally) A 2-byte Cyclic Redundancy Check (CRC) field - A \"side info\" structure. This has the following length: - 32 bytes for MPEG-1 stereo - 17 bytes for MPEG-1 mono, or for MPEG-2 stereo - 9 bytes for MPEG-2 mono - Encoded audio data, plus optional ancillary data (filling out the rest of the frame)",
      "zh-CHS": "- （可选）2字节循环冗余校验（CRC）字段-一种“侧信息”结构。其长度如下：-对于MPEG-1立体声为32字节-对于MPEG-1单声道为17字节，对于MPEG-2立体声为9字节-对于MPEG-2单声道编码的音频数据，加上可选的辅助数据（填充帧的其余部分）"
    },
    {
      "indent": 3,
      "text": "For the purpose of this document, the \"side info\" structure is the most important, because it defines the location and size of the \"Application Data Unit\" (ADU) that an MP3 decoder will process. In particular, the \"side info\" structure defines:",
      "zh-CHS": "在本文档中，“侧信息”结构是最重要的，因为它定义了MP3解码器将处理的“应用程序数据单元”（ADU）的位置和大小。具体而言，“侧信息”结构定义："
    },
    {
      "indent": 3,
      "text": "- \"main_data_begin\": This is a back-pointer (in bytes) to the start of the ADU. The back-pointer is counted from the beginning of the frame, and counts only encoded audio data and any ancillary data (i.e., ignoring any header, CRC, or \"side info\" fields).",
      "zh-CHS": "- “main_data_begin”：这是指向ADU开始的返回指针（以字节为单位）。后向指针从帧开始计数，并且仅计数编码音频数据和任何辅助数据（即，忽略任何头、CRC或“侧信息”字段）。"
    },
    {
      "indent": 3,
      "text": "An MP3 decoder processes each ADU independently. The ADUs will generally vary in length, but their average length will, of course,",
      "zh-CHS": "MP3解码器独立处理每个ADU。ADU的长度通常会有所不同，但它们的平均长度当然会，"
    },
    {
      "indent": 3,
      "text": "be that of the of the MP3 frames (minus the length of the header, CRC, and \"side info\" fields). (In MPEG literature, this ADU is sometimes referred to as a \"bit reservoir\".)",
      "zh-CHS": "是MP3帧的长度（减去标题、CRC和“侧信息”字段的长度）。（在MPEG文献中，该ADU有时被称为“比特库”。）"
    },
    {
      "indent": 0,
      "text": "4. A New Payload Format",
      "section_title": true,
      "zh-CHS": "4. 一种新的有效载荷格式"
    },
    {
      "indent": 3,
      "text": "As noted in [5], a payload format should be designed so that packet boundaries coincide with \"codec frame boundaries\" -- i.e., with ADUs. In the RFC 2250 payload format for MPEG audio [1], each RTP packet payload contains MP3 frames. In this new payload format for MP3 audio, however, each RTP packet payload contains \"ADU frames\", each preceded by an \"ADU descriptor\".",
      "zh-CHS": "如[5]所述，有效载荷格式的设计应确保数据包边界与“编解码器帧边界”（即ADU）一致。在用于MPEG音频[1]的RFC 2250有效载荷格式中，每个RTP包有效载荷包含MP3帧。然而，在这种新的MP3音频有效载荷格式中，每个RTP数据包有效载荷包含“ADU帧”，每个帧前面都有一个“ADU描述符”。"
    },
    {
      "indent": 0,
      "text": "4.1. ADU Frames",
      "section_title": true,
      "zh-CHS": "4.1. ADU框架"
    },
    {
      "indent": 3,
      "text": "An \"ADU frame\" is defined as:",
      "zh-CHS": "“ADU框架”定义为："
    },
    {
      "indent": 6,
      "text": "- The 4-byte MPEG header (the same as the original MP3 frame, except that the first 11 bits are (optionally) replaced by an \"Interleaving Sequence Number\", as described in Section 7 below) - The optional 2-byte CRC field (the same as the original MP3 frame) - The \"side info\" structure (the same as the original MP3 frame) - The complete sequence of encoded audio data (and any ancillary data) for the ADU (i.e., running from the start of this MP3 frame's \"main_data_begin\" back-pointer, up to the start of the next MP3 frame's back-pointer)",
      "zh-CHS": "- 4字节MPEG报头（与原始MP3帧相同，但前11位（可选）替换为“交错序列号”，如下文第7节所述）、-可选2字节CRC字段（与原始MP3帧相同）-“侧信息”结构（与原始MP3帧相同）-ADU的编码音频数据（和任何辅助数据）的完整序列（即，从该MP3帧的“主数据开始”后指针开始，一直运行到下一个MP3帧的后指针开始）"
    },
    {
      "indent": 3,
      "text": "Note that there is a one-to-one mapping between MP3 frames and ADU frames. Because MP3 frames are self-describing, with the bitrate (and sampling frequency) encoded within the 4-byte MPEG header, the same is true for ADU frames. Therefore, as with MP3 streams, the bitrate can change within a stream and may be used for congestion control.",
      "zh-CHS": "请注意，MP3帧和ADU帧之间存在一对一映射。由于MP3帧是自描述的，比特率（和采样频率）编码在4字节MPEG报头中，因此ADU帧也是如此。因此，与MP3流一样，比特率可以在流内改变，并且可以用于拥塞控制。"
    },
    {
      "indent": 0,
      "text": "4.2. ADU Descriptors",
      "section_title": true,
      "zh-CHS": "4.2. ADU描述符"
    },
    {
      "indent": 3,
      "text": "Within each RTP packet payload, each \"ADU frame\" is preceded by a 1- or 2-byte \"ADU descriptor\", which gives the size of the ADU and indicates whether or not this packet's data is a continuation of the previous packet's data. (This occurs only when a single \"ADU descriptor\" + \"ADU frame\" is too large to fit within an RTP packet.)",
      "zh-CHS": "在每个RTP数据包有效载荷中，每个“ADU帧”前面都有一个1或2字节的“ADU描述符”，该描述符给出了ADU的大小，并指示该数据包的数据是否是前一个数据包数据的延续。（仅当单个“ADU描述符”+“ADU帧”太大而无法装入RTP数据包时，才会发生这种情况。）"
    },
    {
      "indent": 3,
      "text": "An ADU descriptor consists of the following fields:",
      "zh-CHS": "ADU描述符由以下字段组成："
    },
    {
      "indent": 3,
      "text": "- \"C\": Continuation flag (1 bit): 1, if the data following the ADU descriptor is a continuation of an ADU frame that was too large to fit within a single RTP packet; 0 otherwise.",
      "zh-CHS": "- “C”：延续标志（1位）：1，如果ADU描述符后面的数据是ADU帧的延续，该ADU帧太大，无法容纳在单个RTP数据包中；否则为0。"
    },
    {
      "indent": 3,
      "text": "- \"T\": Descriptor Type flag (1 bit): 0 if this is a 1-byte ADU descriptor; 1 if this is a 2-byte ADU descriptor.",
      "zh-CHS": "- “T”：描述符类型标志（1位）：如果是1字节ADU描述符，则为0；1如果这是一个2字节ADU描述符。"
    },
    {
      "indent": 3,
      "text": "- \"ADU size\" (6 or 14 bits): The size (in bytes) of the ADU frame that will follow this ADU descriptor (i.e., NOT including the size of the descriptor itself). A 2-byte ADU descriptor (with a 14-bit \"ADU size\" field) is used for ADU frame sizes of 64 bytes or more. For smaller ADU frame sizes, senders MAY alternatively use a 1-byte ADU descriptor (with a 6-bit \"ADU size\" field). Receivers MUST be able to accept an ADU descriptor of either size.",
      "zh-CHS": "- “ADU大小”（6或14位）：将跟随此ADU描述符的ADU帧的大小（字节）（即，不包括描述符本身的大小）。2字节ADU描述符（带有14位“ADU大小”字段）用于64字节或更大的ADU帧大小。对于较小的ADU帧大小，发送方也可以使用1字节ADU描述符（带有6位“ADU大小”字段）。接收器必须能够接受任意大小的ADU描述符。"
    },
    {
      "indent": 3,
      "text": "Thus, a 1-byte ADU descriptor is formatted as follows:",
      "zh-CHS": "因此，1字节ADU描述符的格式如下："
    },
    {
      "indent": 9,
      "text": " 0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n|C|0|  ADU size |\n+-+-+-+-+-+-+-+-+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "and a 2-byte ADU descriptor is formatted as follows:",
      "zh-CHS": "2字节ADU描述符的格式如下："
    },
    {
      "indent": 9,
      "text": " 0                   1\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|C|1|     ADU size (14 bits)    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "4.3. Packing Rules",
      "section_title": true,
      "zh-CHS": "4.3. 包装规则"
    },
    {
      "indent": 3,
      "text": "Each RTP packet payload begins with an \"ADU descriptor\", followed by \"ADU frame\" data. Normally, this \"ADU descriptor\" + \"ADU frame\" will fit completely within the RTP packet. In this case, more than one successive \"ADU descriptor\" + \"ADU frame\" MAY be packed into a single RTP packet, provided that they all fit completely.",
      "zh-CHS": "每个RTP数据包有效载荷以“ADU描述符”开始，后跟“ADU帧”数据。通常，“ADU描述符”+“ADU帧”将完全适合RTP数据包。在这种情况下，可以将多个连续的“ADU描述符”+“ADU帧”打包到单个RTP分组中，前提是它们都完全适合。"
    },
    {
      "indent": 3,
      "text": "If, however, a single \"ADU descriptor\" + \"ADU frame\" is too large to fit within an RTP packet, then the \"ADU frame\" is split across two or more successive RTP packets. Each such packet begins with an ADU descriptor. The first packet's descriptor has a \"C\" (continuation) flag of 0; the following packets' descriptors each have a \"C\" flag of 1. Each descriptor, in this case, has the same \"ADU size\" value: the",
      "zh-CHS": "然而，如果单个“ADU描述符”+“ADU帧”太大而无法容纳在RTP数据包中，则“ADU帧”被分割成两个或多个连续RTP数据包。每个这样的数据包都以ADU描述符开始。第一个数据包的描述符具有0的“C”（延续）标志；以下数据包的描述符每个都有一个1的“C”标志。在本例中，每个描述符都具有相同的“ADU大小”值："
    },
    {
      "indent": 3,
      "text": "size of the entire \"ADU frame\" (not just the portion that will fit within a single RTP packet). Each such packet (even the last one) contains only one \"ADU descriptor\".",
      "zh-CHS": "整个“ADU帧”的大小（不仅仅是适合单个RTP数据包的部分）。每个这样的数据包（甚至最后一个）只包含一个“ADU描述符”。"
    },
    {
      "indent": 0,
      "text": "4.4. RTP Header Fields",
      "section_title": true,
      "zh-CHS": "4.4. RTP头字段"
    },
    {
      "indent": 3,
      "text": "Payload Type: The (static) payload type 14 that was defined for MPEG audio [6] MUST NOT be used. Instead, a different, dynamic payload type MUST be used -- i.e., one within the range [96..127].",
      "zh-CHS": "有效负载类型：不得使用为MPEG音频[6]定义的（静态）有效负载类型14。相反，必须使用不同的动态有效负载类型，即范围[96..127]内的有效负载类型。"
    },
    {
      "indent": 3,
      "text": "M bit: This payload format defines no use for this bit. Senders SHOULD set this bit to zero in each outgoing packet.",
      "zh-CHS": "M位：此有效负载格式定义此位不可用。发送方应在每个传出数据包中将该位设置为零。"
    },
    {
      "indent": 3,
      "text": "Timestamp: This is a 32-bit, 90 kHz timestamp, representing the presentation time of the first ADU packed within the packet.",
      "zh-CHS": "时间戳：这是一个32位、90 kHz的时间戳，表示数据包中打包的第一个ADU的显示时间。"
    },
    {
      "indent": 0,
      "text": "4.5. Handling Received Data",
      "section_title": true,
      "zh-CHS": "4.5. 处理接收到的数据"
    },
    {
      "indent": 3,
      "text": "Note that no information is lost by converting a sequence of MP3 frames to a corresponding sequence of \"ADU frames\", so a receiving RTP implementation can either feed the ADU frames directly to an appropriately modified MP3 decoder, or convert them back into a sequence of MP3 frames, as described in Appendix A.2 below.",
      "zh-CHS": "请注意，将MP3帧序列转换为相应的“ADU帧”序列不会丢失任何信息，因此接收RTP实现可以将ADU帧直接馈送到适当修改的MP3解码器，或者将其转换回MP3帧序列，如下面附录a.2所述。"
    },
    {
      "indent": 0,
      "text": "5. Handling Multiple MPEG Audio Layers",
      "section_title": true,
      "zh-CHS": "5. 处理多个MPEG音频层"
    },
    {
      "indent": 3,
      "text": "The RTP payload format described here is intended only for MPEG-1 or 2, layer III audio (\"MP3\"). In contrast, layer I and layer II frames are self-contained, without a back-pointer to earlier frames. However, it is possible (although unusual) for a sequence of audio frames to consist of a mixture of layer III frames, and layer I or II frames. When such a sequence is transmitted, only layer III frames are converted to ADUs; layer I or II frames are sent 'as is' (except for the prepending of an \"ADU descriptor\"). Similarly, the receiver of a sequence of frames -- using this payload format -- leaves layer I and II frames untouched (after removing the prepended \"ADU descriptor\"), but converts layer III frames from \"ADU frames\" to regular MP3 frames. (Recall that each frame's layer is identified from its 4-byte MPEG header.)",
      "zh-CHS": "此处描述的RTP有效负载格式仅适用于MPEG-1或2第三层音频（“MP3”）。相反，层I和层II帧是自包含的，没有指向早期帧的反向指针。然而，音频帧序列可能（尽管不常见）由第三层帧和第一层或第二层帧的混合组成。当发送这样的序列时，仅将第三层帧转换为adu；层I或层II帧按“原样”发送（除了“ADU描述符”的前置）。类似地，帧序列的接收器——使用这种有效负载格式——保持第一层和第二层帧不变（在删除前面的“ADU描述符”之后），但将第三层帧从“ADU帧”转换为常规MP3帧。（回想一下，每个帧的层都是从其4字节的MPEG报头识别的。）"
    },
    {
      "indent": 3,
      "text": "If you are transmitting a stream consisting *only* of layer I or layer II frames (i.e., without any MP3 data), then there is no benefit to using this payload format, *unless* you are using the interleaving mechanism described in Section 7 below.",
      "zh-CHS": "如果您传输的流*仅*由第一层或第二层帧组成（即，没有任何MP3数据），则使用此有效负载格式*没有任何好处，除非*您使用下面第7节中描述的交织机制。"
    },
    {
      "indent": 0,
      "text": "6. Frame Packetizing and Depacketizing",
      "section_title": true,
      "zh-CHS": "6. 框架包装和拆包"
    },
    {
      "indent": 3,
      "text": "The transmission of a sequence of MP3 frames takes the following steps:",
      "zh-CHS": "MP3帧序列的传输采取以下步骤："
    },
    {
      "indent": 9,
      "text": "MP3 frames\n        -1-> ADU frames\n            -2-> interleaved ADU frames\n                  -3-> RTP packets",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Step 1 is the conversion of a sequence of MP3 frames to a corresponding sequence of ADU frames, and takes place as described in Sections 3 and 4.1 above. (Note also the pseudo-code in Appendix A.1.)",
      "zh-CHS": "步骤1是将MP3帧序列转换为相应的ADU帧序列，并按照上文第3节和第4.1节所述进行。（另请注意附录A.1中的伪代码。）"
    },
    {
      "indent": 3,
      "text": "Step 2 is the reordering of the sequence of ADU frames in an (optional) interleaving pattern, prior to packetization, as described in section 7 below. (Note also the pseudo-code in Appendix B.1.) Interleaving helps reduce the effect of packet loss by distributing consecutive ADU frames over non-consecutive packets. (Note that because of the back-pointer in MP3 frames, interleaving can be applied -- in general -- only to ADU frames. Thus, interleaving was not possible for RFC 2250.)",
      "zh-CHS": "步骤2是在分组之前以（可选）交织模式对ADU帧序列重新排序，如下面第7节所述。（另请注意附录B.1中的伪代码。）交织通过在非连续数据包上分布连续ADU帧，有助于减少数据包丢失的影响。（请注意，由于MP3帧中的后向指针，交织通常只能应用于ADU帧。因此，RFC2250无法实现交织。）"
    },
    {
      "indent": 3,
      "text": "Step 3 is the packetizing of a sequence of (interleaved) ADU frames into RTP packets -- as described in section 4.3 above. Each packet's RTP timestamp is the presentation time of the first ADU that is packed within it. Note that if interleaving was done in step 2, the RTP timestamps on outgoing packets will not necessarily be monotonically nondecreasing.",
      "zh-CHS": "步骤3是将一系列（交错）ADU帧打包成RTP数据包——如上文第4.3节所述。每个数据包的RTP时间戳是打包在其中的第一个ADU的显示时间。注意，如果在步骤2中进行了交织，则传出分组上的RTP时间戳不一定是单调的非减损的。"
    },
    {
      "indent": 3,
      "text": "Similarly, a sequence of received RTP packets is handled as follows:",
      "zh-CHS": "类似地，接收到的RTP分组的序列被如下处理："
    },
    {
      "indent": 9,
      "text": "RTP packets\n      -4-> RTP packets ordered by RTP sequence number\n            -5-> interleaved ADU frames\n                  -6-> ADU frames\n                        -7-> MP3 frames",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Step 4 is the usual sorting of incoming RTP packets using the RTP sequence number.",
      "zh-CHS": "步骤4是使用RTP序列号对传入RTP数据包进行常规排序。"
    },
    {
      "indent": 3,
      "text": "Step 5 is the depacketizing of ADU frames from RTP packets -- i.e., the reverse of step 3. As part of this process, a receiver uses the \"C\" (continuation) flag in the ADU descriptor to notice when an ADU frame is split over more than one packet (and to discard the ADU frame entirely if one of these packets is lost).",
      "zh-CHS": "步骤5是从RTP数据包中取出ADU帧的分组——即，与步骤3相反。作为该过程的一部分，接收机使用ADU描述符中的“C”（continuation）标志来通知何时在多个分组上分割ADU帧（并且如果其中一个分组丢失，则完全丢弃ADU帧）。"
    },
    {
      "indent": 3,
      "text": "Step 6 is the rearranging of the sequence of ADU frames back to its original order (except for ADU frames missing due to packet loss), as described in Section 7 below. (Note also the pseudo-code in Appendix B.2.)",
      "zh-CHS": "步骤6是将ADU帧序列重新排列回其原始顺序（由于分组丢失而丢失的ADU帧除外），如下文第7节所述。（另请注意附录B.2中的伪代码。）"
    },
    {
      "indent": 3,
      "text": "Step 7 is the conversion of the sequence of ADU frames into a corresponding sequence of MP3 frames -- i.e., the reverse of step 1. (Note also the pseudo-code in Appendix A.2.) With an appropriately modified MP3 decoder, an implementation may omit this step; instead, it could feed ADU frames directly to the (modified) MP3 decoder.",
      "zh-CHS": "步骤7是将ADU帧序列转换为相应的MP3帧序列——即，与步骤1相反。（另请注意附录A.2中的伪代码。）对于经过适当修改的MP3解码器，实现可以省略该步骤；相反，它可以将ADU帧直接送入（修改过的）MP3解码器。"
    },
    {
      "indent": 0,
      "text": "7. ADU Frame Interleaving",
      "section_title": true,
      "zh-CHS": "7. 帧交织"
    },
    {
      "indent": 3,
      "text": "In MPEG audio frames (MPEG-1 or 2; all layers), the high-order 11 bits of the 4-byte MPEG header ('syncword') are always all-one (i.e., 0xFFE). When reordering a sequence of ADU frames for transmission, we reuse these 11 bits as an \"Interleaving Sequence Number\" (ISN). (Upon reception, they are replaced with 0xFFE once again.)",
      "zh-CHS": "在MPEG音频帧（MPEG-1或2；所有层）中，4字节MPEG报头（‘syncword’）的高阶11位始终为一（即0xFFE）。当重新排列ADU帧序列以进行传输时，我们将这11位重新用作“交织序列号”（ISN）。（接收后，它们将再次替换为0xFFE。）"
    },
    {
      "indent": 3,
      "text": "The structure of the ISN is (a,b), where:",
      "zh-CHS": "ISN的结构为（a，b），其中："
    },
    {
      "indent": 9,
      "text": "- a == bits 0-7: 8-bit Interleave Index (within Cycle) - b == bits 8-10: 3-bit Interleave Cycle Count",
      "zh-CHS": "- a==位0-7:8位交织索引（周期内）-b==位8-10:3位交织周期计数"
    },
    {
      "indent": 3,
      "text": "That is, the 4-byte MPEG header is reused as follows:",
      "zh-CHS": "也就是说，4字节MPEG报头的重用如下："
    },
    {
      "indent": 4,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Interleave Idx |CycCt|   The rest of the original MPEG header  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Example: Consider the following interleave cycle (of size 8):",
      "zh-CHS": "示例：考虑以下交错周期（大小8）："
    },
    {
      "indent": 12,
      "text": "1,3,5,7,0,2,4,6",
      "zh-CHS": "1,3,5,7,0,2,4,6"
    },
    {
      "indent": 3,
      "text": "(This particular pattern has the property that any loss of up to four consecutive ADUs in the interleaved stream will lead to a deinterleaved stream with no gaps greater than one.) This produces the following sequence of ISNs:",
      "zh-CHS": "（该特定模式具有这样的特性，即交织流中任何多达四个连续ADU的丢失都将导致无大于一个间隙的解交织流。）这将产生以下ISN序列："
    },
    {
      "indent": 3,
      "text": "(1,0) (3,0) (5,0) (7,0) (0,0) (2,0) (4,0) (6,0) (1,1) (3,1) (5,1) etc.",
      "zh-CHS": "（1,0）（3,0）（5,0）（7,0）（0,0）（2,0）（4,0）（6,0）（1,1）（3,1）（5,1）等。"
    },
    {
      "indent": 3,
      "text": "So, in this example, a sequence of ADU frames",
      "zh-CHS": "因此，在本例中，一系列ADU帧"
    },
    {
      "indent": 3,
      "text": "f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 (etc.)",
      "zh-CHS": "f0 f1 f2 f3 f4 f5 f6 f7 f8 f9（等）"
    },
    {
      "indent": 3,
      "text": "would get reordered, in step 2, into:",
      "zh-CHS": "将在步骤2中重新排序为："
    },
    {
      "indent": 3,
      "text": "(1,0)f1 (3,0)f3 (5,0)f5 (7,0)f7 (0,0)f0 (2,0)f2 (4,0)f4 (6,0)f6 (1,1)f9 (3,1)f11 (5,1)f13 (etc.)",
      "zh-CHS": "（1,0）f1（3,0）f3（5,0）f5（7,0）f7（0,0）f0（2,0）f2（4,0）f4（6,0）f6（1,1）f9（3,1）f11（5,1）f13（等）"
    },
    {
      "indent": 3,
      "text": "and the reverse reordering (along with replacement of the 0xFFE) would occur upon reception.",
      "zh-CHS": "接收时会发生反向重新排序（以及0xFFE的更换）。"
    },
    {
      "indent": 3,
      "text": "The reason for breaking the ISN into \"Interleave Cycle Count\" and \"Interleave Index\" (rather than just treating it as a single 11-bit counter) is to give receivers a way of knowing when an ADU frame should be 'released' to the ADU->MP3 conversion process (step 7 above), rather than waiting for more interleaved ADU frames to arrive. For instance, in the example above, when the receiver sees a frame with ISN (<something>,1), it knows that it can release all previously seen frames with ISN (<something>,0), even if some other (<something>,0) frames remain missing due to packet loss. An 8-bit Interleave Index allows interleave cycles of size up to 256.",
      "zh-CHS": "将ISN分为“交织周期计数”和“交织索引”（而不仅仅将其视为一个11位计数器）的原因是为了让接收机知道何时应将ADU帧“释放”到ADU->MP3转换过程（上面的步骤7），而不是等待更多交织的ADU帧到达。例如，在上面的示例中，当接收器看到一个具有ISN（<something>，1）的帧时，它知道它可以释放所有先前看到的具有ISN（<something>，0）的帧，即使一些其他（<something>，0）帧由于数据包丢失而仍然丢失。8位交织索引允许最大256个交织周期。"
    },
    {
      "indent": 3,
      "text": "The choice of an interleaving order can be made independently of RTP packetization. Thus, a simple implementation could choose an interleaving order first, reorder the ADU frames accordingly (step 2), then simply pack them sequentially into RTP packets (step 3). However, the size of ADU frames -- and thus the number of ADU frames that will fit in each RTP packet -- will typically vary in size, so a more optimal implementation would combine steps 2 and 3, by choosing an interleaving order that better reflected the number of ADU frames packed within each RTP packet.",
      "zh-CHS": "交错顺序的选择可以独立于RTP打包。因此，一个简单的实现可以首先选择交织顺序，相应地对ADU帧重新排序（步骤2），然后简单地将它们顺序打包成RTP分组（步骤3）。然而，ADU帧的大小——以及每个RTP数据包中适合的ADU帧的数量——通常在大小上会有所不同，因此更优化的实现将结合步骤2和步骤3，方法是选择更好地反映每个RTP数据包中打包的ADU帧数量的交错顺序。"
    },
    {
      "indent": 3,
      "text": "Each receiving implementation of this payload format MUST recognize the ISN and be able to perform deinterleaving of incoming ADU frames (step 6). However, a sending implementation of this payload format MAY choose not to perform interleaving -- i.e., by omitting step 2. In this case, the high-order 11 bits in each 4-byte MPEG header would remain at 0xFFE. Receiving implementations would thus see a sequence of identical ISNs (all 0xFFE). They would handle this in the same way as if the Interleave Cycle Count changed with each ADU frame, by simply releasing the sequence of incoming ADU frames sequentially to the ADU->MP3 conversion process (step 7), without reordering. (Note also the pseudo-code in Appendix B.2.)",
      "zh-CHS": "此有效负载格式的每个接收实现必须识别ISN，并能够执行传入ADU帧的解交织（步骤6）。然而，该有效负载格式的发送实现可以选择不执行交织——即，通过省略步骤2。在这种情况下，每个4字节MPEG报头中的高阶11位将保持为0xFFE。因此，接收实现将看到一系列相同的iSN（都是0xFFE）。他们将以与交织周期计数随每个ADU帧而改变相同的方式来处理此问题，只需将传入ADU帧的序列顺序释放到ADU->MP3转换过程（步骤7），而无需重新排序。（另请注意附录B.2中的伪代码。）"
    },
    {
      "indent": 0,
      "text": "8. IANA Considerations",
      "section_title": true,
      "zh-CHS": "8. IANA考虑"
    },
    {
      "indent": 3,
      "text": "Media type name: audio",
      "zh-CHS": "媒体类型名称：音频"
    },
    {
      "indent": 3,
      "text": "Media subtype: mpa-robust",
      "zh-CHS": "媒体子类型：mpa"
    },
    {
      "indent": 3,
      "text": "Required parameters: none",
      "zh-CHS": "所需参数：无"
    },
    {
      "indent": 3,
      "text": "Optional parameters: none",
      "zh-CHS": "可选参数：无"
    },
    {
      "indent": 3,
      "text": "Encoding considerations: This type is defined only for transfer via RTP, as specified in RFC 5219.",
      "zh-CHS": "编码注意事项：按照RFC 5219中的规定，此类型仅为通过RTP传输而定义。"
    },
    {
      "indent": 6,
      "text": "Security considerations: See the \"Security Considerations\" section of RFC 5219.",
      "zh-CHS": "安全注意事项：请参阅RFC 5219的“安全注意事项”部分。"
    },
    {
      "indent": 6,
      "text": "Interoperability considerations: This encoding is incompatible with both the \"audio/mpa\" and \"audio/mpeg\" media types.",
      "zh-CHS": "互操作性注意事项：此编码与“音频/mpa”和“音频/mpeg”媒体类型都不兼容。"
    },
    {
      "indent": 6,
      "text": "Published specification: The ISO/IEC MPEG-1 [3] and MPEG-2 [4] audio specifications, and RFC 5219.",
      "zh-CHS": "已发布规范：ISO/IEC MPEG-1[3]和MPEG-2[4]音频规范，以及RFC 5219。"
    },
    {
      "indent": 6,
      "text": "Applications that use this media type: Audio streaming tools (transmitting and receiving)",
      "zh-CHS": "使用此媒体类型的应用程序：音频流工具（发送和接收）"
    },
    {
      "indent": 6,
      "text": "Additional information: none",
      "zh-CHS": "其他信息：无"
    },
    {
      "indent": 6,
      "text": "Person & email address to contact for further information: Ross Finlayson finlayson@live555.com",
      "zh-CHS": "联系人和电子邮件地址，以获取更多信息：Ross Finlaysonfinlayson@live555.com"
    },
    {
      "indent": 6,
      "text": "Intended usage: COMMON",
      "zh-CHS": "预期用途：普通"
    },
    {
      "indent": 6,
      "text": "Author/Change controller: Author: Ross Finlayson Change controller: IETF AVT Working Group",
      "zh-CHS": "作者/变更负责人：作者：Ross Finlayson变更负责人：IETF AVT工作组"
    },
    {
      "indent": 0,
      "text": "9. SDP Usage",
      "section_title": true,
      "zh-CHS": "9. SDP使用"
    },
    {
      "indent": 3,
      "text": "When conveying information by SDP [7], the encoding name SHALL be \"mpa-robust\" (the same as the media subtype). An example of the media representation in SDP is:",
      "zh-CHS": "当通过SDP[7]传输信息时，编码名称应为“mpa鲁棒”（与媒体子类型相同）。SDP中媒体表示的一个示例是："
    },
    {
      "indent": 9,
      "text": "m=audio 49000 RTP/AVP 121\na=rtpmap:121 mpa-robust/90000",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Note that the RTP timestamp frequency MUST be 90000.",
      "zh-CHS": "请注意，RTP时间戳频率必须为90000。"
    },
    {
      "indent": 0,
      "text": "10. Security Considerations",
      "section_title": true,
      "zh-CHS": "10. 安全考虑"
    },
    {
      "indent": 3,
      "text": "If a session using this payload format is being encrypted, and interleaving is being used, then the sender SHOULD ensure that any change of encryption key coincides with a start of a new interleave cycle. Apart from this, the security considerations for this payload format are identical to those noted for RFC 2250 [1].",
      "zh-CHS": "如果正在加密使用此有效负载格式的会话，并且正在使用交织，则发送方应确保加密密钥的任何更改与新交织周期的开始一致。除此之外，此有效负载格式的安全注意事项与RFC 2250[1]中的注意事项相同。"
    },
    {
      "indent": 0,
      "text": "11. Acknowledgements",
      "section_title": true,
      "zh-CHS": "11. 致谢"
    },
    {
      "indent": 3,
      "text": "The suggestion of adding an interleaving option (using the first bits of the MPEG 'syncword' -- which would otherwise be all-ones -- as an interleaving index) is due to Dave Singer and Stefan Gewinner. In addition, Dave Singer provided valuable feedback that helped clarify",
      "zh-CHS": "Dave Singer和Stefan Gewinner建议添加一个交织选项（使用MPEG“syncword”的前几位——否则将是全1——作为交织索引）。此外，Dave Singer提供了有价值的反馈，有助于澄清问题"
    },
    {
      "indent": 3,
      "text": "and improve the description of this payload format. Feedback from Chris Sloan led to the addition of an \"ADU descriptor\" preceding each ADU frame in the RTP packet.",
      "zh-CHS": "并改进此有效负载格式的描述。Chris Sloan的反馈导致在RTP数据包的每个ADU帧之前添加了一个“ADU描述符”。"
    },
    {
      "indent": 0,
      "text": "12. Normative References",
      "section_title": true,
      "zh-CHS": "12. 规范性引用文件"
    },
    {
      "indent": 3,
      "text": "[1] Hoffman, D., Fernando, G., Goyal, V., and M. Civanlar, \"RTP Payload Format for MPEG1/MPEG2 Video\", RFC 2250, January 1998.",
      "zh-CHS": "[1] Hoffman，D.，Fernando，G.，Goyal，V.，和M.Civanlar，“MPEG1/MPEG2视频的RTP有效载荷格式”，RFC 2250，1998年1月。"
    },
    {
      "indent": 3,
      "text": "[2] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "zh-CHS": "[2] Bradner，S.，“RFC中用于表示需求水平的关键词”，BCP 14，RFC 2119，1997年3月。"
    },
    {
      "indent": 3,
      "text": "[3] ISO/IEC International Standard 11172-3; \"Coding of moving pictures and associated audio for digital storage media up to about 1,5 Mbits/s -- Part 3: Audio\", 1993.",
      "zh-CHS": "[3] ISO/IEC国际标准11172-3；“高达约1.5 Mbits/s的数字存储媒体用运动图像和相关音频的编码——第3部分：音频”，1993年。"
    },
    {
      "indent": 3,
      "text": "[4] ISO/IEC International Standard 13818-3; \"Generic coding of moving pictures and associated audio information -- Part 3: Audio\", 1998.",
      "zh-CHS": "[4] ISO/IEC国际标准13818-3；“运动图像和相关音频信息的通用编码——第3部分：音频”，1998年。"
    },
    {
      "indent": 3,
      "text": "[5] Handley, M. and C. Perkins, \"Guidelines for Writers of RTP Payload Format Specifications\", BCP 36, RFC 2736, December 1999.",
      "zh-CHS": "[5] Handley，M.和C.Perkins，“RTP有效载荷格式规范编写者指南”，BCP 36，RFC 2736，1999年12月。"
    },
    {
      "indent": 3,
      "text": "[6] Schulzrinne, H. and S. Casner, \"RTP Profile for Audio and Video Conferences with Minimal Control\", STD 65, RFC 3551, July 2003.",
      "zh-CHS": "[6] Schulzrinne，H.和S.Casner，“具有最小控制的音频和视频会议的RTP配置文件”，STD 65，RFC 3551，2003年7月。"
    },
    {
      "indent": 3,
      "text": "[7] Handley, M., Jacobson, V., and C. Perkins, \"SDP: Session Description Protocol\", RFC 4566, July 2006.",
      "zh-CHS": "[7] Handley，M.，Jacobson，V.，和C.Perkins，“SDP：会话描述协议”，RFC4566，2006年7月。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Translating between \"MP3 Frames\" and \"ADU Frames\"",
      "zh-CHS": "附录A“MP3框架”和“ADU框架”之间的翻译"
    },
    {
      "indent": 3,
      "text": "The following 'pseudo code' describes how a sender using this payload format can translate a sequence of regular \"MP3 Frames\" to \"ADU Frames\", and how a receiver can perform the reverse translation: from \"ADU Frames\" to \"MP3 Frames\".",
      "zh-CHS": "以下“伪代码”描述了使用此有效负载格式的发送方如何将一系列常规“MP3帧”转换为“ADU帧”，以及接收方如何执行反向转换：从“ADU帧”转换为“MP3帧”。"
    },
    {
      "indent": 3,
      "text": "We first define the following abstract data structures:",
      "zh-CHS": "我们首先定义以下抽象数据结构："
    },
    {
      "indent": 3,
      "text": "- \"Segment\": A record that represents either a \"MP3 Frame\" or an \"ADU Frame\". It consists of the following fields: - \"header\": the 4-byte MPEG header - \"headerSize\": a constant (== 4) - \"sideInfo\": the 'side info' structure, *including* the optional 2-byte CRC field, if present - \"sideInfoSize\": the size (in bytes) of the above structure - \"frameData\": the remaining data in this frame - \"frameDataSize\": the size (in bytes) of the above data - \"backpointer\": the value (expressed in bytes) of the backpointer for this frame - \"aduDataSize\": the size (in bytes) of the ADU associated with this frame. (If the frame is already an \"ADU Frame\", then aduDataSize == frameDataSize) - \"mp3FrameSize\": the total size (in bytes) that this frame would have if it were a regular \"MP3 Frame\". (If it is already a \"MP3 Frame\", then mp3FrameSize == headerSize + sideInfoSize + frameDataSize) Note that this size can be derived completely from \"header\".",
      "zh-CHS": "- “段”：表示“MP3帧”或“ADU帧”的记录。它由以下字段组成：-“header”：4字节MPEG标头-“headerSize”：一个常数（=4）-“sideInfo”：侧信息结构，*包括*可选的2字节CRC字段，如果存在-“sideInfoSize”：上述结构的大小（以字节为单位）“frameData”：此帧中的剩余数据-“frameDataSize”：大小（以字节为单位）在上述数据中—“backpointer”：此帧的backpointer的值（以字节表示）：“aduDataSize”：与此帧关联的ADU的大小（以字节为单位）。（如果帧已经是“ADU帧”，则ADUDASize==frameDataSize）-“mp3FrameSize”：如果该帧是常规“MP3帧”，则该帧将具有的总大小（以字节为单位）。（如果它已经是一个“MP3帧”，那么mp3FrameSize==headerSize+sideInfoSize+frameDataSize）请注意，此大小可以完全从“header”派生。"
    },
    {
      "indent": 3,
      "text": "-  \"SegmentQueue\": A FIFO queue of \"Segments\", with operations\n   -  void enqueue(Segment)\n   -  Segment dequeue()\n   -  Boolean isEmpty()\n   -  Segment head()\n   -  Segment tail()\n   -  Segment previous(Segment):  returns the segment prior to a\n      given one\n   -  Segment next(Segment): returns the segment after a given one\n   -  unsigned totalDataSize(): returns the sum of the\n      \"frameDataSize\" fields of each entry in the queue",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "A.1. Converting a Sequence of \"MP3 Frames\" to a Sequence of \"ADU Frames\"",
      "zh-CHS": "A.1. 将“MP3帧”序列转换为“ADU帧”序列"
    },
    {
      "indent": 3,
      "text": "SegmentQueue pendingMP3Frames; // initially empty\nwhile (1) {\n         // Enqueue new MP3 Frames, until we have enough data to\n         // generate the ADU for a frame:\n         do {\n                 int totalDataSizeBefore\n                         = pendingMP3Frames.totalDataSize();",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 20,
      "text": "Segment newFrame = 'the next MP3 Frame';\npendingMP3Frames.enqueue(newFrame);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 12,
      "text": "        int totalDataSizeAfter\n                = pendingMP3Frames.totalDataSize();\n} while (totalDataSizeBefore < newFrame.backpointer ||\n          totalDataSizeAfter < newFrame.aduDataSize);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 12,
      "text": "// We now have enough data to generate the ADU for the most\n// recently enqueued frame (i.e., the tail of the queue).\n// (The earlier frames in the queue -- if any -- must be\n// discarded, as we don't have enough data to generate\n// their ADUs.)\nSegment tailFrame = pendingMP3Frames.tail();",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 12,
      "text": "// Output the header and side info:\noutput(tailFrame.header);\noutput(tailFrame.sideInfo);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 12,
      "text": "// Go back to the frame that contains the start of our\n// ADU data:\nint offset = 0;\nSegment curFrame = tailFrame;\nint prevBytes = tailFrame.backpointer;\nwhile (prevBytes > 0) {\n        curFrame = pendingMP3Frames.previous(curFrame);\n        int dataHere = curFrame.frameDataSize;\n        if (dataHere < prevBytes) {\n                prevBytes -= dataHere;\n        } else {\n                offset = dataHere - prevBytes;\n                break;\n        }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 12,
      "text": "// Dequeue any frames that we no longer need:\nwhile (pendingMP3Frames.head() != curFrame) {",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 12,
      "text": "        pendingMP3Frames.dequeue();\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 12,
      "text": "// Output, from the remaining frames, the ADU data that\n// we want:\nint bytesToUse = tailFrame.aduDataSize;\nwhile (bytesToUse > 0) {\n        int dataHere = curFrame.frameDataSize - offset;\n        int bytesUsedHere\n                = dataHere < bytesToUse ? dataHere :\n                bytesToUse;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 20,
      "text": "output(\"bytesUsedHere\" bytes from curFrame.frameData, starting from \"offset\");",
      "zh-CHS": "输出curFrame.frameData中的“bytesUsedHere”字节，从“offset”开始；"
    },
    {
      "indent": 3,
      "text": "                 bytesToUse -= bytesUsedHere;\n                 offset = 0;\n                 curFrame = pendingMP3Frames.next(curFrame);\n         }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "A.2. Converting a Sequence of \"ADU Frames\" to a Sequence of \"MP3 Frames\"",
      "zh-CHS": "A.2. 将“ADU帧”序列转换为“MP3帧”序列"
    },
    {
      "indent": 3,
      "text": "SegmentQueue pendingADUFrames; // initially empty\nwhile (1) {\n         while (needToGetAnADU()) {\n                 Segment newADU = 'the next ADU Frame';\n                 pendingADUFrames.enqueue(newADU);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 12,
      "text": "        insertDummyADUsIfNecessary();\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "         generateFrameFromHeadADU();\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Boolean needToGetAnADU() {\n         // Checks whether we need to enqueue one or more new ADUs\n         // before we have enough data to generate a frame for the\n         // head ADU.\n         Boolean needToEnqueue = True;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 12,
      "text": "if (!pendingADUFrames.isEmpty()) {\n        Segment curADU = pendingADUFrames.head();\n        int endOfHeadFrame = curADU.mp3FrameSize\n                - curADU.headerSize - curADU.sideInfoSize;\n        int frameOffset = 0;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 20,
      "text": "while (1) {\n       int endOfData = frameOffset\n               - curADU.backpointer +\n                 curADU.aduDataSize;\n       if (endOfData >= endOfHeadFrame) {\n               // We have enough data to generate a\n               // frame.\n               needToEnqueue = False;\n               break;\n       }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 12,
      "text": "               frameOffset += curADU.mp3FrameSize\n                       - curADU.headerSize\n                       - curADU.sideInfoSize;\n               if (curADU == pendingADUFrames.tail()) break;\n               curADU = pendingADUFrames.next(curADU);\n        }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "     return needToEnqueue;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "void generateFrameFromHeadADU() {\n         Segment curADU = pendingADUFrames.head();",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 12,
      "text": "// Output the header and side info:\noutput(curADU.header);\noutput(curADU.sideInfo);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 12,
      "text": "// Begin by zeroing out the rest of the frame, in case the\n// ADU data doesn't fill it in completely:\nint endOfHeadFrame = curADU.mp3FrameSize\n        - curADU.headerSize - curADU.sideInfoSize;\noutput(\"endOfHeadFrame\" zero bytes);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 12,
      "text": "// Fill in the frame with appropriate ADU data from this and\n// subsequent ADUs:\nint frameOffset = 0;\nint toOffset = 0;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 12,
      "text": "while (toOffset < endOfHeadFrame) {\n       int startOfData = frameOffset - curADU.backpointer;\n       if (startOfData > endOfHeadFrame) {\n               break; // no more ADUs are needed\n       }\n       int endOfData = startOfData + curADU.aduDataSize;\n       if (endOfData > endOfHeadFrame) {\n               endOfData = endOfHeadFrame;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 19,
      "text": "}",
      "zh-CHS": "}"
    },
    {
      "indent": 19,
      "text": "int fromOffset;\nif (startOfData <= toOffset) {\n        fromOffset = toOffset - startOfData;\n        startOfData = toOffset;\n        if (endOfData < startOfData) {\n                endOfData = startOfData;\n        }\n} else {\n        fromOffset = 0;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 19,
      "text": "        // leave some zero bytes beforehand:\n        toOffset = startOfData;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 19,
      "text": "int bytesUsedHere = endOfData - startOfData;\noutput(starting at offset \"toOffset\", \"bytesUsedHere\"\n        bytes from \"&curADU.frameData[fromOffset]\");\ntoOffset += bytesUsedHere;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 12,
      "text": "       frameOffset += curADU.mp3FrameSize\n               - curADU.headerSize - curADU.sideInfoSize;\n       curADU = pendingADUFrames.next(curADU);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "         pendingADUFrames.dequeue();\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "void insertDummyADUsIfNecessary() {\n         // The tail segment (ADU) is assumed to have been recently\n         // enqueued.  If its backpointer would overlap the data\n         // of the previous ADU, then we need to insert one or more\n         // empty, 'dummy' ADUs ahead of it.  (This situation\n         // should occur only if an intermediate ADU was missing\n         // -- e.g., due to packet loss.)\n         while (1) {\n                Segment tailADU = pendingADUFrames.tail();\n                int prevADUend; // relative to the start\n                 of the tail ADU",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 19,
      "text": "if (pendingADUFrames.head() != tailADU) {\n        // there is a previous ADU\n        Segment prevADU\n                = pendingADUFrames.previous(tailADU);\n        prevADUend\n                = prevADU.mp3FrameSize +\n                  prevADU.backpointer",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 19,
      "text": "                  - prevADU.headerSize\n                  - prevADU.sideInfoSize;\n        if (prevADU.aduDataSize > prevADUend) {\n                // this shouldn't happen if the\n                // previous ADU was well-formed\n                prevADUend = 0;\n        } else {\n                prevADUend -= prevADU.aduDataSize;\n        }\n} else {\n        prevADUend = 0;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "                if (tailADU.backpointer > prevADUend) {\n                   // Insert a 'dummy' ADU in front of the tail.\n                   // This ADU can have the same \"header\" (and thus,\n                   // \"mp3FrameSize\") as the tail ADU, but should\n                   // have a \"backpointer\" of \"prevADUend\", and\n                   // an \"aduDataSize\" of zero.  The simplest\n                   // way to do this is to copy the \"sideInfo\" from\n                   // the tail ADU, replace the value of\n                   // \"main_data_begin\" with \"prevADUend\", and set\n                   // all of the \"part2_3_length\" fields to zero.\n                } else {\n                        break; // no more dummy ADUs need to be\n                               // inserted\n                }\n         }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "Appendix B. Interleaving and Deinterleaving",
      "section_title": true,
      "zh-CHS": "附录B.交织和解交织"
    },
    {
      "indent": 3,
      "text": "The following 'pseudo code' describes how a sender can reorder a sequence of \"ADU Frames\" according to an interleaving pattern (step 2), and how a receiver can perform the reverse reordering (step 6).",
      "zh-CHS": "以下“伪代码”描述发送方如何根据交织模式对“ADU帧”序列进行重新排序（步骤2），以及接收方如何执行反向重新排序（步骤6）。"
    },
    {
      "indent": 0,
      "text": "B.1. Interleaving a Sequence of \"ADU Frames\"",
      "section_title": true,
      "zh-CHS": "B.1. 交织“ADU帧”序列"
    },
    {
      "indent": 3,
      "text": "We first define the following abstract data structures:",
      "zh-CHS": "我们首先定义以下抽象数据结构："
    },
    {
      "indent": 3,
      "text": "- \"interleaveCycleSize\": an integer in the range [1..256] -- \"interleaveCycle\": an array, of size \"interleaveCycleSize\", containing some permutation of the integers from the set [0 .. interleaveCycleSize-1] e.g., if \"interleaveCycleSize\" == 8, \"interleaveCycle\" might contain: 1,3,5,7,0,2,4,6 - \"inverseInterleaveCycle\": an array containing the inverse of the permutation in \"interleaveCycle\" -- i.e., such that",
      "zh-CHS": "- “interleaveCycleSize”：范围为[1..256]的整数--“interleaveCycleSize”：大小为“interleaveCycleSize”的数组，包含集合[0..interleaveCycleSize-1]中的一些整数排列，例如，如果“interleaveCycleSize”==8，“interleaveCycle”可能包含：1,3,5,7,0,2,4,6-“inverseInterleaveCycle”：一个数组，包含“交错循环”中排列的倒数，即"
    },
    {
      "indent": 3,
      "text": " interleaveCycle[inverseInterleaveCycle[i]] == i - \"ii\": the current Interleave Index (initially 0) - \"icc\": the current Interleave Cycle Count (initially 0) - \"aduFrameBuffer\": an array, of size \"interleaveCycleSize\", of ADU Frames that are awaiting packetization",
      "zh-CHS": "交织周期[inverseInterleaveCycle[i]==i-“ii”：当前交织索引（最初为0）-“icc”：当前交织周期计数（最初为0）-“aduFrameBuffer”：等待打包的ADU帧的大小为“interleaveCycleSize”的数组"
    },
    {
      "indent": 3,
      "text": "while (1) {\n         int positionOfNextFrame = inverseInterleaveCycle[ii];\n         aduFrameBuffer[positionOfNextFrame] = the next ADU frame;\n         replace the high-order 11 bits of this frame's MPEG header\n             with (ii,icc);\n                 // Note: Be sure to leave the remaining 21 bits\n                 // as is\n         if (++ii == interleaveCycleSize) {\n                 // We've finished this cycle, so pass all\n                 // pending frames to the packetizing step\n                 for (int i = 0; i < interleaveCycleSize; ++i) {\n                      pass aduFrameBuffer[i] to the packetizing step;\n                 }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "                 ii = 0;\n                 icc = (icc+1)%8;\n         }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "B.2. Deinterleaving a Sequence of (Interleaved) \"ADU Frames\"",
      "section_title": true,
      "zh-CHS": "B.2. 解交织（交织）“ADU帧”序列"
    },
    {
      "indent": 3,
      "text": "We first define the following abstract data structures:",
      "zh-CHS": "我们首先定义以下抽象数据结构："
    },
    {
      "indent": 3,
      "text": "- \"ii\": the Interleave Index from the current incoming ADU frame - \"icc\": the Interleave Cycle Count from the current incoming ADU frame - \"iiLastSeen\": the most recently seen Interleave Index (initially, some integer *not* in the range [0..255]) - \"iccLastSeen\": the most recently seen Interleave Cycle Count (initially, some integer *not* in the range [0..7]) - \"aduFrameBuffer\": an array, of size 256, of (pointers to) ADU Frames that have just been depacketized (initially, all entries are NULL)",
      "zh-CHS": "- “ii”：来自当前传入ADU帧的交织索引-“icc”：来自当前传入ADU帧的交织周期计数-“iiLastSeen”：最近看到的交织索引（最初，某个整数*不*在[0..255]范围内）-“icc”：最近看到的交织周期计数（最初，范围[0..7]中的某个整数*不*）-“ADU帧缓冲区”：一个大小为256的数组，包含（指向）刚刚被解包的ADU帧（最初，所有条目均为空）"
    },
    {
      "indent": 3,
      "text": "while (1) {\n         aduFrame = the next ADU frame from the depacketizing step;\n         (ii,icc) = \"the high-order 11 bits of aduFrame's MPEG\n         header\"; \"the high-order 11 bits of aduFrame's MPEG\n         header\" = 0xFFE;\n                 // Note: Be sure to leave the remaining 21 bits\n                 // as is",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 12,
      "text": "if (icc != iccLastSeen || ii == iiLastSeen) {\n        // We've started a new interleave cycle\n        // (or interleaving was not used).  Release all\n        // pending ADU frames to the ADU->MP3 conversion\n        // step:\n        for (int i = 0; i < 256; ++i) {\n                if (aduFrameBuffer[i] != NULL) {\n                        release aduFrameBuffer[i];\n                        aduFrameBuffer[i] = NULL;\n                }\n        }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "         iiLastSeen = ii;\n         iccLastSeen = icc;\n         aduFrameBuffer[ii] = aduFrame;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "Appendix C. Changes from RFC 3119",
      "section_title": true,
      "zh-CHS": "附录C.对RFC 3119的变更"
    },
    {
      "indent": 3,
      "text": "The primary change from RFC 3119 is to correct the encoding name in the \"SDP usage\" section. The correct encoding name is \"mpa-robust\". Also, the term \"media type\" replaces \"mime type\". Finally, some minor bug fixes and clarifications were made to the (non-normative) pseudo code in Appendix A and Appendix B.",
      "zh-CHS": "RFC3119的主要更改是更正“SDP用法”部分中的编码名称。正确的编码名称是“mpa robust”。此外，术语“媒体类型”取代了“mime类型”。最后，对附录A和附录B中的（非规范性）伪代码进行了一些小错误修复和澄清。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "zh-CHS": "作者地址"
    },
    {
      "indent": 3,
      "text": "Ross Finlayson, Live Networks, Inc. 650 Castro St., suite 120-196 Mountain View, CA 94041 USA",
      "zh-CHS": "Ross Finlayson，美国加利福尼亚州山景城卡斯特罗街650号Live Networks有限公司，邮编94041，120-196室"
    },
    {
      "indent": 3,
      "text": "EMail: finlayson@live555.com\nURI: http://www.live555.com/",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "zh-CHS": "完整版权声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The IETF Trust (2008).",
      "zh-CHS": "版权所有（C）IETF信托基金（2008年）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "zh-CHS": "本文件受BCP 78中包含的权利、许可和限制的约束，除其中规定外，作者保留其所有权利。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "zh-CHS": "本文件及其包含的信息以“原样”为基础提供，贡献者、他/她所代表或赞助的组织（如有）、互联网协会、IETF信托基金和互联网工程任务组不承担任何明示或暗示的担保，包括但不限于任何保证，即使用本文中的信息不会侵犯任何权利，或对适销性或特定用途适用性的任何默示保证。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "zh-CHS": "知识产权"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "zh-CHS": "IETF对可能声称与本文件所述技术的实施或使用有关的任何知识产权或其他权利的有效性或范围，或此类权利下的任何许可可能或可能不可用的程度，不采取任何立场；它也不表示它已作出任何独立努力来确定任何此类权利。有关RFC文件中权利的程序信息，请参见BCP 78和BCP 79。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "zh-CHS": "向IETF秘书处披露的知识产权副本和任何许可证保证，或本规范实施者或用户试图获得使用此类专有权利的一般许可证或许可的结果，可从IETF在线知识产权存储库获取，网址为http://www.ietf.org/ipr."
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "zh-CHS": "IETF邀请任何相关方提请其注意任何版权、专利或专利申请，或其他可能涵盖实施本标准所需技术的专有权利。请将信息发送至IETF的IETF-ipr@ietf.org."
    }
  ]
}