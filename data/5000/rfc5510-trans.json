{
  "title": {
    "text": "RFC 5510: Reed-Solomon Forward Error Correction (FEC) Schemes",
    "zh-CHS": "RFC 5510"
  },
  "number": 5510,
  "created_at": "2021-11-07 19:59:37.938586+08:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                           J. Lacan\nRequest for Comments: 5510                                ISAE/LAAS-CNRS\nCategory: Standards Track                                        V. Roca\n                                                                   INRIA\n                                                            J. Peltotalo\n                                                            S. Peltotalo\n                                        Tampere University of Technology\n                                                              April 2009",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "Reed-Solomon Forward Error Correction (FEC) Schemes",
      "zh-CHS": "Reed-Solomon前向纠错（FEC）方案"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "zh-CHS": "关于下段备忘"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "zh-CHS": "本文件规定了互联网社区的互联网标准跟踪协议，并要求进行讨论和提出改进建议。有关本协议的标准化状态和状态，请参考当前版本的“互联网官方协议标准”（STD 1）。本备忘录的分发不受限制。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "zh-CHS": "版权公告"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2009 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "zh-CHS": "版权所有（c）2009 IETF信托基金和确定为文件作者的人员。版权所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents in effect on the date of publication of this document (http://trustee.ietf.org/license-info). Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "zh-CHS": "本文件受BCP 78和IETF信托在本文件出版之日生效的与IETF文件有关的法律规定的约束(http://trustee.ietf.org/license-info). 请仔细阅读这些文件，因为它们描述了您对本文件的权利和限制。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "zh-CHS": "本文件可能包含2008年11月10日之前发布或公开的IETF文件或IETF贡献中的材料。控制某些材料版权的人员可能未授予IETF信托允许在IETF标准流程之外修改此类材料的权利。在未从控制此类材料版权的人员处获得充分许可的情况下，不得在IETF标准流程之外修改本文件，也不得在IETF标准流程之外创建其衍生作品，除了将其格式化以RFC形式发布或将其翻译成英语以外的其他语言。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "zh-CHS": "摘要"
    },
    {
      "indent": 3,
      "text": "This document describes a Fully-Specified Forward Error Correction (FEC) Scheme for the Reed-Solomon FEC codes over GF(2^^m), where m is in {2..16}, and its application to the reliable delivery of data objects on the packet erasure channel (i.e., a communication path where packets are either received without any corruption or discarded during transmission). This document also describes a Fully-Specified FEC Scheme for the special case of Reed-Solomon codes over GF(2^^8) when there is no encoding symbol group. Finally, in the context of the Under-Specified Small Block Systematic FEC Scheme (FEC Encoding ID 129), this document assigns an FEC Instance ID to the special case of Reed-Solomon codes over GF(2^^8).",
      "zh-CHS": "本文描述了GF（2^^m）上Reed-Solomon FEC码的一种完全指定的前向纠错（FEC）方案，其中m在{2..16}中，并将其应用于数据包擦除信道上数据对象的可靠传输（即，一种通信路径，在该路径中，数据包要么在接收时没有任何损坏，要么在传输过程中被丢弃）。本文件还描述了一种完全指定的FEC方案，用于GF（2^^8）上的Reed-Solomon码的特殊情况最后，在指定的小块系统FEC方案（FEC编码ID 129）的上下文中，本文档将FEC实例ID分配给GF（2^^8）上的Reed-Solomon码的特例。"
    },
    {
      "indent": 3,
      "text": "Reed-Solomon codes belong to the class of Maximum Distance Separable (MDS) codes, i.e., they enable a receiver to recover the k source symbols from any set of k received symbols. The schemes described here are compatible with the implementation from Luigi Rizzo.",
      "zh-CHS": "Reed-Solomon码属于最大距离可分离（MDS）码的类别，即，它们使接收器能够从任意k个接收符号集合中恢复k个源符号。这里描述的方案与Luigi Rizzo的实现兼容。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "zh-CHS": "目录"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................4\n2. Terminology .....................................................5\n3. Definitions Notations and Abbreviations .........................5\n   3.1. Definitions ................................................5\n   3.2. Notations ..................................................6\n   3.3. Abbreviations ..............................................7\n4. Formats and Codes with FEC Encoding ID 2 ........................7\n   4.1. FEC Payload ID .............................................7\n   4.2. FEC Object Transmission Information ........................8\n        4.2.1. Mandatory Elements ..................................8\n        4.2.2. Common Elements .....................................8\n        4.2.3. Scheme-Specific Elements ............................9\n        4.2.4. Encoding Format .....................................9\n5. Formats and Codes with FEC Encoding ID 5 .......................11\n   5.1. FEC Payload ID ............................................11\n   5.2. FEC Object Transmission Information .......................12\n        5.2.1. Mandatory Elements .................................12\n        5.2.2. Common Elements ....................................12\n        5.2.3. Scheme-Specific Elements ...........................12\n        5.2.4. Encoding Format ....................................12\n6. Procedures with FEC Encoding IDs 2 and 5 .......................13\n   6.1. Determining the Maximum Source Block Length (B) ...........13\n   6.2. Determining the Number of Encoding Symbols of a Block .....14\n7. Small Block Systematic FEC Scheme (FEC Encoding ID 129)\n   and Reed-Solomon Codes over GF(2^^8) ...........................15\n8. Reed-Solomon Codes Specification for the Erasure Channel .......16\n   8.1. Finite Field ..............................................16\n   8.2. Reed-Solomon Encoding Algorithm ...........................17\n        8.2.1. Encoding Principles ................................17\n        8.2.2. Encoding Complexity ................................18\n   8.3. Reed-Solomon Decoding Algorithm ...........................18\n        8.3.1. Decoding Principles ................................18\n        8.3.2. Decoding Complexity ................................19\n   8.4. Implementation for the Packet Erasure Channel .............19\n9. Security Considerations ........................................22\n   9.1. Problem Statement .........................................22\n   9.2. Attacks against the Data Flow .............................23\n        9.2.1. Access to Confidential Objects .....................23\n        9.2.2. Content Corruption .................................23\n   9.3. Attacks against the FEC Parameters ........................24\n10. IANA Considerations ...........................................25\n11. Acknowledgments ...............................................25\n12. References ....................................................26\n   12.1. Normative References .....................................26\n   12.2. Informative References ...................................26",
      "raw": true,
      "toc": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "zh-CHS": "1. 介绍"
    },
    {
      "indent": 3,
      "text": "The use of Forward Error Correction (FEC) codes is a classical solution to improve the reliability of multicast and broadcast transmissions. The [RFC5052] document describes a general framework to use FEC in Content Delivery Protocols (CDPs). The companion document [RFC3453] describes some applications of FEC codes for content delivery.",
      "zh-CHS": "使用前向纠错（FEC）码是提高多播和广播传输可靠性的经典解决方案。[RFC5052]文档描述了在内容交付协议（CDP）中使用FEC的一般框架。配套文件[RFC3453]描述了FEC代码在内容交付中的一些应用。"
    },
    {
      "indent": 3,
      "text": "Recent FEC schemes like [RFC5053] and [RFC5170] proposed erasure codes based on sparse graphs/matrices. These codes are efficient in terms of processing but not optimal in terms of correction capabilities when dealing with \"small\" objects.",
      "zh-CHS": "最近的FEC方案，如[RFC5053]和[RFC5170]提出了基于稀疏图/矩阵的擦除码。在处理“小”对象时，这些代码在处理方面是有效的，但在纠正能力方面不是最佳的。"
    },
    {
      "indent": 3,
      "text": "The FEC schemes described in this document belongs to the class of Maximum Distance Separable codes that are optimal in terms of erasure correction capability. In others words, it enables a receiver to recover the k source symbols from any set of exactly k encoding symbols. They are also systematic codes, which means that the k source symbols are part of the encoding symbols. Even if the encoding/decoding complexity is larger than that of [RFC5053] or [RFC5170], this family of codes is very useful.",
      "zh-CHS": "本文中描述的FEC方案属于在擦除校正能力方面是最优的最大距离可分离码类。换句话说，它使接收器能够从任何一组恰好为k的编码符号中恢复k个源符号。它们也是系统代码，这意味着k个源符号是编码符号的一部分。即使编码/解码复杂度大于[RFC5053]或[RFC5170]的编码/解码复杂度，这一系列代码也是非常有用的。"
    },
    {
      "indent": 3,
      "text": "Many applications dealing with content transmission or content storage already rely on packet-based Reed-Solomon codes. In particular, many of them use the Reed-Solomon codec of Luigi Rizzo [RS-codec] [Rizzo97]. The goal of the present document is to specify an implementation of Reed-Solomon codes that is compatible with this codec.",
      "zh-CHS": "许多处理内容传输或内容存储的应用程序已经依赖于基于分组的Reed-Solomon码。特别是，他们中的许多人使用Luigi Rizzo[RS codec][Rizzo97]的Reed Solomon编解码器。本文档的目标是指定与此编解码器兼容的Reed Solomon代码的实现。"
    },
    {
      "indent": 3,
      "text": "The present document:",
      "zh-CHS": "本文件："
    },
    {
      "indent": 3,
      "text": "o introduces the Fully-Specified FEC Scheme with FEC Encoding ID 2, which specifies the use of Reed-Solomon codes over GF(2^^m), where m is in {2..16},",
      "zh-CHS": "o 介绍FEC编码ID为2的完全指定的FEC方案，该方案指定在GF（2^^m）上使用Reed-Solomon码，其中m位于{2..16}，"
    },
    {
      "indent": 3,
      "text": "o introduces the Fully-Specified FEC Scheme with FEC Encoding ID 5, which focuses on the special case of Reed-Solomon codes over GF(2^^8) and no encoding symbol group (i.e., exactly one symbol per packet), and",
      "zh-CHS": "o 介绍了FEC编码ID为5的完全指定的FEC方案，重点介绍了GF（2^^8）上的Reed-Solomon码和无编码符号组（即每个数据包只有一个符号）的特例，以及"
    },
    {
      "indent": 3,
      "text": "o in the context of the Under-Specified Small Block Systematic FEC Scheme (FEC Encoding ID 129) [RFC5445], assigns the FEC Instance ID 0 to the special case of Reed-Solomon codes over GF(2^^8) and no encoding symbol group.",
      "zh-CHS": "o 在未指定的小块系统FEC方案（FEC编码ID 129）[RFC5445]的上下文中，将FEC实例ID 0分配给GF（2^^8）上的Reed-Solomon码和无编码符号组的特例。"
    },
    {
      "indent": 3,
      "text": "For a definition of the terms Fully-Specified and Under-Specified FEC Schemes, see [RFC5052], Section 4.",
      "zh-CHS": "有关完全指定和指定FEC方案下的术语定义，请参见[RFC5052]第4节。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "zh-CHS": "2. 术语"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "zh-CHS": "本文件中的关键词“必须”、“不得”、“要求”、“应”、“不应”、“应”、“不应”、“建议”、“可”和“可选”应按照RFC 2119[RFC2119]中所述进行解释。"
    },
    {
      "indent": 0,
      "text": "3. Definitions Notations and Abbreviations",
      "section_title": true,
      "zh-CHS": "3. 定义、符号和缩写"
    },
    {
      "indent": 0,
      "text": "3.1. Definitions",
      "section_title": true,
      "zh-CHS": "3.1. 定义"
    },
    {
      "indent": 3,
      "text": "This document uses the same terms and definitions as those specified in [RFC5052]. Additionally, it uses the following definitions:",
      "zh-CHS": "本文件使用的术语和定义与[RFC5052]中规定的术语和定义相同。此外，它使用以下定义："
    },
    {
      "indent": 6,
      "text": "Source symbol: unit of data used during the encoding process.",
      "zh-CHS": "源符号：编码过程中使用的数据单位。"
    },
    {
      "indent": 6,
      "text": "Encoding symbol: unit of data generated by the encoding process.",
      "zh-CHS": "编码符号：编码过程产生的数据单位。"
    },
    {
      "indent": 6,
      "text": "Repair symbol: encoding symbol that is not a source symbol.",
      "zh-CHS": "修复符号：编码非源符号的符号。"
    },
    {
      "indent": 6,
      "text": "Code rate: the k/n ratio, i.e., the ratio between the number of source symbols and the number of encoding symbols. By definition, the code rate is such that: 0 < code rate <= 1. A code rate close to 1 indicates that a small number of repair symbols have been produced during the encoding process.",
      "zh-CHS": "码率：k/n比，即源符号数与编码符号数之比。根据定义，代码速率为：0<代码速率<=1。接近1的码率表示在编码过程中产生了少量修复符号。"
    },
    {
      "indent": 6,
      "text": "Systematic code: FEC code in which the source symbols are part of the encoding symbols.",
      "zh-CHS": "系统代码：FEC代码，其中源符号是编码符号的一部分。"
    },
    {
      "indent": 6,
      "text": "Source block: a block of k source symbols that are considered together for the encoding.",
      "zh-CHS": "源代码块：为编码而考虑在一起的k个源代码块。"
    },
    {
      "indent": 6,
      "text": "Encoding Symbol Group: a group of encoding symbols that are sent together within the same packet, and whose relationships to the source block can be derived from a single Encoding Symbol ID.",
      "zh-CHS": "编码符号组：在同一数据包内一起发送的一组编码符号，其与源块的关系可从单个编码符号ID派生。"
    },
    {
      "indent": 6,
      "text": "Source Packet: a data packet containing only source symbols.",
      "zh-CHS": "源数据包：只包含源符号的数据包。"
    },
    {
      "indent": 6,
      "text": "Repair Packet: a data packet containing only repair symbols.",
      "zh-CHS": "修复包：仅包含修复符号的数据包。"
    },
    {
      "indent": 6,
      "text": "Packet Erasure Channel: a communication path where packets are either dropped (e.g., by a congested router, or because the number of transmission errors exceeds the correction capabilities of the physical layer codes) or received. When a packet is received, it is assumed that this packet is not corrupted.",
      "zh-CHS": "数据包擦除信道：数据包被丢弃（例如，被拥塞的路由器丢弃，或者因为传输错误的数量超过了物理层代码的纠正能力）或被接收的通信路径。当接收到数据包时，假定该数据包未损坏。"
    },
    {
      "indent": 0,
      "text": "3.2. Notations",
      "section_title": true,
      "zh-CHS": "3.2. 符号"
    },
    {
      "indent": 3,
      "text": "This document uses the following notations:",
      "zh-CHS": "本文件使用以下符号："
    },
    {
      "indent": 6,
      "text": "L the object transfer length in bytes.",
      "zh-CHS": "L以字节为单位的对象传输长度。"
    },
    {
      "indent": 6,
      "text": "k the number of source symbols in a source block.",
      "zh-CHS": "k源块中的源符号数。"
    },
    {
      "indent": 6,
      "text": "n_r the number of repair symbols generated for a source block.",
      "zh-CHS": "n\\r为源块生成的修复符号数。"
    },
    {
      "indent": 6,
      "text": "n the encoding block length, i.e., the number of encoding symbols generated for a source block. Therefore: n = k + n_r.",
      "zh-CHS": "n编码块长度，即为源块生成的编码符号数。因此：n=k+n\\r。"
    },
    {
      "indent": 6,
      "text": "max_n the maximum number of encoding symbols generated for any source block.",
      "zh-CHS": "max\\n为任何源块生成的最大编码符号数。"
    },
    {
      "indent": 6,
      "text": "B the maximum source block length in symbols, i.e., the maximum number of source symbols per source block.",
      "zh-CHS": "B以符号表示的最大源块长度，即每个源块的最大源符号数。"
    },
    {
      "indent": 6,
      "text": "N the number of source blocks into which the object shall be partitioned.",
      "zh-CHS": "N应将对象分割成的源块的数量。"
    },
    {
      "indent": 6,
      "text": "E the encoding symbol length in bytes.",
      "zh-CHS": "E以字节为单位的编码符号长度。"
    },
    {
      "indent": 6,
      "text": "S the symbol size in units of m-bit elements. When m = 8, then S and E are equal.",
      "zh-CHS": "S以m位元素为单位的符号大小。当m=8时，S和E相等。"
    },
    {
      "indent": 6,
      "text": "m the length of the elements in the finite field, in bits. In this document, m belongs to {2..16}.",
      "zh-CHS": "m有限域中元素的长度，单位为位。在本文中，m属于{2..16}。"
    },
    {
      "indent": 6,
      "text": "q the number of elements in the finite field. We have: q = 2^^m in this specification.",
      "zh-CHS": "q有限域中的元素数。本规范中有：q=2^^m。"
    },
    {
      "indent": 6,
      "text": "G the number of encoding symbols per group, i.e., the number of symbols sent in the same packet.",
      "zh-CHS": "G每组编码符号的数量，即在同一数据包中发送的符号数量。"
    },
    {
      "indent": 6,
      "text": "GM the Generator Matrix of a Reed-Solomon code.",
      "zh-CHS": "GM里德-所罗门码的生成矩阵。"
    },
    {
      "indent": 6,
      "text": "CR the \"code rate\", i.e., the k/n ratio.",
      "zh-CHS": "CR“编码率”，即k/n比。"
    },
    {
      "indent": 6,
      "text": "a^^b a raised to the power b.",
      "zh-CHS": "a^^b a升到b的幂。"
    },
    {
      "indent": 6,
      "text": "a^^-1 the inverse of a.",
      "zh-CHS": "a^^-1是a的倒数。"
    },
    {
      "indent": 6,
      "text": "I_k the k*k identity matrix.",
      "zh-CHS": "我知道k*k单位矩阵。"
    },
    {
      "indent": 0,
      "text": "3.3. Abbreviations",
      "section_title": true,
      "zh-CHS": "3.3. 缩写"
    },
    {
      "indent": 3,
      "text": "This document uses the following abbreviations:",
      "zh-CHS": "本文件使用以下缩写："
    },
    {
      "indent": 6,
      "text": "ESI Encoding Symbol ID.",
      "zh-CHS": "ESI编码符号ID。"
    },
    {
      "indent": 6,
      "text": "FEC OTI FEC Object Transmission Information.",
      "zh-CHS": "FEC OTI FEC对象传输信息。"
    },
    {
      "indent": 6,
      "text": "RS Reed-Solomon.",
      "zh-CHS": "里德·所罗门。"
    },
    {
      "indent": 6,
      "text": "MDS Maximum Distance Separable code.",
      "zh-CHS": "最大距离可分离码。"
    },
    {
      "indent": 6,
      "text": "GF(q) a finite field (also known as Galois Field) with q elements. We assume that q = 2^^m in this document.",
      "zh-CHS": "GF（q）一个有限域（也称为伽罗瓦域），包含q元素。在本文件中，我们假设q=2^^m。"
    },
    {
      "indent": 0,
      "text": "4. Formats and Codes with FEC Encoding ID 2",
      "section_title": true,
      "zh-CHS": "4. FEC编码ID为2的格式和代码"
    },
    {
      "indent": 3,
      "text": "This section introduces the formats and codes associated with the Fully-Specified FEC Scheme with FEC Encoding ID 2, which specifies the use of Reed-Solomon codes over GF(2^^m).",
      "zh-CHS": "本节介绍与FEC编码ID为2的完全指定的FEC方案相关的格式和代码，该方案指定在GF（2^^m）上使用Reed-Solomon码。"
    },
    {
      "indent": 0,
      "text": "4.1. FEC Payload ID",
      "section_title": true,
      "zh-CHS": "4.1. 有效载荷ID"
    },
    {
      "indent": 3,
      "text": "The FEC Payload ID is composed of the Source Block Number and the Encoding Symbol ID. The lengths of these two fields depend on the parameter m (which is transmitted in the FEC OTI) as follows:",
      "zh-CHS": "FEC有效负载ID由源块号和编码符号ID组成。这两个字段的长度取决于参数m（在FEC OTI中传输），如下所示："
    },
    {
      "indent": 3,
      "text": "o The Source Block Number (field of size 32-m bits) identifies from which source block of the object the encoding symbol(s) in the payload are generated. There is a maximum of 2^^(32-m) blocks per object.",
      "zh-CHS": "o 源块编号（大小为32-m位的字段）标识有效负载中的编码符号是从对象的哪个源块生成的。每个对象最多有2^^（32-m）个块。"
    },
    {
      "indent": 3,
      "text": "o The Encoding Symbol ID (field of size m bits) identifies which specific encoding symbol(s) generated from the source block are carried in the packet payload. There is a maximum of 2^^m encoding symbols per block. The first k values (0 to k - 1) identify source symbols, the remaining n-k values identify repair symbols.",
      "zh-CHS": "o 编码符号ID（大小为m位的字段）标识从源块生成的哪些特定编码符号被携带在分组有效载荷中。每个块最多有2^^m个编码符号。前k个值（0到k-1）标识源符号，其余n-k个值标识修复符号。"
    },
    {
      "indent": 3,
      "text": "There MUST be exactly one FEC Payload ID per source or repair packet. In case of an Encoding Symbol Group, when multiple encoding symbols are sent in the same packet, the FEC Payload ID refers to the first symbol of the packet. The other symbols can be deduced from the ESI of the first symbol by incrementing sequentially the ESI.",
      "zh-CHS": "每个源或修复数据包必须只有一个FEC有效负载ID。在编码符号组的情况下，当在同一分组中发送多个编码符号时，FEC有效载荷ID指该分组的第一符号。通过顺序递增ESI，可以从第一个符号的ESI推导出其他符号。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Source Block Number (32-8=24 bits)        | Enc. Symb. ID |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "Figure 1: FEC Payload ID Encoding Format for m = 8 (Default)",
      "zh-CHS": "图1:m=8的FEC有效负载ID编码格式（默认）"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Src Block Nb (32-16=16 bits)  |  Enc. Symbol ID (m=16 bits)   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 12,
      "text": "Figure 2: FEC Payload ID Encoding Format for m = 16",
      "zh-CHS": "图2:m=16的FEC有效负载ID编码格式"
    },
    {
      "indent": 3,
      "text": "The formats of the FEC Payload ID for m = 8 and m = 16 are illustrated in Figure 1 and Figure 2, respectively.",
      "zh-CHS": "图1和图2中分别说明了m=8和m=16的FEC有效负载ID的格式。"
    },
    {
      "indent": 0,
      "text": "4.2. FEC Object Transmission Information",
      "section_title": true,
      "zh-CHS": "4.2. 对象传输信息"
    },
    {
      "indent": 0,
      "text": "4.2.1. Mandatory Elements",
      "section_title": true,
      "zh-CHS": "4.2.1. 强制性要素"
    },
    {
      "indent": 3,
      "text": "o FEC Encoding ID: the Fully-Specified FEC Scheme described in this section uses FEC Encoding ID 2.",
      "zh-CHS": "o FEC编码ID：本节中描述的完全指定的FEC方案使用FEC编码ID 2。"
    },
    {
      "indent": 0,
      "text": "4.2.2. Common Elements",
      "section_title": true,
      "zh-CHS": "4.2.2. 共同要素"
    },
    {
      "indent": 3,
      "text": "The following elements MUST be defined with the present FEC scheme.",
      "zh-CHS": "必须使用当前FEC方案定义以下要素。"
    },
    {
      "indent": 3,
      "text": "o Transfer-Length (L): a non-negative integer indicating the length of the object in bytes. There are some restrictions on the maximum Transfer-Length that can be supported:",
      "zh-CHS": "o 传输长度（L）：一个非负整数，表示对象的长度（字节）。可以支持的最大传输长度有一些限制："
    },
    {
      "indent": 9,
      "text": "max_transfer_length = 2^^(32-m) * B * E",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "For instance, for m = 8, for B = 2^^8 - 1 (because the codec operates on a finite field with 2^^8 elements), and if E = 1024 bytes, then the maximum transfer length is approximately equal to 2^^42 bytes (i.e., 4 terabytes). Similarly, for m = 16, for B = 2^^16 - 1, and if E = 1024 bytes, then the maximum transfer length is also approximately equal to 2^^42 bytes. For larger objects, another FEC scheme, with a larger Source Block Number field in the FEC Payload ID, could be defined. Another solution consists in fragmenting large objects into smaller objects, each of them complying with the above limits.",
      "zh-CHS": "例如，对于m=8，对于B=2^^8-1（因为编解码器在具有2^^8个元素的有限字段上运行），并且如果E=1024字节，则最大传输长度大约等于2^^42字节（即4 TB）。类似地，对于m=16，对于B=2^^16-1，如果E=1024字节，则最大传输长度也大约等于2^^42字节。对于较大的对象，可以定义另一个FEC方案，该方案在FEC有效负载ID中具有较大的源块编号字段。另一个解决方案是将大对象分割成更小的对象，每个对象都符合上述限制。"
    },
    {
      "indent": 3,
      "text": "o Encoding-Symbol-Length (E): a non-negative integer indicating the length of each encoding symbol in bytes.",
      "zh-CHS": "o 编码符号长度（E）：一个非负整数，表示每个编码符号的长度（以字节为单位）。"
    },
    {
      "indent": 3,
      "text": "o Maximum-Source-Block-Length (B): a non-negative integer indicating the maximum number of source symbols in a source block.",
      "zh-CHS": "o 最大源块长度（B）：一个非负整数，表示源块中源符号的最大数量。"
    },
    {
      "indent": 3,
      "text": "o Max-Number-of-Encoding-Symbols (max_n): a non-negative integer indicating the maximum number of encoding symbols generated for any source block.",
      "zh-CHS": "o 最大编码符号数（Max_n）：一个非负整数，表示为任何源块生成的最大编码符号数。"
    },
    {
      "indent": 3,
      "text": "Section 6 explains how to derive the values of each of these elements.",
      "zh-CHS": "第6节解释了如何推导这些元素的值。"
    },
    {
      "indent": 0,
      "text": "4.2.3. Scheme-Specific Elements",
      "section_title": true,
      "zh-CHS": "4.2.3. 方案特定要素"
    },
    {
      "indent": 3,
      "text": "The following element MUST be defined with the present FEC scheme. It contains two distinct pieces of information:",
      "zh-CHS": "必须使用当前FEC方案定义以下元素。它包含两条不同的信息："
    },
    {
      "indent": 3,
      "text": "o G: a non-negative integer indicating the number of encoding symbols per group used for the object. The default value is 1, meaning that each packet contains exactly one symbol. When no G parameter is communicated to the decoder, then the latter MUST assume that G = 1.",
      "zh-CHS": "o G：一个非负整数，表示用于对象的每组编码符号的数量。默认值为1，这意味着每个数据包只包含一个符号。当没有G参数传送到解码器时，解码器必须假定G=1。"
    },
    {
      "indent": 3,
      "text": "o m: The m parameter is the length of the finite field elements, in bits. It also characterizes the number of elements in the finite field: q = 2^^m elements. The default value is m = 8. When no finite field size parameter is communicated to the decoder, then the latter MUST assume that m = 8.",
      "zh-CHS": "o m:m参数是有限域元素的长度，单位为位。它还描述了有限域中元素的数量：q=2^^m个元素。默认值为m=8。当没有有限字段大小参数传送到解码器时，解码器必须假定m＝8。"
    },
    {
      "indent": 0,
      "text": "4.2.4. Encoding Format",
      "section_title": true,
      "zh-CHS": "4.2.4. 编码格式"
    },
    {
      "indent": 3,
      "text": "This section shows the two possible encoding formats of the above FEC OTI. The present document does not specify when one encoding format or the other should be used.",
      "zh-CHS": "本节显示上述FEC OTI的两种可能的编码格式。本文件未规定何时应使用一种编码格式或另一种编码格式。"
    },
    {
      "indent": 0,
      "text": "4.2.4.1. Using the General EXT_FTI Format",
      "section_title": true,
      "zh-CHS": "4.2.4.1. 使用通用EXT_FTI格式"
    },
    {
      "indent": 3,
      "text": "The FEC OTI binary format is the following, when the EXT_FTI mechanism is used (e.g., within the ALC [ALC] or NORM [NORM] protocols).",
      "zh-CHS": "当使用EXT_FTI机制时（例如，在ALC[ALC]或NORM[NORM]协议内），FEC OTI二进制格式如下所示。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   HET = 64    |    HEL = 4    |                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +\n|                      Transfer Length (L)                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       m       |       G       |   Encoding Symbol Length (E)  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Max Source Block Length (B)  |  Max Nb Enc. Symbols (max_n)  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 22,
      "text": "Figure 3: EXT_FTI Header Format",
      "zh-CHS": "图3:EXT_FTI标题格式"
    },
    {
      "indent": 0,
      "text": "4.2.4.2. Using the FDT Instance (FLUTE specific)",
      "section_title": true,
      "zh-CHS": "4.2.4.2. 使用FDT实例（特定于长笛）"
    },
    {
      "indent": 3,
      "text": "When it is desired that the FEC OTI be carried in the FDT (File Delivery Table) Instance of a FLUTE session [FLUTE], the following XML attributes must be described for the associated object:",
      "zh-CHS": "当需要在FLUTE会话[FLUTE]的FDT（文件传递表）实例中携带FEC OTI时，必须为关联对象描述以下XML属性："
    },
    {
      "indent": 3,
      "text": "o FEC-OTI-FEC-Encoding-ID",
      "zh-CHS": "o FEC OTI FEC编码ID"
    },
    {
      "indent": 3,
      "text": "o FEC-OTI-Transfer-Length (L)",
      "zh-CHS": "o FEC OTI传输长度（L）"
    },
    {
      "indent": 3,
      "text": "o FEC-OTI-Encoding-Symbol-Length (E)",
      "zh-CHS": "o FEC OTI编码符号长度（E）"
    },
    {
      "indent": 3,
      "text": "o FEC-OTI-Maximum-Source-Block-Length (B)",
      "zh-CHS": "o FEC OTI最大源块长度（B）"
    },
    {
      "indent": 3,
      "text": "o FEC-OTI-Max-Number-of-Encoding-Symbols (max_n)",
      "zh-CHS": "o FEC OTI编码符号的最大数量（最大）"
    },
    {
      "indent": 3,
      "text": "o FEC-OTI-Scheme-Specific-Info",
      "zh-CHS": "o FEC OTI方案特定信息"
    },
    {
      "indent": 3,
      "text": "The FEC-OTI-Scheme-Specific-Info contains the string resulting from the Base64 encoding (in the XML Schema xs:base64Binary sense) of the following value:",
      "zh-CHS": "FEC OTI方案特定信息包含以下值的Base64编码（在XML模式xs:Base64二进制意义下）产生的字符串："
    },
    {
      "indent": 3,
      "text": " 0                   1\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       m       |       G       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "Figure 4: FEC OTI Scheme Specific Information To Be Included in the FDT Instance",
      "zh-CHS": "图4:FDT实例中包含的FEC OTI方案特定信息"
    },
    {
      "indent": 3,
      "text": "When no m parameter is to be carried in the FEC OTI, the m field is set to 0 (which is not a valid seed value). Otherwise, the m field contains a valid value as explained in Section 4.2.3. Similarly,",
      "zh-CHS": "当FEC OTI中不携带m参数时，m字段设置为0（这不是有效的种子值）。否则，m字段包含有效值，如第4.2.3节所述。同样地，"
    },
    {
      "indent": 3,
      "text": "when no G parameter is to be carried in the FEC OTI, the G field is set to 0 (which is not a valid seed value). Otherwise, the G field contains a valid value as explained in Section 4.2.3. When neither m nor G are to be carried in the FEC OTI, then the sender simply omits the FEC-OTI-Scheme-Specific-Info attribute.",
      "zh-CHS": "当FEC OTI中不携带G参数时，G字段设置为0（这不是有效的种子值）。否则，如第4.2.3节所述，G字段包含有效值。当在FEC-OTI中既不携带m也不携带G时，发送方只需省略FEC-OTI方案特定信息属性。"
    },
    {
      "indent": 3,
      "text": "During Base64 encoding, the 2 bytes of the FEC OTI Scheme-Specific Information are transformed into a string of 4 printable characters (in the 64-character alphabet) that is added to the FEC-OTI-Scheme-Specific-Info attribute.",
      "zh-CHS": "在Base64编码期间，FEC OTI方案特定信息的2个字节被转换为一个由4个可打印字符组成的字符串（以64个字符的字母表示），该字符串被添加到FEC OTI方案特定信息属性中。"
    },
    {
      "indent": 0,
      "text": "5. Formats and Codes with FEC Encoding ID 5",
      "section_title": true,
      "zh-CHS": "5. FEC编码ID为5的格式和代码"
    },
    {
      "indent": 3,
      "text": "This section introduces the formats and codes associated with the Fully-Specified FEC Scheme with FEC Encoding ID 5, which focuses on the special case of Reed-Solomon codes over GF(2^^8) and no encoding symbol group.",
      "zh-CHS": "本节介绍与FEC编码ID为5的完全指定FEC方案相关的格式和代码，重点介绍GF（2^^8）上的Reed-Solomon码和无编码符号组的特例。"
    },
    {
      "indent": 0,
      "text": "5.1. FEC Payload ID",
      "section_title": true,
      "zh-CHS": "5.1. 有效载荷ID"
    },
    {
      "indent": 3,
      "text": "The FEC Payload ID is composed of the Source Block Number and the Encoding Symbol ID:",
      "zh-CHS": "FEC有效负载ID由源块号和编码符号ID组成："
    },
    {
      "indent": 3,
      "text": "o The Source Block Number (24-bit field) identifies from which source block of the object the encoding symbol in the payload is generated. There is a maximum of 2^^24 blocks per object.",
      "zh-CHS": "o 源块编号（24位字段）标识从对象的哪个源块生成有效负载中的编码符号。每个对象最多有2^^24个块。"
    },
    {
      "indent": 3,
      "text": "o The Encoding Symbol ID (8-bit field) identifies which specific encoding symbol generated from the source block is carried in the packet payload. There is a maximum of 2^^8 encoding symbols per block. The first k values (0 to k - 1) identify source symbols; the remaining n-k values identify repair symbols.",
      "zh-CHS": "o 编码符号ID（8位字段）标识在分组有效载荷中携带从源块生成的特定编码符号。每个块最多有2^^8个编码符号。第一k值（0到k-1）标识源符号；其余的n-k值标识维修符号。"
    },
    {
      "indent": 3,
      "text": "There MUST be exactly one FEC Payload ID per source or repair packet. This FEC Payload ID refers to the one and only symbol of the packet.",
      "zh-CHS": "每个源或修复数据包必须只有一个FEC有效负载ID。此FEC有效负载ID指的是数据包的唯一符号。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Source Block Number (24 bits)          | Enc. Symb. ID |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "Figure 5: FEC Payload ID Encoding Format with FEC Encoding ID 5",
      "zh-CHS": "图5:FEC编码ID为5的FEC有效负载ID编码格式"
    },
    {
      "indent": 0,
      "text": "5.2. FEC Object Transmission Information",
      "section_title": true,
      "zh-CHS": "5.2. 对象传输信息"
    },
    {
      "indent": 0,
      "text": "5.2.1. Mandatory Elements",
      "section_title": true,
      "zh-CHS": "5.2.1. 强制性要素"
    },
    {
      "indent": 3,
      "text": "o FEC Encoding ID: the Fully-Specified FEC Scheme described in this section uses FEC Encoding ID 5.",
      "zh-CHS": "o FEC编码ID：本节中描述的完全指定的FEC方案使用FEC编码ID 5。"
    },
    {
      "indent": 0,
      "text": "5.2.2. Common Elements",
      "section_title": true,
      "zh-CHS": "5.2.2. 共同要素"
    },
    {
      "indent": 3,
      "text": "The Common elements are the same as those specified in Section 4.2.2 when m = 8 and G = 1.",
      "zh-CHS": "当m=8和G=1时，公共元件与第4.2.2节中规定的相同。"
    },
    {
      "indent": 0,
      "text": "5.2.3. Scheme-Specific Elements",
      "section_title": true,
      "zh-CHS": "5.2.3. 方案特定要素"
    },
    {
      "indent": 3,
      "text": "No Scheme-Specific elements are defined by this FEC scheme.",
      "zh-CHS": "此FEC方案未定义任何特定于方案的元素。"
    },
    {
      "indent": 0,
      "text": "5.2.4. Encoding Format",
      "section_title": true,
      "zh-CHS": "5.2.4. 编码格式"
    },
    {
      "indent": 3,
      "text": "This section shows the two possible encoding formats of the above FEC OTI. The present document does not specify when one encoding format or the other should be used.",
      "zh-CHS": "本节显示上述FEC OTI的两种可能的编码格式。本文件未规定何时应使用一种编码格式或另一种编码格式。"
    },
    {
      "indent": 0,
      "text": "5.2.4.1. Using the General EXT_FTI Format",
      "section_title": true,
      "zh-CHS": "5.2.4.1. 使用通用EXT_FTI格式"
    },
    {
      "indent": 3,
      "text": "The FEC OTI binary format is the following, when the EXT_FTI mechanism is used (e.g., within the ALC [ALC] or NORM [NORM] protocols).",
      "zh-CHS": "当使用EXT_FTI机制时（例如，在ALC[ALC]或NORM[NORM]协议内），FEC OTI二进制格式如下所示。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   HET = 64    |    HEL = 3    |                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +\n|                      Transfer Length (L)                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Encoding Symbol Length (E)  | MaxBlkLen (B) |     max_n     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "Figure 6: EXT_FTI Header Format with FEC Encoding ID 5",
      "zh-CHS": "图6:FEC编码ID为5的EXT_FTI报头格式"
    },
    {
      "indent": 0,
      "text": "5.2.4.2. Using the FDT Instance (FLUTE specific)",
      "section_title": true,
      "zh-CHS": "5.2.4.2. 使用FDT实例（特定于长笛）"
    },
    {
      "indent": 3,
      "text": "When it is desired that the FEC OTI be carried in the FDT Instance of a FLUTE session [FLUTE], the following XML attributes must be described for the associated object:",
      "zh-CHS": "当需要在FLUTE会话[FLUTE]的FDT实例中携带FEC OTI时，必须为相关对象描述以下XML属性："
    },
    {
      "indent": 3,
      "text": "o FEC-OTI-FEC-Encoding-ID",
      "zh-CHS": "o FEC OTI FEC编码ID"
    },
    {
      "indent": 3,
      "text": "o FEC-OTI-Transfer-Length (L)",
      "zh-CHS": "o FEC OTI传输长度（L）"
    },
    {
      "indent": 3,
      "text": "o FEC-OTI-Encoding-Symbol-Length (E)",
      "zh-CHS": "o FEC OTI编码符号长度（E）"
    },
    {
      "indent": 3,
      "text": "o FEC-OTI-Maximum-Source-Block-Length (B)",
      "zh-CHS": "o FEC OTI最大源块长度（B）"
    },
    {
      "indent": 3,
      "text": "o FEC-OTI-Max-Number-of-Encoding-Symbols (max_n)",
      "zh-CHS": "o FEC OTI编码符号的最大数量（最大）"
    },
    {
      "indent": 0,
      "text": "6. Procedures with FEC Encoding IDs 2 and 5",
      "section_title": true,
      "zh-CHS": "6. FEC编码ID为2和5的过程"
    },
    {
      "indent": 3,
      "text": "This section defines procedures that are common to FEC Encoding IDs 2 and 5. In case of FEC Encoding ID 5, m = 8 and G = 1. The block partitioning algorithm that is defined in Section 9.1 of [RFC5052] MUST be used with FEC Encoding IDs 2 and 5.",
      "zh-CHS": "本节定义了FEC编码ID 2和5通用的过程。在FEC编码ID为5的情况下，m＝8且G＝1。[RFC5052]第9.1节中定义的块划分算法必须与FEC编码ID 2和5一起使用。"
    },
    {
      "indent": 0,
      "text": "6.1. Determining the Maximum Source Block Length (B)",
      "section_title": true,
      "zh-CHS": "6.1. 确定最大源块长度（B）"
    },
    {
      "indent": 3,
      "text": "The finite field size parameter, m, defines the number of non-zero elements in this field, which is equal to: q - 1 = 2^^m - 1. Note that q - 1 is also the theoretical maximum number of encoding symbols that can be produced for a source block. For instance, when m = 8 (default) there is a maximum of 2^^8 - 1 = 255 encoding symbols.",
      "zh-CHS": "有限字段大小参数m定义此字段中非零元素的数量，等于：q-1=2^^m-1。请注意，q-1也是源块可以产生的理论最大编码符号数。例如，当m=8（默认值）时，最多有2^^8-1=255个编码符号。"
    },
    {
      "indent": 3,
      "text": "Given the target FEC code rate (e.g., provided by the user when starting a FLUTE sending application), the sender calculates:",
      "zh-CHS": "给定目标FEC代码速率（例如，用户在启动长笛发送应用程序时提供），发送方计算："
    },
    {
      "indent": 6,
      "text": "max1_B = floor((2^^m - 1) * CR)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "This max1_B value leaves enough room for the sender to produce the desired number of parity symbols.",
      "zh-CHS": "这个max1_B值为发送方提供了足够的空间来生成所需数量的奇偶校验符号。"
    },
    {
      "indent": 3,
      "text": "Additionally, a codec MAY impose other limitations on the maximum block size. Yet it is not expected that such limits exist when using the default m = 8 value. This decision MUST be clarified at implementation time, when the target use case is known. This results in a max2_B limitation.",
      "zh-CHS": "此外，编解码器可以对最大块大小施加其他限制。然而，在使用默认m=8值时，预计不会存在此类限制。当目标用例已知时，必须在实现时澄清该决策。这会导致max2_B限制。"
    },
    {
      "indent": 3,
      "text": "Then, B is given by:",
      "zh-CHS": "然后，B由下式给出："
    },
    {
      "indent": 6,
      "text": "B = min(max1_B, max2_B)",
      "zh-CHS": "B=最小值（最大值为1，最大值为2）"
    },
    {
      "indent": 3,
      "text": "Note that this calculation is only required at the coder, since the B parameter is communicated to the decoder through the FEC OTI.",
      "zh-CHS": "注意，由于B参数通过FEC OTI传送到解码器，因此仅在编码器处需要该计算。"
    },
    {
      "indent": 0,
      "text": "6.2. Determining the Number of Encoding Symbols of a Block",
      "section_title": true,
      "zh-CHS": "6.2. 确定块的编码符号数"
    },
    {
      "indent": 3,
      "text": "The following algorithm, also called \"n-algorithm\", explains how to determine the maximum number of encoding symbols generated for any source block (max_n) and the number of encoding symbols for a given block (n) as a function of the target code rate.",
      "zh-CHS": "以下算法（也称为“n-算法”）解释了如何确定为任何源块生成的编码符号的最大数量（max_n）以及作为目标码率函数的给定块的编码符号数量（n）。"
    },
    {
      "indent": 3,
      "text": "AT A SENDER:",
      "zh-CHS": "在发件人处："
    },
    {
      "indent": 3,
      "text": "Input:",
      "zh-CHS": "输入："
    },
    {
      "indent": 6,
      "text": "B: Maximum source block length, for any source block. Section 6.1 explains how to determine its value.",
      "zh-CHS": "B：任何源块的最大源块长度。第6.1节解释了如何确定其值。"
    },
    {
      "indent": 6,
      "text": "k: Current source block length. This parameter is given by the block partitioning algorithm.",
      "zh-CHS": "k：当前源块长度。该参数由块划分算法给出。"
    },
    {
      "indent": 6,
      "text": "CR: FEC code rate, which is given by the user (e.g., when starting a FLUTE sending application). It is expressed as a floating point value.",
      "zh-CHS": "CR:FEC码速率，由用户给出（例如，启动长笛发送应用程序时）。它表示为浮点值。"
    },
    {
      "indent": 3,
      "text": "Output:",
      "zh-CHS": "输出："
    },
    {
      "indent": 6,
      "text": "max_n: Maximum number of encoding symbols generated for any source block.",
      "zh-CHS": "max_n：为任何源块生成的编码符号的最大数量。"
    },
    {
      "indent": 6,
      "text": "n: Number of encoding symbols generated for this source block.",
      "zh-CHS": "n：为此源块生成的编码符号数。"
    },
    {
      "indent": 3,
      "text": "Algorithm:",
      "zh-CHS": "算法："
    },
    {
      "indent": 6,
      "text": "max_n = ceil(B / CR);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "if (max_n > 2^^m - 1), then return an error (\"invalid code rate\");",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "n = floor(k * max_n / B);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "AT A RECEIVER:",
      "zh-CHS": "在接收器处："
    },
    {
      "indent": 3,
      "text": "Input:",
      "zh-CHS": "输入："
    },
    {
      "indent": 6,
      "text": "B: Extracted from the received FEC OTI.",
      "zh-CHS": "B：从接收到的FEC OTI中提取。"
    },
    {
      "indent": 6,
      "text": "max_n: Extracted from the received FEC OTI.",
      "zh-CHS": "最大值：从接收到的FEC OTI中提取。"
    },
    {
      "indent": 6,
      "text": "k: Given by the block partitioning algorithm.",
      "zh-CHS": "k：由块划分算法给出。"
    },
    {
      "indent": 3,
      "text": "Output:",
      "zh-CHS": "输出："
    },
    {
      "indent": 6,
      "text": "n",
      "zh-CHS": "N"
    },
    {
      "indent": 3,
      "text": "Algorithm:",
      "zh-CHS": "算法："
    },
    {
      "indent": 6,
      "text": "n = floor(k * max_n / B);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that the \"n-algorithm\" be used by a sender, but other algorithms remain possible to determine max_n and/or n.",
      "zh-CHS": "建议发送方使用“n-算法”，但仍可以使用其他算法来确定max_n和/或n。"
    },
    {
      "indent": 3,
      "text": "At a receiver, the max_n value is extracted from the received FEC OTI. Since the Reed-Solomon decoder does not need to know the actual n value, using the receiver part of the \"n-algorithm\" is not necessary from a decoding point of view.",
      "zh-CHS": "在接收机处，从接收到的FEC OTI中提取最大值。由于Reed-Solomon解码器不需要知道实际的n值，因此从解码的角度来看，不需要使用“n算法”的接收器部分。"
    },
    {
      "indent": 3,
      "text": "However, a receiver may want to have an estimate of n for other reasons (e.g., for memory management purposes). In that case, a receiver knows that the number of encoding symbols of a block cannot exceed max_n. Additionally, if a receiver believes that a sender uses the \"n-algorithm\", this receiver MAY use the receiver part of the \"n-algorithm\" to get a better estimate of n. When this is the case, a receiver MUST be prepared to handle symbols with an Encoding Symbol ID superior or equal to the computed n value (e.g., it can choose to simply drop them).",
      "zh-CHS": "然而，出于其他原因（例如，出于内存管理目的），接收机可能希望具有n的估计。在这种情况下，接收机知道块的编码符号的数量不能超过max\\n。此外，如果接收机认为发送方使用“n-算法”，则该接收机可以使用“n-算法”的接收机部分来获得对n的更好估计。在这种情况下，接收器必须准备好处理编码符号ID大于或等于计算出的n值的符号（例如，它可以选择简单地丢弃它们）。"
    },
    {
      "indent": 0,
      "text": "7. Small Block Systematic FEC Scheme (FEC Encoding ID 129) and Reed-Solomon Codes over GF(2^^8)",
      "zh-CHS": "7. GF（2^^8）上的小分组系统FEC方案（FEC编码ID 129）和Reed-Solomon码"
    },
    {
      "indent": 3,
      "text": "In the context of the Under-Specified Small Block Systematic FEC Scheme (FEC Encoding ID 129) [RFC5445], this document assigns the FEC Instance ID 0 to the special case of Reed-Solomon codes over GF(2^^8) and no encoding symbol group.",
      "zh-CHS": "在未指定的小数据块系统FEC方案（FEC编码ID 129）[RFC5445]的上下文中，本文档将FEC实例ID 0分配给GF（2^^8）上的Reed-Solomon码和无编码符号组的特例。"
    },
    {
      "indent": 3,
      "text": "The FEC Instance ID 0 uses the Formats and Codes specified in [RFC5445].",
      "zh-CHS": "FEC实例ID 0使用[RFC5445]中指定的格式和代码。"
    },
    {
      "indent": 3,
      "text": "The FEC scheme with FEC Instance ID 0 MAY use the block partitioning algorithm defined in Section 9.1 of [RFC5052] to partition the object into source blocks. This FEC scheme MAY also use another algorithm. For instance, the CDP sender may change the length of each source block dynamically, depending on some external criteria (e.g., to adjust the FEC coding rate to the current loss rate experienced by NORM receivers) and inform the CDP receivers of the current block length by means of the EXT_FTI mechanism. This choice is out of the scope of the current document.",
      "zh-CHS": "FEC实例ID为0的FEC方案可使用[RFC5052]第9.1节中定义的块划分算法将对象划分为源块。该FEC方案还可以使用另一种算法。例如，CDP发送方可以根据一些外部标准（例如，将FEC编码速率调整为NORM接收机所经历的当前丢失率）动态地改变每个源块的长度，并通过EXT_FTI机制将当前块长度通知CDP接收机。此选项超出当前文档的范围。"
    },
    {
      "indent": 0,
      "text": "8. Reed-Solomon Codes Specification for the Erasure Channel",
      "section_title": true,
      "zh-CHS": "8. 擦除信道用里德-所罗门码规范"
    },
    {
      "indent": 3,
      "text": "Reed-Solomon (RS) codes are linear block codes. They also belong to the class of MDS codes. A [n,k]-RS code encodes a sequence of k source elements defined over a finite field GF(q) into a sequence of n encoding elements, where n is upper bounded by q - 1. The implementation described in this document is based on a generator matrix built from a Vandermonde matrix put into systematic form.",
      "zh-CHS": "Reed-Solomon（RS）码是线性分组码。它们也属于MDS代码类。[n，k]-RS码将有限域GF（q）上定义的k个源元素序列编码为n个编码元素序列，其中n的上界为q-1。本文档中描述的实现基于从系统形式的Vandermonde矩阵构建的生成器矩阵。"
    },
    {
      "indent": 3,
      "text": "Sections 8.1 to 8.3 specify the [n,k]-RS codes when applied to m-bit elements, and Section 8.4 specifies the use of [n,k]-RS codes when applied to symbols composed of several m-bit elements. The use described in Section 8.4 is the crux of this specification.",
      "zh-CHS": "第8.1节至第8.3节规定了应用于m位元素时的[n，k]-RS码，第8.4节规定了应用于由多个m位元素组成的符号时的[n，k]-RS码的使用。第8.4节中描述的用途是本规范的关键。"
    },
    {
      "indent": 3,
      "text": "A reader who wants to understand the underlying theory is invited to refer to references [Rizzo97] and [MWS77].",
      "zh-CHS": "希望了解基本理论的读者请参考参考文献[Rizzo97]和[MWS77]。"
    },
    {
      "indent": 0,
      "text": "8.1. Finite Field",
      "section_title": true,
      "zh-CHS": "8.1. 有限域"
    },
    {
      "indent": 3,
      "text": "A finite field GF(q) is defined as a finite set of q elements that has a structure of field. It contains necessarily q = p^^m elements, where p is a prime number. With packet erasure channels, p is always set to 2. The elements of the field GF(2^^m) can be represented by polynomials with binary coefficients (i.e., over GF(2)) of degree lower or equal to m-1. The polynomials can be associated with binary vectors of length m. For example, the vector (11001) represents the polynomial 1 + x + x^^4. This representation is often called polynomial representation. The addition between two elements is defined as the addition of binary polynomials in GF(2) and the multiplication is the multiplication modulo a given irreducible polynomial over GF(2) of degree m. Note that all the roots of this polynomial are in GF(2^^m) but not in GF(2).",
      "zh-CHS": "有限域GF（q）定义为具有场结构的有限q元素集。它必然包含q=p^^m个元素，其中p是素数。对于数据包擦除通道，p始终设置为2。域GF（2^^m）的元素可以由二元系数（即，在GF（2）上）小于或等于m-1的多项式表示。多项式可以与长度为m的二元向量相关联。例如，向量（11001）表示多项式1+x+x^^4。这种表示法通常称为多项式表示法。两个元素之间的加法定义为GF（2）中二元多项式的加法，乘法是给定不可约多项式在GF（2）上m次的乘法模。请注意，此多项式的所有根都在GF（2^^m）中，但不在GF（2）中。"
    },
    {
      "indent": 3,
      "text": "The chosen polynomial representation of the finite field GF(2^^m) is completely characterized by the irreducible polynomial. The following polynomials are chosen to represent the field GF(2^^m), for m varying from 2 to 16:",
      "zh-CHS": "有限域GF（2^^m）的多项式表示完全由不可约多项式表示。选择以下多项式表示字段GF（2^^m），m从2到16变化："
    },
    {
      "indent": 6,
      "text": "m = 2, \"111\" (1+x+x^^2)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "m = 3, \"1101\", (1+x+x^^3)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "m = 4, \"11001\", (1+x+x^^4)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "m = 5, \"101001\", (1+x^^2+x^^5)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "m = 6, \"1100001\", (1+x+x^^6)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "m = 7, \"10010001\", (1+x^^3+x^^7)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "m = 8, \"101110001\", (1+x^^2+x^^3+x^^4+x^^8)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "m = 9, \"1000100001\", (1+x^^4+x^^9)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "m = 10, \"10010000001\", (1+x^^3+x^^10)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "m = 11, \"101000000001\", (1+x^^2+x^^11)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "m = 12, \"1100101000001\", (1+x+x^^4+x^^6+x^^12)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "m = 13, \"11011000000001\", (1+x+x^^3+x^^4+x^^13)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "m = 14, \"110000100010001\", (1+x+x^^6+x^^10+x^^14)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "m = 15, \"1100000000000001\", (1+x+x^^15)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "m = 16, \"11010000000010001\", (1+x+x^^3+x^^12+x^^16)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "In order to facilitate the implementation, these polynomials are also primitive. This means that any element of GF(2^^m) can be expressed as a power of a given root of this polynomial. These polynomials are also chosen so that they contain the minimum number of monomials.",
      "zh-CHS": "为了便于实现，这些多项式也是原始的。这意味着GF（2^^m）的任何元素都可以表示为该多项式给定根的幂。这些多项式也被选择，以便它们包含最小数量的单项式。"
    },
    {
      "indent": 0,
      "text": "8.2. Reed-Solomon Encoding Algorithm",
      "section_title": true,
      "zh-CHS": "8.2. 里德-所罗门编码算法"
    },
    {
      "indent": 0,
      "text": "8.2.1. Encoding Principles",
      "section_title": true,
      "zh-CHS": "8.2.1. 编码原则"
    },
    {
      "indent": 3,
      "text": "Let s = (s_0, ..., s_{k-1}) be a source vector of k elements over\nGF(2^^m).  Let e = (e_0, ..., e_{n-1}) be the corresponding encoding\nvector of n elements over GF(2^^m).  Being a linear code, encoding is\nperformed by multiplying the source vector by a generator matrix, GM,\nof k rows and n columns over GF(2^^m).  Thus:",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "e = s * GM.",
      "zh-CHS": "e=s*GM。"
    },
    {
      "indent": 3,
      "text": "The definition of the generator matrix completely characterizes the RS code.",
      "zh-CHS": "生成矩阵的定义完全刻画了RS码的特征。"
    },
    {
      "indent": 3,
      "text": "Let us consider that n = 2^^m - 1 and that 0 < k <= n.  Let us denote\nby alpha the root of the primitive polynomial of degree m chosen in\nthe list of Section 8.1 for the corresponding value of m.  Let us\nconsider a Vandermonde matrix of k rows and n columns, denoted by\nV_{k,n}, and built as follows: the {i, j} entry of V_{k,n} is v_{i,j}\n= alpha^^(i*j), where 0 <= i <= k - 1 and 0 <= j <= n - 1.  This\nmatrix generates a MDS code.  However, this MDS code is not\nsystematic, which is a problem for many networking applications.  To",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "obtain a systematic matrix (and code), the simplest solution consists in considering the matrix V_{k,k} formed by the first k columns of V_{k,n}, then to invert it and to multiply this inverse by V_{k,n}. Clearly, the product V_{k,k}^^-1 * V_{k,n} contains the identity matrix I_k on its first k columns, meaning that the first k encoding elements are equal to source elements. Besides, the associated code keeps the MDS property.",
      "zh-CHS": "获得一个系统矩阵（和代码），最简单的解决方案是考虑由V_{k，n}的前k列构成的矩阵V_{k，k}，然后将其求逆并将其乘以V_{k，n}。显然，乘积V_{k，k}^-1*V_{k，n}在其前k列上包含单位矩阵I_k，这意味着前k个编码元素等于源元素。此外，关联的代码保留MDS属性。"
    },
    {
      "indent": 3,
      "text": "Therefore, the generator matrix of the code considered in this document is:",
      "zh-CHS": "因此，本文件中考虑的代码生成器矩阵为："
    },
    {
      "indent": 6,
      "text": "GM = (V_{k,k}^^-1) * V_{k,n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Note that, in practice, the [n,k]-RS code can be shortened to a [n',k]-RS code, where k <= n' < n, by considering the sub-matrix formed by the n' first columns of GM.",
      "zh-CHS": "注意，在实践中，通过考虑由GM的n′第一列形成的子矩阵，可以将[n，k]-RS码缩短为[n'，k]-RS码，其中k<=n′<n。"
    },
    {
      "indent": 0,
      "text": "8.2.2. Encoding Complexity",
      "section_title": true,
      "zh-CHS": "8.2.2. 编码复杂性"
    },
    {
      "indent": 3,
      "text": "Encoding can be performed by first pre-computing GM and by multiplying the source vector (k elements) by GM (k rows and n columns). The complexity of the pre-computation of the generator matrix can be estimated as the complexity of the multiplication of the inverse of a Vandermonde matrix by n-k vectors (i.e., the last n-k columns of V_{k,n}). Since the complexity of the inverse of a k*k-Vandermonde matrix by a vector is O(k * (log(k))^^2), the generator matrix can be computed in 0((n-k)* k * (log(k))^^2)) operations. When the generator matrix is pre-computed, the encoding needs k operations per repair element (vector-matrix multiplication).",
      "zh-CHS": "编码可以通过首先预计算GM和将源向量（k个元素）乘以GM（k行和n列）来执行。生成矩阵预计算的复杂性可以估计为范德蒙矩阵的逆与n-k向量（即V_{k，n}的最后n-k列）相乘的复杂性。由于向量对k*k-Vandermonde矩阵求逆的复杂度为O（k*（log（k））^^2，因此可以通过0（（n-k）*k*（log（k））^^2）运算计算生成矩阵。当预计算生成器矩阵时，编码需要每个修复元素进行k次运算（向量矩阵乘法）。"
    },
    {
      "indent": 3,
      "text": "Encoding can also be performed by first computing the product s *\nV_{k,k}^^-1 and then by multiplying the result with V_{k,n}.  The\nmultiplication by the inverse of a square Vandermonde matrix is known\nas the interpolation problem and its complexity is O(k *\n(log(k))^^2).  The multiplication by a Vandermonde matrix, known as\nthe multipoint evaluation problem, requires O((n-k) * log(k)) by\nusing Fast Fourier Transform, as explained in [GO94].  The total\ncomplexity of this encoding algorithm is then O((k/(n-k)) *\n(log(k))^^2 + log(k)) operations per repair element.",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "8.3. Reed-Solomon Decoding Algorithm",
      "section_title": true,
      "zh-CHS": "8.3. 里德-所罗门译码算法"
    },
    {
      "indent": 0,
      "text": "8.3.1. Decoding Principles",
      "section_title": true,
      "zh-CHS": "8.3.1. 解码原理"
    },
    {
      "indent": 3,
      "text": "The Reed-Solomon decoding algorithm for the erasure channel allows the recovery of the k source elements from any set of k received elements. It is based on the fundamental property of the generator matrix, which is such that any k*k-submatrix is invertible (see",
      "zh-CHS": "擦除信道的Reed-Solomon解码算法允许从任意k个接收元素集合中恢复k个源元素。它基于生成矩阵的基本性质，即任何k*k-子矩阵都是可逆的（参见"
    },
    {
      "indent": 3,
      "text": "[MWS77]). The first step of the decoding consists in extracting the k*k submatrix of the generator matrix obtained by considering the columns corresponding to the received elements. Indeed, since any encoding element is obtained by multiplying the source vector by one column of the generator matrix, the received vector of k encoding elements can be considered as the result of the multiplication of the source vector by a k*k submatrix of the generator matrix. Since this submatrix is invertible, the second step of the algorithm is to invert this matrix and to multiply the received vector by the obtained matrix to recover the source vector.",
      "zh-CHS": "[MWS77]）。解码的第一步包括提取通过考虑与接收元素对应的列而获得的生成器矩阵的k×k子矩阵。实际上，由于通过将源向量乘以生成器矩阵的一列来获得任何编码元素，因此k个编码元素的接收向量可以被视为源向量乘以生成器矩阵的k×k子矩阵的结果。由于该子矩阵是可逆的，因此该算法的第二步是将该矩阵求逆，并将接收到的向量乘以获得的矩阵以恢复源向量。"
    },
    {
      "indent": 0,
      "text": "8.3.2. Decoding Complexity",
      "section_title": true,
      "zh-CHS": "8.3.2. 解码复杂度"
    },
    {
      "indent": 3,
      "text": "The decoding algorithm described previously includes the matrix inversion and the vector-matrix multiplication. With the classical Gauss-Jordan algorithm, the matrix inversion requires O(k^^3) operations and the vector-matrix multiplication is performed in O(k^^2) operations.",
      "zh-CHS": "前面描述的解码算法包括矩阵求逆和向量矩阵乘法。对于经典的Gauss-Jordan算法，矩阵求逆需要O（k^^3）运算，向量矩阵乘法在O（k^^2）运算中执行。"
    },
    {
      "indent": 3,
      "text": "This complexity can be improved by considering that the received submatrix of GM is the product between the inverse of a Vandermonde matrix (V_(k,k)^^-1) and another Vandermonde matrix (denoted by V', which is a submatrix of V_(k,n)). The decoding can be done by multiplying the received vector by V'^^-1 (interpolation problem with complexity O( k * (log(k))^^2) ) then by V_{k,k} (multipoint evaluation with complexity O(k * log(k))). The global decoding complexity is then O((log(k))^^2) operations per source element.",
      "zh-CHS": "通过考虑GM的接收子矩阵是Vandermonde矩阵（V_k，k）^^-1）的逆与另一个Vandermonde矩阵（由V'表示，V'是V_k（k，n）的子矩阵）之间的乘积，可以改善这种复杂性。解码可以通过将接收向量乘以V'^^-1（复杂度为O（k*（log（k））^^2））然后乘以V_{k，k}（复杂度为O（k*log（k））的多点评估）来完成。然后，全局解码复杂度是每个源元素的O（（log（k））^^2）个操作。"
    },
    {
      "indent": 0,
      "text": "8.4. Implementation for the Packet Erasure Channel",
      "section_title": true,
      "zh-CHS": "8.4. 分组擦除信道的实现"
    },
    {
      "indent": 3,
      "text": "In a packet erasure channel, each packet (including its symbol(s), since packets contain G >= 1 symbols) is either correctly received or erased. The location of the erased symbols in the sequence of symbols MUST be known. The following specification describes the use of Reed-Solomon codes for generating redundant symbols from the k source symbols and for recovering the source symbols from any set of k received symbols.",
      "zh-CHS": "在分组擦除信道中，每个分组（包括其符号，因为分组包含G>=1个符号）被正确接收或擦除。必须知道已擦除符号在符号序列中的位置。以下规范描述了使用里德-所罗门码从k个源符号生成冗余符号以及从k个接收符号的任何集合恢复源符号。"
    },
    {
      "indent": 3,
      "text": "The k source symbols of a source block are assumed to be composed of S m-bit elements. Each m-bit element corresponds to an element of the finite field GF(2^^m) through the polynomial representation (Section 8.1). If some of the source symbols contain less than S elements, they MUST be virtually padded with zero elements (this can be the case for the last symbol of the last block of the object). However, this padding does not need to be actually sent with the data to the receivers.",
      "zh-CHS": "假设源块的k个源符号由S个m位元素组成。通过多项式表示（第8.1节），每个m位元素对应于有限域GF（2^^m）的一个元素。如果某些源符号包含的元素少于S，则必须使用零元素对其进行虚拟填充（对象最后一个块的最后一个符号就是这种情况）。然而，这种填充实际上不需要与数据一起发送到接收器。"
    },
    {
      "indent": 3,
      "text": "The encoding process produces n encoding symbols of size S m-bit elements, of which k are source symbols (this is a systematic code) and n-k are repair symbols (Figure 7). The m-bit elements of the repair symbols are calculated using the corresponding m-bit elements of the source symbol set. A logical u-th source vector, comprised of the u-th elements from the set of source symbols, is used to calculate a u-th encoding vector. This u-th encoding vector then provides the u-th elements for the set encoding symbols calculated for the block. As a systematic code, the first k encoding symbols are the same as the k source symbols, and the last n-k repair symbols are the result of the Reed-Solomon encoding.",
      "zh-CHS": "编码过程产生大小为S m位元素的n个编码符号，其中k是源符号（这是一个系统代码），n-k是修复符号（图7）。使用源符号集的相应m位元素计算修复符号的m位元素。由源符号集合中的第u个元素组成的逻辑第u个源向量用于计算第u个编码向量。然后，该第u个编码向量为为块计算的集合编码符号提供第u个元素。作为系统代码，前k个编码符号与k个源符号相同，最后n-k个修复符号是Reed-Solomon编码的结果。"
    },
    {
      "indent": 10,
      "text": "Input: k source symbols",
      "zh-CHS": "输入：k个源符号"
    },
    {
      "indent": 3,
      "text": " 0             u                                S-1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             |X|                                 | source symbol 0\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             |X|                                 | source symbol 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n             . . .\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             |X|                                 | source symbol k-1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 18,
      "text": "*",
      "zh-CHS": "*"
    },
    {
      "indent": 8,
      "text": "+--------------------+\n|  generator matrix  |\n|         GM         |\n|       (k x n)      |\n+--------------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 18,
      "text": "| V",
      "zh-CHS": "|五"
    },
    {
      "indent": 8,
      "text": "Output: n encoding symbols (source + repair)",
      "zh-CHS": "输出：n个编码符号（源+修复）"
    },
    {
      "indent": 3,
      "text": " 0             u                                S-1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             |X|                                 | enc. symbol 0\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             |X|                                 | enc. symbol 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n             . . .\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             |Y|                                 | enc. symbol n-1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 21,
      "text": "Figure 7: Packet Encoding Scheme",
      "zh-CHS": "图7：包编码方案"
    },
    {
      "indent": 3,
      "text": "An asset of this scheme is that the loss of some encoding symbols produces the same erasure pattern for each of the S encoding vectors. It follows that the matrix inversion must be done only once and will be used by all the S encoding vectors. For large S, this matrix inversion cost becomes negligible in front of the S vector-matrix multiplications.",
      "zh-CHS": "该方案的一个优点是，一些编码符号的丢失为每个S编码向量产生相同的擦除模式。因此，矩阵求逆必须只进行一次，并且将由所有S编码向量使用。对于较大的S，在S向量矩阵乘法之前，该矩阵求逆成本变得可以忽略不计。"
    },
    {
      "indent": 3,
      "text": "Another asset is that the n-k repair symbols can be produced on demand. For instance, a sender can start by producing a limited number of repair symbols and later on, depending on the observed erasures on the channel, decide to produce additional repair symbols, up to the n-k upper limit. Indeed, to produce the repair symbol e_j, where k <= j < n, it is sufficient to multiply the S source vectors with column j of GM.",
      "zh-CHS": "另一个优点是可以根据需要生成n-k维修符号。例如，发送方可以从生成有限数量的修复符号开始，然后根据在信道上观察到的擦除情况，决定生成额外的修复符号，直到n-k上限。实际上，为了产生修复符号e_j，其中k<=j<n，将S源向量与GM的列j相乘就足够了。"
    },
    {
      "indent": 0,
      "text": "9. Security Considerations",
      "section_title": true,
      "zh-CHS": "9. 安全考虑"
    },
    {
      "indent": 0,
      "text": "9.1. Problem Statement",
      "section_title": true,
      "zh-CHS": "9.1. 问题陈述"
    },
    {
      "indent": 3,
      "text": "A content delivery system is potentially subject to many attacks: some of them target the network (e.g., to compromise the routing infrastructure, by compromising the congestion control component), others target the Content Delivery Protocol (CDP) (e.g., to compromise its normal behavior), and finally some attacks target the content itself. Since this document focuses on a FEC building block independently of any particular CDP (even if ALC and NORM are two natural candidates), this section only discusses the additional threats that an arbitrary CDP may be exposed to when using this building block.",
      "zh-CHS": "内容交付系统可能会受到多种攻击：其中一些攻击以网络为目标（例如，通过破坏拥塞控制组件来破坏路由基础设施），另一些攻击以内容交付协议（CDP）为目标（例如，破坏其正常行为），最后一些攻击以内容本身为目标。由于本文档关注的是独立于任何特定CDP的FEC构建块（即使ALC和NORM是两个自然候选），因此本节仅讨论任意CDP在使用该构建块时可能面临的其他威胁。"
    },
    {
      "indent": 3,
      "text": "More specifically, several kinds of attacks exist:",
      "zh-CHS": "更具体地说，存在几种类型的攻击："
    },
    {
      "indent": 3,
      "text": "o those that are meant to give access to confidential content (e.g., in case of non-free content),",
      "zh-CHS": "o 用于访问机密内容的内容（例如，在非免费内容的情况下），"
    },
    {
      "indent": 3,
      "text": "o those that try to corrupt the object being transmitted (e.g., to inject malicious code within an object or to prevent a receiver from using an object),",
      "zh-CHS": "o 试图破坏正在传输的对象（例如，在对象内注入恶意代码或阻止接收者使用对象）的人，"
    },
    {
      "indent": 3,
      "text": "o and those that try to compromise the receiver's behavior (e.g., by making the decoding of an object computationally expensive).",
      "zh-CHS": "o 以及那些试图损害接收者行为的人（例如，通过使解码对象的计算代价高昂）。"
    },
    {
      "indent": 3,
      "text": "These attacks can be launched either against the data flow itself (e.g., by sending forged symbols) or against the FEC parameters that are sent either in-band (e.g., in an EXT_FTI or FDT Instance) or out-of-band (e.g., in a session description).",
      "zh-CHS": "这些攻击可以针对数据流本身（例如，通过发送伪造符号）或针对带内（例如，在EXT_FTI或FDT实例中）或带外（例如，在会话描述中）发送的FEC参数发起。"
    },
    {
      "indent": 0,
      "text": "9.2. Attacks against the Data Flow",
      "section_title": true,
      "zh-CHS": "9.2. 对数据流的攻击"
    },
    {
      "indent": 3,
      "text": "First of all, let us consider the attacks against the data flow.",
      "zh-CHS": "首先，让我们考虑对数据流的攻击。"
    },
    {
      "indent": 0,
      "text": "9.2.1. Access to Confidential Objects",
      "section_title": true,
      "zh-CHS": "9.2.1. 接触机密物品"
    },
    {
      "indent": 3,
      "text": "Access control to the object being transmitted is typically provided by means of encryption. This encryption can be done over the whole object (e.g., by the content provider, before the FEC encoding process), or be done on a packet per-packet basis (e.g., when IPsec Encapsulating Security Payload (ESP) is used [RFC4303]). If access control is a concern, it is RECOMMENDED that one of these solutions be used. Even if we mention these attacks here, they are not related nor facilitated by the use of FEC.",
      "zh-CHS": "对被传输对象的访问控制通常通过加密的方式提供。该加密可以在整个对象上完成（例如，由内容提供商在FEC编码过程之前完成），或者在每个包的基础上完成（例如，当使用IPsec封装安全有效负载（ESP）时[RFC4303]）。如果访问控制是一个问题，建议使用其中一种解决方案。即使我们在这里提到这些攻击，它们也与FEC的使用无关，也不受其促进。"
    },
    {
      "indent": 0,
      "text": "9.2.2. Content Corruption",
      "section_title": true,
      "zh-CHS": "9.2.2. 内容损坏"
    },
    {
      "indent": 3,
      "text": "Protection against corruptions (e.g., after sending forged packets) is achieved by means of a content integrity verification/sender authentication scheme. This service can be provided at the object level, but in that case a receiver has no way to identify which symbol(s) are corrupted if the object is detected as corrupted. This service can also be provided at the packet level. In this case, after removing all forged packets, the object may be recovered sometimes. Several techniques can provide this source authentication/content integrity service:",
      "zh-CHS": "通过内容完整性验证/发送方身份验证方案实现对损坏的保护（例如，在发送伪造数据包之后）。可以在对象级别提供此服务，但在这种情况下，如果检测到对象已损坏，则接收器无法识别哪些符号已损坏。也可以在分组级别提供该服务。在这种情况下，删除所有伪造数据包后，有时可能会恢复对象。有几种技术可以提供此源身份验证/内容完整性服务："
    },
    {
      "indent": 3,
      "text": "o At the object level, the object MAY be digitally signed (with public key cryptography), for instance by using RSASSA-PKCS1-v1_5 [RFC3447]. This signature enables a receiver to check the object integrity, once the object has been fully decoded. Even if digital signatures are computationally expensive, this calculation occurs only once per object, which is usually acceptable.",
      "zh-CHS": "o 在对象级别，对象可以进行数字签名（使用公钥加密），例如使用RSASSA-PKCS1-v1_5[RFC3447]。一旦对象被完全解码，该签名使接收者能够检查对象的完整性。即使数字签名在计算上很昂贵，但每个对象只进行一次计算，这通常是可以接受的。"
    },
    {
      "indent": 3,
      "text": "o At the packet level, each packet can be digitally signed. A major limitation is the high computational and transmission overheads that this solution requires (unless Elliptic Curve Cryptography (ECC) is used). To avoid this problem, the signature may span a set of symbols (instead of a single one) in order to amortize the signature calculation. But if a single symbol is missing, the integrity of the whole set cannot be checked.",
      "zh-CHS": "o 在数据包级别，每个数据包都可以进行数字签名。一个主要的限制是该解决方案需要较高的计算和传输开销（除非使用椭圆曲线加密（ECC））。为了避免这个问题，签名可以跨越一组符号（而不是单个符号），以便分摊签名计算。但如果缺少一个符号，则无法检查整个集合的完整性。"
    },
    {
      "indent": 3,
      "text": "o At the packet level, a Group Message Authentication Code (MAC) [RFC2104] scheme can be used; for instance, by using HMAC-SHA-256 with a secret key shared by all the group members (i.e., the sender(s) and receivers). Thanks to the secret key, this technique creates a cryptographically secured digest of a packet that is sent along with the packet. The Group MAC scheme does not",
      "zh-CHS": "o 在分组级别，可以使用组消息认证码（MAC）[RFC2104]方案；例如，通过使用HMAC-SHA-256和所有组成员（即发送方和接收方）共享的密钥。多亏了密钥，这项技术创建了与数据包一起发送的数据包的加密安全摘要。组MAC方案不适用"
    },
    {
      "indent": 6,
      "text": "create prohibitive processing load nor transmission overhead, but it has a major limitation: it only provides a group authentication/integrity service since all group members share the same secret group key, which means that each member can send a forged packet. It is therefore restricted to situations where group members are fully trusted (or in association with another technique as a pre-check).",
      "zh-CHS": "创建禁止的处理负载或传输开销，但它有一个主要限制：它只提供组身份验证/完整性服务，因为所有组成员共享相同的组密钥，这意味着每个成员都可以发送伪造的数据包。因此，它仅限于组成员完全受信任（或与另一种技术关联作为预检查）的情况。"
    },
    {
      "indent": 3,
      "text": "o At the packet level, TESLA [RFC4082] is a very attractive and efficient solution that is robust to losses, provides a true authentication/integrity service, and does not create any prohibitive processing load or transmission overhead. Yet checking a packet requires a small delay (a second or more) after its reception.",
      "zh-CHS": "o 在数据包级别，特斯拉[RFC4082]是一个非常有吸引力和高效的解决方案，它对丢失具有鲁棒性，提供真正的身份验证/完整性服务，并且不会产生任何禁止性的处理负载或传输开销。然而，检查数据包需要在接收后有一个小的延迟（一秒或更长）。"
    },
    {
      "indent": 3,
      "text": "Techniques relying on public key cryptography (digital signatures and TESLA during the bootstrap process, when used) require that public keys be securely associated to the entities. This can be achieved by a Public Key Infrastructure (PKI), or by a PGP Web of Trust, or by pre-distributing the public keys of each group member.",
      "zh-CHS": "依靠公钥加密技术（使用引导过程中的数字签名和特斯拉）的技术要求公钥与实体安全关联。这可以通过公钥基础设施（PKI）、PGP信任网或预分发每个组成员的公钥来实现。"
    },
    {
      "indent": 3,
      "text": "Techniques relying on symmetric key cryptography (group MAC) require that a secret key be shared by all group members. This can be achieved by means of a group key management protocol, or simply by pre-distributing the secret key (but this manual solution has many limitations).",
      "zh-CHS": "依赖对称密钥加密（组MAC）的技术要求所有组成员共享密钥。这可以通过组密钥管理协议或简单地通过预分发密钥来实现（但此手动解决方案有许多限制）。"
    },
    {
      "indent": 3,
      "text": "It is up to the developer and deployer, who know the security requirements and features of the target application area, to define which solution is the most appropriate. Nonetheless, in case there is any concern of the threat of object corruption, it is RECOMMENDED that at least one of these techniques be used.",
      "zh-CHS": "由了解目标应用程序领域的安全需求和特性的开发人员和部署人员来定义哪种解决方案最合适。尽管如此，如果担心对象损坏的威胁，建议至少使用其中一种技术。"
    },
    {
      "indent": 0,
      "text": "9.3. Attacks against the FEC Parameters",
      "section_title": true,
      "zh-CHS": "9.3. 对FEC参数的攻击"
    },
    {
      "indent": 3,
      "text": "Let us now consider attacks against the FEC parameters (or FEC OTI). The FEC OTI can either be sent in-band (i.e., in an EXT_FTI or in an FDT Instance containing FEC OTI for the object) or out-of-band (e.g., in a session description). Attacks on these FEC parameters can prevent the decoding of the associated object: for instance, modifying the B parameter will lead to a different block partitioning at a receiver thereby compromising decoding; or setting the m parameter to 16 instead of 8 with FEC Encoding ID 2 will increase the processing load while compromising decoding.",
      "zh-CHS": "现在让我们考虑对FEC参数（或FEC OTI）的攻击。FEC-OTI可以在带内（即，在EXT_-FTI中或在包含对象的FEC-OTI的FDT实例中）或带外（例如，在会话描述中）发送。对这些FEC参数的攻击可阻止相关对象的解码：例如，修改B参数将导致接收器处的不同块划分，从而影响解码；或者使用FEC编码ID 2将m参数设置为16而不是8将增加处理负载，同时影响解码。"
    },
    {
      "indent": 3,
      "text": "It is therefore RECOMMENDED that security measures be taken to guarantee the FEC OTI integrity. To that purpose, the packets carrying the FEC parameters sent in-band in an EXT_FTI header",
      "zh-CHS": "因此，建议采取安全措施以保证FEC OTI的完整性。为此，携带FEC参数的分组在EXT_FTI报头中带内发送"
    },
    {
      "indent": 3,
      "text": "extension SHOULD be protected by one of the per-packet techniques described above: digital signature, group MAC, or TESLA. When FEC OTI is contained in an FDT Instance, this FDT Instance object SHOULD be protected, for instance, by digitally signing it with XML digital signatures [RFC3275]. Finally, when FEC OTI is sent out-of-band (e.g., in a session description), this FEC OTI SHOULD be protected, for instance, by digitally signing the object that includes this FEC OTI.",
      "zh-CHS": "扩展应该受到上述每包技术之一的保护：数字签名、组MAC或TESLA。当FEC OTI包含在FDT实例中时，应保护该FDT实例对象，例如，通过使用XML数字签名对其进行数字签名[RFC3275]。最后，当FEC-OTI在带外发送时（例如，在会话描述中），该FEC-OTI应该受到保护，例如，通过对包含该FEC-OTI的对象进行数字签名。"
    },
    {
      "indent": 3,
      "text": "The same considerations concerning the key management aspects apply here also.",
      "zh-CHS": "关于关键管理方面的同样考虑也适用于此。"
    },
    {
      "indent": 0,
      "text": "10. IANA Considerations",
      "section_title": true,
      "zh-CHS": "10. IANA考虑"
    },
    {
      "indent": 3,
      "text": "Values of FEC Encoding IDs and FEC Instance IDs are subject to IANA registration. For general guidelines on IANA considerations as they apply to this document, see [RFC5052].",
      "zh-CHS": "FEC编码ID和FEC实例ID的值受IANA注册的约束。有关适用于本文件的IANA注意事项的一般指南，请参见[RFC5052]。"
    },
    {
      "indent": 3,
      "text": "This document assigns the Fully-Specified FEC Encoding ID 2 under the \"ietf:rmt:fec:encoding\" name-space to \"Reed-Solomon Codes over GF(2^^m)\".",
      "zh-CHS": "本文档将“ietf:rmt:FEC:Encoding”名称空间下完全指定的FEC编码ID 2分配给“GF（2^^m）上的里德所罗门码”。"
    },
    {
      "indent": 3,
      "text": "This document assigns the Fully-Specified FEC Encoding ID 5 under the \"ietf:rmt:fec:encoding\" name-space to \"Reed-Solomon Codes over GF(2^^8)\".",
      "zh-CHS": "本文档将“ietf:rmt:FEC:Encoding”名称空间下完全指定的FEC编码ID 5分配给“GF（2^^8）上的里德所罗门码”。"
    },
    {
      "indent": 3,
      "text": "This document assigns the FEC Instance ID 0 scoped by the Under-Specified FEC Encoding ID 129 to \"Reed-Solomon Codes over GF(2^^8)\". More specifically, under the \"ietf:rmt:fec:encoding:instance\" sub-name-space that is scoped by the \"ietf:rmt:fec:encoding\" called \"Small Block Systematic FEC Codes\", this document assigns FEC Instance ID 0 to \"Reed-Solomon Codes over GF(2^^8)\".",
      "zh-CHS": "本文档将指定的FEC编码ID 129范围内的FEC实例ID 0分配给“GF上的Reed Solomon代码（2^^8）”。更具体地说，在“ietf:rmt:fec:encoding:instance”子名称空间（其范围为“ietf:rmt:fec:encoding”称为“小数据块系统fec代码”）下，本文档将fec实例ID 0分配给“GF（2^^8）上的里德所罗门代码”。"
    },
    {
      "indent": 0,
      "text": "11. Acknowledgments",
      "section_title": true,
      "zh-CHS": "11. 致谢"
    },
    {
      "indent": 3,
      "text": "The authors want to thank Brian Adamson, Igor Slepchin, Stephen Kent, Francis Dupont, Elwyn Davies, Magnus Westerlund, and Alfred Hoenes for their valuable comments. The authors also want to thank Luigi Rizzo for his comments and for the design of the reference Reed-Solomon codec.",
      "zh-CHS": "作者要感谢Brian Adamson、Igor Slepchin、Stephen Kent、Francis Dupont、Elwyn Davies、Magnus Westerlund和Alfred Hoenes的宝贵评论。作者还想感谢Luigi Rizzo的评论和参考Reed-Solomon编解码器的设计。"
    },
    {
      "indent": 0,
      "text": "12. References",
      "section_title": true,
      "zh-CHS": "12. 工具书类"
    },
    {
      "indent": 0,
      "text": "12.1. Normative References",
      "section_title": true,
      "zh-CHS": "12.1. 规范性引用文件"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "zh-CHS": "[RFC2119]Bradner，S.，“RFC中用于表示需求水平的关键词”，BCP 14，RFC 2119，1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC5052] Watson, M., Luby, M., and L. Vicisano, \"Forward Error Correction (FEC) Building Block\", RFC 5052, August 2007.",
      "zh-CHS": "[RFC5052]Watson，M.，Luby，M.，和L.Vicisano，“前向纠错（FEC）构建块”，RFC 5052，2007年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC5445] Watson, M., \"Basic Forward Error Correction (FEC) Schemes\", RFC 5445, March 2009.",
      "zh-CHS": "[RFC5445]Watson，M.，“基本前向纠错（FEC）方案”，RFC 54452009年3月。"
    },
    {
      "indent": 0,
      "text": "12.2. Informative References",
      "section_title": true,
      "zh-CHS": "12.2. 资料性引用"
    },
    {
      "indent": 3,
      "text": "[RFC3453] Luby, M., Vicisano, L., Gemmell, J., Rizzo, L., Handley, M., and J. Crowcroft, \"The Use of Forward Error Correction (FEC) in Reliable Multicast\", RFC 3453, December 2002.",
      "zh-CHS": "[RFC3453]Luby，M.，Vicisano，L.，Gemmell，J.，Rizzo，L.，Handley，M.，和J.Crowcroft，“在可靠多播中使用前向纠错（FEC）”，RFC 3453，2002年12月。"
    },
    {
      "indent": 3,
      "text": "[RS-codec] Rizzo, L., \"Reed-Solomon FEC codec\", available at http://info.iet.unipi.it/~luigi/vdm98/vdm980702.tgz and mirrored at http://planete-bcast.inrialpes.fr/, revised version of July 1998.",
      "zh-CHS": "[RS编解码器]Rizzo，L.，“Reed Solomon FEC编解码器”，可在http://info.iet.unipi.it/~luigi/vdm98/vdm980702.tgz，镜像位置为http://planete-bcast.inrialpes.fr/，1998年7月修订本。"
    },
    {
      "indent": 3,
      "text": "[Rizzo97] Rizzo, L., \"Effective Erasure Codes for Reliable Computer Communication Protocols\", ACM SIGCOMM Computer Communication Review Vol.27, No.2, pp.24-36, April 1997.",
      "zh-CHS": "[Rizzo97]Rizzo，L.，“可靠计算机通信协议的有效擦除代码”，ACM SIGCOMM计算机通信评论第27卷，第2期，第24-36页，1997年4月。"
    },
    {
      "indent": 3,
      "text": "[MWS77] Mac Williams, F. and N. Sloane, \"The Theory of Error Correcting Codes\", North Holland, 1977.",
      "zh-CHS": "[MWS77]Mac Williams，F.和N.Sloane，“纠错码理论”，北荷兰，1977年。"
    },
    {
      "indent": 3,
      "text": "[GO94] Gohberg, I. and V. Olshevsky, \"Fast algorithms with preprocessing for matrix-vector multiplication problems\", Journal of Complexity, pp. 411-427, vol. 10, 1994.",
      "zh-CHS": "[GO94]Gohberg，I.和V.Olshevsky，“矩阵向量乘法问题的预处理快速算法”，《复杂性杂志》，第411-427页，第10卷，1994年。"
    },
    {
      "indent": 3,
      "text": "[RFC5170] Roca, V., Neumann, C., and D. Furodet, \"Low Density Parity Check (LDPC) Forward Error Correction\", RFC 5170, June 2008.",
      "zh-CHS": "[RFC5170]Roca，V.，Neumann，C.，和D.Furodet，“低密度奇偶校验（LDPC）前向纠错”，RFC 51702008年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC5053] Luby, M., Shokrollahi, A., Watson, M., and T. Stockhammer, \"Raptor Forward Error Correction Scheme\", RFC 5053, October 2007.",
      "zh-CHS": "[RFC5053]Luby，M.，Shokrollahi，A.，Watson，M.，和T.Stockhammer，“猛禽前向纠错方案”，RFC 50532007年10月。"
    },
    {
      "indent": 3,
      "text": "[ALC] Luby, M., Watson, M., and L. Vicisano, \"Asynchronous Layered Coding (ALC) Protocol Instantiation\", Work in Progress, November 2008.",
      "zh-CHS": "[ALC]Luby，M.，Watson，M.，和L.Vicisano，“异步分层编码（ALC）协议实例化”，正在进行的工作，2008年11月。"
    },
    {
      "indent": 3,
      "text": "[NORM] Adamson, B., Bormann, C., Handley, M., and J. Macker, \"NACK-Oriented Reliable Multicast Protocol\", Work in Progress, March 2009.",
      "zh-CHS": "[NORM]Adamson，B.，Bormann，C.，Handley，M.，和J.Macker，“面向NACK的可靠多播协议”，正在进行的工作，2009年3月。"
    },
    {
      "indent": 3,
      "text": "[FLUTE] Paila, T., Walsh, R., Luby, M., Lehtonen, R., and V. Roca, \"FLUTE - File Delivery over Unidirectional Transport\", Work in Progress, September 2008.",
      "zh-CHS": "[长笛]Paila，T.，Walsh，R.，Luby，M.，Lehtonen，R.，和V.Roca，“长笛-单向运输上的文件交付”，在建工程，2008年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC3447] Jonsson, J. and B. Kaliski, \"Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1\", RFC 3447, February 2003.",
      "zh-CHS": "[RFC3447]Jonsson，J.和B.Kaliski，“公钥密码标准（PKCS）#1:RSA密码规范版本2.1”，RFC 3447，2003年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC4303] Kent, S., \"IP Encapsulating Security Payload (ESP)\", RFC 4303, December 2005.",
      "zh-CHS": "[RFC4303]Kent，S.，“IP封装安全有效载荷（ESP）”，RFC 4303，2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC2104] \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "zh-CHS": "[RFC2104]“HMAC：用于消息认证的键控哈希”，RFC2104，1997年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC4082] \"Timed Efficient Stream Loss-Tolerant Authentication (TESLA): Multicast Source Authentication Transform Introduction\", RFC 4082, June 2005.",
      "zh-CHS": "[RFC4082]“定时高效流丢失容忍认证（TESLA）：多播源认证转换介绍”，RFC 40822005年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3275] Eastlake 3rd, D., Reagle, J., and D. Solo, \"(Extensible Markup Language) XML-Signature Syntax and Processing\", RFC 3275, March 2002.",
      "zh-CHS": "[RFC3275]Eastlake 3rd，D.，Reagle，J.，和D.Solo，“（可扩展标记语言）XML签名语法和处理”，RFC 32752002年3月。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "zh-CHS": "作者地址"
    },
    {
      "indent": 3,
      "text": "Jerome Lacan ISAE/LAAS-CNRS 1, place Emile Blouin Toulouse 31056 France",
      "zh-CHS": "Jerome Lacan ISAE/LAAS-CNRS 1，法国图卢兹埃米尔布鲁因广场31056"
    },
    {
      "indent": 3,
      "text": "EMail: jerome.lacan@isae.fr\nURI:   http://pagespro.isae.fr/jerome-lacan/",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Vincent Roca INRIA 655, av. de l'Europe Inovallee; Montbonnot ST ISMIER cedex 38334 France",
      "zh-CHS": "Vincent Roca INRIA 655，av。欧洲伊诺瓦利；蒙博诺圣伊斯梅尔塞德斯38334法国"
    },
    {
      "indent": 3,
      "text": "EMail: vincent.roca@inria.fr\nURI:   http://planete.inrialpes.fr/people/roca/",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Jani Peltotalo Tampere University of Technology P.O. Box 553 (Korkeakoulunkatu 1) Tampere FIN-33101 Finland",
      "zh-CHS": "詹尼帕尔图罗坦佩雷理工大学坦佩雷理工大学邮政信箱553（Kokkououkkutu 1）坦佩雷芬兰3101芬兰"
    },
    {
      "indent": 3,
      "text": "EMail: jani.peltotalo@tut.fi\nURI:   http://mad.cs.tut.fi/",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Sami Peltotalo Tampere University of Technology P.O. Box 553 (Korkeakoulunkatu 1) Tampere FIN-33101 Finland",
      "zh-CHS": "SAMI PelToRo坦佩雷理工大学邮政信箱553（KOKKAKULKKATU 1）坦佩雷芬兰3101芬兰"
    },
    {
      "indent": 3,
      "text": "EMail: sami.peltotalo@tut.fi\nURI:   http://mad.cs.tut.fi/",
      "raw": true,
      "zh-CHS": " "
    }
  ]
}