{
  "title": {
    "text": "RFC 6020: YANG - A Data Modeling Language for the Network Configuration Protocol (NETCONF)",
    "zh-CHS": "RFC 6020"
  },
  "number": 6020,
  "created_at": "2021-11-04 23:49:18.917739+08:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                 M. Bjorklund, Ed.\nRequest for Comments: 6020                                Tail-f Systems\nCategory: Standards Track                                   October 2010\nISSN: 2070-1721",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 14,
      "text": " YANG - A Data Modeling Language for the Network Configuration Protocol (NETCONF)",
      "zh-CHS": "YANG—网络配置协议（NETCONF）的数据建模语言"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "zh-CHS": "摘要"
    },
    {
      "indent": 3,
      "text": "YANG is a data modeling language used to model configuration and state data manipulated by the Network Configuration Protocol (NETCONF), NETCONF remote procedure calls, and NETCONF notifications.",
      "zh-CHS": "YANG是一种数据建模语言，用于对网络配置协议（NETCONF）、NETCONF远程过程调用和NETCONF通知操作的配置和状态数据进行建模。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "zh-CHS": "关于下段备忘"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "zh-CHS": "这是一份互联网标准跟踪文件。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "zh-CHS": "本文件是互联网工程任务组（IETF）的产品。它代表了IETF社区的共识。它已经接受了公众审查，并已被互联网工程指导小组（IESG）批准出版。有关互联网标准的更多信息，请参见RFC 5741第2节。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6020.",
      "zh-CHS": "有关本文件当前状态、任何勘误表以及如何提供反馈的信息，请访问http://www.rfc-editor.org/info/rfc6020."
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "zh-CHS": "版权公告"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2010 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "zh-CHS": "版权所有（c）2010 IETF信托基金和确定为文件作者的人员。版权所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "zh-CHS": "本文件受BCP 78和IETF信托有关IETF文件的法律规定的约束(http://trustee.ietf.org/license-info)自本文件出版之日起生效。请仔细阅读这些文件，因为它们描述了您对本文件的权利和限制。从本文件中提取的代码组件必须包括信托法律条款第4.e节中所述的简化BSD许可证文本，并提供简化BSD许可证中所述的无担保。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "zh-CHS": "本文件可能包含2008年11月10日之前发布或公开的IETF文件或IETF贡献中的材料。控制某些材料版权的人员可能未授予IETF信托允许在IETF标准流程之外修改此类材料的权利。在未从控制此类材料版权的人员处获得充分许可的情况下，不得在IETF标准流程之外修改本文件，也不得在IETF标准流程之外创建其衍生作品，除了将其格式化以RFC形式发布或将其翻译成英语以外的其他语言。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "zh-CHS": "目录"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................8\n2. Keywords ........................................................8\n3. Terminology .....................................................8\n   3.1. Mandatory Nodes ...........................................10\n4. YANG Overview ..................................................11\n   4.1. Functional Overview .......................................11\n   4.2. Language Overview .........................................13\n        4.2.1. Modules and Submodules .............................13\n        4.2.2. Data Modeling Basics ...............................13\n        4.2.3. State Data .........................................18\n        4.2.4. Built-In Types .....................................18\n        4.2.5. Derived Types (typedef) ............................19\n        4.2.6. Reusable Node Groups (grouping) ....................20\n        4.2.7. Choices ............................................21\n        4.2.8. Extending Data Models (augment) ....................22\n        4.2.9. RPC Definitions ....................................23\n        4.2.10. Notification Definitions ..........................24\n5. Language Concepts ..............................................25\n   5.1. Modules and Submodules ....................................25\n        5.1.1. Import and Include by Revision .....................26\n        5.1.2. Module Hierarchies .................................27\n   5.2. File Layout ...............................................28\n   5.3. XML Namespaces ............................................29\n        5.3.1. YANG XML Namespace .................................29\n   5.4. Resolving Grouping, Type, and Identity Names ..............29\n   5.5. Nested Typedefs and Groupings .............................29\n   5.6. Conformance ...............................................30\n        5.6.1. Basic Behavior .....................................31\n        5.6.2. Optional Features ..................................31\n        5.6.3. Deviations .........................................31\n        5.6.4. Announcing Conformance Information in the\n               <hello> Message ....................................32\n   5.7. Data Store Modification ...................................34\n6. YANG Syntax ....................................................34",
      "raw": true,
      "toc": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "   6.1. Lexical Tokenization ......................................34\n        6.1.1. Comments ...........................................34\n        6.1.2. Tokens .............................................34\n        6.1.3. Quoting ............................................35\n   6.2. Identifiers ...............................................36\n        6.2.1. Identifiers and Their Namespaces ...................36\n   6.3. Statements ................................................37\n        6.3.1. Language Extensions ................................37\n   6.4. XPath Evaluations .........................................38\n        6.4.1. XPath Context ......................................38\n   6.5. Schema Node Identifier ....................................39\n7. YANG Statements ................................................39\n   7.1. The module Statement ......................................39\n        7.1.1. The module's Substatements .........................41\n        7.1.2. The yang-version Statement .........................41\n        7.1.3. The namespace Statement ............................42\n        7.1.4. The prefix Statement ...............................42\n        7.1.5. The import Statement ...............................42\n        7.1.6. The include Statement ..............................43\n        7.1.7. The organization Statement .........................44\n        7.1.8. The contact Statement ..............................44\n        7.1.9. The revision Statement .............................44\n        7.1.10. Usage Example .....................................45\n   7.2. The submodule Statement ...................................46\n        7.2.1. The submodule's Substatements ......................48\n        7.2.2. The belongs-to Statement ...........................48\n        7.2.3. Usage Example ......................................49\n   7.3. The typedef Statement .....................................49\n        7.3.1. The typedef's Substatements ........................50\n        7.3.2. The typedef's type Statement .......................50\n        7.3.3. The units Statement ................................50\n        7.3.4. The typedef's default Statement ....................50\n        7.3.5. Usage Example ......................................51\n   7.4. The type Statement ........................................51\n        7.4.1. The type's Substatements ...........................51\n   7.5. The container Statement ...................................51\n        7.5.1. Containers with Presence ...........................52\n        7.5.2. The container's Substatements ......................53\n        7.5.3. The must Statement .................................53\n        7.5.4. The must's Substatements ...........................55\n        7.5.5. The presence Statement .............................56\n        7.5.6. The container's Child Node Statements ..............56\n        7.5.7. XML Mapping Rules ..................................56\n        7.5.8. NETCONF <edit-config> Operations ...................56\n        7.5.9. Usage Example ......................................57\n   7.6. The leaf Statement ........................................58\n        7.6.1. The leaf's default value ...........................58\n        7.6.2. The leaf's Substatements ...........................59",
      "raw": true,
      "toc": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "     7.6.3. The leaf's type Statement ..........................59\n     7.6.4. The leaf's default Statement .......................59\n     7.6.5. The leaf's mandatory Statement .....................60\n     7.6.6. XML Mapping Rules ..................................60\n     7.6.7. NETCONF <edit-config> Operations ...................60\n     7.6.8. Usage Example ......................................61\n7.7. The leaf-list Statement ...................................62\n     7.7.1. Ordering ...........................................62\n     7.7.2. The leaf-list's Substatements ......................63\n     7.7.3. The min-elements Statement .........................63\n     7.7.4. The max-elements Statement .........................63\n     7.7.5. The ordered-by Statement ...........................64\n     7.7.6. XML Mapping Rules ..................................64\n     7.7.7. NETCONF <edit-config> Operations ...................65\n     7.7.8. Usage Example ......................................66\n7.8. The list Statement ........................................67\n     7.8.1. The list's Substatements ...........................68\n     7.8.2. The list's key Statement ...........................68\n     7.8.3. The list's unique Statement ........................69\n     7.8.4. The list's Child Node Statements ...................70\n     7.8.5. XML Mapping Rules ..................................70\n     7.8.6. NETCONF <edit-config> Operations ...................71\n     7.8.7. Usage Example ......................................72\n7.9. The choice Statement ......................................75\n     7.9.1. The choice's Substatements .........................76\n     7.9.2. The choice's case Statement ........................76\n     7.9.3. The choice's default Statement .....................77\n     7.9.4. The choice's mandatory Statement ...................79\n     7.9.5. XML Mapping Rules ..................................79\n     7.9.6. NETCONF <edit-config> Operations ...................79\n     7.9.7. Usage Example ......................................79\n7.10. The anyxml Statement .....................................80\n     7.10.1. The anyxml's Substatements ........................81\n     7.10.2. XML Mapping Rules .................................81\n     7.10.3. NETCONF <edit-config> Operations ..................81\n     7.10.4. Usage Example .....................................82\n7.11. The grouping Statement ...................................82\n     7.11.1. The grouping's Substatements ......................83\n     7.11.2. Usage Example .....................................84\n7.12. The uses Statement .......................................84\n     7.12.1. The uses's Substatements ..........................85\n     7.12.2. The refine Statement ..............................85\n     7.12.3. XML Mapping Rules .................................86\n     7.12.4. Usage Example .....................................86\n7.13. The rpc Statement ........................................87\n     7.13.1. The rpc's Substatements ...........................88\n     7.13.2. The input Statement ...............................88\n     7.13.3. The output Statement ..............................89",
      "raw": true,
      "toc": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "        7.13.4. XML Mapping Rules .................................90\n        7.13.5. Usage Example .....................................91\n   7.14. The notification Statement ...............................91\n        7.14.1. The notification's Substatements ..................92\n        7.14.2. XML Mapping Rules .................................92\n        7.14.3. Usage Example .....................................93\n   7.15. The augment Statement ....................................93\n        7.15.1. The augment's Substatements .......................94\n        7.15.2. XML Mapping Rules .................................94\n        7.15.3. Usage Example .....................................95\n   7.16. The identity Statement ...................................97\n        7.16.1. The identity's Substatements ......................97\n        7.16.2. The base Statement ................................97\n        7.16.3. Usage Example .....................................98\n   7.17. The extension Statement ..................................98\n        7.17.1. The extension's Substatements .....................99\n        7.17.2. The argument Statement ............................99\n        7.17.3. Usage Example ....................................100\n   7.18. Conformance-Related Statements ..........................100\n        7.18.1. The feature Statement ............................100\n        7.18.2. The if-feature Statement .........................102\n        7.18.3. The deviation Statement ..........................102\n   7.19. Common Statements .......................................105\n        7.19.1. The config Statement .............................105\n        7.19.2. The status Statement .............................105\n        7.19.3. The description Statement ........................106\n        7.19.4. The reference Statement ..........................106\n        7.19.5. The when Statement ...............................107\n8. Constraints ...................................................108\n   8.1. Constraints on Data ......................................108\n   8.2. Hierarchy of Constraints .................................109\n   8.3. Constraint Enforcement Model .............................109\n        8.3.1. Payload Parsing ...................................109\n        8.3.2. NETCONF <edit-config> Processing ..................110\n        8.3.3. Validation ........................................111\n9. Built-In Types ................................................111\n   9.1. Canonical Representation .................................112\n   9.2. The Integer Built-In Types ...............................112\n        9.2.1. Lexical Representation ............................113\n        9.2.2. Canonical Form ....................................114\n        9.2.3. Restrictions ......................................114\n        9.2.4. The range Statement ...............................114\n        9.2.5. Usage Example .....................................115\n   9.3. The decimal64 Built-In Type ..............................115\n        9.3.1. Lexical Representation ............................115\n        9.3.2. Canonical Form ....................................115\n        9.3.3. Restrictions ......................................116\n        9.3.4. The fraction-digits Statement .....................116",
      "raw": true,
      "toc": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "     9.3.5. Usage Example .....................................117\n9.4. The string Built-In Type .................................117\n     9.4.1. Lexical Representation ............................117\n     9.4.2. Canonical Form ....................................117\n     9.4.3. Restrictions ......................................117\n     9.4.4. The length Statement ..............................117\n     9.4.5. Usage Example .....................................118\n     9.4.6. The pattern Statement .............................119\n     9.4.7. Usage Example .....................................119\n9.5. The boolean Built-In Type ................................120\n     9.5.1. Lexical Representation ............................120\n     9.5.2. Canonical Form ....................................120\n     9.5.3. Restrictions ......................................120\n9.6. The enumeration Built-In Type ............................120\n     9.6.1. Lexical Representation ............................120\n     9.6.2. Canonical Form ....................................120\n     9.6.3. Restrictions ......................................120\n     9.6.4. The enum Statement ................................120\n     9.6.5. Usage Example .....................................121\n9.7. The bits Built-In Type ...................................122\n     9.7.1. Restrictions ......................................122\n     9.7.2. Lexical Representation ............................122\n     9.7.3. Canonical Form ....................................122\n     9.7.4. The bit Statement .................................122\n     9.7.5. Usage Example .....................................123\n9.8. The binary Built-In Type .................................123\n     9.8.1. Restrictions ......................................124\n     9.8.2. Lexical Representation ............................124\n     9.8.3. Canonical Form ....................................124\n9.9. The leafref Built-In Type ................................124\n     9.9.1. Restrictions ......................................124\n     9.9.2. The path Statement ................................124\n     9.9.3. Lexical Representation ............................125\n     9.9.4. Canonical Form ....................................125\n     9.9.5. Usage Example .....................................126\n9.10. The identityref Built-In Type ...........................129\n     9.10.1. Restrictions .....................................129\n     9.10.2. The identityref's base Statement .................129\n     9.10.3. Lexical Representation ...........................130\n     9.10.4. Canonical Form ...................................130\n     9.10.5. Usage Example ....................................130\n9.11. The empty Built-In Type .................................131\n     9.11.1. Restrictions .....................................131\n     9.11.2. Lexical Representation ...........................131\n     9.11.3. Canonical Form ...................................131\n     9.11.4. Usage Example ....................................131\n9.12. The union Built-In Type .................................132\n     9.12.1. Restrictions .....................................132",
      "raw": true,
      "toc": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "        9.12.2. Lexical Representation ...........................132\n        9.12.3. Canonical Form ...................................133\n   9.13. The instance-identifier Built-In Type ...................133\n        9.13.1. Restrictions .....................................134\n        9.13.2. The require-instance Statement ...................134\n        9.13.3. Lexical Representation ...........................134\n        9.13.4. Canonical Form ...................................134\n        9.13.5. Usage Example ....................................134\n10. Updating a Module ............................................135\n11. YIN ..........................................................137\n   11.1. Formal YIN Definition ...................................137\n        11.1.1. Usage Example ....................................141\n12. YANG ABNF Grammar ............................................143\n13. Error Responses for YANG Related Errors ......................165\n   13.1. Error Message for Data That Violates a unique\n         Statement ...............................................165\n   13.2. Error Message for Data That Violates a\n         max-elements Statement ..................................165\n   13.3. Error Message for Data That Violates a\n         min-elements Statement ..................................165\n   13.4. Error Message for Data That Violates a must Statement ...166\n   13.5. Error Message for Data That Violates a\n         require-instance Statement ..............................166\n   13.6. Error Message for Data That Does Not Match a\n         leafref Type ............................................166\n   13.7. Error Message for Data That Violates a mandatory\n         choice Statement ........................................166\n   13.8. Error Message for the \"insert\" Operation ................167\n14. IANA Considerations ..........................................167\n   14.1. Media type application/yang .............................168\n   14.2. Media type application/yin+xml ..........................169\n15. Security Considerations ......................................170\n16. Contributors .................................................171\n17. Acknowledgements .............................................171\n18. References ...................................................171\n   18.1. Normative References ....................................171\n   18.2. Informative References ..................................172",
      "raw": true,
      "toc": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "zh-CHS": "1. 介绍"
    },
    {
      "indent": 3,
      "text": "YANG is a data modeling language used to model configuration and state data manipulated by the Network Configuration Protocol (NETCONF), NETCONF remote procedure calls, and NETCONF notifications. YANG is used to model the operations and content layers of NETCONF (see the NETCONF Configuration Protocol [RFC4741], Section 1.1).",
      "zh-CHS": "YANG是一种数据建模语言，用于对网络配置协议（NETCONF）、NETCONF远程过程调用和NETCONF通知操作的配置和状态数据进行建模。YANG用于建模NETCONF的操作和内容层（请参阅NETCONF配置协议[RFC4741]，第1.1节）。"
    },
    {
      "indent": 3,
      "text": "This document describes the syntax and semantics of the YANG language, how the data model defined in a YANG module is represented in the Extensible Markup Language (XML), and how NETCONF operations are used to manipulate the data.",
      "zh-CHS": "本文档描述YANG语言的语法和语义，YANG模块中定义的数据模型如何用可扩展标记语言（XML）表示，以及如何使用NETCONF操作来操作数据。"
    },
    {
      "indent": 0,
      "text": "2. Keywords",
      "section_title": true,
      "zh-CHS": "2. 关键词"
    },
    {
      "indent": 3,
      "text": "The keywords \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14, [RFC2119].",
      "zh-CHS": "本文件中的关键词“必须”、“不得”、“必需”、“应”、“不应”、“建议”、“不建议”、“可”和“可选”应按照BCP 14、[RFC2119]中所述进行解释。"
    },
    {
      "indent": 0,
      "text": "3. Terminology",
      "section_title": true,
      "zh-CHS": "3. 术语"
    },
    {
      "indent": 3,
      "text": "o anyxml: A data node that can contain an unknown chunk of XML data.",
      "zh-CHS": "o anyxml：可以包含未知XML数据块的数据节点。"
    },
    {
      "indent": 3,
      "text": "o augment: Adds new schema nodes to a previously defined schema node.",
      "zh-CHS": "o 扩充：将新架构节点添加到先前定义的架构节点。"
    },
    {
      "indent": 3,
      "text": "o base type: The type from which a derived type was derived, which may be either a built-in type or another derived type.",
      "zh-CHS": "o 基类型：派生类型的派生类型，可以是内置类型或其他派生类型。"
    },
    {
      "indent": 3,
      "text": "o built-in type: A YANG data type defined in the YANG language, such as uint32 or string.",
      "zh-CHS": "o 内置类型：用YANG语言定义的YANG数据类型，如uint32或字符串。"
    },
    {
      "indent": 3,
      "text": "o choice: A schema node where only one of a number of identified alternatives is valid.",
      "zh-CHS": "o 选择：一个模式节点，其中许多已识别的备选方案中只有一个是有效的。"
    },
    {
      "indent": 3,
      "text": "o configuration data: The set of writable data that is required to transform a system from its initial default state into its current state [RFC4741].",
      "zh-CHS": "o 配置数据：将系统从初始默认状态转换为当前状态所需的一组可写数据[RFC4741]。"
    },
    {
      "indent": 3,
      "text": "o conformance: A measure of how accurately a device follows a data model.",
      "zh-CHS": "o 一致性：衡量设备遵循数据模型的准确程度。"
    },
    {
      "indent": 3,
      "text": "o container: An interior data node that exists in at most one instance in the data tree. A container has no value, but rather a set of child nodes.",
      "zh-CHS": "o 容器：数据树中最多存在一个实例的内部数据节点。容器没有值，而是一组子节点。"
    },
    {
      "indent": 3,
      "text": "o data definition statement: A statement that defines new data nodes. One of container, leaf, leaf-list, list, choice, case, augment, uses, and anyxml.",
      "zh-CHS": "o 数据定义语句：定义新数据节点的语句。容器、叶、叶列表、列表、选项、大小写、扩充、使用和anyxml之一。"
    },
    {
      "indent": 3,
      "text": "o data model: A data model describes how data is represented and accessed.",
      "zh-CHS": "o 数据模型：数据模型描述如何表示和访问数据。"
    },
    {
      "indent": 3,
      "text": "o data node: A node in the schema tree that can be instantiated in a data tree. One of container, leaf, leaf-list, list, and anyxml.",
      "zh-CHS": "o 数据节点：架构树中可以在数据树中实例化的节点。容器、叶、叶列表、列表和anyxml之一。"
    },
    {
      "indent": 3,
      "text": "o data tree: The instantiated tree of configuration and state data on a device.",
      "zh-CHS": "o 数据树：设备上配置和状态数据的实例化树。"
    },
    {
      "indent": 3,
      "text": "o derived type: A type that is derived from a built-in type (such as uint32), or another derived type.",
      "zh-CHS": "o 派生类型：从内置类型（如uint32）或其他派生类型派生的类型。"
    },
    {
      "indent": 3,
      "text": "o device deviation: A failure of the device to implement the module faithfully.",
      "zh-CHS": "o 设备偏差：设备未能忠实执行模块。"
    },
    {
      "indent": 3,
      "text": "o extension: An extension attaches non-YANG semantics to statements. The extension statement defines new statements to express these semantics.",
      "zh-CHS": "o 扩展：扩展将非YANG语义附加到语句。extension语句定义新语句来表达这些语义。"
    },
    {
      "indent": 3,
      "text": "o feature: A mechanism for marking a portion of the model as optional. Definitions can be tagged with a feature name and are only valid on devices that support that feature.",
      "zh-CHS": "o 特性：将模型的一部分标记为可选的机制。定义可以使用功能名称进行标记，并且仅在支持该功能的设备上有效。"
    },
    {
      "indent": 3,
      "text": "o grouping: A reusable set of schema nodes, which may be used locally in the module, in modules that include it, and by other modules that import from it. The grouping statement is not a data definition statement and, as such, does not define any nodes in the schema tree.",
      "zh-CHS": "o 分组：一组可重用的模式节点，可以在模块中本地使用，也可以在包含它的模块中使用，还可以由从中导入的其他模块使用。grouping语句不是数据定义语句，因此不定义架构树中的任何节点。"
    },
    {
      "indent": 3,
      "text": "o identifier: Used to identify different kinds of YANG items by name.",
      "zh-CHS": "o 标识符：用于按名称标识不同种类的项目。"
    },
    {
      "indent": 3,
      "text": "o instance identifier: A mechanism for identifying a particular node in a data tree.",
      "zh-CHS": "o 实例标识符：用于标识数据树中特定节点的机制。"
    },
    {
      "indent": 3,
      "text": "o interior node: Nodes within a hierarchy that are not leaf nodes.",
      "zh-CHS": "o 内部节点：层次中不是叶节点的节点。"
    },
    {
      "indent": 3,
      "text": "o leaf: A data node that exists in at most one instance in the data tree. A leaf has a value but no child nodes.",
      "zh-CHS": "o 叶：数据树中最多存在一个实例的数据节点。叶有一个值，但没有子节点。"
    },
    {
      "indent": 3,
      "text": "o leaf-list: Like the leaf node but defines a set of uniquely identifiable nodes rather than a single node. Each node has a value but no child nodes.",
      "zh-CHS": "o 叶列表：与叶节点类似，但定义了一组唯一可识别的节点，而不是单个节点。每个节点都有一个值，但没有子节点。"
    },
    {
      "indent": 3,
      "text": "o list: An interior data node that may exist in multiple instances in the data tree. A list has no value, but rather a set of child nodes.",
      "zh-CHS": "o 列表：可能存在于数据树中多个实例中的内部数据节点。列表没有值，而是一组子节点。"
    },
    {
      "indent": 3,
      "text": "o module: A YANG module defines a hierarchy of nodes that can be used for NETCONF-based operations. With its definitions and the definitions it imports or includes from elsewhere, a module is self-contained and \"compilable\".",
      "zh-CHS": "o 模块：模块定义了可用于基于NETCONF的操作的节点层次结构。通过定义以及从其他地方导入或包含的定义，模块是自包含的且“可编译的”。"
    },
    {
      "indent": 3,
      "text": "o RPC: A Remote Procedure Call, as used within the NETCONF protocol.",
      "zh-CHS": "o RPC：在NETCONF协议中使用的远程过程调用。"
    },
    {
      "indent": 3,
      "text": "o RPC operation: A specific Remote Procedure Call, as used within the NETCONF protocol. It is also called a protocol operation.",
      "zh-CHS": "o RPC操作：在NETCONF协议中使用的特定远程过程调用。它也被称为协议操作。"
    },
    {
      "indent": 3,
      "text": "o schema node: A node in the schema tree. One of container, leaf, leaf-list, list, choice, case, rpc, input, output, notification, and anyxml.",
      "zh-CHS": "o 架构节点：架构树中的节点。容器、叶、叶列表、列表、选项、大小写、rpc、输入、输出、通知和anyxml之一。"
    },
    {
      "indent": 3,
      "text": "o schema node identifier: A mechanism for identifying a particular node in the schema tree.",
      "zh-CHS": "o 模式节点标识符：用于标识模式树中特定节点的机制。"
    },
    {
      "indent": 3,
      "text": "o schema tree: The definition hierarchy specified within a module.",
      "zh-CHS": "o 架构树：模块中指定的定义层次结构。"
    },
    {
      "indent": 3,
      "text": "o state data: The additional data on a system that is not configuration data such as read-only status information and collected statistics [RFC4741].",
      "zh-CHS": "o 状态数据：系统上非配置数据的附加数据，如只读状态信息和收集的统计信息[RFC4741]。"
    },
    {
      "indent": 3,
      "text": "o submodule: A partial module definition that contributes derived types, groupings, data nodes, RPCs, and notifications to a module. A YANG module can be constructed from a number of submodules.",
      "zh-CHS": "o 子模块：向模块提供派生类型、分组、数据节点、RPC和通知的部分模块定义。杨模可以由许多子模构成。"
    },
    {
      "indent": 3,
      "text": "o top-level data node: A data node where there is no other data node between it and a module or submodule statement.",
      "zh-CHS": "o 顶级数据节点：与模块或子模块语句之间没有其他数据节点的数据节点。"
    },
    {
      "indent": 3,
      "text": "o uses: The \"uses\" statement is used to instantiate the set of schema nodes defined in a grouping statement. The instantiated nodes may be refined and augmented to tailor them to any specific needs.",
      "zh-CHS": "o uses：“uses”语句用于实例化在分组语句中定义的模式节点集。可以对实例化的节点进行细化和扩充，以使其适应任何特定需求。"
    },
    {
      "indent": 0,
      "text": "3.1. Mandatory Nodes",
      "section_title": true,
      "zh-CHS": "3.1. 强制节点"
    },
    {
      "indent": 3,
      "text": "A mandatory node is one of:",
      "zh-CHS": "强制节点是以下节点之一："
    },
    {
      "indent": 3,
      "text": "o A leaf, choice, or anyxml node with a \"mandatory\" statement with the value \"true\".",
      "zh-CHS": "o 具有值为“true”的“强制”语句的叶节点、选项节点或任意XML节点。"
    },
    {
      "indent": 3,
      "text": "o A list or leaf-list node with a \"min-elements\" statement with a value greater than zero.",
      "zh-CHS": "o 具有值大于零的“min elements”语句的列表或叶列表节点。"
    },
    {
      "indent": 3,
      "text": "o A container node without a \"presence\" statement, which has at least one mandatory node as a child.",
      "zh-CHS": "o 没有“presence”语句的容器节点，至少有一个强制节点作为子节点。"
    },
    {
      "indent": 0,
      "text": "4. YANG Overview",
      "section_title": true,
      "zh-CHS": "4. 杨总览"
    },
    {
      "indent": 0,
      "text": "4.1. Functional Overview",
      "section_title": true,
      "zh-CHS": "4.1. 功能概述"
    },
    {
      "indent": 3,
      "text": "YANG is a language used to model data for the NETCONF protocol. A YANG module defines a hierarchy of data that can be used for NETCONF-based operations, including configuration, state data, Remote Procedure Calls (RPCs), and notifications. This allows a complete description of all data sent between a NETCONF client and server.",
      "zh-CHS": "YANG是一种用于为NETCONF协议建模数据的语言。模块定义了可用于基于NETCONF的操作的数据层次结构，包括配置、状态数据、远程过程调用（RPC）和通知。这允许完整描述NETCONF客户端和服务器之间发送的所有数据。"
    },
    {
      "indent": 3,
      "text": "YANG models the hierarchical organization of data as a tree in which each node has a name, and either a value or a set of child nodes. YANG provides clear and concise descriptions of the nodes, as well as the interaction between those nodes.",
      "zh-CHS": "YANG将数据的分层组织建模为一棵树，其中每个节点都有一个名称、一个值或一组子节点。YANG对节点以及这些节点之间的交互进行了清晰简洁的描述。"
    },
    {
      "indent": 3,
      "text": "YANG structures data models into modules and submodules. A module can import data from other external modules, and include data from submodules. The hierarchy can be augmented, allowing one module to add data nodes to the hierarchy defined in another module. This augmentation can be conditional, with new nodes appearing only if certain conditions are met.",
      "zh-CHS": "YANG将数据模型分为模块和子模块。模块可以从其他外部模块导入数据，并包括子模块的数据。层次结构可以扩充，允许一个模块向另一个模块中定义的层次结构添加数据节点。这种扩展可以是有条件的，只有在满足某些条件时才会出现新节点。"
    },
    {
      "indent": 3,
      "text": "YANG models can describe constraints to be enforced on the data, restricting the appearance or value of nodes based on the presence or value of other nodes in the hierarchy. These constraints are enforceable by either the client or the server, and valid content MUST abide by them.",
      "zh-CHS": "YANG模型可以描述对数据实施的约束，根据层次结构中其他节点的存在或值限制节点的外观或值。客户机或服务器都可以强制执行这些约束，有效内容必须遵守这些约束。"
    },
    {
      "indent": 3,
      "text": "YANG defines a set of built-in types, and has a type mechanism through which additional types may be defined. Derived types can restrict their base type's set of valid values using mechanisms like range or pattern restrictions that can be enforced by clients or servers. They can also define usage conventions for use of the derived type, such as a string-based type that contains a host name.",
      "zh-CHS": "YANG定义了一组内置类型，并具有一种类型机制，通过该机制可以定义其他类型。派生类型可以使用诸如范围或模式限制之类的机制来限制其基类型的有效值集，这些机制可以由客户端或服务器强制实施。它们还可以定义使用派生类型的使用约定，例如包含主机名的基于字符串的类型。"
    },
    {
      "indent": 3,
      "text": "YANG permits the definition of reusable groupings of nodes. The instantiation of these groupings can refine or augment the nodes, allowing it to tailor the nodes to its particular needs. Derived types and groupings can be defined in one module or submodule and used in either that location or in another module or submodule that imports or includes it.",
      "zh-CHS": "YANG允许定义可重用的节点分组。这些分组的实例化可以细化或扩充节点，使其能够根据特定需求定制节点。派生类型和分组可以在一个模块或子模块中定义，并在该位置或导入或包含它的另一个模块或子模块中使用。"
    },
    {
      "indent": 3,
      "text": "YANG data hierarchy constructs include defining lists where list entries are identified by keys that distinguish them from each other. Such lists may be defined as either sorted by user or automatically sorted by the system. For user-sorted lists, operations are defined for manipulating the order of the list entries.",
      "zh-CHS": "数据层次结构包括定义列表，其中列表项由键标识，键将它们彼此区分开来。此类列表可定义为按用户排序或由系统自动排序。对于用户排序的列表，定义了用于操纵列表项顺序的操作。"
    },
    {
      "indent": 3,
      "text": "YANG modules can be translated into an equivalent XML syntax called YANG Independent Notation (YIN) (Section 11), allowing applications using XML parsers and Extensible Stylesheet Language Transformations (XSLT) scripts to operate on the models. The conversion from YANG to YIN is lossless, so content in YIN can be round-tripped back into YANG.",
      "zh-CHS": "YANG模块可以转换为一种等价的XML语法，称为YANG独立表示法（YIN）（第11节），允许使用XML解析器和可扩展样式表语言转换（XSLT）脚本的应用程序在模型上操作。从阳到阴的转换是无损的，因此阴中的内容可以循环回到阳中。"
    },
    {
      "indent": 3,
      "text": "YANG strikes a balance between high-level data modeling and low-level bits-on-the-wire encoding. The reader of a YANG module can see the high-level view of the data model while understanding how the data will be encoded in NETCONF operations.",
      "zh-CHS": "杨在高级数据建模和线编码的低级位之间取得了平衡。YANG模块的读者可以看到数据模型的高级视图，同时了解数据在NETCONF操作中的编码方式。"
    },
    {
      "indent": 3,
      "text": "YANG is an extensible language, allowing extension statements to be defined by standards bodies, vendors, and individuals. The statement syntax allows these extensions to coexist with standard YANG statements in a natural way, while extensions in a YANG module stand out sufficiently for the reader to notice them.",
      "zh-CHS": "YANG是一种可扩展语言，允许标准机构、供应商和个人定义扩展语句。语句语法允许这些扩展以一种自然的方式与标准的YANG语句共存，而YANG模块中的扩展足以让读者注意到它们。"
    },
    {
      "indent": 3,
      "text": "YANG resists the tendency to solve all possible problems, limiting the problem space to allow expression of NETCONF data models, not arbitrary XML documents or arbitrary data models. The data models described by YANG are designed to be easily operated upon by NETCONF operations.",
      "zh-CHS": "YANG抵制解决所有可能问题的倾向，将问题空间限制为允许表达NETCONF数据模型，而不是任意XML文档或任意数据模型。YANG所描述的数据模型设计为便于NETCONF操作。"
    },
    {
      "indent": 3,
      "text": "To the extent possible, YANG maintains compatibility with Simple Network Management Protocol's (SNMP's) SMIv2 (Structure of Management Information version 2 [RFC2578], [RFC2579]). SMIv2-based MIB modules can be automatically translated into YANG modules for read-only access. However, YANG is not concerned with reverse translation from YANG to SMIv2.",
      "zh-CHS": "YANG尽可能保持与简单网络管理协议（SNMP）SMIv2（管理信息结构版本2[RFC2578]，[RFC2579]）的兼容性。基于SMIv2的MIB模块可以自动转换为只读访问的模块。然而，杨并不关心从杨到SMIv2的反向翻译。"
    },
    {
      "indent": 3,
      "text": "Like NETCONF, YANG targets smooth integration with the device's native management infrastructure. This allows implementations to leverage their existing access control mechanisms to protect or expose elements of the data model.",
      "zh-CHS": "与NETCONF一样，YANG的目标是与设备的本机管理基础设施平滑集成。这允许实现利用其现有的访问控制机制来保护或公开数据模型的元素。"
    },
    {
      "indent": 0,
      "text": "4.2. Language Overview",
      "section_title": true,
      "zh-CHS": "4.2. 语言概述"
    },
    {
      "indent": 3,
      "text": "This section introduces some important constructs used in YANG that will aid in the understanding of the language specifics in later sections. This progressive approach handles the inter-related nature of YANG concepts and statements. A detailed description of YANG statements and syntax begins in Section 7.",
      "zh-CHS": "本节介绍YANG中使用的一些重要结构，这些结构将有助于理解后面章节中的语言细节。这种渐进的方法处理杨概念和陈述的相互关联性质。YANG语句和语法的详细描述从第7节开始。"
    },
    {
      "indent": 0,
      "text": "4.2.1. Modules and Submodules",
      "section_title": true,
      "zh-CHS": "4.2.1. 模与子模"
    },
    {
      "indent": 3,
      "text": "A module contains three types of statements: module-header statements, revision statements, and definition statements. The module header statements describe the module and give information about the module itself, the revision statements give information about the history of the module, and the definition statements are the body of the module where the data model is defined.",
      "zh-CHS": "模块包含三种类型的语句：模块标题语句、修订语句和定义语句。模块标题语句描述模块并提供关于模块本身的信息，修订语句提供关于模块历史的信息，定义语句是定义数据模型的模块主体。"
    },
    {
      "indent": 3,
      "text": "A NETCONF server may implement a number of modules, allowing multiple views of the same data, or multiple views of disjoint subsections of the device's data. Alternatively, the server may implement only one module that defines all available data.",
      "zh-CHS": "NETCONF服务器可以实现多个模块，允许相同数据的多个视图，或设备数据不相交部分的多个视图。或者，服务器可以仅实现一个定义所有可用数据的模块。"
    },
    {
      "indent": 3,
      "text": "A module may be divided into submodules, based on the needs of the module owner. The external view remains that of a single module, regardless of the presence or size of its submodules.",
      "zh-CHS": "根据模块所有者的需要，可以将模块划分为子模块。外部视图保持单个模块的视图，无论其子模块的存在或大小。"
    },
    {
      "indent": 3,
      "text": "The \"include\" statement allows a module or submodule to reference material in submodules, and the \"import\" statement allows references to material defined in other modules.",
      "zh-CHS": "“include”语句允许模块或子模块引用子模块中的材料，“import”语句允许引用其他模块中定义的材料。"
    },
    {
      "indent": 0,
      "text": "4.2.2. Data Modeling Basics",
      "section_title": true,
      "zh-CHS": "4.2.2. 数据建模基础"
    },
    {
      "indent": 3,
      "text": "YANG defines four types of nodes for data modeling. In each of the following subsections, the example shows the YANG syntax as well as a corresponding NETCONF XML representation.",
      "zh-CHS": "YANG为数据建模定义了四种类型的节点。在下面的每个小节中，示例都显示了YANG语法以及相应的NETCONF XML表示。"
    },
    {
      "indent": 0,
      "text": "4.2.2.1. Leaf Nodes",
      "section_title": true,
      "zh-CHS": "4.2.2.1. 叶节点"
    },
    {
      "indent": 3,
      "text": "A leaf node contains simple data like an integer or a string. It has exactly one value of a particular type and no child nodes.",
      "zh-CHS": "叶节点包含简单的数据，如整数或字符串。它只有一个特定类型的值，并且没有子节点。"
    },
    {
      "indent": 3,
      "text": "YANG Example:",
      "zh-CHS": "杨举例："
    },
    {
      "indent": 7,
      "text": "leaf host-name {\n    type string;\n    description \"Hostname for this system\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "NETCONF XML Example:",
      "zh-CHS": "NETCONF XML示例："
    },
    {
      "indent": 7,
      "text": "<host-name>my.example.com</host-name>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The \"leaf\" statement is covered in Section 7.6.",
      "zh-CHS": "第7.6节介绍了“叶”声明。"
    },
    {
      "indent": 0,
      "text": "4.2.2.2. Leaf-List Nodes",
      "section_title": true,
      "zh-CHS": "4.2.2.2. 叶列表节点"
    },
    {
      "indent": 3,
      "text": "A leaf-list is a sequence of leaf nodes with exactly one value of a particular type per leaf.",
      "zh-CHS": "叶列表是一系列叶节点，每个叶只有一个特定类型的值。"
    },
    {
      "indent": 3,
      "text": "YANG Example:",
      "zh-CHS": "杨举例："
    },
    {
      "indent": 5,
      "text": "leaf-list domain-search {\n    type string;\n    description \"List of domain names to search\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "NETCONF XML Example:",
      "zh-CHS": "NETCONF XML示例："
    },
    {
      "indent": 5,
      "text": "<domain-search>high.example.com</domain-search>\n<domain-search>low.example.com</domain-search>\n<domain-search>everywhere.example.com</domain-search>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The \"leaf-list\" statement is covered in Section 7.7.",
      "zh-CHS": "第7.7节介绍了“叶列表”声明。"
    },
    {
      "indent": 0,
      "text": "4.2.2.3. Container Nodes",
      "section_title": true,
      "zh-CHS": "4.2.2.3. 容器节点"
    },
    {
      "indent": 3,
      "text": "A container node is used to group related nodes in a subtree. A container has only child nodes and no value. A container may contain any number of child nodes of any type (including leafs, lists, containers, and leaf-lists).",
      "zh-CHS": "容器节点用于将子树中的相关节点分组。容器只有子节点，没有值。容器可以包含任意数量的任意类型的子节点（包括叶、列表、容器和叶列表）。"
    },
    {
      "indent": 3,
      "text": "YANG Example:",
      "zh-CHS": "杨举例："
    },
    {
      "indent": 5,
      "text": "container system {\n    container login {\n        leaf message {\n            type string;\n            description\n                \"Message given at start of login session\";\n        }\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "NETCONF XML Example:",
      "zh-CHS": "NETCONF XML示例："
    },
    {
      "indent": 5,
      "text": "<system>\n  <login>\n    <message>Good morning</message>\n  </login>\n</system>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The \"container\" statement is covered in Section 7.5.",
      "zh-CHS": "第7.5节介绍了“容器”声明。"
    },
    {
      "indent": 0,
      "text": "4.2.2.4. List Nodes",
      "section_title": true,
      "zh-CHS": "4.2.2.4. 列表节点"
    },
    {
      "indent": 3,
      "text": "A list defines a sequence of list entries. Each entry is like a structure or a record instance, and is uniquely identified by the values of its key leafs. A list can define multiple key leafs and may contain any number of child nodes of any type (including leafs, lists, containers etc.).",
      "zh-CHS": "列表定义了一系列列表条目。每个条目就像一个结构或一个记录实例，并由其键叶的值唯一标识。列表可以定义多个键叶，并且可以包含任意数量的任何类型的子节点（包括叶、列表、容器等）。"
    },
    {
      "indent": 3,
      "text": "YANG Example:",
      "zh-CHS": "杨举例："
    },
    {
      "indent": 5,
      "text": "list user {\n    key \"name\";\n    leaf name {\n        type string;\n    }\n    leaf full-name {\n        type string;\n    }\n    leaf class {\n        type string;\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "NETCONF XML Example:",
      "zh-CHS": "NETCONF XML示例："
    },
    {
      "indent": 5,
      "text": "<user>\n  <name>glocks</name>\n  <full-name>Goldie Locks</full-name>\n  <class>intruder</class>\n</user>\n<user>\n  <name>snowey</name>\n  <full-name>Snow White</full-name>\n  <class>free-loader</class>\n</user>\n<user>\n  <name>rzell</name>\n  <full-name>Rapun Zell</full-name>\n  <class>tower</class>\n</user>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The \"list\" statement is covered in Section 7.8.",
      "zh-CHS": "第7.8节介绍了“列表”说明。"
    },
    {
      "indent": 0,
      "text": "4.2.2.5. Example Module",
      "section_title": true,
      "zh-CHS": "4.2.2.5. 示例模块"
    },
    {
      "indent": 3,
      "text": "These statements are combined to define the module:",
      "zh-CHS": "这些语句组合起来定义模块："
    },
    {
      "indent": 5,
      "text": "// Contents of \"acme-system.yang\"\nmodule acme-system {\n    namespace \"http://acme.example.com/system\";\n    prefix \"acme\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "organization \"ACME Inc.\";\ncontact \"joe@acme.example.com\";\ndescription\n    \"The module for entities implementing the ACME system.\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "revision 2007-06-09 {\n    description \"Initial revision.\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "container system {\n    leaf host-name {\n        type string;\n        description \"Hostname for this system\";\n    }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 13,
      "text": "leaf-list domain-search {\n    type string;\n    description \"List of domain names to search\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 13,
      "text": "container login {\n    leaf message {\n        type string;\n        description\n            \"Message given at start of login session\";\n    }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "            list user {\n                key \"name\";\n                leaf name {\n                    type string;\n                }\n                leaf full-name {\n                    type string;\n                }\n                leaf class {\n                    type string;\n                }\n            }\n        }\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "4.2.3. State Data",
      "section_title": true,
      "zh-CHS": "4.2.3. 状态数据"
    },
    {
      "indent": 3,
      "text": "YANG can model state data, as well as configuration data, based on the \"config\" statement. When a node is tagged with \"config false\", its subhierarchy is flagged as state data, to be reported using NETCONF's <get> operation, not the <get-config> operation. Parent containers, lists, and key leafs are reported also, giving the context for the state data.",
      "zh-CHS": "YANG可以根据“config”语句对状态数据和配置数据进行建模。当一个节点被标记为“config false”时，它的子层次结构被标记为状态数据，将使用NETCONF的<get>操作而不是<get config>操作来报告。还报告父容器、列表和键叶，为状态数据提供上下文。"
    },
    {
      "indent": 3,
      "text": "In this example, two leafs are defined for each interface, a configured speed and an observed speed. The observed speed is not configuration, so it can be returned with NETCONF <get> operations, but not with <get-config> operations. The observed speed is not configuration data, and it cannot be manipulated using <edit-config>.",
      "zh-CHS": "在本例中，为每个接口定义了两个LEAF，一个配置速度和一个观察速度。观察到的速度不是配置，因此可以通过NETCONF<get>操作返回，但不能通过<get config>操作返回。观察到的速度不是配置数据，不能使用<edit config>进行操作。"
    },
    {
      "indent": 5,
      "text": "list interface {\n    key \"name\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "    leaf name {\n        type string;\n    }\n    leaf speed {\n        type enumeration {\n            enum 10m;\n            enum 100m;\n            enum auto;\n        }\n    }\n    leaf observed-speed {\n        type uint32;\n        config false;\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "4.2.4. Built-In Types",
      "section_title": true,
      "zh-CHS": "4.2.4. 内置类型"
    },
    {
      "indent": 3,
      "text": "YANG has a set of built-in types, similar to those of many programming languages, but with some differences due to special requirements from the management domain. The following table summarizes the built-in types discussed in Section 9:",
      "zh-CHS": "YANG有一组内置类型，类似于许多编程语言的类型，但由于管理领域的特殊要求而有所不同。下表总结了第9节中讨论的内置类型："
    },
    {
      "indent": 7,
      "text": "+---------------------+-------------------------------------+\n| Name                | Description                         |\n+---------------------+-------------------------------------+\n| binary              | Any binary data                     |\n| bits                | A set of bits or flags              |\n| boolean             | \"true\" or \"false\"                   |\n| decimal64           | 64-bit signed decimal number        |\n| empty               | A leaf that does not have any value |\n| enumeration         | Enumerated strings                  |\n| identityref         | A reference to an abstract identity |\n| instance-identifier | References a data tree node         |\n| int8                | 8-bit signed integer                |\n| int16               | 16-bit signed integer               |\n| int32               | 32-bit signed integer               |\n| int64               | 64-bit signed integer               |\n| leafref             | A reference to a leaf instance      |\n| string              | Human-readable string               |\n| uint8               | 8-bit unsigned integer              |\n| uint16              | 16-bit unsigned integer             |\n| uint32              | 32-bit unsigned integer             |\n| uint64              | 64-bit unsigned integer             |\n| union               | Choice of member types              |\n+---------------------+-------------------------------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The \"type\" statement is covered in Section 7.4.",
      "zh-CHS": "“类型”说明见第7.4节。"
    },
    {
      "indent": 0,
      "text": "4.2.5. Derived Types (typedef)",
      "section_title": true,
      "zh-CHS": "4.2.5. 派生类型（typedef）"
    },
    {
      "indent": 3,
      "text": "YANG can define derived types from base types using the \"typedef\" statement. A base type can be either a built-in type or a derived type, allowing a hierarchy of derived types.",
      "zh-CHS": "YANG可以使用“typedef”语句从基类型定义派生类型。基类型可以是内置类型或派生类型，允许派生类型的层次结构。"
    },
    {
      "indent": 3,
      "text": "A derived type can be used as the argument for the \"type\" statement.",
      "zh-CHS": "派生类型可用作“type”语句的参数。"
    },
    {
      "indent": 3,
      "text": "YANG Example:",
      "zh-CHS": "杨举例："
    },
    {
      "indent": 5,
      "text": "typedef percent {\n    type uint8 {\n        range \"0 .. 100\";\n    }\n    description \"Percentage\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "leaf completed {\n    type percent;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "NETCONF XML Example:",
      "zh-CHS": "NETCONF XML示例："
    },
    {
      "indent": 5,
      "text": "<completed>20</completed>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The \"typedef\" statement is covered in Section 7.3.",
      "zh-CHS": "第7.3节介绍了“typedef”语句。"
    },
    {
      "indent": 0,
      "text": "4.2.6. Reusable Node Groups (grouping)",
      "section_title": true,
      "zh-CHS": "4.2.6. 可重用节点组（分组）"
    },
    {
      "indent": 3,
      "text": "Groups of nodes can be assembled into reusable collections using the \"grouping\" statement. A grouping defines a set of nodes that are instantiated with the \"uses\" statement:",
      "zh-CHS": "可以使用“grouping”语句将节点组组装成可重用的集合。分组定义了一组用“uses”语句实例化的节点："
    },
    {
      "indent": 5,
      "text": "grouping target {\n    leaf address {\n        type inet:ip-address;\n        description \"Target IP address\";\n    }\n    leaf port {\n        type inet:port-number;\n        description \"Target port number\";\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "container peer {\n    container destination {\n        uses target;\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "NETCONF XML Example:",
      "zh-CHS": "NETCONF XML示例："
    },
    {
      "indent": 5,
      "text": "<peer>\n  <destination>\n    <address>192.0.2.1</address>\n    <port>830</port>\n  </destination>\n</peer>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The grouping can be refined as it is used, allowing certain statements to be overridden. In this example, the description is refined:",
      "zh-CHS": "分组可以在使用时进行细化，允许覆盖某些语句。在本例中，对描述进行了细化："
    },
    {
      "indent": 5,
      "text": "container connection {\n    container source {\n        uses target {\n            refine \"address\" {\n                description \"Source IP address\";\n            }\n            refine \"port\" {\n                description \"Source port number\";\n            }\n        }\n    }\n    container destination {\n        uses target {\n            refine \"address\" {\n                description \"Destination IP address\";\n            }\n            refine \"port\" {\n                description \"Destination port number\";\n            }\n        }\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The \"grouping\" statement is covered in Section 7.11.",
      "zh-CHS": "第7.11节介绍了“分组”声明。"
    },
    {
      "indent": 0,
      "text": "4.2.7. Choices",
      "section_title": true,
      "zh-CHS": "4.2.7. 选择"
    },
    {
      "indent": 3,
      "text": "YANG allows the data model to segregate incompatible nodes into distinct choices using the \"choice\" and \"case\" statements. The \"choice\" statement contains a set of \"case\" statements that define sets of schema nodes that cannot appear together. Each \"case\" may contain multiple nodes, but each node may appear in only one \"case\" under a \"choice\".",
      "zh-CHS": "YANG允许数据模型使用“choice”和“case”语句将不兼容的节点分隔为不同的选项。“choice”语句包含一组“case”语句，用于定义不能同时出现的模式节点集。每个“案例”可能包含多个节点，但每个节点可能仅出现在“选项”下的一个“案例”中。"
    },
    {
      "indent": 3,
      "text": "When an element from one case is created, all elements from all other cases are implicitly deleted. The device handles the enforcement of the constraint, preventing incompatibilities from existing in the configuration.",
      "zh-CHS": "创建一个案例中的元素时，隐式删除所有其他案例中的所有元素。设备处理约束的实施，防止配置中存在不兼容。"
    },
    {
      "indent": 3,
      "text": "The choice and case nodes appear only in the schema tree, not in the data tree or NETCONF messages. The additional levels of hierarchy are not needed beyond the conceptual schema.",
      "zh-CHS": "choice和case节点仅出现在模式树中，而不出现在数据树或NETCONF消息中。除了概念模式之外，不需要额外的层次结构。"
    },
    {
      "indent": 3,
      "text": "YANG Example:",
      "zh-CHS": "杨举例："
    },
    {
      "indent": 4,
      "text": " container food {\n   choice snack {\n       case sports-arena {\n           leaf pretzel {\n               type empty;\n           }\n           leaf beer {\n               type empty;\n           }\n       }\n       case late-night {\n           leaf chocolate {\n               type enumeration {\n                   enum dark;\n                   enum milk;\n                   enum first-available;\n               }\n           }\n       }\n   }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "NETCONF XML Example:",
      "zh-CHS": "NETCONF XML示例："
    },
    {
      "indent": 5,
      "text": "<food>\n  <pretzel/>\n  <beer/>\n</food>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The \"choice\" statement is covered in Section 7.9.",
      "zh-CHS": "“选择”声明见第7.9节。"
    },
    {
      "indent": 0,
      "text": "4.2.8. Extending Data Models (augment)",
      "section_title": true,
      "zh-CHS": "4.2.8. 扩展数据模型（扩充）"
    },
    {
      "indent": 3,
      "text": "YANG allows a module to insert additional nodes into data models, including both the current module (and its submodules) or an external module. This is useful for example for vendors to add vendor-specific parameters to standard data models in an interoperable way.",
      "zh-CHS": "YANG允许模块将其他节点插入数据模型，包括当前模块（及其子模块）或外部模块。例如，这对于供应商以可互操作的方式向标准数据模型添加供应商特定的参数非常有用。"
    },
    {
      "indent": 3,
      "text": "The \"augment\" statement defines the location in the data model hierarchy where new nodes are inserted, and the \"when\" statement defines the conditions when the new nodes are valid.",
      "zh-CHS": "“augment”语句定义了数据模型层次结构中插入新节点的位置，“when”语句定义了新节点有效的条件。"
    },
    {
      "indent": 3,
      "text": "YANG Example:",
      "zh-CHS": "杨举例："
    },
    {
      "indent": 5,
      "text": "augment /system/login/user {\n    when \"class != 'wheel'\";\n    leaf uid {\n        type uint16 {\n            range \"1000 .. 30000\";\n        }\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "This example defines a \"uid\" node that only is valid when the user's \"class\" is not \"wheel\".",
      "zh-CHS": "此示例定义了一个“uid”节点，该节点仅在用户的“类”不是“轮子”时有效。"
    },
    {
      "indent": 3,
      "text": "If a module augments another module, the XML representation of the data will reflect the prefix of the augmenting module. For example, if the above augmentation were in a module with prefix \"other\", the XML would look like:",
      "zh-CHS": "如果一个模块扩充了另一个模块，则数据的XML表示形式将反映扩充模块的前缀。例如，如果上述扩展位于前缀为“other”的模块中，则XML将如下所示："
    },
    {
      "indent": 3,
      "text": "NETCONF XML Example:",
      "zh-CHS": "NETCONF XML示例："
    },
    {
      "indent": 5,
      "text": "<user>\n  <name>alicew</name>\n  <full-name>Alice N. Wonderland</full-name>\n  <class>drop-out</class>\n  <other:uid>1024</other:uid>\n</user>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The \"augment\" statement is covered in Section 7.15.",
      "zh-CHS": "第7.15节介绍了“增强”声明。"
    },
    {
      "indent": 0,
      "text": "4.2.9. RPC Definitions",
      "section_title": true,
      "zh-CHS": "4.2.9. RPC定义"
    },
    {
      "indent": 3,
      "text": "YANG allows the definition of NETCONF RPCs. The operations' names, input parameters, and output parameters are modeled using YANG data definition statements.",
      "zh-CHS": "YANG允许定义NETCONF RPC。使用数据定义语句对操作的名称、输入参数和输出参数进行建模。"
    },
    {
      "indent": 3,
      "text": "YANG Example:",
      "zh-CHS": "杨举例："
    },
    {
      "indent": 5,
      "text": "rpc activate-software-image {\n    input {\n        leaf image-name {\n            type string;\n        }\n    }\n    output {\n        leaf status {\n            type string;\n        }\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "NETCONF XML Example:",
      "zh-CHS": "NETCONF XML示例："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <activate-software-image xmlns=\"http://acme.example.com/system\">\n    <image-name>acmefw-2.3</image-name>\n </activate-software-image>\n</rpc>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "<rpc-reply message-id=\"101\"\n           xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <status xmlns=\"http://acme.example.com/system\">\n    The image acmefw-2.3 is being installed.\n  </status>\n</rpc-reply>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The \"rpc\" statement is covered in Section 7.13.",
      "zh-CHS": "第7.13节介绍了“rpc”语句。"
    },
    {
      "indent": 0,
      "text": "4.2.10. Notification Definitions",
      "section_title": true,
      "zh-CHS": "4.2.10. 通知定义"
    },
    {
      "indent": 3,
      "text": "YANG allows the definition of notifications suitable for NETCONF. YANG data definition statements are used to model the content of the notification.",
      "zh-CHS": "YANG允许定义适用于NETCONF的通知。数据定义语句用于对通知的内容建模。"
    },
    {
      "indent": 3,
      "text": "YANG Example:",
      "zh-CHS": "杨举例："
    },
    {
      "indent": 5,
      "text": "notification link-failure {\n    description \"A link failure has been detected\";\n    leaf if-name {\n        type leafref {\n            path \"/interface/name\";\n        }\n    }\n    leaf if-admin-status {\n        type admin-status;\n    }\n    leaf if-oper-status {\n        type oper-status;\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "NETCONF XML Example:",
      "zh-CHS": "NETCONF XML示例："
    },
    {
      "indent": 5,
      "text": "<notification\n    xmlns=\"urn:ietf:params:netconf:capability:notification:1.0\">\n  <eventTime>2007-09-01T10:00:00Z</eventTime>\n  <link-failure xmlns=\"http://acme.example.com/system\">\n    <if-name>so-1/2/3.0</if-name>\n    <if-admin-status>up</if-admin-status>\n    <if-oper-status>down</if-oper-status>\n  </link-failure>\n</notification>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The \"notification\" statement is covered in Section 7.14.",
      "zh-CHS": "“通知”声明见第7.14节。"
    },
    {
      "indent": 0,
      "text": "5. Language Concepts",
      "section_title": true,
      "zh-CHS": "5. 语言概念"
    },
    {
      "indent": 0,
      "text": "5.1. Modules and Submodules",
      "section_title": true,
      "zh-CHS": "5.1. 模与子模"
    },
    {
      "indent": 3,
      "text": "The module is the base unit of definition in YANG. A module defines a single data model. A module can define a complete, cohesive model, or augment an existing data model with additional nodes.",
      "zh-CHS": "模块是杨定义的基本单位。模块定义单个数据模型。一个模块可以定义一个完整的、内聚的模型，或者用额外的节点扩充现有的数据模型。"
    },
    {
      "indent": 3,
      "text": "Submodules are partial modules that contribute definitions to a module. A module may include any number of submodules, but each submodule may belong to only one module.",
      "zh-CHS": "子模块是为模块提供定义的部分模块。一个模块可以包括任意数量的子模块，但每个子模块只能属于一个模块。"
    },
    {
      "indent": 3,
      "text": "The names of all standard modules and submodules MUST be unique. Developers of enterprise modules are RECOMMENDED to choose names for their modules that will have a low probability of colliding with standard or other enterprise modules, e.g., by using the enterprise or organization name as a prefix for the module name.",
      "zh-CHS": "所有标准模块和子模块的名称必须唯一。建议企业模块的开发人员为其模块选择与标准模块或其他企业模块发生冲突的可能性较低的名称，例如，使用企业或组织名称作为模块名称的前缀。"
    },
    {
      "indent": 3,
      "text": "A module uses the \"include\" statement to include its submodules, and the \"import\" statement to reference external modules. Similarly, a submodule uses the \"import\" statement to reference other modules, and uses the \"include\" statement to reference other submodules within its module. A module or submodule MUST NOT include submodules from other modules, and a submodule MUST NOT import its own module.",
      "zh-CHS": "模块使用“include”语句包含其子模块，“import”语句引用外部模块。类似地，子模块使用“import”语句引用其他模块，并使用“include”语句引用其模块内的其他子模块。模块或子模块不得包含来自其他模块的子模块，并且子模块不得导入自己的模块。"
    },
    {
      "indent": 3,
      "text": "The import and include statements are used to make definitions available to other modules and submodules:",
      "zh-CHS": "import和include语句用于将定义提供给其他模块和子模块："
    },
    {
      "indent": 3,
      "text": "o For a module or submodule to reference definitions in an external module, the external module MUST be imported.",
      "zh-CHS": "o 要使模块或子模块引用外部模块中的定义，必须导入外部模块。"
    },
    {
      "indent": 3,
      "text": "o For a module to reference definitions in one of its submodules, the module MUST include the submodule.",
      "zh-CHS": "o 要使模块引用其子模块之一中的定义，该模块必须包含该子模块。"
    },
    {
      "indent": 3,
      "text": "o For a submodule to reference definitions in a second submodule of the same module, the first submodule MUST include the second submodule.",
      "zh-CHS": "o 要使子模块引用同一模块的第二个子模块中的定义，第一个子模块必须包含第二个子模块。"
    },
    {
      "indent": 3,
      "text": "There MUST NOT be any circular chains of imports or includes. For example, if submodule \"a\" includes submodule \"b\", \"b\" cannot include \"a\".",
      "zh-CHS": "不得有任何进口或包含的环形链。例如，如果子模块“a”包括子模块“b”，则“b”不能包括“a”。"
    },
    {
      "indent": 3,
      "text": "When a definition in an external module is referenced, a locally defined prefix MUST be used, followed by \":\", and then the external identifier. References to definitions in the local module MAY use the prefix notation. Since built-in data types do not belong to any module and have no prefix, references to built-in data types (e.g., int32) cannot use the prefix notation.",
      "zh-CHS": "引用外部模块中的定义时，必须使用本地定义的前缀，后跟“：”，然后是外部标识符。对本地模块中定义的引用可以使用前缀表示法。由于内置数据类型不属于任何模块且没有前缀，因此对内置数据类型（例如int32）的引用不能使用前缀表示法。"
    },
    {
      "indent": 0,
      "text": "5.1.1. Import and Include by Revision",
      "section_title": true,
      "zh-CHS": "5.1.1. 通过修订导入和包含"
    },
    {
      "indent": 3,
      "text": "Published modules evolve independently over time. In order to allow for this evolution, modules need to be imported using specific revisions. When a module is written, it uses the current revisions of other modules, based on what is available at the time. As future revisions of the imported modules are published, the importing module is unaffected and its contents are unchanged. When the author of the module is prepared to move to the most recently published revision of an imported module, the module is republished with an updated \"import\" statement. By republishing with the new revision, the authors explicitly indicate their acceptance of any changes in the imported module.",
      "zh-CHS": "已发布的模块会随着时间的推移独立演化。为了允许这种演变，需要使用特定的版本导入模块。编写模块时，它会根据当时可用的内容使用其他模块的当前版本。随着导入模块的未来版本的发布，导入模块不受影响，其内容不变。当模块的作者准备移动到导入模块的最新发布版本时，将使用更新的“导入”语句重新发布该模块。通过使用新版本重新发布，作者明确表示接受导入模块中的任何更改。"
    },
    {
      "indent": 3,
      "text": "For submodules, the issue is related but simpler. A module or submodule that includes submodules needs to specify the revision of the included submodules. If a submodule changes, any module or submodule that includes it needs to be updated.",
      "zh-CHS": "对于子模块，问题是相关的，但更简单。包含子模块的模块或子模块需要指定包含子模块的版本。如果子模块发生更改，则需要更新包含它的任何模块或子模块。"
    },
    {
      "indent": 3,
      "text": "For example, module \"b\" imports module \"a\".",
      "zh-CHS": "例如，模块“b”导入模块“a”。"
    },
    {
      "indent": 5,
      "text": "module a {\n    revision 2008-01-01 { ... }\n    grouping a {\n        leaf eh { .... }\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "module b {\n    import a {\n        prefix p;\n        revision-date 2008-01-01;\n    }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "    container bee {\n        uses p:a;\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "When the author of \"a\" publishes a new revision, the changes may not be acceptable to the author of \"b\". If the new revision is acceptable, the author of \"b\" can republish with an updated revision in the \"import\" statement.",
      "zh-CHS": "当“a”的作者发布新版本时，“b”的作者可能不接受这些更改。如果新版本可以接受，“b”的作者可以在“导入”语句中使用更新版本重新发布。"
    },
    {
      "indent": 0,
      "text": "5.1.2. Module Hierarchies",
      "section_title": true,
      "zh-CHS": "5.1.2. 模块层次结构"
    },
    {
      "indent": 3,
      "text": "YANG allows modeling of data in multiple hierarchies, where data may have more than one top-level node. Models that have multiple top-level nodes are sometimes convenient, and are supported by YANG.",
      "zh-CHS": "YANG允许在多个层次结构中对数据进行建模，其中数据可能有多个顶级节点。具有多个顶级节点的模型有时很方便，并且受到YANG的支持。"
    },
    {
      "indent": 3,
      "text": "NETCONF is capable of carrying any XML content as the payload in the <config> and <data> elements. The top-level nodes of YANG modules are encoded as child elements, in any order, within these elements. This encapsulation guarantees that the corresponding NETCONF messages are always well-formed XML documents.",
      "zh-CHS": "NETCONF能够在<config>和<data>元素中承载任何XML内容作为有效负载。YANG模块的顶级节点在这些元素中以任意顺序编码为子元素。这种封装保证了相应的NETCONF消息始终是格式良好的XML文档。"
    },
    {
      "indent": 3,
      "text": "For example:",
      "zh-CHS": "例如："
    },
    {
      "indent": 5,
      "text": "module my-config {\n    namespace \"http://example.com/schema/config\";\n    prefix \"co\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "    container system { ... }\n    container routing { ... }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "could be encoded in NETCONF as:",
      "zh-CHS": "可以在NETCONF中编码为："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <edit-config>\n    <target>\n      <running/>\n    </target>\n    <config>\n      <system xmlns=\"http://example.com/schema/config\">\n        <!-- system data here -->\n      </system>\n      <routing xmlns=\"http://example.com/schema/config\">\n        <!-- routing data here -->\n      </routing>\n    </config>\n  </edit-config>\n</rpc>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "5.2. File Layout",
      "section_title": true,
      "zh-CHS": "5.2. 文件布局"
    },
    {
      "indent": 3,
      "text": "YANG modules and submodules are typically stored in files, one module or submodule per file. The name of the file SHOULD be of the form:",
      "zh-CHS": "模块和子模块通常存储在文件中，每个文件一个模块或子模块。文件名的格式应为："
    },
    {
      "indent": 5,
      "text": "module-or-submodule-name ['@' revision-date] ( '.yang' / '.yin' )",
      "zh-CHS": "模块或子模块名称['@'修订日期]（'.yang'/'.yin'）"
    },
    {
      "indent": 3,
      "text": "YANG compilers can find imported modules and included submodules via this convention. While the YANG language defines modules, tools may compile submodules independently for performance and manageability reasons. Errors and warnings that cannot be detected during submodule compilation may be delayed until the submodules are linked into a cohesive module.",
      "zh-CHS": "YANG编译器可以通过此约定查找导入的模块和包含的子模块。虽然YANG语言定义模块，但出于性能和可管理性的原因，工具可以独立编译子模块。在子模块编译期间无法检测到的错误和警告可能会延迟，直到子模块链接到内聚模块中。"
    },
    {
      "indent": 0,
      "text": "5.3. XML Namespaces",
      "section_title": true,
      "zh-CHS": "5.3. XML名称空间"
    },
    {
      "indent": 3,
      "text": "All YANG definitions are specified within a module that is bound to a particular XML namespace [XML-NAMES], which is a globally unique URI [RFC3986]. A NETCONF client or server uses the namespace during XML encoding of data.",
      "zh-CHS": "所有定义都在绑定到特定XML名称空间[XML-NAMES]的模块中指定，该名称空间是全局唯一的URI[RFC3986]。NETCONF客户端或服务器在数据的XML编码期间使用名称空间。"
    },
    {
      "indent": 3,
      "text": "Namespaces for modules published in RFC streams [RFC4844] MUST be assigned by IANA, see Section 14.",
      "zh-CHS": "RFC streams[RFC4844]中发布的模块名称空间必须由IANA分配，请参见第14节。"
    },
    {
      "indent": 3,
      "text": "Namespaces for private modules are assigned by the organization owning the module without a central registry. Namespace URIs MUST be chosen so they cannot collide with standard or other enterprise namespaces, for example by using the enterprise or organization name in the namespace.",
      "zh-CHS": "私有模块的名称空间由拥有该模块的组织分配，而没有中央注册表。必须选择名称空间URI，以便它们不会与标准或其他企业名称空间冲突，例如，通过在名称空间中使用企业或组织名称。"
    },
    {
      "indent": 3,
      "text": "The \"namespace\" statement is covered in Section 7.1.3.",
      "zh-CHS": "第7.1.3节介绍了“名称空间”语句。"
    },
    {
      "indent": 0,
      "text": "5.3.1. YANG XML Namespace",
      "section_title": true,
      "zh-CHS": "5.3.1. XML名称空间"
    },
    {
      "indent": 3,
      "text": "YANG defines an XML namespace for NETCONF <edit-config> operations and <error-info> content. The name of this namespace is \"urn:ietf:params:xml:ns:yang:1\".",
      "zh-CHS": "YANG为NETCONF<edit config>操作和<error info>内容定义了一个XML名称空间。此命名空间的名称为“urn:ietf:params:xml:ns:yang:1”。"
    },
    {
      "indent": 0,
      "text": "5.4. Resolving Grouping, Type, and Identity Names",
      "section_title": true,
      "zh-CHS": "5.4. 解析分组、类型和标识名"
    },
    {
      "indent": 3,
      "text": "Grouping, type, and identity names are resolved in the context in which they are defined, rather than the context in which they are used. Users of groupings, typedefs, and identities are not required to import modules or include submodules to satisfy all references made by the original definition. This behaves like static scoping in a conventional programming language.",
      "zh-CHS": "分组、类型和标识名在定义它们的上下文中解析，而不是在使用它们的上下文中解析。分组、typedef和标识的用户无需导入模块或包含子模块以满足原始定义所做的所有引用。这与传统编程语言中的静态作用域类似。"
    },
    {
      "indent": 3,
      "text": "For example, if a module defines a grouping in which a type is referenced, when the grouping is used in a second module, the type is resolved in the context of the original module, not the second module. There is no worry over conflicts if both modules define the type, since there is no ambiguity.",
      "zh-CHS": "例如，如果一个模块定义了一个引用类型的分组，则当该分组在第二个模块中使用时，该类型将在原始模块的上下文中解析，而不是在第二个模块中解析。如果两个模块都定义了类型，则不必担心冲突，因为不存在歧义。"
    },
    {
      "indent": 0,
      "text": "5.5. Nested Typedefs and Groupings",
      "section_title": true,
      "zh-CHS": "5.5. 嵌套的typedef和分组"
    },
    {
      "indent": 3,
      "text": "Typedefs and groupings may appear nested under many YANG statements, allowing these to be lexically scoped by the hierarchy under which they appear. This allows types and groupings to be defined near where they are used, rather than placing them at the top level of the hierarchy. The close proximity increases readability.",
      "zh-CHS": "typedef和groupings可能嵌套在许多YANG语句下，允许这些语句根据它们出现的层次结构在词汇上确定范围。这允许在使用类型和分组的位置附近定义它们，而不是将它们放在层次结构的顶层。近距离增加了可读性。"
    },
    {
      "indent": 3,
      "text": "Scoping also allows types to be defined without concern for naming conflicts between types in different submodules. Type names can be specified without adding leading strings designed to prevent name collisions within large modules.",
      "zh-CHS": "作用域还允许定义类型，而不必担心不同子模块中类型之间的命名冲突。可以在不添加前导字符串的情况下指定类型名，前导字符串旨在防止大型模块中的名称冲突。"
    },
    {
      "indent": 3,
      "text": "Finally, scoping allows the module author to keep types and groupings private to their module or submodule, preventing their reuse. Since only top-level types and groupings (i.e., those appearing as substatements to a module or submodule statement) can be used outside the module or submodule, the developer has more control over what pieces of their module are presented to the outside world, supporting the need to hide internal information and maintaining a boundary between what is shared with the outside world and what is kept private.",
      "zh-CHS": "最后，作用域允许模块作者将类型和分组保持为其模块或子模块的私有，从而防止其重用。由于只有顶级类型和分组（即，那些作为模块或子模块语句的子状态出现的类型和分组）可以在模块或子模块外部使用，因此开发人员可以更好地控制向外部世界显示其模块的哪些部分，支持隐藏内部信息的需要，并在与外部世界共享的信息和保密的信息之间保持界限。"
    },
    {
      "indent": 3,
      "text": "Scoped definitions MUST NOT shadow definitions at a higher scope. A type or grouping cannot be defined if a higher level in the schema hierarchy has a definition with a matching identifier.",
      "zh-CHS": "作用域定义不能在更高的作用域中隐藏定义。如果架构层次结构中的更高级别具有具有匹配标识符的定义，则无法定义类型或分组。"
    },
    {
      "indent": 3,
      "text": "A reference to an unprefixed type or grouping, or one which uses the prefix of the current module, is resolved by locating the closest matching \"typedef\" or \"grouping\" statement among the immediate substatements of each ancestor statement.",
      "zh-CHS": "通过在每个祖先语句的直接子语句中查找最匹配的“typedef”或“grouping”语句，可以解析对未固定类型或分组或使用当前模块前缀的类型或分组的引用。"
    },
    {
      "indent": 0,
      "text": "5.6. Conformance",
      "section_title": true,
      "zh-CHS": "5.6. 一致性"
    },
    {
      "indent": 3,
      "text": "Conformance is a measure of how accurately a device follows the model. Generally speaking, devices are responsible for implementing the model faithfully, allowing applications to treat devices which implement the model identically. Deviations from the model can reduce the utility of the model and increase fragility of applications that use it.",
      "zh-CHS": "一致性是衡量设备遵循模型的准确程度。一般来说，设备负责忠实地实现模型，允许应用程序以相同的方式处理实现模型的设备。偏离模型会降低模型的实用性，并增加使用它的应用程序的脆弱性。"
    },
    {
      "indent": 3,
      "text": "YANG modelers have three mechanisms for conformance:",
      "zh-CHS": "YANG建模者有三种一致性机制："
    },
    {
      "indent": 3,
      "text": "o the basic behavior of the model",
      "zh-CHS": "o 模型的基本行为"
    },
    {
      "indent": 3,
      "text": "o optional features that are part of the model",
      "zh-CHS": "o 作为模型一部分的可选功能"
    },
    {
      "indent": 3,
      "text": "o deviations from the model",
      "zh-CHS": "o 与模型的偏差"
    },
    {
      "indent": 3,
      "text": "We will consider each of these in sequence.",
      "zh-CHS": "我们将依次考虑每一个问题。"
    },
    {
      "indent": 0,
      "text": "5.6.1. Basic Behavior",
      "section_title": true,
      "zh-CHS": "5.6.1. 基本行为"
    },
    {
      "indent": 3,
      "text": "The model defines a contract between the NETCONF client and server, which allows both parties to have faith the other knows the syntax and semantics behind the modeled data. The strength of YANG lies in the strength of this contract.",
      "zh-CHS": "该模型在NETCONF客户机和服务器之间定义了一个契约，它允许双方相信对方知道建模数据背后的语法和语义。杨的力量在于这份合同的力量。"
    },
    {
      "indent": 0,
      "text": "5.6.2. Optional Features",
      "section_title": true,
      "zh-CHS": "5.6.2. 可选功能"
    },
    {
      "indent": 3,
      "text": "In many models, the modeler will allow sections of the model to be conditional. The device controls whether these conditional portions of the model are supported or valid for that particular device.",
      "zh-CHS": "在许多模型中，建模者将允许模型的部分是有条件的。该设备控制模型的这些条件部分对于该特定设备是否受支持或有效。"
    },
    {
      "indent": 3,
      "text": "For example, a syslog data model may choose to include the ability to save logs locally, but the modeler will realize that this is only possible if the device has local storage. If there is no local storage, an application should not tell the device to save logs.",
      "zh-CHS": "例如，syslog数据模型可能会选择包含本地保存日志的功能，但建模者会意识到，只有当设备具有本地存储时，这才是可能的。如果没有本地存储，应用程序不应告诉设备保存日志。"
    },
    {
      "indent": 3,
      "text": "YANG supports this conditional mechanism using a construct called \"feature\". Features give the modeler a mechanism for making portions of the module conditional in a manner that is controlled by the device. The model can express constructs that are not universally present in all devices. These features are included in the model definition, allowing a consistent view and allowing applications to learn which features are supported and tailor their behavior to the device.",
      "zh-CHS": "YANG使用一种称为“特征”的结构来支持这种条件机制。特性为建模者提供了一种机制，使模块的某些部分以设备控制的方式有条件。该模型可以表示并非所有设备中都普遍存在的结构。这些功能包含在模型定义中，允许一致的视图，允许应用程序了解支持哪些功能，并根据设备调整其行为。"
    },
    {
      "indent": 3,
      "text": "A module may declare any number of features, identified by simple strings, and may make portions of the module optional based on those features. If the device supports a feature, then the corresponding portions of the module are valid for that device. If the device doesn't support the feature, those parts of the module are not valid, and applications should behave accordingly.",
      "zh-CHS": "一个模块可以声明任意数量的特性，由简单字符串标识，并且可以基于这些特性使模块的部分成为可选的。如果设备支持功能，则模块的相应部分对该设备有效。如果设备不支持该功能，则模块的这些部分无效，应用程序应相应运行。"
    },
    {
      "indent": 3,
      "text": "Features are defined using the \"feature\" statement. Definitions in the module that are conditional to the feature are noted by the \"if-feature\" statement with the name of the feature as its argument.",
      "zh-CHS": "使用“功能”语句定义功能。模块中与功能相关的定义由“if feature”语句注释，该语句以功能的名称作为参数。"
    },
    {
      "indent": 3,
      "text": "Further details are available in Section 7.18.1.",
      "zh-CHS": "更多详情见第7.18.1节。"
    },
    {
      "indent": 0,
      "text": "5.6.3. Deviations",
      "section_title": true,
      "zh-CHS": "5.6.3. 偏差"
    },
    {
      "indent": 3,
      "text": "In an ideal world, all devices would be required to implement the model exactly as defined, and deviations from the model would not be allowed. But in the real world, devices are often not able or designed to implement the model as written. For YANG-based",
      "zh-CHS": "在理想情况下，所有设备都需要完全按照定义实现模型，并且不允许偏离模型。但在现实世界中，设备往往无法或设计为实现所编写的模型。以杨为基础"
    },
    {
      "indent": 3,
      "text": "automation to deal with these device deviations, a mechanism must exist for devices to inform applications of the specifics of such deviations.",
      "zh-CHS": "自动化为了处理这些设备偏差，必须为设备提供一种机制，以告知应用程序此类偏差的具体情况。"
    },
    {
      "indent": 3,
      "text": "For example, a BGP module may allow any number of BGP peers, but a particular device may only support 16 BGP peers. Any application configuring the 17th peer will receive an error. While an error may suffice to let the application know it cannot add another peer, it would be far better if the application had prior knowledge of this limitation and could prevent the user from starting down the path that could not succeed.",
      "zh-CHS": "例如，BGP模块可允许任意数量的BGP对等点，但特定设备可仅支持16个BGP对等点。任何配置第17个对等点的应用程序都将收到错误。虽然一个错误可能足以让应用程序知道它无法添加另一个对等点，但如果应用程序事先知道这一限制，并且可以阻止用户沿着无法成功的路径启动，那就更好了。"
    },
    {
      "indent": 3,
      "text": "Device deviations are declared using the \"deviation\" statement, which takes as its argument a string that identifies a node in the schema tree. The contents of the statement details the manner in which the device implementation deviates from the contract as defined in the module.",
      "zh-CHS": "设备偏差是使用“偏差”语句声明的，该语句以标识模式树中节点的字符串作为参数。声明的内容详细说明了设备实现偏离模块中定义的契约的方式。"
    },
    {
      "indent": 3,
      "text": "Further details are available in Section 7.18.3.",
      "zh-CHS": "更多详情见第7.18.3节。"
    },
    {
      "indent": 0,
      "text": "5.6.4. Announcing Conformance Information in the <hello> Message",
      "section_title": true,
      "zh-CHS": "5.6.4. 在<hello>消息中宣布一致性信息"
    },
    {
      "indent": 3,
      "text": "The namespace URI MUST be advertised as a capability in the NETCONF <hello> message to indicate support for the YANG module by a NETCONF server. The capability URI advertised MUST be of the form:",
      "zh-CHS": "名称空间URI必须在NETCONF<hello>消息中作为一种功能发布，以指示NETCONF服务器对模块的支持。播发的功能URI的格式必须为："
    },
    {
      "indent": 5,
      "text": "capability-string   = namespace-uri [ parameter-list ]\nparameter-list      = \"?\" parameter *( \"&\" parameter )\nparameter           = revision-parameter /\n                      module-parameter /\n                      feature-parameter /\n                      deviation-parameter\nrevision-parameter  = \"revision=\" revision-date\nmodule-parameter    = \"module=\" module-name\nfeature-parameter   = \"features=\" feature *( \",\" feature )\ndeviation-parameter = \"deviations=\" deviation *( \",\" deviation )",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Where \"revision-date\" is the revision of the module (see Section 7.1.9) that the NETCONF server implements, \"module-name\" is the name of module as it appears in the \"module\" statement (see Section 7.1), \"namespace-uri\" is the namespace URI for the module as it appears in the \"namespace\" statement (see Section 7.1.3), \"feature\" is the name of an optional feature implemented by the device (see Section 7.18.1), and \"deviation\" is the name of a module defining device deviations (see Section 7.18.3).",
      "zh-CHS": "其中，“修订日期”是NETCONF服务器实现的模块修订版（见第7.1.9节），“模块名称”是“模块”语句中出现的模块名称（见第7.1节），“名称空间uri”是“名称空间”语句中出现的模块名称空间uri（见第7.1.3节），“功能”是设备实现的可选功能的名称（见第7.18.1节），“偏差”是定义设备偏差的模块名称（见第7.18.3节）。"
    },
    {
      "indent": 3,
      "text": "In the parameter list, each named parameter MUST occur at most once.",
      "zh-CHS": "在参数列表中，每个命名参数最多只能出现一次。"
    },
    {
      "indent": 0,
      "text": "5.6.4.1. Modules",
      "section_title": true,
      "zh-CHS": "5.6.4.1. 模块"
    },
    {
      "indent": 3,
      "text": "Servers indicate the names of supported modules via the <hello> message. Module namespaces are encoded as the base URI in the capability string, and the module name is encoded as the \"module\" parameter to the base URI.",
      "zh-CHS": "服务器通过<hello>消息指示受支持模块的名称。模块名称空间编码为功能字符串中的基本URI，模块名称编码为基本URI的“模块”参数。"
    },
    {
      "indent": 3,
      "text": "A server MUST advertise all revisions of all modules it implements.",
      "zh-CHS": "服务器必须公布其实现的所有模块的所有版本。"
    },
    {
      "indent": 3,
      "text": "For example, this <hello> message advertises one module \"syslog\".",
      "zh-CHS": "例如，此<hello>消息播发一个模块“syslog”。"
    },
    {
      "indent": 3,
      "text": "<hello xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <capability>\n    http://example.com/syslog?module=syslog&amp;revision=2008-04-01\n  </capability>\n</hello>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "5.6.4.2. Features",
      "section_title": true,
      "zh-CHS": "5.6.4.2. 特征"
    },
    {
      "indent": 3,
      "text": "Servers indicate the names of supported features via the <hello> message. In <hello> messages, the features are encoded in the \"features\" parameter within the URI. The value of this parameter is a comma-separated list of feature names that the device supports for the specific module.",
      "zh-CHS": "服务器通过<hello>消息指示受支持功能的名称。在<hello>消息中，功能在URI中的“features”参数中编码。此参数的值是设备支持特定模块的功能名称的逗号分隔列表。"
    },
    {
      "indent": 0,
      "text": "   For example, this <hello> message advertises one module, informing\n   the client that it supports the \"local-storage\" feature of module\n   \"syslog\".\n<hello xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <capability>\n    http://example.com/syslog?module=syslog&amp;features=local-storage\n  </capability>\n</hello>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "5.6.4.3. Deviations",
      "section_title": true,
      "zh-CHS": "5.6.4.3. 偏差"
    },
    {
      "indent": 3,
      "text": "Device deviations are announced via the \"deviations\" parameter. The value of the \"deviations\" parameter is a comma-separated list of modules containing deviations from the capability's module.",
      "zh-CHS": "通过“偏差”参数宣布设备偏差。“偏差”参数的值是以逗号分隔的模块列表，其中包含与能力模块的偏差。"
    },
    {
      "indent": 3,
      "text": "For example, this <hello> message advertises two modules, informing the client that it deviates from module \"syslog\" according to the deviations listed in the module \"my-devs\".",
      "zh-CHS": "例如，此<hello>消息播发两个模块，通知客户机它根据模块“my devs”中列出的偏差偏离了模块“syslog”。"
    },
    {
      "indent": 3,
      "text": "<hello xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n    <capability>\n      http://example.com/syslog?module=syslog&amp;deviations=my-devs\n    </capability>\n    <capability>\n      http://example.com/my-deviations?module=my-devs\n    </capability>\n  </hello>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "5.7. Data Store Modification",
      "section_title": true,
      "zh-CHS": "5.7. 数据存储修改"
    },
    {
      "indent": 3,
      "text": "Data models may allow the server to alter the configuration data store in ways not explicitly directed via NETCONF protocol messages. For example, a data model may define leafs that are assigned system-generated values when the client does not provide one. A formal mechanism for specifying the circumstances where these changes are allowed is out of scope for this specification.",
      "zh-CHS": "数据模型可能允许服务器以NETCONF协议消息未明确指示的方式更改配置数据存储。例如，数据模型可以定义在客户端不提供时分配给系统生成值的LEAF。用于指定允许这些更改的情况的正式机制超出了本规范的范围。"
    },
    {
      "indent": 0,
      "text": "6. YANG Syntax",
      "section_title": true,
      "zh-CHS": "6. 阳语法"
    },
    {
      "indent": 3,
      "text": "The YANG syntax is similar to that of SMIng [RFC3780] and programming languages like C and C++. This C-like syntax was chosen specifically for its readability, since YANG values the time and effort of the readers of models above those of modules writers and YANG tool-chain developers. This section introduces the YANG syntax.",
      "zh-CHS": "杨语法类似于SMI[RCF380]和C语言和C++语言。这种类似C的语法是专门为其可读性而选择的，因为YANG重视模型读者的时间和精力，而不是模块作者和YANG工具链开发人员的时间和精力。本节介绍YANG语法。"
    },
    {
      "indent": 3,
      "text": "YANG modules use the UTF-8 [RFC3629] character encoding.",
      "zh-CHS": "模块使用UTF-8[RFC3629]字符编码。"
    },
    {
      "indent": 0,
      "text": "6.1. Lexical Tokenization",
      "section_title": true,
      "zh-CHS": "6.1. 词汇标记化"
    },
    {
      "indent": 3,
      "text": "YANG modules are parsed as a series of tokens. This section details the rules for recognizing tokens from an input stream. YANG tokenization rules are both simple and powerful. The simplicity is driven by a need to keep the parsers easy to implement, while the power is driven by the fact that modelers need to express their models in readable formats.",
      "zh-CHS": "YANG模块被解析为一系列标记。本节详细介绍了从输入流识别令牌的规则。YANG标记化规则既简单又强大。简单性是由保持解析器易于实现的需要驱动的，而强大的驱动力是由建模者需要以可读的格式表达他们的模型这一事实驱动的。"
    },
    {
      "indent": 0,
      "text": "6.1.1. Comments",
      "section_title": true,
      "zh-CHS": "6.1.1. 评论"
    },
    {
      "indent": 3,
      "text": "Comments are C++ style. A single line comment starts with \"//\" and ends at the end of the line. A block comment is enclosed within \"/*\" and \"*/\".",
      "zh-CHS": "注释是C++风格。单行注释以“/”开头，并在行尾结束。块注释包含在“/*”和“*/”中。"
    },
    {
      "indent": 0,
      "text": "6.1.2. Tokens",
      "section_title": true,
      "zh-CHS": "6.1.2. 代币"
    },
    {
      "indent": 3,
      "text": "A token in YANG is either a keyword, a string, a semicolon (\";\"), or braces (\"{\" or \"}\"). A string can be quoted or unquoted. A keyword is either one of the YANG keywords defined in this document, or a",
      "zh-CHS": "YANG中的标记可以是关键字、字符串、分号（“；”）或大括号（“{”或“}”）。字符串可以是带引号的或不带引号的。关键字可以是本文档中定义的关键字之一，也可以是"
    },
    {
      "indent": 3,
      "text": "prefix identifier, followed by \":\", followed by a language extension keyword. Keywords are case sensitive. See Section 6.2 for a formal definition of identifiers.",
      "zh-CHS": "前缀标识符，后跟“：”，后跟语言扩展关键字。关键字区分大小写。标识符的正式定义见第6.2节。"
    },
    {
      "indent": 0,
      "text": "6.1.3. Quoting",
      "section_title": true,
      "zh-CHS": "6.1.3. 引用"
    },
    {
      "indent": 3,
      "text": "If a string contains any space or tab characters, a semicolon (\";\"), braces (\"{\" or \"}\"), or comment sequences (\"//\", \"/*\", or \"*/\"), then it MUST be enclosed within double or single quotes.",
      "zh-CHS": "如果字符串包含任何空格或制表符、分号（“；”）、大括号（“{”或“}”）或注释序列（“//”、“/*”）或“*/”），则必须将其括在双引号或单引号内。"
    },
    {
      "indent": 3,
      "text": "If the double-quoted string contains a line break followed by space or tab characters that are used to indent the text according to the layout in the YANG file, this leading whitespace is stripped from the string, up to and including the column of the double quote character, or to the first non-whitespace character, whichever occurs first. In this process, a tab character is treated as 8 space characters.",
      "zh-CHS": "如果双引号字符串包含一个换行符，后跟空格或制表符，用于根据YANG文件中的布局缩进文本，则该前导空格将从字符串中删除，直至并包括双引号字符的列，或第一个非空格字符，以先出现的为准。在此过程中，制表符被视为8个空格字符。"
    },
    {
      "indent": 3,
      "text": "If the double-quoted string contains space or tab characters before a line break, this trailing whitespace is stripped from the string.",
      "zh-CHS": "如果双引号字符串在换行符之前包含空格或制表符，则会从字符串中删除该尾随空格。"
    },
    {
      "indent": 3,
      "text": "A single-quoted string (enclosed within ' ') preserves each character within the quotes. A single quote character cannot occur in a single-quoted string, even when preceded by a backslash.",
      "zh-CHS": "单引号字符串（括在“”中）保留引号中的每个字符。单引号字符不能出现在单引号字符串中，即使前面有反斜杠。"
    },
    {
      "indent": 3,
      "text": "Within a double-quoted string (enclosed within \" \"), a backslash character introduces a special character, which depends on the character that immediately follows the backslash:",
      "zh-CHS": "在双引号字符串（括在“”中）中，反斜杠字符引入一个特殊字符，该字符取决于紧跟在反斜杠后面的字符："
    },
    {
      "indent": 4,
      "text": "\\n new line \\t a tab character \\\" a double quote \\\\ a single backslash",
      "zh-CHS": "\\n新行\\t制表符\\“双引号\\\\单反斜杠”"
    },
    {
      "indent": 3,
      "text": "If a quoted string is followed by a plus character (\"+\"), followed by another quoted string, the two strings are concatenated into one string, allowing multiple concatenations to build one string. Whitespace trimming and substitution of backslash-escaped characters in double-quoted strings is done before concatenation.",
      "zh-CHS": "如果一个带引号的字符串后跟一个加号（“+”），后跟另一个带引号的字符串，则这两个字符串将连接成一个字符串，从而允许多个连接生成一个字符串。双引号字符串中的空格修剪和反斜杠转义字符替换在连接之前完成。"
    },
    {
      "indent": 0,
      "text": "6.1.3.1. Quoting Examples",
      "section_title": true,
      "zh-CHS": "6.1.3.1. 举出例子"
    },
    {
      "indent": 3,
      "text": "The following strings are equivalent:",
      "zh-CHS": "以下字符串是等效的："
    },
    {
      "indent": 5,
      "text": "hello \"hello\" 'hello' \"hel\" + \"lo\" 'hel' + \"lo\"",
      "zh-CHS": "喂喂喂喂喂喂喂喂喂喂喂喂喂喂喂喂喂喂喂喂喂喂喂喂喂喂喂喂喂"
    },
    {
      "indent": 3,
      "text": "The following examples show some special strings:",
      "zh-CHS": "以下示例显示了一些特殊字符串："
    },
    {
      "indent": 5,
      "text": "\"\\\"\" - string containing a double quote '\"' - string containing a double quote \"\\n\" - string containing a new line character '\\n' - string containing a backslash followed by the character n",
      "zh-CHS": "“\\”“-包含双引号的字符串”-包含双引号的字符串“\\n”-包含新行字符“\\n”-包含反斜杠后跟字符n的字符串"
    },
    {
      "indent": 3,
      "text": "The following examples show some illegal strings:",
      "zh-CHS": "以下示例显示了一些非法字符串："
    },
    {
      "indent": 5,
      "text": "'''' - a single-quoted string cannot contain single quotes \"\"\" - a double quote must be escaped in a double-quoted string",
      "zh-CHS": "“”“”-单引号字符串不能包含单引号“”-双引号字符串中必须转义双引号"
    },
    {
      "indent": 3,
      "text": "The following strings are equivalent:",
      "zh-CHS": "以下字符串是等效的："
    },
    {
      "indent": 9,
      "text": "\"first line second line\"",
      "zh-CHS": "“第一行第二行”"
    },
    {
      "indent": 5,
      "text": "\"first line\\n\" + \" second line\"",
      "zh-CHS": "“第一行\\n”+“第二行”"
    },
    {
      "indent": 0,
      "text": "6.2. Identifiers",
      "section_title": true,
      "zh-CHS": "6.2. 标识符"
    },
    {
      "indent": 3,
      "text": "Identifiers are used to identify different kinds of YANG items by name. Each identifier starts with an uppercase or lowercase ASCII letter or an underscore character, followed by zero or more ASCII letters, digits, underscore characters, hyphens, and dots. Implementations MUST support identifiers up to 64 characters in length. Identifiers are case sensitive. The identifier syntax is formally defined by the rule \"identifier\" in Section 12. Identifiers can be specified as quoted or unquoted strings.",
      "zh-CHS": "标识符用于按名称标识不同种类的项目。每个标识符以大写或小写ASCII字母或下划线字符开头，后跟零个或多个ASCII字母、数字、下划线字符、连字符和点。实现必须支持长度不超过64个字符的标识符。标识符区分大小写。标识符语法由第12节中的“标识符”规则正式定义。标识符可以指定为带引号或不带引号的字符串。"
    },
    {
      "indent": 0,
      "text": "6.2.1. Identifiers and Their Namespaces",
      "section_title": true,
      "zh-CHS": "6.2.1. 标识符及其名称空间"
    },
    {
      "indent": 3,
      "text": "Each identifier is valid in a namespace that depends on the type of the YANG item being defined. All identifiers defined in a namespace MUST be unique.",
      "zh-CHS": "每个标识符在命名空间中都是有效的，该命名空间取决于所定义项的类型。命名空间中定义的所有标识符都必须是唯一的。"
    },
    {
      "indent": 3,
      "text": "o All module and submodule names share the same global module identifier namespace.",
      "zh-CHS": "o 所有模块和子模块名称共享相同的全局模块标识符命名空间。"
    },
    {
      "indent": 3,
      "text": "o All extension names defined in a module and its submodules share the same extension identifier namespace.",
      "zh-CHS": "o 模块及其子模块中定义的所有扩展名共享相同的扩展标识符命名空间。"
    },
    {
      "indent": 3,
      "text": "o All feature names defined in a module and its submodules share the same feature identifier namespace.",
      "zh-CHS": "o 模块及其子模块中定义的所有功能名称共享相同的功能标识符命名空间。"
    },
    {
      "indent": 3,
      "text": "o All identity names defined in a module and its submodules share the same identity identifier namespace.",
      "zh-CHS": "o 模块及其子模块中定义的所有标识名共享相同的标识标识符命名空间。"
    },
    {
      "indent": 3,
      "text": "o All derived type names defined within a parent node or at the top level of the module or its submodules share the same type identifier namespace. This namespace is scoped to all descendant nodes of the parent node or module. This means that any descendent node may use that typedef, and it MUST NOT define a typedef with the same name.",
      "zh-CHS": "o 在父节点内或在模块或其子模块的顶层定义的所有派生类型名称共享相同的类型标识符命名空间。此命名空间的作用域为父节点或模块的所有子节点。这意味着任何子节点都可以使用该typedef，并且它不能定义具有相同名称的typedef。"
    },
    {
      "indent": 3,
      "text": "o All grouping names defined within a parent node or at the top level of the module or its submodules share the same grouping identifier namespace. This namespace is scoped to all descendant nodes of the parent node or module. This means that any descendent node may use that grouping, and it MUST NOT define a grouping with the same name.",
      "zh-CHS": "o 在父节点内或在模块或其子模块的顶层定义的所有分组名称共享相同的分组标识符命名空间。此命名空间的作用域为父节点或模块的所有子节点。这意味着任何子节点都可以使用该分组，并且不能使用相同的名称定义分组。"
    },
    {
      "indent": 3,
      "text": "o All leafs, leaf-lists, lists, containers, choices, rpcs, notifications, and anyxmls defined (directly or through a uses statement) within a parent node or at the top level of the module or its submodules share the same identifier namespace. This namespace is scoped to the parent node or module, unless the parent node is a case node. In that case, the namespace is scoped to the closest ancestor node that is not a case or choice node.",
      "zh-CHS": "o 父节点内或模块或其子模块顶层定义的所有叶、叶列表、列表、容器、选项、RPC、通知和任何XML（直接或通过uses语句）共享相同的标识符命名空间。除非父节点是案例节点，否则此命名空间的作用域为父节点或模块。在这种情况下，名称空间的作用域是最接近的祖先节点，该节点不是case或choice节点。"
    },
    {
      "indent": 3,
      "text": "o All cases within a choice share the same case identifier namespace. This namespace is scoped to the parent choice node.",
      "zh-CHS": "o 选项中的所有案例共享相同的案例标识符命名空间。此命名空间的作用域为父选择节点。"
    },
    {
      "indent": 3,
      "text": "Forward references are allowed in YANG.",
      "zh-CHS": "在YANG中允许向前引用。"
    },
    {
      "indent": 0,
      "text": "6.3. Statements",
      "section_title": true,
      "zh-CHS": "6.3. 声明"
    },
    {
      "indent": 3,
      "text": "A YANG module contains a sequence of statements. Each statement starts with a keyword, followed by zero or one argument, followed either by a semicolon (\";\") or a block of substatements enclosed within braces (\"{ }\"):",
      "zh-CHS": "模块包含一系列语句。每个语句都以关键字开头，后跟零或一个参数，后跟分号（；）或大括号（{}）中包含的子语句块："
    },
    {
      "indent": 5,
      "text": "statement = keyword [argument] (\";\" / \"{\" *statement \"}\")",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The argument is a string, as defined in Section 6.1.2.",
      "zh-CHS": "参数是一个字符串，如第6.1.2节所定义。"
    },
    {
      "indent": 0,
      "text": "6.3.1. Language Extensions",
      "section_title": true,
      "zh-CHS": "6.3.1. 语言外延"
    },
    {
      "indent": 3,
      "text": "A module can introduce YANG extensions by using the \"extension\" keyword (see Section 7.17). The extensions can be imported by other modules with the \"import\" statement (see Section 7.1.5). When an imported extension is used, the extension's keyword MUST be qualified using the prefix with which the extension's module was imported. If an extension is used in the module where it is defined, the extension's keyword MUST be qualified with the module's prefix.",
      "zh-CHS": "模块可以使用“extension”关键字引入YANG扩展（参见第7.17节）。其他模块可以使用“导入”语句导入扩展（参见第7.1.5节）。使用导入的扩展时，必须使用导入扩展模块时使用的前缀限定扩展的关键字。如果在定义扩展的模块中使用扩展，则扩展的关键字必须使用模块的前缀限定。"
    },
    {
      "indent": 3,
      "text": "Since submodules cannot include the parent module, any extensions in the module that need to be exposed to submodules MUST be defined in a submodule. Submodules can then include this submodule to find the definition of the extension.",
      "zh-CHS": "由于子模块不能包含父模块，因此必须在子模块中定义模块中需要向子模块公开的任何扩展。然后子模块可以包含此子模块以查找扩展的定义。"
    },
    {
      "indent": 3,
      "text": "If a YANG compiler does not support a particular extension, which appears in a YANG module as an unknown-statement (see Section 12), the entire unknown-statement MAY be ignored by the compiler.",
      "zh-CHS": "如果YANG编译器不支持特定的扩展，该扩展在YANG模块中作为未知语句出现（参见第12节），编译器可能会忽略整个未知语句。"
    },
    {
      "indent": 0,
      "text": "6.4. XPath Evaluations",
      "section_title": true,
      "zh-CHS": "6.4. XPath求值"
    },
    {
      "indent": 3,
      "text": "YANG relies on XML Path Language (XPath) 1.0 [XPATH] as a notation for specifying many inter-node references and dependencies. NETCONF clients and servers are not required to implement an XPath interpreter, but MUST ensure that the requirements encoded in the data model are enforced. The manner of enforcement is an implementation decision. The XPath expressions MUST be syntactically correct, and all prefixes used MUST be present in the XPath context (see Section 6.4.1). An implementation may choose to implement them by hand, rather than using the XPath expression directly.",
      "zh-CHS": "YANG依赖XML路径语言（XPath）1.0[XPath]作为指定许多节点间引用和依赖关系的表示法。NETCONF客户端和服务器不需要实现XPath解释器，但必须确保数据模型中编码的要求得到实施。执行方式是一项执行决定。XPath表达式必须语法正确，并且使用的所有前缀必须出现在XPath上下文中（请参见第6.4.1节）。实现可以选择手工实现，而不是直接使用XPath表达式。"
    },
    {
      "indent": 3,
      "text": "The data model used in the XPath expressions is the same as that used in XPath 1.0 [XPATH], with the same extension for root node children as used by XSLT 1.0 [XSLT] (Section 3.1). Specifically, it means that the root node may have any number of element nodes as its children.",
      "zh-CHS": "XPath表达式中使用的数据模型与XPath 1.0[XPath]中使用的数据模型相同，根节点子节点的扩展与XSLT 1.0[XSLT]使用的扩展相同（第3.1节）。具体来说，这意味着根节点可以有任意数量的元素节点作为其子节点。"
    },
    {
      "indent": 0,
      "text": "6.4.1. XPath Context",
      "section_title": true,
      "zh-CHS": "6.4.1. XPath上下文"
    },
    {
      "indent": 3,
      "text": "All YANG XPath expressions share the following XPath context definition:",
      "zh-CHS": "所有XPath表达式共享以下XPath上下文定义："
    },
    {
      "indent": 3,
      "text": "o The set of namespace declarations is the set of all \"import\" statements' prefix and namespace pairs in the module where the XPath expression is specified, and the \"prefix\" statement's prefix for the \"namespace\" statement's URI.",
      "zh-CHS": "o 名称空间声明集是指定XPath表达式的模块中所有“导入”语句的前缀和名称空间对的集合，以及“名称空间”语句URI的“前缀”语句的前缀。"
    },
    {
      "indent": 3,
      "text": "o Names without a namespace prefix belong to the same namespace as the identifier of the current node. Inside a grouping, that namespace is affected by where the grouping is used (see Section 7.12).",
      "zh-CHS": "o 没有名称空间前缀的名称与当前节点的标识符属于同一名称空间。在分组中，名称空间受分组使用位置的影响（参见第7.12节）。"
    },
    {
      "indent": 3,
      "text": "o The function library is the core function library defined in [XPATH], and a function \"current()\" that returns a node set with the initial context node.",
      "zh-CHS": "o 函数库是[XPATH]中定义的核心函数库，是一个函数“current（）”，返回带有初始上下文节点的节点集。"
    },
    {
      "indent": 3,
      "text": "o The set of variable bindings is empty.",
      "zh-CHS": "o 变量绑定集为空。"
    },
    {
      "indent": 3,
      "text": "The mechanism for handling unprefixed names is adopted from XPath 2.0 [XPATH2.0], and helps simplify XPath expressions in YANG. No ambiguity may ever arise because YANG node identifiers are always qualified names with a non-null namespace URI.",
      "zh-CHS": "处理不固定名称的机制采用XPATH2.0[XPATH2.0]，有助于简化XML中的XPath表达式。不会出现歧义，因为节点标识符始终是具有非空命名空间URI的限定名称。"
    },
    {
      "indent": 3,
      "text": "The context node varies with the YANG XPath expression, and is specified where the YANG statement with the XPath expression is defined.",
      "zh-CHS": "上下文节点随YANG XPath表达式的不同而变化，并在定义带有XPath表达式的YANG语句的位置指定。"
    },
    {
      "indent": 0,
      "text": "6.5. Schema Node Identifier",
      "section_title": true,
      "zh-CHS": "6.5. 模式节点标识符"
    },
    {
      "indent": 3,
      "text": "A schema node identifier is a string that identifies a node in the schema tree. It has two forms, \"absolute\" and \"descendant\", defined by the rules \"absolute-schema-nodeid\" and \"descendant-schema-nodeid\" in Section 12, respectively. A schema node identifier consists of a path of identifiers, separated by slashes (\"/\"). In an absolute schema node identifier, the first identifier after the leading slash is any top-level schema node in the local module or in all imported modules.",
      "zh-CHS": "架构节点标识符是标识架构树中节点的字符串。它有两种形式，“绝对”和“后代”，分别由第12节中的规则“绝对模式节点ID”和“后代模式节点ID”定义。架构节点标识符由标识符路径组成，由斜杠（“/”）分隔。在绝对模式节点标识符中，前导斜杠后的第一个标识符是本地模块或所有导入模块中的任何顶级模式节点。"
    },
    {
      "indent": 3,
      "text": "References to identifiers defined in external modules MUST be qualified with appropriate prefixes, and references to identifiers defined in the current module and its submodules MAY use a prefix.",
      "zh-CHS": "对外部模块中定义的标识符的引用必须使用适当的前缀进行限定，对当前模块及其子模块中定义的标识符的引用可以使用前缀。"
    },
    {
      "indent": 3,
      "text": "For example, to identify the child node \"b\" of top-level node \"a\", the string \"/a/b\" can be used.",
      "zh-CHS": "例如，要标识顶级节点“a”的子节点“b”，可以使用字符串“/a/b”。"
    },
    {
      "indent": 0,
      "text": "7. YANG Statements",
      "section_title": true,
      "zh-CHS": "7. 杨声明"
    },
    {
      "indent": 3,
      "text": "The following sections describe all of the YANG statements.",
      "zh-CHS": "以下各节描述了所有杨陈述。"
    },
    {
      "indent": 3,
      "text": "Note that even a statement that does not have any substatements defined in YANG can have vendor-specific extensions as substatements. For example, the \"description\" statement does not have any substatements defined in YANG, but the following is legal:",
      "zh-CHS": "请注意，即使没有在YANG中定义任何子状态的语句也可以将特定于供应商的扩展作为子状态。例如，“description”语句在YANG中没有定义任何子语句，但以下语句是合法的："
    },
    {
      "indent": 5,
      "text": "description \"some text\" {\n    acme:documentation-flag 5;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.1. The module Statement",
      "section_title": true,
      "zh-CHS": "7.1. 模块语句"
    },
    {
      "indent": 3,
      "text": "The \"module\" statement defines the module's name, and groups all statements that belong to the module together. The \"module\" statement's argument is the name of the module, followed by a block of substatements that hold detailed module information. The module name follows the rules for identifiers in Section 6.2.",
      "zh-CHS": "“module”语句定义模块的名称，并将属于该模块的所有语句分组在一起。“module”语句的参数是模块的名称，后跟一块包含详细模块信息的子语句。模块名称遵循第6.2节中的标识符规则。"
    },
    {
      "indent": 3,
      "text": "Names of modules published in RFC streams [RFC4844] MUST be assigned by IANA, see Section 14.",
      "zh-CHS": "在RFC流[RFC4844]中发布的模块名称必须由IANA分配，见第14节。"
    },
    {
      "indent": 3,
      "text": "Private module names are assigned by the organization owning the module without a central registry. It is RECOMMENDED to choose module names that will have a low probability of colliding with standard or other enterprise modules and submodules, e.g., by using the enterprise or organization name as a prefix for the module name.",
      "zh-CHS": "私有模块名称由拥有该模块的组织分配，而无需中央注册表。建议选择与标准或其他企业模块和子模块冲突的可能性较低的模块名称，例如，使用企业或组织名称作为模块名称的前缀。"
    },
    {
      "indent": 3,
      "text": "A module typically has the following layout:",
      "zh-CHS": "模块通常具有以下布局："
    },
    {
      "indent": 5,
      "text": "module <module-name> {",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "// header information\n<yang-version statement>\n<namespace statement>\n<prefix statement>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "// linkage statements\n<import statements>\n<include statements>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "// meta information\n<organization statement>\n<contact statement>\n<description statement>\n<reference statement>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "// revision history\n<revision statements>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "    // module definitions\n    <other statements>\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.1.1. The module's Substatements",
      "section_title": true,
      "zh-CHS": "7.1.1. 模块的子状态"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| anyxml       | 7.10    | 0..n        |\n| augment      | 7.15    | 0..n        |\n| choice       | 7.9     | 0..n        |\n| contact      | 7.1.8   | 0..1        |\n| container    | 7.5     | 0..n        |\n| description  | 7.19.3  | 0..1        |\n| deviation    | 7.18.3  | 0..n        |\n| extension    | 7.17    | 0..n        |\n| feature      | 7.18.1  | 0..n        |\n| grouping     | 7.11    | 0..n        |\n| identity     | 7.16    | 0..n        |\n| import       | 7.1.5   | 0..n        |\n| include      | 7.1.6   | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| namespace    | 7.1.3   | 1           |\n| notification | 7.14    | 0..n        |\n| organization | 7.1.7   | 0..1        |\n| prefix       | 7.1.4   | 1           |\n| reference    | 7.19.4  | 0..1        |\n| revision     | 7.1.9   | 0..n        |\n| rpc          | 7.13    | 0..n        |\n| typedef      | 7.3     | 0..n        |\n| uses         | 7.12    | 0..n        |\n| yang-version | 7.1.2   | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.1.2. The yang-version Statement",
      "section_title": true,
      "zh-CHS": "7.1.2. 杨版声明"
    },
    {
      "indent": 3,
      "text": "The optional \"yang-version\" statement specifies which version of the YANG language was used in developing the module. The statement's argument is a string. If present, it MUST contain the value \"1\", which is the current YANG version and the default value.",
      "zh-CHS": "可选的“yang version”语句指定在开发模块时使用的yang语言版本。语句的参数是字符串。如果存在，它必须包含值“1”，这是当前版本和默认值。"
    },
    {
      "indent": 3,
      "text": "Handling of the \"yang-version\" statement for versions other than \"1\" (the version defined here) is out of scope for this specification. Any document that defines a higher version will need to define the backward compatibility of such a higher version.",
      "zh-CHS": "对于“1”以外的版本（此处定义的版本）处理“yang version”语句超出了本规范的范围。任何定义更高版本的文档都需要定义这样一个更高版本的向后兼容性。"
    },
    {
      "indent": 0,
      "text": "7.1.3. The namespace Statement",
      "section_title": true,
      "zh-CHS": "7.1.3. 名称空间语句"
    },
    {
      "indent": 3,
      "text": "The \"namespace\" statement defines the XML namespace that all identifiers defined by the module are qualified by, with the exception of data node identifiers defined inside a grouping (see Section 7.12 for details). The argument to the \"namespace\" statement is the URI of the namespace.",
      "zh-CHS": "“namespace”语句定义了由模块定义的所有标识符所限定的XML名称空间，分组中定义的数据节点标识符除外（有关详细信息，请参见第7.12节）。“namespace”语句的参数是名称空间的URI。"
    },
    {
      "indent": 3,
      "text": "See also Section 5.3.",
      "zh-CHS": "另见第5.3节。"
    },
    {
      "indent": 0,
      "text": "7.1.4. The prefix Statement",
      "section_title": true,
      "zh-CHS": "7.1.4. 前缀语句"
    },
    {
      "indent": 3,
      "text": "The \"prefix\" statement is used to define the prefix associated with the module and its namespace. The \"prefix\" statement's argument is the prefix string that is used as a prefix to access a module. The prefix string MAY be used to refer to definitions contained in the module, e.g., \"if:ifName\". A prefix follows the same rules as an identifier (see Section 6.2).",
      "zh-CHS": "“prefix”语句用于定义与模块及其命名空间关联的前缀。“prefix”语句的参数是用作访问模块前缀的前缀字符串。前缀字符串可用于引用模块中包含的定义，例如，“if:ifName”。前缀遵循与标识符相同的规则（见第6.2节）。"
    },
    {
      "indent": 3,
      "text": "When used inside the \"module\" statement, the \"prefix\" statement defines the prefix to be used when this module is imported. To improve readability of the NETCONF XML, a NETCONF client or server that generates XML or XPath that use prefixes SHOULD use the prefix defined by the module, unless there is a conflict.",
      "zh-CHS": "在“module”语句中使用时，“prefix”语句定义导入此模块时要使用的前缀。为了提高NETCONF XML的可读性，生成使用前缀的XML或XPath的NETCONF客户端或服务器应使用模块定义的前缀，除非存在冲突。"
    },
    {
      "indent": 3,
      "text": "When used inside the \"import\" statement, the \"prefix\" statement defines the prefix to be used when accessing definitions inside the imported module. When a reference to an identifier from the imported module is used, the prefix string for the imported module is used in combination with a colon (\":\") and the identifier, e.g., \"if: ifIndex\". To improve readability of YANG modules, the prefix defined by a module SHOULD be used when the module is imported, unless there is a conflict. If there is a conflict, i.e., two different modules that both have defined the same prefix are imported, at least one of them MUST be imported with a different prefix.",
      "zh-CHS": "在“import”语句中使用时，“prefix”语句定义访问导入模块中的定义时要使用的前缀。使用对导入模块标识符的引用时，导入模块的前缀字符串将与冒号（“：”）和标识符结合使用，例如“if:ifIndex”。为提高模块的可读性，导入模块时应使用模块定义的前缀，除非存在冲突。如果存在冲突，即导入两个定义了相同前缀的不同模块，则必须使用不同前缀导入其中至少一个模块。"
    },
    {
      "indent": 3,
      "text": "All prefixes, including the prefix for the module itself MUST be unique within the module or submodule.",
      "zh-CHS": "所有前缀（包括模块本身的前缀）在模块或子模块中必须是唯一的。"
    },
    {
      "indent": 0,
      "text": "7.1.5. The import Statement",
      "section_title": true,
      "zh-CHS": "7.1.5. 进口声明"
    },
    {
      "indent": 3,
      "text": "The \"import\" statement makes definitions from one module available inside another module or submodule. The argument is the name of the module to import, and the statement is followed by a block of substatements that holds detailed import information. When a module is imported, the importing module may:",
      "zh-CHS": "“import”语句使一个模块中的定义在另一个模块或子模块中可用。参数是要导入的模块的名称，语句后面是一个包含详细导入信息的子语句块。导入模块时，导入模块可以："
    },
    {
      "indent": 3,
      "text": "o use any grouping and typedef defined at the top level in the imported module or its submodules.",
      "zh-CHS": "o 使用在导入的模块或其子模块的顶层定义的任何分组和typedef。"
    },
    {
      "indent": 3,
      "text": "o use any extension, feature, and identity defined in the imported module or its submodules.",
      "zh-CHS": "o 使用导入的模块或其子模块中定义的任何扩展、功能和标识。"
    },
    {
      "indent": 3,
      "text": "o use any node in the imported module's schema tree in \"must\", \"path\", and \"when\" statements, or as the target node in \"augment\" and \"deviation\" statements.",
      "zh-CHS": "o 在“must”、“path”和“when”语句中使用导入模块模式树中的任何节点，或者在“augment”和“develope”语句中作为目标节点。"
    },
    {
      "indent": 3,
      "text": "The mandatory \"prefix\" substatement assigns a prefix for the imported module that is scoped to the importing module or submodule. Multiple \"import\" statements may be specified to import from different modules.",
      "zh-CHS": "必填的“prefix”子语句为导入的模块分配一个前缀，其作用域为导入模块或子模块。可以指定多个“导入”语句从不同的模块导入。"
    },
    {
      "indent": 3,
      "text": "When the optional \"revision-date\" substatement is present, any typedef, grouping, extension, feature, and identity referenced by definitions in the local module are taken from the specified revision of the imported module. It is an error if the specified revision of the imported module does not exist. If no \"revision-date\" substatement is present, it is undefined from which revision of the module they are taken.",
      "zh-CHS": "当存在可选的“修订日期”子状态时，本地模块中定义引用的任何类型定义、分组、扩展、特征和标识都将取自导入模块的指定版本。如果导入模块的指定版本不存在，则为错误。如果不存在“修订日期”子语句，则未定义从哪个版本获取这些子语句的模块。"
    },
    {
      "indent": 3,
      "text": "Multiple revisions of the same module MUST NOT be imported.",
      "zh-CHS": "不得导入同一模块的多个修订版。"
    },
    {
      "indent": 24,
      "text": "The import's Substatements",
      "zh-CHS": "导入的子语句"
    },
    {
      "indent": 17,
      "text": "+---------------+---------+-------------+\n| substatement  | section | cardinality |\n+---------------+---------+-------------+\n| prefix        | 7.1.4   | 1           |\n| revision-date | 7.1.5.1 | 0..1        |\n+---------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.1.5.1. The import's revision-date Statement",
      "section_title": true,
      "zh-CHS": "7.1.5.1. 导入的修订日期声明"
    },
    {
      "indent": 3,
      "text": "The import's \"revision-date\" statement is used to specify the exact version of the module to import. The \"revision-date\" statement MUST match the most recent \"revision\" statement in the imported module.",
      "zh-CHS": "导入的“修订日期”语句用于指定要导入的模块的确切版本。“修订日期”语句必须与导入模块中最近的“修订”语句匹配。"
    },
    {
      "indent": 0,
      "text": "7.1.6. The include Statement",
      "section_title": true,
      "zh-CHS": "7.1.6. include语句"
    },
    {
      "indent": 3,
      "text": "The \"include\" statement is used to make content from a submodule available to that submodule's parent module, or to another submodule of that parent module. The argument is an identifier that is the name of the submodule to include. Modules are only allowed to",
      "zh-CHS": "“include”语句用于将子模块中的内容提供给该子模块的父模块或该父模块的另一个子模块。参数是一个标识符，它是要包含的子模块的名称。模块只允许"
    },
    {
      "indent": 3,
      "text": "include submodules that belong to that module, as defined by the \"belongs-to\" statement (see Section 7.2.2). Submodules are only allowed to include other submodules belonging to the same module.",
      "zh-CHS": "包括属于该模块的子模块，如“属于”语句所定义（见第7.2.2节）。子模块仅允许包含属于同一模块的其他子模块。"
    },
    {
      "indent": 3,
      "text": "When a module includes a submodule, it incorporates the contents of the submodule into the node hierarchy of the module. When a submodule includes another submodule, the target submodule's definitions are made available to the current submodule.",
      "zh-CHS": "当模块包含子模块时，它会将子模块的内容合并到模块的节点层次结构中。当一个子模块包含另一个子模块时，目标子模块的定义可供当前子模块使用。"
    },
    {
      "indent": 3,
      "text": "When the optional \"revision-date\" substatement is present, the specified revision of the submodule is included in the module. It is an error if the specified revision of the submodule does not exist. If no \"revision-date\" substatement is present, it is undefined which revision of the submodule is included.",
      "zh-CHS": "当存在可选的“修订日期”子状态时，子模块的指定修订将包含在模块中。如果子模块的指定版本不存在，则为错误。如果不存在“修订日期”子语句，则未定义包含子模块的哪个修订。"
    },
    {
      "indent": 3,
      "text": "Multiple revisions of the same submodule MUST NOT be included.",
      "zh-CHS": "不得包含同一子模块的多个修订版。"
    },
    {
      "indent": 23,
      "text": "The includes's Substatements",
      "zh-CHS": "包含的子语句"
    },
    {
      "indent": 17,
      "text": "+---------------+---------+-------------+\n| substatement  | section | cardinality |\n+---------------+---------+-------------+\n| revision-date | 7.1.5.1 | 0..1        |\n+---------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.1.7. The organization Statement",
      "section_title": true,
      "zh-CHS": "7.1.7. 组织声明"
    },
    {
      "indent": 3,
      "text": "The \"organization\" statement defines the party responsible for this module. The argument is a string that is used to specify a textual description of the organization(s) under whose auspices this module was developed.",
      "zh-CHS": "“组织”声明定义了负责此模块的一方。参数是一个字符串，用于指定在其主持下开发此模块的组织的文本描述。"
    },
    {
      "indent": 0,
      "text": "7.1.8. The contact Statement",
      "section_title": true,
      "zh-CHS": "7.1.8. 联络声明"
    },
    {
      "indent": 3,
      "text": "The \"contact\" statement provides contact information for the module. The argument is a string that is used to specify contact information for the person or persons to whom technical queries concerning this module should be sent, such as their name, postal address, telephone number, and electronic mail address.",
      "zh-CHS": "“contact”语句提供模块的联系信息。参数是一个字符串，用于指定应向其发送有关此模块的技术查询的人员的联系信息，如姓名、邮政地址、电话号码和电子邮件地址。"
    },
    {
      "indent": 0,
      "text": "7.1.9. The revision Statement",
      "section_title": true,
      "zh-CHS": "7.1.9. 修订声明"
    },
    {
      "indent": 3,
      "text": "The \"revision\" statement specifies the editorial revision history of the module, including the initial revision. A series of revision statements detail the changes in the module's definition. The argument is a date string in the format \"YYYY-MM-DD\", followed by a block of substatements that holds detailed revision information. A module SHOULD have at least one initial \"revision\" statement. For",
      "zh-CHS": "“修订”语句指定模块的编辑修订历史记录，包括初始修订。一系列修订声明详细说明了模块定义中的更改。参数是格式为“YYYY-MM-DD”的日期字符串，后跟一块保存详细修订信息的子状态。模块应至少有一个初始“修订”语句。对于"
    },
    {
      "indent": 3,
      "text": "every published editorial change, a new one SHOULD be added in front of the revisions sequence, so that all revisions are in reverse chronological order.",
      "zh-CHS": "每次发布的编辑变更，都应在修订顺序前添加一个新的修订，以便所有修订都按相反的时间顺序进行。"
    },
    {
      "indent": 0,
      "text": "7.1.9.1. The revision's Substatement",
      "section_title": true,
      "zh-CHS": "7.1.9.1. 修订版的替代版本"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| description  | 7.19.3  | 0..1        |\n| reference    | 7.19.4  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.1.10. Usage Example",
      "section_title": true,
      "zh-CHS": "7.1.10. 用法示例"
    },
    {
      "indent": 5,
      "text": "module acme-system {\n    namespace \"http://acme.example.com/system\";\n    prefix \"acme\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "import ietf-yang-types {\n    prefix \"yang\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "include acme-types;",
      "zh-CHS": "包括顶点类型；"
    },
    {
      "indent": 9,
      "text": "organization \"ACME Inc.\"; contact \"Joe L. User",
      "zh-CHS": "组织“ACME公司”；联系“Joe L.用户”"
    },
    {
      "indent": 14,
      "text": "ACME, Inc. 42 Anywhere Drive Nowhere, CA 95134 USA",
      "zh-CHS": "ACME，Inc.42 Anywhere Drive Nowhere，加利福尼亚州95134美国"
    },
    {
      "indent": 14,
      "text": "Phone: +1 800 555 0100\nEMail: joe@acme.example.com\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "description \"The module for entities implementing the ACME protocol.\";",
      "zh-CHS": "描述“用于实现ACME协议的实体的模块。”；"
    },
    {
      "indent": 9,
      "text": "revision \"2007-06-09\" {\n    description \"Initial revision.\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": " // definitions follow... }",
      "zh-CHS": "//定义如下…}"
    },
    {
      "indent": 0,
      "text": "7.2. The submodule Statement",
      "section_title": true,
      "zh-CHS": "7.2. 子模块语句"
    },
    {
      "indent": 3,
      "text": "While the primary unit in YANG is a module, a YANG module can itself be constructed out of several submodules. Submodules allow a module designer to split a complex model into several pieces where all the submodules contribute to a single namespace, which is defined by the module that includes the submodules.",
      "zh-CHS": "虽然YANG中的主要单元是一个模块，但YANG模块本身可以由几个子模块构成。子模块允许模块设计器将复杂模型拆分为多个部分，其中所有子模块都贡献给单个名称空间，该名称空间由包含子模块的模块定义。"
    },
    {
      "indent": 3,
      "text": "The \"submodule\" statement defines the submodule's name, and groups all statements that belong to the submodule together. The \"submodule\" statement's argument is the name of the submodule, followed by a block of substatements that hold detailed submodule information. The submodule name follows the rules for identifiers in Section 6.2.",
      "zh-CHS": "“submodule”语句定义子模块的名称，并将属于该子模块的所有语句分组在一起。“submodule”语句的参数是子模块的名称，后跟包含详细子模块信息的子语句块。子模块名称遵循第6.2节中的标识符规则。"
    },
    {
      "indent": 3,
      "text": "Names of submodules published in RFC streams [RFC4844] MUST be assigned by IANA, see Section 14.",
      "zh-CHS": "在RFC streams[RFC4844]中发布的子模块名称必须由IANA分配，见第14节。"
    },
    {
      "indent": 3,
      "text": "Private submodule names are assigned by the organization owning the submodule without a central registry. It is RECOMMENDED to choose submodule names that will have a low probability of colliding with standard or other enterprise modules and submodules, e.g., by using the enterprise or organization name as a prefix for the submodule name.",
      "zh-CHS": "私有子模块名称由拥有该子模块的组织分配，而无需中央注册表。建议选择与标准或其他企业模块和子模块冲突概率较低的子模块名称，例如，使用企业或组织名称作为子模块名称的前缀。"
    },
    {
      "indent": 3,
      "text": "A submodule typically has the following layout:",
      "zh-CHS": "子模块通常具有以下布局："
    },
    {
      "indent": 5,
      "text": "submodule <module-name> {",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "<yang-version statement>",
      "zh-CHS": "<yang版本声明>"
    },
    {
      "indent": 9,
      "text": "// module identification\n<belongs-to statement>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "// linkage statements\n<import statements>\n<include statements>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "// meta information\n<organization statement>\n<contact statement>\n<description statement>\n<reference statement>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "// revision history\n<revision statements>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "    // module definitions\n    <other statements>\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.2.1. The submodule's Substatements",
      "section_title": true,
      "zh-CHS": "7.2.1. 子模块的子状态"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| anyxml       | 7.10    | 0..n        |\n| augment      | 7.15    | 0..n        |\n| belongs-to   | 7.2.2   | 1           |\n| choice       | 7.9     | 0..n        |\n| contact      | 7.1.8   | 0..1        |\n| container    | 7.5     | 0..n        |\n| description  | 7.19.3  | 0..1        |\n| deviation    | 7.18.3  | 0..n        |\n| extension    | 7.17    | 0..n        |\n| feature      | 7.18.1  | 0..n        |\n| grouping     | 7.11    | 0..n        |\n| identity     | 7.16    | 0..n        |\n| import       | 7.1.5   | 0..n        |\n| include      | 7.1.6   | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| notification | 7.14    | 0..n        |\n| organization | 7.1.7   | 0..1        |\n| reference    | 7.19.4  | 0..1        |\n| revision     | 7.1.9   | 0..n        |\n| rpc          | 7.13    | 0..n        |\n| typedef      | 7.3     | 0..n        |\n| uses         | 7.12    | 0..n        |\n| yang-version | 7.1.2   | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.2.2. The belongs-to Statement",
      "section_title": true,
      "zh-CHS": "7.2.2. “属于”语句"
    },
    {
      "indent": 3,
      "text": "The \"belongs-to\" statement specifies the module to which the submodule belongs. The argument is an identifier that is the name of the module.",
      "zh-CHS": "“属于”语句指定子模块所属的模块。参数是一个标识符，它是模块的名称。"
    },
    {
      "indent": 3,
      "text": "A submodule MUST only be included by the module to which it belongs, or by another submodule that belongs to that module.",
      "zh-CHS": "子模块只能由其所属的模块或属于该模块的另一个子模块包含。"
    },
    {
      "indent": 3,
      "text": "The mandatory \"prefix\" substatement assigns a prefix for the module to which the submodule belongs. All definitions in the local submodule and any included submodules can be accessed by using the prefix.",
      "zh-CHS": "强制性的“prefix”子语句为子模块所属的模块指定前缀。可以使用前缀访问本地子模块和任何包含的子模块中的所有定义。"
    },
    {
      "indent": 22,
      "text": "The belongs-to's Substatements",
      "zh-CHS": "属于的子状态"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| prefix       | 7.1.4   | 1           |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.2.3. Usage Example",
      "section_title": true,
      "zh-CHS": "7.2.3. 用法示例"
    },
    {
      "indent": 5,
      "text": "submodule acme-types {",
      "zh-CHS": "子模块顶点类型{"
    },
    {
      "indent": 9,
      "text": "belongs-to \"acme-system\" {\n    prefix \"acme\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "import ietf-yang-types {\n    prefix \"yang\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "organization \"ACME Inc.\"; contact \"Joe L. User",
      "zh-CHS": "组织“ACME公司”；联系“Joe L.用户”"
    },
    {
      "indent": 14,
      "text": "ACME, Inc. 42 Anywhere Drive Nowhere, CA 95134 USA",
      "zh-CHS": "ACME，Inc.42 Anywhere Drive Nowhere，加利福尼亚州95134美国"
    },
    {
      "indent": 14,
      "text": "Phone: +1 800 555 0100\nEMail: joe@acme.example.com\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "description \"This submodule defines common ACME types.\";",
      "zh-CHS": "description“此子模块定义常见的ACME类型。”；"
    },
    {
      "indent": 9,
      "text": "revision \"2007-06-09\" {\n    description \"Initial revision.\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": " // definitions follows... }",
      "zh-CHS": "//定义如下…}"
    },
    {
      "indent": 0,
      "text": "7.3. The typedef Statement",
      "section_title": true,
      "zh-CHS": "7.3. typedef语句"
    },
    {
      "indent": 3,
      "text": "The \"typedef\" statement defines a new type that may be used locally in the module, in modules or submodules which include it, and by other modules that import from it, according to the rules in",
      "zh-CHS": "“typedef”语句定义了一个新类型，该类型可以根据中的规则在模块、包含它的模块或子模块中本地使用，也可以由从中导入的其他模块使用"
    },
    {
      "indent": 3,
      "text": "Section 5.5. The new type is called the \"derived type\", and the type from which it was derived is called the \"base type\". All derived types can be traced back to a YANG built-in type.",
      "zh-CHS": "第5.5节。新类型称为“派生类型”，派生它的类型称为“基类型”。所有派生类型都可以追溯到内置类型。"
    },
    {
      "indent": 3,
      "text": "The \"typedef\" statement's argument is an identifier that is the name of the type to be defined, and MUST be followed by a block of substatements that holds detailed typedef information.",
      "zh-CHS": "“typedef”语句的参数是一个标识符，它是要定义的类型的名称，后面必须跟一个包含详细typedef信息的子语句块。"
    },
    {
      "indent": 3,
      "text": "The name of the type MUST NOT be one of the YANG built-in types. If the typedef is defined at the top level of a YANG module or submodule, the name of the type to be defined MUST be unique within the module.",
      "zh-CHS": "类型的名称不能是内置类型之一。如果typedef是在模块或子模块的顶层定义的，则要定义的类型名称在模块中必须是唯一的。"
    },
    {
      "indent": 0,
      "text": "7.3.1. The typedef's Substatements",
      "section_title": true,
      "zh-CHS": "7.3.1. typedef的子状态"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| default      | 7.3.4   | 0..1        |\n| description  | 7.19.3  | 0..1        |\n| reference    | 7.19.4  | 0..1        |\n| status       | 7.19.2  | 0..1        |\n| type         | 7.3.2   | 1           |\n| units        | 7.3.3   | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.3.2. The typedef's type Statement",
      "section_title": true,
      "zh-CHS": "7.3.2. typedef的type语句"
    },
    {
      "indent": 3,
      "text": "The \"type\" statement, which MUST be present, defines the base type from which this type is derived. See Section 7.4 for details.",
      "zh-CHS": "必须存在的“type”语句定义了派生此类型的基类型。详见第7.4节。"
    },
    {
      "indent": 0,
      "text": "7.3.3. The units Statement",
      "section_title": true,
      "zh-CHS": "7.3.3. 单位声明"
    },
    {
      "indent": 3,
      "text": "The \"units\" statement, which is optional, takes as an argument a string that contains a textual definition of the units associated with the type.",
      "zh-CHS": "“units”语句是可选的，它将包含与类型关联的单元的文本定义的字符串作为参数。"
    },
    {
      "indent": 0,
      "text": "7.3.4. The typedef's default Statement",
      "section_title": true,
      "zh-CHS": "7.3.4. typedef的默认语句"
    },
    {
      "indent": 3,
      "text": "The \"default\" statement takes as an argument a string that contains a default value for the new type.",
      "zh-CHS": "“default”语句将包含新类型的默认值的字符串作为参数。"
    },
    {
      "indent": 3,
      "text": "The value of the \"default\" statement MUST be valid according to the type specified in the \"type\" statement.",
      "zh-CHS": "根据“type”语句中指定的类型，“default”语句的值必须有效。"
    },
    {
      "indent": 3,
      "text": "If the base type has a default value, and the new derived type does not specify a new default value, the base type's default value is also the default value of the new derived type.",
      "zh-CHS": "如果基类型具有默认值，而新派生类型未指定新的默认值，则基类型的默认值也是新派生类型的默认值。"
    },
    {
      "indent": 3,
      "text": "If the type's default value is not valid according to the new restrictions specified in a derived type or leaf definition, the derived type or leaf definition MUST specify a new default value compatible with the restrictions.",
      "zh-CHS": "如果根据派生类型或叶定义中指定的新限制，类型的默认值无效，则派生类型或叶定义必须指定与这些限制兼容的新默认值。"
    },
    {
      "indent": 0,
      "text": "7.3.5. Usage Example",
      "section_title": true,
      "zh-CHS": "7.3.5. 用法示例"
    },
    {
      "indent": 5,
      "text": "typedef listen-ipv4-address {\n    type inet:ipv4-address;\n    default \"0.0.0.0\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.4. The type Statement",
      "section_title": true,
      "zh-CHS": "7.4. 类型语句"
    },
    {
      "indent": 3,
      "text": "The \"type\" statement takes as an argument a string that is the name of a YANG built-in type (see Section 9) or a derived type (see Section 7.3), followed by an optional block of substatements that are used to put further restrictions on the type.",
      "zh-CHS": "“type”语句将一个字符串作为参数，该字符串是内置类型（参见第9节）或派生类型（参见第7.3节）的名称，后跟一个可选的子语句块，用于对该类型施加进一步的限制。"
    },
    {
      "indent": 3,
      "text": "The restrictions that can be applied depend on the type being restricted. The restriction statements for all built-in types are described in the subsections of Section 9.",
      "zh-CHS": "可以应用的限制取决于被限制的类型。所有内置类型的限制说明见第9节的小节。"
    },
    {
      "indent": 0,
      "text": "7.4.1. The type's Substatements",
      "section_title": true,
      "zh-CHS": "7.4.1. 类型的子状态"
    },
    {
      "indent": 15,
      "text": "+------------------+---------+-------------+\n| substatement     | section | cardinality |\n+------------------+---------+-------------+\n| bit              | 9.7.4   | 0..n        |\n| enum             | 9.6.4   | 0..n        |\n| length           | 9.4.4   | 0..1        |\n| path             | 9.9.2   | 0..1        |\n| pattern          | 9.4.6   | 0..n        |\n| range            | 9.2.4   | 0..1        |\n| require-instance | 9.13.2  | 0..1        |\n| type             | 7.4     | 0..n        |\n+------------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.5. The container Statement",
      "section_title": true,
      "zh-CHS": "7.5. 容器语句"
    },
    {
      "indent": 3,
      "text": "The \"container\" statement is used to define an interior data node in the schema tree. It takes one argument, which is an identifier, followed by a block of substatements that holds detailed container information.",
      "zh-CHS": "“container”语句用于定义模式树中的内部数据节点。它有一个参数，它是一个标识符，后跟一个包含详细容器信息的子语句块。"
    },
    {
      "indent": 3,
      "text": "A container node does not have a value, but it has a list of child nodes in the data tree. The child nodes are defined in the container's substatements.",
      "zh-CHS": "容器节点没有值，但在数据树中有子节点列表。子节点在容器的子状态中定义。"
    },
    {
      "indent": 0,
      "text": "7.5.1. Containers with Presence",
      "section_title": true,
      "zh-CHS": "7.5.1. 存在的容器"
    },
    {
      "indent": 3,
      "text": "YANG supports two styles of containers, those that exist only for organizing the hierarchy of data nodes, and those whose presence in the configuration has an explicit meaning.",
      "zh-CHS": "YANG支持两种类型的容器，一种是仅用于组织数据节点层次结构的容器，另一种是在配置中具有明确含义的容器。"
    },
    {
      "indent": 3,
      "text": "In the first style, the container has no meaning of its own, existing only to contain child nodes. This is the default style.",
      "zh-CHS": "在第一种样式中，容器本身没有意义，只存在于包含子节点的地方。这是默认样式。"
    },
    {
      "indent": 3,
      "text": "For example, the set of scrambling options for Synchronous Optical Network (SONET) interfaces may be placed inside a \"scrambling\" container to enhance the organization of the configuration hierarchy, and to keep these nodes together. The \"scrambling\" node itself has no meaning, so removing the node when it becomes empty relieves the user from performing this task.",
      "zh-CHS": "例如，用于同步光网络（SONET）接口的一组加扰选项可放置在“加扰”容器内，以增强配置层次结构的组织，并将这些节点保持在一起。“加扰”节点本身没有任何意义，因此在节点变空时移除节点可以免除用户执行此任务。"
    },
    {
      "indent": 3,
      "text": "In the second style, the presence of the container itself is configuration data, representing a single bit of configuration data. The container acts as both a configuration knob and a means of organizing related configuration. These containers are explicitly created and deleted.",
      "zh-CHS": "在第二种样式中，容器本身的存在是配置数据，表示单个位的配置数据。容器充当配置旋钮和组织相关配置的手段。这些容器是显式创建和删除的。"
    },
    {
      "indent": 3,
      "text": "YANG calls this style a \"presence container\" and it is indicated using the \"presence\" statement, which takes as its argument a text string indicating what the presence of the node means.",
      "zh-CHS": "YANG将这种样式称为“状态容器”，并使用“状态”语句表示，该语句将一个文本字符串作为其参数，指示节点的存在意味着什么。"
    },
    {
      "indent": 3,
      "text": "For example, an \"ssh\" container may turn on the ability to log into the device using ssh, but can also contain any ssh-related configuration knobs, such as connection rates or retry limits.",
      "zh-CHS": "例如，“ssh”容器可以启用使用ssh登录设备的功能，但也可以包含任何与ssh相关的配置旋钮，例如连接速率或重试限制。"
    },
    {
      "indent": 3,
      "text": "The \"presence\" statement (see Section 7.5.5) is used to give semantics to the existence of the container in the data tree.",
      "zh-CHS": "“presence”语句（见第7.5.5节）用于为数据树中容器的存在提供语义。"
    },
    {
      "indent": 0,
      "text": "7.5.2. The container's Substatements",
      "section_title": true,
      "zh-CHS": "7.5.2. 容器的子状态"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| anyxml       | 7.10    | 0..n        |\n| choice       | 7.9     | 0..n        |\n| config       | 7.19.1  | 0..1        |\n| container    | 7.5     | 0..n        |\n| description  | 7.19.3  | 0..1        |\n| grouping     | 7.11    | 0..n        |\n| if-feature   | 7.18.2  | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| must         | 7.5.3   | 0..n        |\n| presence     | 7.5.5   | 0..1        |\n| reference    | 7.19.4  | 0..1        |\n| status       | 7.19.2  | 0..1        |\n| typedef      | 7.3     | 0..n        |\n| uses         | 7.12    | 0..n        |\n| when         | 7.19.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.5.3. The must Statement",
      "section_title": true,
      "zh-CHS": "7.5.3. 必须声明"
    },
    {
      "indent": 3,
      "text": "The \"must\" statement, which is optional, takes as an argument a string that contains an XPath expression (see Section 6.4). It is used to formally declare a constraint on valid data. The constraint is enforced according to the rules in Section 8.",
      "zh-CHS": "“must”语句是可选的，它将包含XPath表达式的字符串作为参数（参见第6.4节）。它用于正式声明对有效数据的约束。根据第8节中的规则强制执行约束。"
    },
    {
      "indent": 3,
      "text": "When a datastore is validated, all \"must\" constraints are conceptually evaluated once for each data node in the data tree, and for all leafs with default values in use (see Section 7.6.1). If a data node does not exist in the data tree, and it does not have a default value, its \"must\" statements are not evaluated.",
      "zh-CHS": "验证数据存储时，对数据树中的每个数据节点以及使用默认值的所有LEAF，在概念上对所有“必须”约束进行一次评估（见第7.6.1节）。如果数据树中不存在数据节点，并且该节点没有默认值，则不会计算其“必须”语句。"
    },
    {
      "indent": 3,
      "text": "All such constraints MUST evaluate to true for the data to be valid.",
      "zh-CHS": "所有这些约束的计算结果必须为true，数据才能有效。"
    },
    {
      "indent": 3,
      "text": "The XPath expression is conceptually evaluated in the following context, in addition to the definition in Section 6.4.1:",
      "zh-CHS": "除了第6.4.1节中的定义外，XPath表达式在以下上下文中进行概念性评估："
    },
    {
      "indent": 3,
      "text": "o The context node is the node in the data tree for which the \"must\" statement is defined.",
      "zh-CHS": "o 上下文节点是数据树中定义了“必须”语句的节点。"
    },
    {
      "indent": 3,
      "text": "o The accessible tree is made up of all nodes in the data tree, and all leafs with default values in use (see Section 7.6.1).",
      "zh-CHS": "o 可访问树由数据树中的所有节点和使用默认值的所有叶组成（见第7.6.1节）。"
    },
    {
      "indent": 3,
      "text": "The accessible tree depends on the context node:",
      "zh-CHS": "可访问树取决于上下文节点："
    },
    {
      "indent": 3,
      "text": "o If the context node represents configuration, the tree is the data in the NETCONF datastore where the context node exists. The XPath root node has all top-level configuration data nodes in all modules as children.",
      "zh-CHS": "o 如果上下文节点表示配置，则树是存在上下文节点的NETCONF数据存储中的数据。XPath根节点将所有模块中的所有顶级配置数据节点作为子节点。"
    },
    {
      "indent": 3,
      "text": "o If the context node represents state data, the tree is all state data on the device, and the <running/> datastore. The XPath root node has all top-level data nodes in all modules as children.",
      "zh-CHS": "o 如果上下文节点表示状态数据，则树是设备上的所有状态数据，以及<running/>数据存储。XPath根节点将所有模块中的所有顶级数据节点作为子节点。"
    },
    {
      "indent": 3,
      "text": "o If the context node represents notification content, the tree is the notification XML instance document. The XPath root node has the element representing the notification being defined as the only child.",
      "zh-CHS": "o 如果上下文节点表示通知内容，则树就是通知XML实例文档。XPath根节点具有表示被定义为唯一子节点的通知的元素。"
    },
    {
      "indent": 3,
      "text": "o If the context node represents RPC input parameters, the tree is the RPC XML instance document. The XPath root node has the element representing the RPC operation being defined as the only child.",
      "zh-CHS": "o 如果上下文节点表示RPC输入参数，则树就是RPC XML实例文档。XPath根节点将表示RPC操作的元素定义为唯一的子节点。"
    },
    {
      "indent": 3,
      "text": "o If the context node represents RPC output parameters, the tree is the RPC reply instance document. The XPath root node has the elements representing the RPC output parameters as children.",
      "zh-CHS": "o 如果上下文节点表示RPC输出参数，则树就是RPC应答实例文档。XPath根节点具有表示RPC输出参数的子元素。"
    },
    {
      "indent": 3,
      "text": "The result of the XPath expression is converted to a boolean value using the standard XPath rules.",
      "zh-CHS": "XPath表达式的结果使用标准XPath规则转换为布尔值。"
    },
    {
      "indent": 3,
      "text": "Note that since all leaf values in the data tree are conceptually stored in their canonical form (see Sections 7.6 and 7.7), any XPath comparisons are done on the canonical value.",
      "zh-CHS": "请注意，由于数据树中的所有叶值在概念上都以其规范形式存储（请参见第7.6和7.7节），因此任何XPath比较都是在规范值上进行的。"
    },
    {
      "indent": 3,
      "text": "Also note that the XPath expression is conceptually evaluated. This means that an implementation does not have to use an XPath evaluator on the device. How the evaluation is done in practice is an implementation decision.",
      "zh-CHS": "还要注意，XPath表达式是在概念上计算的。这意味着实现不必在设备上使用XPath计算器。如何在实践中进行评估是一项实施决策。"
    },
    {
      "indent": 0,
      "text": "7.5.4. The must's Substatements",
      "section_title": true,
      "zh-CHS": "7.5.4. 必须的子状态"
    },
    {
      "indent": 17,
      "text": "+---------------+---------+-------------+\n| substatement  | section | cardinality |\n+---------------+---------+-------------+\n| description   | 7.19.3  | 0..1        |\n| error-app-tag | 7.5.4.2 | 0..1        |\n| error-message | 7.5.4.1 | 0..1        |\n| reference     | 7.19.4  | 0..1        |\n+---------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.5.4.1. The error-message Statement",
      "section_title": true,
      "zh-CHS": "7.5.4.1. 错误消息语句"
    },
    {
      "indent": 3,
      "text": "The \"error-message\" statement, which is optional, takes a string as an argument. If the constraint evaluates to false, the string is passed as <error-message> in the <rpc-error>.",
      "zh-CHS": "“error message”语句是可选的，它将字符串作为参数。如果约束的计算结果为false，则字符串将作为<rpc error>中的<error message>传递。"
    },
    {
      "indent": 0,
      "text": "7.5.4.2. The error-app-tag Statement",
      "section_title": true,
      "zh-CHS": "7.5.4.2. 错误应用程序标记语句"
    },
    {
      "indent": 3,
      "text": "The \"error-app-tag\" statement, which is optional, takes a string as an argument. If the constraint evaluates to false, the string is passed as <error-app-tag> in the <rpc-error>.",
      "zh-CHS": "“error-app-tag”语句是可选的，它将字符串作为参数。如果约束的计算结果为false，则字符串将作为<rpc error>中的<error app tag>传递。"
    },
    {
      "indent": 0,
      "text": "7.5.4.3. Usage Example of must and error-message",
      "section_title": true,
      "zh-CHS": "7.5.4.3. must和错误消息的用法示例"
    },
    {
      "indent": 5,
      "text": "container interface {\n    leaf ifType {\n        type enumeration {\n            enum ethernet;\n            enum atm;\n        }\n    }\n    leaf ifMTU {\n        type uint32;\n    }\n    must \"ifType != 'ethernet' or \" +\n         \"(ifType = 'ethernet' and ifMTU = 1500)\" {\n        error-message \"An ethernet MTU must be 1500\";\n    }\n    must \"ifType != 'atm' or \" +\n         \"(ifType = 'atm' and ifMTU <= 17966 and ifMTU >= 64)\" {\n        error-message \"An atm MTU must be  64 .. 17966\";\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.5.5. The presence Statement",
      "section_title": true,
      "zh-CHS": "7.5.5. 出席声明"
    },
    {
      "indent": 3,
      "text": "The \"presence\" statement assigns a meaning to the presence of a container in the data tree. It takes as an argument a string that contains a textual description of what the node's presence means.",
      "zh-CHS": "“presence”语句为数据树中容器的存在赋予了意义。它接受一个字符串作为参数，该字符串包含节点存在的含义的文本描述。"
    },
    {
      "indent": 3,
      "text": "If a container has the \"presence\" statement, the container's existence in the data tree carries some meaning. Otherwise, the container is used to give some structure to the data, and it carries no meaning by itself.",
      "zh-CHS": "如果一个容器有“presence”语句，那么该容器在数据树中的存在就具有某种意义。否则，容器被用来为数据提供某种结构，它本身没有任何意义。"
    },
    {
      "indent": 3,
      "text": "See Section 7.5.1 for additional information.",
      "zh-CHS": "更多信息见第7.5.1节。"
    },
    {
      "indent": 0,
      "text": "7.5.6. The container's Child Node Statements",
      "section_title": true,
      "zh-CHS": "7.5.6. 容器的子节点语句"
    },
    {
      "indent": 3,
      "text": "Within a container, the \"container\", \"leaf\", \"list\", \"leaf-list\", \"uses\", \"choice\", and \"anyxml\" statements can be used to define child nodes to the container.",
      "zh-CHS": "在容器中，“container”、“leaf”、“list”、“leaf list”、“uses”、“choice”和“anyxml”语句可用于定义容器的子节点。"
    },
    {
      "indent": 0,
      "text": "7.5.7. XML Mapping Rules",
      "section_title": true,
      "zh-CHS": "7.5.7. XML映射规则"
    },
    {
      "indent": 3,
      "text": "A container node is encoded as an XML element. The element's local name is the container's identifier, and its namespace is the module's XML namespace (see Section 7.1.3).",
      "zh-CHS": "容器节点编码为XML元素。元素的本地名称是容器的标识符，其名称空间是模块的XML名称空间（参见第7.1.3节）。"
    },
    {
      "indent": 3,
      "text": "The container's child nodes are encoded as subelements to the container element. If the container defines RPC input or output parameters, these subelements are encoded in the same order as they are defined within the \"container\" statement. Otherwise, the subelements are encoded in any order.",
      "zh-CHS": "容器的子节点被编码为容器元素的子元素。如果容器定义了RPC输入或输出参数，则这些子元素的编码顺序与“container”语句中定义的顺序相同。否则，子元素按任意顺序编码。"
    },
    {
      "indent": 3,
      "text": "A NETCONF server that replies to a <get> or <get-config> request MAY choose not to send a container element if the container node does not have the \"presence\" statement and no child nodes exist. Thus, a client that receives an <rpc-reply> for a <get> or <get-config> request, must be prepared to handle the case that a container node without a \"presence\" statement is not present in the XML.",
      "zh-CHS": "如果容器节点没有“presence”语句且不存在子节点，则响应<get>或<get config>请求的NETCONF服务器可以选择不发送容器元素。因此，接收<get>或<get config>请求的<rpc reply>的客户机必须准备好处理没有“presence”语句的容器节点在XML中不存在的情况。"
    },
    {
      "indent": 0,
      "text": "7.5.8. NETCONF <edit-config> Operations",
      "section_title": true,
      "zh-CHS": "7.5.8. NETCONF<edit config>操作"
    },
    {
      "indent": 3,
      "text": "Containers can be created, deleted, replaced, and modified through <edit-config>, by using the \"operation\" attribute (see [RFC4741], Section 7.2) in the container's XML element.",
      "zh-CHS": "通过使用容器XML元素中的“操作”属性（参见[RFC4741]，第7.2节），可以通过<edit config>创建、删除、替换和修改容器。"
    },
    {
      "indent": 3,
      "text": "If a container does not have a \"presence\" statement and the last child node is deleted, the NETCONF server MAY delete the container.",
      "zh-CHS": "如果容器没有“presence”语句，并且删除了最后一个子节点，NETCONF服务器可能会删除该容器。"
    },
    {
      "indent": 3,
      "text": "When a NETCONF server processes an <edit-config> request, the elements of procedure for the container node are:",
      "zh-CHS": "当NETCONF服务器处理<edit config>请求时，容器节点的过程元素包括："
    },
    {
      "indent": 6,
      "text": "If the operation is \"merge\" or \"replace\", the node is created if it does not exist.",
      "zh-CHS": "如果操作为“合并”或“替换”，则会在节点不存在时创建该节点。"
    },
    {
      "indent": 6,
      "text": "If the operation is \"create\", the node is created if it does not exist. If the node already exists, a \"data-exists\" error is returned.",
      "zh-CHS": "如果操作为“创建”，则在节点不存在时创建该节点。如果节点已经存在，则返回“数据存在”错误。"
    },
    {
      "indent": 6,
      "text": "If the operation is \"delete\", the node is deleted if it exists. If the node does not exist, a \"data-missing\" error is returned.",
      "zh-CHS": "如果操作为“删除”，则删除节点（如果存在）。如果节点不存在，则返回“数据丢失”错误。"
    },
    {
      "indent": 0,
      "text": "7.5.9. Usage Example",
      "section_title": true,
      "zh-CHS": "7.5.9. 用法示例"
    },
    {
      "indent": 3,
      "text": "Given the following container definition:",
      "zh-CHS": "给定以下容器定义："
    },
    {
      "indent": 5,
      "text": "container system {\n    description \"Contains various system parameters\";\n    container services {\n        description \"Configure externally available services\";\n        container \"ssh\" {\n            presence \"Enables SSH\";\n            description \"SSH service specific configuration\";\n            // more leafs, containers and stuff here...\n        }\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example:",
      "zh-CHS": "对应的XML实例示例："
    },
    {
      "indent": 5,
      "text": "<system>\n  <services>\n    <ssh/>\n  </services>\n</system>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Since the <ssh> element is present, ssh is enabled.",
      "zh-CHS": "由于存在<ssh>元素，因此启用了ssh。"
    },
    {
      "indent": 3,
      "text": "To delete a container with an <edit-config>:",
      "zh-CHS": "要删除带有<edit config>的容器，请执行以下操作："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <edit-config>\n    <target>\n      <running/>\n    </target>\n    <config>\n      <system xmlns=\"http://example.com/schema/config\">\n        <services>\n          <ssh nc:operation=\"delete\"/>\n        </services>\n      </system>\n    </config>\n  </edit-config>\n</rpc>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.6. The leaf Statement",
      "section_title": true,
      "zh-CHS": "7.6. 叶声明"
    },
    {
      "indent": 3,
      "text": "The \"leaf\" statement is used to define a leaf node in the schema tree. It takes one argument, which is an identifier, followed by a block of substatements that holds detailed leaf information.",
      "zh-CHS": "“leaf”语句用于在模式树中定义叶节点。它有一个参数，它是一个标识符，后跟一个包含详细叶信息的子语句块。"
    },
    {
      "indent": 3,
      "text": "A leaf node has a value, but no child nodes in the data tree. Conceptually, the value in the data tree is always in the canonical form (see Section 9.1).",
      "zh-CHS": "叶节点有一个值，但在数据树中没有子节点。从概念上讲，数据树中的值始终采用规范形式（参见第9.1节）。"
    },
    {
      "indent": 3,
      "text": "A leaf node exists in zero or one instances in the data tree.",
      "zh-CHS": "叶节点存在于数据树中的零个或一个实例中。"
    },
    {
      "indent": 3,
      "text": "The \"leaf\" statement is used to define a scalar variable of a particular built-in or derived type.",
      "zh-CHS": "“leaf”语句用于定义特定内置或派生类型的标量变量。"
    },
    {
      "indent": 0,
      "text": "7.6.1. The leaf's default value",
      "section_title": true,
      "zh-CHS": "7.6.1. 叶的默认值"
    },
    {
      "indent": 3,
      "text": "The default value of a leaf is the value that the server uses if the leaf does not exist in the data tree. The usage of the default value depends on the leaf's closest ancestor node in the schema tree that is not a non-presence container:",
      "zh-CHS": "如果叶在数据树中不存在，则叶的默认值是服务器使用的值。默认值的使用取决于叶在架构树中最近的祖先节点，该节点不是非存在容器："
    },
    {
      "indent": 3,
      "text": "o If no such ancestor exists in the schema tree, the default value MUST be used.",
      "zh-CHS": "o 如果模式树中不存在这样的祖先，则必须使用默认值。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, if this ancestor is a case node, the default value MUST be used if any node from the case exists in the data tree, or if the case node is the choice's default case, and no nodes from any other case exist in the data tree.",
      "zh-CHS": "o 否则，如果此祖先是案例节点，则如果数据树中存在案例中的任何节点，或者如果案例节点是选项的默认案例，并且数据树中不存在任何其他案例中的节点，则必须使用默认值。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, the default value MUST be used if the ancestor node exists in the data tree.",
      "zh-CHS": "o 否则，如果数据树中存在祖先节点，则必须使用默认值。"
    },
    {
      "indent": 3,
      "text": "In these cases, the default value is said to be in use.",
      "zh-CHS": "在这些情况下，默认值被称为正在使用。"
    },
    {
      "indent": 3,
      "text": "When the default value is in use, the server MUST operationally behave as if the leaf was present in the data tree with the default value as its value.",
      "zh-CHS": "当使用默认值时，服务器在操作上的行为必须与叶在数据树中以默认值作为其值一样。"
    },
    {
      "indent": 3,
      "text": "If a leaf has a \"default\" statement, the leaf's default value is the value of the \"default\" statement. Otherwise, if the leaf's type has a default value, and the leaf is not mandatory, then the leaf's default value is the type's default value. In all other cases, the leaf does not have a default value.",
      "zh-CHS": "如果一个叶子有一个“default”语句，那么叶子的默认值就是“default”语句的值。否则，如果叶的类型具有默认值，并且叶不是必需的，则叶的默认值是该类型的默认值。在所有其他情况下，叶没有默认值。"
    },
    {
      "indent": 0,
      "text": "7.6.2. The leaf's Substatements",
      "section_title": true,
      "zh-CHS": "7.6.2. 叶的亚基"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| config       | 7.19.1  | 0..1        |\n| default      | 7.6.4   | 0..1        |\n| description  | 7.19.3  | 0..1        |\n| if-feature   | 7.18.2  | 0..n        |\n| mandatory    | 7.6.5   | 0..1        |\n| must         | 7.5.3   | 0..n        |\n| reference    | 7.19.4  | 0..1        |\n| status       | 7.19.2  | 0..1        |\n| type         | 7.6.3   | 1           |\n| units        | 7.3.3   | 0..1        |\n| when         | 7.19.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.6.3. The leaf's type Statement",
      "section_title": true,
      "zh-CHS": "7.6.3. 叶的类型语句"
    },
    {
      "indent": 3,
      "text": "The \"type\" statement, which MUST be present, takes as an argument the name of an existing built-in or derived type. The optional substatements specify restrictions on this type. See Section 7.4 for details.",
      "zh-CHS": "必须存在的“type”语句将现有内置类型或派生类型的名称作为参数。可选子语句指定此类型的限制。详见第7.4节。"
    },
    {
      "indent": 0,
      "text": "7.6.4. The leaf's default Statement",
      "section_title": true,
      "zh-CHS": "7.6.4. 叶的默认语句"
    },
    {
      "indent": 3,
      "text": "The \"default\" statement, which is optional, takes as an argument a string that contains a default value for the leaf.",
      "zh-CHS": "“default”语句是可选的，它将包含叶的默认值的字符串作为参数。"
    },
    {
      "indent": 3,
      "text": "The value of the \"default\" statement MUST be valid according to the type specified in the leaf's \"type\" statement.",
      "zh-CHS": "根据叶的“type”语句中指定的类型，“default”语句的值必须有效。"
    },
    {
      "indent": 3,
      "text": "The \"default\" statement MUST NOT be present on nodes where \"mandatory\" is true.",
      "zh-CHS": "“default”语句不能出现在“mandatory”为true的节点上。"
    },
    {
      "indent": 0,
      "text": "7.6.5. The leaf's mandatory Statement",
      "section_title": true,
      "zh-CHS": "7.6.5. 叶的强制性声明"
    },
    {
      "indent": 3,
      "text": "The \"mandatory\" statement, which is optional, takes as an argument the string \"true\" or \"false\", and puts a constraint on valid data. If not specified, the default is \"false\".",
      "zh-CHS": "“mandatory”语句是可选的，它将字符串“true”或“false”作为参数，并对有效数据进行约束。如果未指定，则默认值为“false”。"
    },
    {
      "indent": 3,
      "text": "If \"mandatory\" is \"true\", the behavior of the constraint depends on the type of the leaf's closest ancestor node in the schema tree that is not a non-presence container (see Section 7.5.1):",
      "zh-CHS": "如果“mandatory”为“true”，则约束的行为取决于模式树中叶的最近祖先节点的类型，该节点不是非存在容器（请参见第7.5.1节）："
    },
    {
      "indent": 3,
      "text": "o If no such ancestor exists in the schema tree, the leaf MUST exist.",
      "zh-CHS": "o 如果模式树中不存在这样的祖先，那么叶必须存在。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, if this ancestor is a case node, the leaf MUST exist if any node from the case exists in the data tree.",
      "zh-CHS": "o 否则，如果此祖先是案例节点，则如果案例中的任何节点存在于数据树中，则该叶必须存在。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, the leaf MUST exist if the ancestor node exists in the data tree.",
      "zh-CHS": "o 否则，如果数据树中存在祖先节点，则叶必须存在。"
    },
    {
      "indent": 3,
      "text": "This constraint is enforced according to the rules in Section 8.",
      "zh-CHS": "此约束根据第8节中的规则强制执行。"
    },
    {
      "indent": 0,
      "text": "7.6.6. XML Mapping Rules",
      "section_title": true,
      "zh-CHS": "7.6.6. XML映射规则"
    },
    {
      "indent": 3,
      "text": "A leaf node is encoded as an XML element. The element's local name is the leaf's identifier, and its namespace is the module's XML namespace (see Section 7.1.3).",
      "zh-CHS": "叶节点编码为XML元素。元素的本地名称是叶的标识符，其名称空间是模块的XML名称空间（参见第7.1.3节）。"
    },
    {
      "indent": 3,
      "text": "The value of the leaf node is encoded to XML according to the type, and sent as character data in the element.",
      "zh-CHS": "叶节点的值根据类型编码为XML，并作为元素中的字符数据发送。"
    },
    {
      "indent": 3,
      "text": "A NETCONF server that replies to a <get> or <get-config> request MAY choose not to send the leaf element if its value is the default value. Thus, a client that receives an <rpc-reply> for a <get> or <get-config> request, MUST be prepared to handle the case that a leaf node with a default value is not present in the XML. In this case, the value used by the server is known to be the default value.",
      "zh-CHS": "A NETCONF server that replies to a <get> or <get-config> request MAY choose not to send the leaf element if its value is the default value. Thus, a client that receives an <rpc-reply> for a <get> or <get-config> request, MUST be prepared to handle the case that a leaf node with a default value is not present in the XML. In this case, the value used by the server is known to be the default value.translate error, please retry"
    },
    {
      "indent": 3,
      "text": "See Section 7.6.8 for an example.",
      "zh-CHS": "示例见第7.6.8节。"
    },
    {
      "indent": 0,
      "text": "7.6.7. NETCONF <edit-config> Operations",
      "section_title": true,
      "zh-CHS": "7.6.7. NETCONF<edit config>操作"
    },
    {
      "indent": 3,
      "text": "When a NETCONF server processes an <edit-config> request, the elements of procedure for the leaf node are:",
      "zh-CHS": "当NETCONF服务器处理<edit config>请求时，叶节点的过程元素包括："
    },
    {
      "indent": 6,
      "text": "If the operation is \"merge\" or \"replace\", the node is created if it does not exist, and its value is set to the value found in the XML RPC data.",
      "zh-CHS": "如果操作为“merge”或“replace”，则将在节点不存在时创建该节点，并将其值设置为在XML RPC数据中找到的值。"
    },
    {
      "indent": 6,
      "text": "If the operation is \"create\", the node is created if it does not exist. If the node already exists, a \"data-exists\" error is returned.",
      "zh-CHS": "如果操作为“创建”，则在节点不存在时创建该节点。如果节点已经存在，则返回“数据存在”错误。"
    },
    {
      "indent": 6,
      "text": "If the operation is \"delete\", the node is deleted if it exists. If the node does not exist, a \"data-missing\" error is returned.",
      "zh-CHS": "如果操作为“删除”，则删除节点（如果存在）。如果节点不存在，则返回“数据丢失”错误。"
    },
    {
      "indent": 0,
      "text": "7.6.8. Usage Example",
      "section_title": true,
      "zh-CHS": "7.6.8. 用法示例"
    },
    {
      "indent": 3,
      "text": "Given the following \"leaf\" statement, placed in the previously defined \"ssh\" container (see Section 7.5.9):",
      "zh-CHS": "给出以下“leaf”语句，放在前面定义的“ssh”容器中（参见第7.5.9节）："
    },
    {
      "indent": 5,
      "text": "leaf port {\n    type inet:port-number;\n    default 22;\n    description \"The port to which the SSH server listens\"\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example:",
      "zh-CHS": "对应的XML实例示例："
    },
    {
      "indent": 5,
      "text": "<port>2022</port>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "To set the value of a leaf with an <edit-config>:",
      "zh-CHS": "要使用<edit config>设置叶的值，请执行以下操作："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <edit-config>\n    <target>\n      <running/>\n    </target>\n    <config>\n      <system xmlns=\"http://example.com/schema/config\">\n        <services>\n          <ssh>\n            <port>2022</port>\n          </ssh>\n        </services>\n      </system>\n    </config>\n  </edit-config>\n</rpc>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.7. The leaf-list Statement",
      "section_title": true,
      "zh-CHS": "7.7. 叶列表语句"
    },
    {
      "indent": 3,
      "text": "Where the \"leaf\" statement is used to define a simple scalar variable of a particular type, the \"leaf-list\" statement is used to define an array of a particular type. The \"leaf-list\" statement takes one argument, which is an identifier, followed by a block of substatements that holds detailed leaf-list information.",
      "zh-CHS": "如果“leaf”语句用于定义特定类型的简单标量变量，“leaf list”语句用于定义特定类型的数组。“叶列表”语句接受一个参数，该参数是一个标识符，后跟一个包含详细叶列表信息的子语句块。"
    },
    {
      "indent": 3,
      "text": "The values in a leaf-list MUST be unique.",
      "zh-CHS": "叶列表中的值必须是唯一的。"
    },
    {
      "indent": 3,
      "text": "Conceptually, the values in the data tree are always in the canonical form (see Section 9.1).",
      "zh-CHS": "从概念上讲，数据树中的值始终采用规范形式（参见第9.1节）。"
    },
    {
      "indent": 3,
      "text": "If the type referenced by the leaf-list has a default value, it has no effect in the leaf-list.",
      "zh-CHS": "如果叶列表引用的类型具有默认值，则该类型在叶列表中无效。"
    },
    {
      "indent": 0,
      "text": "7.7.1. Ordering",
      "section_title": true,
      "zh-CHS": "7.7.1. 订购"
    },
    {
      "indent": 3,
      "text": "YANG supports two styles for ordering the entries within lists and leaf-lists. In many lists, the order of list entries does not impact the implementation of the list's configuration, and the device is free to sort the list entries in any reasonable order. The \"description\" string for the list may suggest an order to the device implementor. YANG calls this style of list \"system ordered\" and they are indicated with the statement \"ordered-by system\".",
      "zh-CHS": "YANG支持两种样式对列表和叶列表中的条目进行排序。在许多列表中，列表项的顺序不会影响列表配置的实现，并且设备可以按照任何合理的顺序对列表项进行排序。列表的“描述”字符串可能会向设备实现者建议一个顺序。杨称这种类型的列表为“系统有序”，并用“按系统有序”的语句表示。"
    },
    {
      "indent": 3,
      "text": "For example, a list of valid users would typically be sorted alphabetically, since the order in which the users appeared in the configuration would not impact the creation of those users' accounts.",
      "zh-CHS": "例如，有效用户列表通常按字母顺序排序，因为用户在配置中出现的顺序不会影响这些用户帐户的创建。"
    },
    {
      "indent": 3,
      "text": "In the other style of lists, the order of list entries matters for the implementation of the list's configuration and the user is responsible for ordering the entries, while the device maintains that order. YANG calls this style of list \"user ordered\" and they are indicated with the statement \"ordered-by user\".",
      "zh-CHS": "在另一种类型的列表中，列表条目的顺序对列表配置的实现很重要，用户负责对条目进行排序，而设备保持该顺序。YANG将这种类型的列表称为“用户订购”，并用语句“按用户订购”表示。"
    },
    {
      "indent": 3,
      "text": "For example, the order in which firewall filters entries are applied to incoming traffic may affect how that traffic is filtered. The user would need to decide if the filter entry that discards all TCP traffic should be applied before or after the filter entry that allows all traffic from trusted interfaces. The choice of order would be crucial.",
      "zh-CHS": "例如，防火墙过滤器条目应用于传入流量的顺序可能会影响该流量的过滤方式。用户需要决定是否应在允许来自受信任接口的所有流量的筛选器条目之前或之后应用丢弃所有TCP流量的筛选器条目。秩序的选择至关重要。"
    },
    {
      "indent": 3,
      "text": "YANG provides a rich set of facilities within NETCONF's <edit-config> operation that allows the order of list entries in user-ordered lists to be controlled. List entries may be inserted or rearranged, positioned as the first or last entry in the list, or positioned before or after another specific entry.",
      "zh-CHS": "YANG在NETCONF的<edit config>操作中提供了一组丰富的工具，允许控制用户排序列表中列表项的顺序。列表条目可以插入或重新排列，定位为列表中的第一个或最后一个条目，或者定位在另一个特定条目之前或之后。"
    },
    {
      "indent": 3,
      "text": "The \"ordered-by\" statement is covered in Section 7.7.5.",
      "zh-CHS": "第7.7.5节介绍了“订购人”声明。"
    },
    {
      "indent": 0,
      "text": "7.7.2. The leaf-list's Substatements",
      "section_title": true,
      "zh-CHS": "7.7.2. 叶列表的子状态"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| config       | 7.19.1  | 0..1        |\n| description  | 7.19.3  | 0..1        |\n| if-feature   | 7.18.2  | 0..n        |\n| max-elements | 7.7.4   | 0..1        |\n| min-elements | 7.7.3   | 0..1        |\n| must         | 7.5.3   | 0..n        |\n| ordered-by   | 7.7.5   | 0..1        |\n| reference    | 7.19.4  | 0..1        |\n| status       | 7.19.2  | 0..1        |\n| type         | 7.4     | 1           |\n| units        | 7.3.3   | 0..1        |\n| when         | 7.19.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.7.3. The min-elements Statement",
      "section_title": true,
      "zh-CHS": "7.7.3. min-elements语句"
    },
    {
      "indent": 3,
      "text": "The \"min-elements\" statement, which is optional, takes as an argument a non-negative integer that puts a constraint on valid list entries. A valid leaf-list or list MUST have at least min-elements entries.",
      "zh-CHS": "“min elements”语句是可选的，它将一个非负整数作为参数，该非负整数对有效的列表项进行约束。有效的叶列表或列表必须至少包含min元素条目。"
    },
    {
      "indent": 3,
      "text": "If no \"min-elements\" statement is present, it defaults to zero.",
      "zh-CHS": "如果不存在“min elements”语句，则默认为零。"
    },
    {
      "indent": 3,
      "text": "The behavior of the constraint depends on the type of the leaf-list's or list's closest ancestor node in the schema tree that is not a non-presence container (see Section 7.5.1):",
      "zh-CHS": "约束的行为取决于模式树中不是非存在容器的叶列表或列表最近祖先节点的类型（参见第7.5.1节）："
    },
    {
      "indent": 3,
      "text": "o If this ancestor is a case node, the constraint is enforced if any other node from the case exists.",
      "zh-CHS": "o 如果此祖先是案例节点，则如果案例中存在任何其他节点，则强制执行约束。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, it is enforced if the ancestor node exists.",
      "zh-CHS": "o 否则，如果祖先节点存在，则强制执行。"
    },
    {
      "indent": 3,
      "text": "The constraint is further enforced according to the rules in Section 8.",
      "zh-CHS": "根据第8节中的规则，进一步实施约束。"
    },
    {
      "indent": 0,
      "text": "7.7.4. The max-elements Statement",
      "section_title": true,
      "zh-CHS": "7.7.4. max-elements语句"
    },
    {
      "indent": 3,
      "text": "The \"max-elements\" statement, which is optional, takes as an argument a positive integer or the string \"unbounded\", which puts a constraint on valid list entries. A valid leaf-list or list always has at most max-elements entries.",
      "zh-CHS": "“max elements”语句是可选的，它将一个正整数或字符串“unbounded”作为参数，该字符串对有效列表项施加约束。有效的叶列表或列表始终最多包含max elements条目。"
    },
    {
      "indent": 3,
      "text": "If no \"max-elements\" statement is present, it defaults to \"unbounded\".",
      "zh-CHS": "如果不存在“max elements”语句，则默认为“unbounded”。"
    },
    {
      "indent": 3,
      "text": "The \"max-elements\" constraint is enforced according to the rules in Section 8.",
      "zh-CHS": "“最大元素”约束根据第8节中的规则强制执行。"
    },
    {
      "indent": 0,
      "text": "7.7.5. The ordered-by Statement",
      "section_title": true,
      "zh-CHS": "7.7.5. ordered by语句"
    },
    {
      "indent": 3,
      "text": "The \"ordered-by\" statement defines whether the order of entries within a list are determined by the user or the system. The argument is one of the strings \"system\" or \"user\". If not present, order defaults to \"system\".",
      "zh-CHS": "“ordered by”语句定义列表中条目的顺序是由用户还是由系统确定的。参数是字符串“system”或“user”之一。如果不存在，订单默认为“系统”。"
    },
    {
      "indent": 3,
      "text": "This statement is ignored if the list represents state data, RPC output parameters, or notification content.",
      "zh-CHS": "如果列表表示状态数据、RPC输出参数或通知内容，则忽略此语句。"
    },
    {
      "indent": 3,
      "text": "See Section 7.7.1 for additional information.",
      "zh-CHS": "更多信息见第7.7.1节。"
    },
    {
      "indent": 0,
      "text": "7.7.5.1. ordered-by system",
      "section_title": true,
      "zh-CHS": "7.7.5.1. 按系统排序"
    },
    {
      "indent": 3,
      "text": "The entries in the list are sorted according to an unspecified order. Thus, an implementation is free to sort the entries in the most appropriate order. An implementation SHOULD use the same order for the same data, regardless of how the data were created. Using a deterministic order will make comparisons possible using simple tools like \"diff\".",
      "zh-CHS": "列表中的条目按照未指定的顺序进行排序。因此，实现可以按照最合适的顺序对条目进行自由排序。无论数据是如何创建的，实现都应该对相同的数据使用相同的顺序。使用确定性顺序可以使用“diff”等简单工具进行比较。"
    },
    {
      "indent": 3,
      "text": "This is the default order.",
      "zh-CHS": "这是默认顺序。"
    },
    {
      "indent": 0,
      "text": "7.7.5.2. ordered-by user",
      "section_title": true,
      "zh-CHS": "7.7.5.2. 按用户订购"
    },
    {
      "indent": 3,
      "text": "The entries in the list are sorted according to an order defined by the user. This order is controlled by using special XML attributes in the <edit-config> request. See Section 7.7.7 for details.",
      "zh-CHS": "列表中的条目根据用户定义的顺序进行排序。此顺序通过在<edit config>请求中使用特殊的XML属性来控制。详见第7.7.7节。"
    },
    {
      "indent": 0,
      "text": "7.7.6. XML Mapping Rules",
      "section_title": true,
      "zh-CHS": "7.7.6. XML映射规则"
    },
    {
      "indent": 3,
      "text": "A leaf-list node is encoded as a series of XML elements. Each element's local name is the leaf-list's identifier, and its namespace is the module's XML namespace (see Section 7.1.3).",
      "zh-CHS": "叶列表节点编码为一系列XML元素。每个元素的本地名称是叶列表的标识符，其名称空间是模块的XML名称空间（参见第7.1.3节）。"
    },
    {
      "indent": 3,
      "text": "The value of each leaf-list entry is encoded to XML according to the type, and sent as character data in the element.",
      "zh-CHS": "每个叶列表条目的值根据类型编码为XML，并作为元素中的字符数据发送。"
    },
    {
      "indent": 3,
      "text": "The XML elements representing leaf-list entries MUST appear in the order specified by the user if the leaf-list is \"ordered-by user\"; otherwise, the order is implementation-dependent. The XML elements",
      "zh-CHS": "如果叶列表是“按用户排序”的，则表示叶列表条目的XML元素必须按照用户指定的顺序出现；否则，顺序取决于实现。XML元素"
    },
    {
      "indent": 3,
      "text": "representing leaf-list entries MAY be interleaved with other sibling elements, unless the leaf-list defines RPC input or output parameters.",
      "zh-CHS": "除非叶列表定义了RPC输入或输出参数，否则表示叶列表的条目可以与其他同级元素交错。"
    },
    {
      "indent": 3,
      "text": "See Section 7.7.8 for an example.",
      "zh-CHS": "示例见第7.7.8节。"
    },
    {
      "indent": 0,
      "text": "7.7.7. NETCONF <edit-config> Operations",
      "section_title": true,
      "zh-CHS": "7.7.7. NETCONF<edit config>操作"
    },
    {
      "indent": 3,
      "text": "Leaf-list entries can be created and deleted, but not modified, through <edit-config>, by using the \"operation\" attribute in the leaf-list entry's XML element.",
      "zh-CHS": "通过使用叶列表条目的XML元素中的“operation”属性，可以创建和删除叶列表条目，但不能修改。"
    },
    {
      "indent": 3,
      "text": "In an \"ordered-by user\" leaf-list, the attributes \"insert\" and \"value\" in the YANG XML namespace (Section 5.3.1) can be used to control where in the leaf-list the entry is inserted. These can be used during \"create\" operations to insert a new leaf-list entry, or during \"merge\" or \"replace\" operations to insert a new leaf-list entry or move an existing one.",
      "zh-CHS": "在“按用户排序”叶列表中，XML命名空间（第5.3.1节）中的属性“插入”和“值”可用于控制在叶列表中插入条目的位置。这些可以在“创建”操作期间用于插入新的叶列表条目，或在“合并”或“替换”操作期间用于插入新的叶列表条目或移动现有的叶列表条目。"
    },
    {
      "indent": 3,
      "text": "The \"insert\" attribute can take the values \"first\", \"last\", \"before\", and \"after\". If the value is \"before\" or \"after\", the \"value\" attribute MUST also be used to specify an existing entry in the leaf-list.",
      "zh-CHS": "“insert”属性可以采用值“first”、“last”、“before”和“after”。如果值为“before”或“after”，则“value”属性还必须用于指定叶列表中的现有条目。"
    },
    {
      "indent": 3,
      "text": "If no \"insert\" attribute is present in the \"create\" operation, it defaults to \"last\".",
      "zh-CHS": "如果“创建”操作中不存在“插入”属性，则默认为“最后”。"
    },
    {
      "indent": 3,
      "text": "If several entries in an \"ordered-by user\" leaf-list are modified in the same <edit-config> request, the entries are modified one at the time, in the order of the XML elements in the request.",
      "zh-CHS": "如果在同一<edit config>请求中修改了“ordered by user”叶列表中的多个条目，则这些条目将按照请求中XML元素的顺序一次修改一个。"
    },
    {
      "indent": 3,
      "text": "In a <copy-config>, or an <edit-config> with a \"replace\" operation that covers the entire leaf-list, the leaf-list order is the same as the order of the XML elements in the request.",
      "zh-CHS": "在包含整个叶列表的“replace”操作的<copy config>或<edit config>中，叶列表顺序与请求中XML元素的顺序相同。"
    },
    {
      "indent": 3,
      "text": "When a NETCONF server processes an <edit-config> request, the elements of procedure for a leaf-list node are:",
      "zh-CHS": "当NETCONF服务器处理<edit config>请求时，叶列表节点的过程元素包括："
    },
    {
      "indent": 6,
      "text": "If the operation is \"merge\" or \"replace\", the leaf-list entry is created if it does not exist.",
      "zh-CHS": "如果操作为“合并”或“替换”，则会在叶列表条目不存在时创建该条目。"
    },
    {
      "indent": 6,
      "text": "If the operation is \"create\", the leaf-list entry is created if it does not exist. If the leaf-list entry already exists, a \"data-exists\" error is returned.",
      "zh-CHS": "如果操作为“创建”，则会创建不存在的叶列表条目。如果叶列表条目已经存在，则返回“数据存在”错误。"
    },
    {
      "indent": 6,
      "text": "If the operation is \"delete\", the entry is deleted from the leaf-list if it exists. If the leaf-list entry does not exist, a \"data-missing\" error is returned.",
      "zh-CHS": "如果操作为“删除”，则该条目将从叶列表中删除（如果存在）。如果叶列表条目不存在，则返回“数据丢失”错误。"
    },
    {
      "indent": 0,
      "text": "7.7.8. Usage Example",
      "section_title": true,
      "zh-CHS": "7.7.8. 用法示例"
    },
    {
      "indent": 5,
      "text": "leaf-list allow-user  {\n    type string;\n    description \"A list of user name patterns to allow\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example:",
      "zh-CHS": "对应的XML实例示例："
    },
    {
      "indent": 5,
      "text": "<allow-user>alice</allow-user>\n<allow-user>bob</allow-user>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "To create a new element in this list, using the default <edit-config> operation \"merge\":",
      "zh-CHS": "要在此列表中创建新元素，请使用默认的<edit config>操作“merge”："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <edit-config>\n    <target>\n      <running/>\n    </target>\n    <config>\n      <system xmlns=\"http://example.com/schema/config\">\n        <services>\n          <ssh>\n            <allow-user>eric</allow-user>\n          </ssh>\n        </services>\n      </system>\n    </config>\n  </edit-config>\n</rpc>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Given the following ordered-by user leaf-list:",
      "zh-CHS": "给定按用户叶列表排序的以下内容："
    },
    {
      "indent": 5,
      "text": "leaf-list cipher  {\n    type string;\n    ordered-by user;\n    description \"A list of ciphers\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The following would be used to insert a new cipher \"blowfish-cbc\" after \"3des-cbc\":",
      "zh-CHS": "以下内容将用于在“3des cbc”之后插入新密码“河豚cbc”："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:yang=\"urn:ietf:params:xml:ns:yang:1\">\n  <edit-config>\n    <target>\n      <running/>\n    </target>\n    <config>\n      <system xmlns=\"http://example.com/schema/config\">\n        <services>\n          <ssh>\n            <cipher nc:operation=\"create\"\n                    yang:insert=\"after\"\n                    yang:value=\"3des-cbc\">blowfish-cbc</cipher>\n          </ssh>\n        </services>\n      </system>\n    </config>\n  </edit-config>\n</rpc>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.8. The list Statement",
      "section_title": true,
      "zh-CHS": "7.8. 列表语句"
    },
    {
      "indent": 3,
      "text": "The \"list\" statement is used to define an interior data node in the schema tree. A list node may exist in multiple instances in the data tree. Each such instance is known as a list entry. The \"list\" statement takes one argument, which is an identifier, followed by a block of substatements that holds detailed list information.",
      "zh-CHS": "“list”语句用于定义模式树中的内部数据节点。列表节点可能存在于数据树中的多个实例中。每个这样的实例称为列表条目。“list”语句接受一个参数，它是一个标识符，后跟一个包含详细列表信息的子语句块。"
    },
    {
      "indent": 3,
      "text": "A list entry is uniquely identified by the values of the list's keys, if defined.",
      "zh-CHS": "列表项由列表键的值唯一标识（如果已定义）。"
    },
    {
      "indent": 0,
      "text": "7.8.1. The list's Substatements",
      "section_title": true,
      "zh-CHS": "7.8.1. 列表的子状态"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| anyxml       | 7.10    | 0..n        |\n| choice       | 7.9     | 0..n        |\n| config       | 7.19.1  | 0..1        |\n| container    | 7.5     | 0..n        |\n| description  | 7.19.3  | 0..1        |\n| grouping     | 7.11    | 0..n        |\n| if-feature   | 7.18.2  | 0..n        |\n| key          | 7.8.2   | 0..1        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| max-elements | 7.7.4   | 0..1        |\n| min-elements | 7.7.3   | 0..1        |\n| must         | 7.5.3   | 0..n        |\n| ordered-by   | 7.7.5   | 0..1        |\n| reference    | 7.19.4  | 0..1        |\n| status       | 7.19.2  | 0..1        |\n| typedef      | 7.3     | 0..n        |\n| unique       | 7.8.3   | 0..n        |\n| uses         | 7.12    | 0..n        |\n| when         | 7.19.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.8.2. The list's key Statement",
      "section_title": true,
      "zh-CHS": "7.8.2. 清单的关键声明"
    },
    {
      "indent": 3,
      "text": "The \"key\" statement, which MUST be present if the list represents configuration, and MAY be present otherwise, takes as an argument a string that specifies a space-separated list of leaf identifiers of this list. A leaf identifier MUST NOT appear more than once in the key. Each such leaf identifier MUST refer to a child leaf of the list. The leafs can be defined directly in substatements to the list, or in groupings used in the list.",
      "zh-CHS": "如果列表表示配置，则“key”语句必须存在，否则可能存在。该语句将一个字符串作为参数，该字符串指定此列表的叶标识符的以空格分隔的列表。叶标识符在键中不能出现多次。每个这样的叶标识符必须引用列表的子叶。可以直接在列表的子状态或列表中使用的分组中定义LEAF。"
    },
    {
      "indent": 3,
      "text": "The combined values of all the leafs specified in the key are used to uniquely identify a list entry. All key leafs MUST be given values when a list entry is created. Thus, any default values in the key leafs or their types are ignored. It also implies that any mandatory statement in the key leafs are ignored.",
      "zh-CHS": "键中指定的所有叶的组合值用于唯一标识列表项。创建列表条目时，必须为所有键叶指定值。因此，将忽略键叶或其类型中的任何默认值。它还意味着忽略键叶中的任何强制语句。"
    },
    {
      "indent": 3,
      "text": "A leaf that is part of the key can be of any built-in or derived type, except it MUST NOT be the built-in type \"empty\".",
      "zh-CHS": "作为键的一部分的叶可以是任何内置类型或派生类型，但它不能是内置类型“empty”。"
    },
    {
      "indent": 3,
      "text": "All key leafs in a list MUST have the same value for their \"config\" as the list itself.",
      "zh-CHS": "列表中的所有键叶的“配置”值必须与列表本身的值相同。"
    },
    {
      "indent": 3,
      "text": "The key string syntax is formally defined by the rule \"key-arg\" in Section 12.",
      "zh-CHS": "键字符串语法由第12节中的规则“key arg”正式定义。"
    },
    {
      "indent": 0,
      "text": "7.8.3. The list's unique Statement",
      "section_title": true,
      "zh-CHS": "7.8.3. 列表的唯一声明"
    },
    {
      "indent": 3,
      "text": "The \"unique\" statement is used to put constraints on valid list entries. It takes as an argument a string that contains a space-separated list of schema node identifiers, which MUST be given in the descendant form (see the rule \"descendant-schema-nodeid\" in Section 12). Each such schema node identifier MUST refer to a leaf.",
      "zh-CHS": "“unique”语句用于对有效列表项进行约束。它接受一个字符串作为参数，该字符串包含一个以空格分隔的模式节点标识符列表，该列表必须以子代形式给出（请参阅第12节中的规则“子代模式节点ID”）。每个这样的模式节点标识符必须引用一个叶。"
    },
    {
      "indent": 3,
      "text": "If one of the referenced leafs represents configuration data, then all of the referenced leafs MUST represent configuration data.",
      "zh-CHS": "如果其中一个引用的leaf表示配置数据，那么所有引用的leaf都必须表示配置数据。"
    },
    {
      "indent": 3,
      "text": "The \"unique\" constraint specifies that the combined values of all the leaf instances specified in the argument string, including leafs with default values, MUST be unique within all list entry instances in which all referenced leafs exist. The constraint is enforced according to the rules in Section 8.",
      "zh-CHS": "“unique”约束指定参数字符串中指定的所有叶实例（包括具有默认值的叶）的组合值在所有引用叶存在的所有列表条目实例中必须是唯一的。根据第8节中的规则强制执行约束。"
    },
    {
      "indent": 3,
      "text": "The unique string syntax is formally defined by the rule \"unique-arg\" in Section 12.",
      "zh-CHS": "唯一字符串语法由第12节中的规则“unique arg”正式定义。"
    },
    {
      "indent": 0,
      "text": "7.8.3.1. Usage Example",
      "section_title": true,
      "zh-CHS": "7.8.3.1. 用法示例"
    },
    {
      "indent": 3,
      "text": "With the following list:",
      "zh-CHS": "以下是："
    },
    {
      "indent": 5,
      "text": "list server {\n    key \"name\";\n    unique \"ip port\";\n    leaf name {\n        type string;\n    }\n    leaf ip {\n        type inet:ip-address;\n    }\n    leaf port {\n        type inet:port-number;\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The following configuration is not valid:",
      "zh-CHS": "以下配置无效："
    },
    {
      "indent": 5,
      "text": "<server>\n  <name>smtp</name>\n  <ip>192.0.2.1</ip>\n  <port>25</port>\n</server>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "<server>\n  <name>http</name>\n  <ip>192.0.2.1</ip>\n  <port>25</port>\n</server>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The following configuration is valid, since the \"http\" and \"ftp\" list entries do not have a value for all referenced leafs, and are thus not taken into account when the \"unique\" constraint is enforced:",
      "zh-CHS": "以下配置是有效的，因为“http”和“ftp”列表项没有针对所有引用的leaf的值，因此在强制执行“unique”约束时不考虑这些值："
    },
    {
      "indent": 5,
      "text": "<server>\n  <name>smtp</name>\n  <ip>192.0.2.1</ip>\n  <port>25</port>\n</server>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "<server>\n  <name>http</name>\n  <ip>192.0.2.1</ip>\n</server>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "<server>\n  <name>ftp</name>\n  <ip>192.0.2.1</ip>\n</server>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.8.4. The list's Child Node Statements",
      "section_title": true,
      "zh-CHS": "7.8.4. 列表的子节点语句"
    },
    {
      "indent": 3,
      "text": "Within a list, the \"container\", \"leaf\", \"list\", \"leaf-list\", \"uses\", \"choice\", and \"anyxml\" statements can be used to define child nodes to the list.",
      "zh-CHS": "在列表中，“container”、“leaf”、“list”、“leaf list”、“uses”、“choice”和“anyxml”语句可用于定义列表的子节点。"
    },
    {
      "indent": 0,
      "text": "7.8.5. XML Mapping Rules",
      "section_title": true,
      "zh-CHS": "7.8.5. XML映射规则"
    },
    {
      "indent": 3,
      "text": "A list is encoded as a series of XML elements, one for each entry in the list. Each element's local name is the list's identifier, and its namespace is the module's XML namespace (see Section 7.1.3).",
      "zh-CHS": "列表被编码为一系列XML元素，列表中的每个条目对应一个XML元素。每个元素的本地名称是列表的标识符，其名称空间是模块的XML名称空间（参见第7.1.3节）。"
    },
    {
      "indent": 3,
      "text": "The list's key nodes are encoded as subelements to the list's identifier element, in the same order as they are defined within the \"key\" statement.",
      "zh-CHS": "列表的关键节点被编码为列表标识符元素的子元素，其顺序与“key”语句中定义的顺序相同。"
    },
    {
      "indent": 3,
      "text": "The rest of the list's child nodes are encoded as subelements to the list element, after the keys. If the list defines RPC input or output parameters, the subelements are encoded in the same order as they are defined within the \"list\" statement. Otherwise, the subelements are encoded in any order.",
      "zh-CHS": "列表的其余子节点在键之后编码为列表元素的子元素。如果列表定义了RPC输入或输出参数，则子元素的编码顺序与“list”语句中定义的顺序相同。否则，子元素按任意顺序编码。"
    },
    {
      "indent": 3,
      "text": "The XML elements representing list entries MUST appear in the order specified by the user if the list is \"ordered-by user\", otherwise the order is implementation-dependent. The XML elements representing list entries MAY be interleaved with other sibling elements, unless the list defines RPC input or output parameters.",
      "zh-CHS": "如果列表是“按用户排序”的，则表示列表项的XML元素必须按照用户指定的顺序出现，否则顺序取决于实现。表示列表项的XML元素可以与其他同级元素交错，除非列表定义了RPC输入或输出参数。"
    },
    {
      "indent": 0,
      "text": "7.8.6. NETCONF <edit-config> Operations",
      "section_title": true,
      "zh-CHS": "7.8.6. NETCONF<edit config>操作"
    },
    {
      "indent": 3,
      "text": "List entries can be created, deleted, replaced, and modified through <edit-config>, by using the \"operation\" attribute in the list's XML element. In each case, the values of all keys are used to uniquely identify a list entry. If all keys are not specified for a list entry, a \"missing-element\" error is returned.",
      "zh-CHS": "通过使用列表XML元素中的“operation”属性，可以通过<edit config>创建、删除、替换和修改列表条目。在每种情况下，所有键的值都用于唯一标识列表条目。如果没有为列表项指定所有键，则返回“缺少元素”错误。"
    },
    {
      "indent": 3,
      "text": "In an \"ordered-by user\" list, the attributes \"insert\" and \"key\" in the YANG XML namespace (Section 5.3.1) can be used to control where in the list the entry is inserted. These can be used during \"create\" operations to insert a new list entry, or during \"merge\" or \"replace\" operations to insert a new list entry or move an existing one.",
      "zh-CHS": "在“按用户排序”列表中，XML名称空间（第5.3.1节）中的属性“插入”和“键”可用于控制条目在列表中插入的位置。可以在“创建”操作期间插入新列表项，或在“合并”或“替换”操作期间插入新列表项或移动现有列表项。"
    },
    {
      "indent": 3,
      "text": "The \"insert\" attribute can take the values \"first\", \"last\", \"before\", and \"after\". If the value is \"before\" or \"after\", the \"key\" attribute MUST also be used, to specify an existing element in the list. The value of the \"key\" attribute is the key predicates of the full instance identifier (see Section 9.13) for the list entry.",
      "zh-CHS": "“insert”属性可以采用值“first”、“last”、“before”和“after”。如果值为“before”或“after”，则还必须使用“key”属性来指定列表中的现有元素。“key”属性的值是列表项的完整实例标识符（见第9.13节）的键谓词。"
    },
    {
      "indent": 3,
      "text": "If no \"insert\" attribute is present in the \"create\" operation, it defaults to \"last\".",
      "zh-CHS": "如果“创建”操作中不存在“插入”属性，则默认为“最后”。"
    },
    {
      "indent": 3,
      "text": "If several entries in an \"ordered-by user\" list are modified in the same <edit-config> request, the entries are modified one at the time, in the order of the XML elements in the request.",
      "zh-CHS": "如果在同一个<edit config>请求中修改了“ordered by user”（按用户排序）列表中的多个条目，则会按照请求中XML元素的顺序一次修改一个条目。"
    },
    {
      "indent": 3,
      "text": "In a <copy-config>, or an <edit-config> with a \"replace\" operation that covers the entire list, the list entry order is the same as the order of the XML elements in the request.",
      "zh-CHS": "在覆盖整个列表的带有“replace”操作的<copy config>或<edit config>中，列表条目顺序与请求中XML元素的顺序相同。"
    },
    {
      "indent": 3,
      "text": "When a NETCONF server processes an <edit-config> request, the elements of procedure for a list node are:",
      "zh-CHS": "当NETCONF服务器处理<edit config>请求时，列表节点的过程元素包括："
    },
    {
      "indent": 6,
      "text": "If the operation is \"merge\" or \"replace\", the list entry is created if it does not exist. If the list entry already exists and the \"insert\" and \"key\" attributes are present, the list entry is moved according to the values of the \"insert\" and \"key\" attributes. If the list entry exists and the \"insert\" and \"key\" attributes are not present, the list entry is not moved.",
      "zh-CHS": "If the operation is \"merge\" or \"replace\", the list entry is created if it does not exist. If the list entry already exists and the \"insert\" and \"key\" attributes are present, the list entry is moved according to the values of the \"insert\" and \"key\" attributes. If the list entry exists and the \"insert\" and \"key\" attributes are not present, the list entry is not moved.translate error, please retry"
    },
    {
      "indent": 6,
      "text": "If the operation is \"create\", the list entry is created if it does not exist. If the list entry already exists, a \"data-exists\" error is returned.",
      "zh-CHS": "如果操作为“创建”，则在列表项不存在时创建列表项。如果列表条目已经存在，则返回“数据存在”错误。"
    },
    {
      "indent": 6,
      "text": "If the operation is \"delete\", the entry is deleted from the list if it exists. If the list entry does not exist, a \"data-missing\" error is returned.",
      "zh-CHS": "如果操作为“删除”，则该条目将从列表中删除（如果存在）。如果列表项不存在，则返回“数据丢失”错误。"
    },
    {
      "indent": 0,
      "text": "7.8.7. Usage Example",
      "section_title": true,
      "zh-CHS": "7.8.7. 用法示例"
    },
    {
      "indent": 3,
      "text": "Given the following list:",
      "zh-CHS": "鉴于以下清单："
    },
    {
      "indent": 5,
      "text": "list user {\n    key \"name\";\n    config true;\n    description \"This is a list of users in the system.\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "    leaf name {\n        type string;\n    }\n    leaf type {\n        type string;\n    }\n    leaf full-name {\n        type string;\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example:",
      "zh-CHS": "对应的XML实例示例："
    },
    {
      "indent": 5,
      "text": "<user>\n  <name>fred</name>\n  <type>admin</type>\n  <full-name>Fred Flintstone</full-name>\n</user>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "To create a new user \"barney\":",
      "zh-CHS": "要创建新用户“barney”："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <edit-config>\n    <target>\n      <running/>\n    </target>\n    <config>\n      <system xmlns=\"http://example.com/schema/config\">\n        <user nc:operation=\"create\">\n          <name>barney</name>\n          <type>admin</type>\n          <full-name>Barney Rubble</full-name>\n        </user>\n      </system>\n    </config>\n  </edit-config>\n</rpc>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "To change the type of \"fred\" to \"superuser\":",
      "zh-CHS": "要将“fred”的类型更改为“超级用户”："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <edit-config>\n    <target>\n      <running/>\n    </target>\n    <config>\n      <system xmlns=\"http://example.com/schema/config\">\n        <user>\n          <name>fred</name>\n          <type>superuser</type>\n        </user>\n      </system>\n    </config>\n  </edit-config>\n</rpc>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Given the following ordered-by user list:",
      "zh-CHS": "给定以下按用户顺序排列的列表："
    },
    {
      "indent": 5,
      "text": "list user {\n    description \"This is a list of users in the system.\";\n    ordered-by user;\n    config true;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "key \"name\";",
      "zh-CHS": "键“名称”；"
    },
    {
      "indent": 5,
      "text": "    leaf name {\n        type string;\n    }\n    leaf type {\n        type string;\n    }\n    leaf full-name {\n        type string;\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The following would be used to insert a new user \"barney\" after the user \"fred\":",
      "zh-CHS": "以下内容将用于在用户“fred”之后插入新用户“barney”："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:yang=\"urn:ietf:params:xml:ns:yang:1\">\n  <edit-config>\n    <target>\n      <running/>\n    </target>\n    <config>\n      <system xmlns=\"http://example.com/schema/config\"\n           xmlns:ex=\"http://example.com/schema/config\">\n        <user nc:operation=\"create\"\n              yang:insert=\"after\"\n              yang:key=\"[ex:name='fred']\">\n          <name>barney</name>\n          <type>admin</type>\n          <full-name>Barney Rubble</full-name>\n        </user>\n      </system>\n    </config>\n  </edit-config>\n</rpc>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The following would be used to move the user \"barney\" before the user \"fred\":",
      "zh-CHS": "以下内容将用于将用户“barney”移动到用户“fred”之前："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:yang=\"urn:ietf:params:xml:ns:yang:1\">\n  <edit-config>\n    <target>\n      <running/>\n    </target>\n    <config>\n      <system xmlns=\"http://example.com/schema/config\"\n           xmlns:ex=\"http://example.com/schema/config\">\n        <user nc:operation=\"merge\"\n              yang:insert=\"before\"\n              yang:key=\"[ex:name='fred']\">\n          <name>barney</name>\n        </user>\n      </system>\n    </config>\n  </edit-config>\n</rpc>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.9. The choice Statement",
      "section_title": true,
      "zh-CHS": "7.9. 选择声明"
    },
    {
      "indent": 3,
      "text": "The \"choice\" statement defines a set of alternatives, only one of which may exist at any one time. The argument is an identifier, followed by a block of substatements that holds detailed choice information. The identifier is used to identify the choice node in the schema tree. A choice node does not exist in the data tree.",
      "zh-CHS": "“choice”语句定义了一组备选方案，在任何时候都只能存在其中一个。参数是一个标识符，后跟一个包含详细选择信息的子语句块。标识符用于标识模式树中的选择节点。数据树中不存在选择节点。"
    },
    {
      "indent": 3,
      "text": "A choice consists of a number of branches, defined with the \"case\" substatement. Each branch contains a number of child nodes. The nodes from at most one of the choice's branches exist at the same time.",
      "zh-CHS": "选项由许多分支组成，这些分支用“case”子语句定义。每个分支包含多个子节点。最多一个选项分支中的节点同时存在。"
    },
    {
      "indent": 3,
      "text": "See Section 8.3.2 for additional information.",
      "zh-CHS": "更多信息见第8.3.2节。"
    },
    {
      "indent": 0,
      "text": "7.9.1. The choice's Substatements",
      "section_title": true,
      "zh-CHS": "7.9.1. 选择的子状态"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| anyxml       | 7.10    | 0..n        |\n| case         | 7.9.2   | 0..n        |\n| config       | 7.19.1  | 0..1        |\n| container    | 7.5     | 0..n        |\n| default      | 7.9.3   | 0..1        |\n| description  | 7.19.3  | 0..1        |\n| if-feature   | 7.18.2  | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| mandatory    | 7.9.4   | 0..1        |\n| reference    | 7.19.4  | 0..1        |\n| status       | 7.19.2  | 0..1        |\n| when         | 7.19.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.9.2. The choice's case Statement",
      "section_title": true,
      "zh-CHS": "7.9.2. 选择的案例陈述"
    },
    {
      "indent": 3,
      "text": "The \"case\" statement is used to define branches of the choice. It takes as an argument an identifier, followed by a block of substatements that holds detailed case information.",
      "zh-CHS": "“case”语句用于定义选项的分支。它将标识符作为参数，后跟一个包含详细案例信息的子语句块。"
    },
    {
      "indent": 3,
      "text": "The identifier is used to identify the case node in the schema tree. A case node does not exist in the data tree.",
      "zh-CHS": "标识符用于标识模式树中的案例节点。数据树中不存在案例节点。"
    },
    {
      "indent": 3,
      "text": "Within a \"case\" statement, the \"anyxml\", \"choice\", \"container\", \"leaf\", \"list\", \"leaf-list\", and \"uses\" statements can be used to define child nodes to the case node. The identifiers of all these child nodes MUST be unique within all cases in a choice. For example, the following is illegal:",
      "zh-CHS": "在“case”语句中，“anyxml”、“choice”、“container”、“leaf”、“list”、“leaf list”和“uses”语句可用于定义case节点的子节点。所有这些子节点的标识符在选项的所有情况下都必须是唯一的。例如，以下行为是非法的："
    },
    {
      "indent": 5,
      "text": "choice interface-type {     // This example is illegal YANG\n    case a {\n        leaf ethernet { ... }\n    }\n    case b {\n        container ethernet { ...}\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "As a shorthand, the \"case\" statement can be omitted if the branch contains a single \"anyxml\", \"container\", \"leaf\", \"list\", or \"leaf-list\" statement. In this case, the identifier of the case node is the same as the identifier in the branch statement. The following example:",
      "zh-CHS": "简而言之，如果分支包含单个“anyxml”、“container”、“leaf”、“list”或“leaf list”语句，则可以省略“case”语句。在这种情况下，案例节点的标识符与分支语句中的标识符相同。下面是一个例子："
    },
    {
      "indent": 5,
      "text": "choice interface-type {\n    container ethernet { ... }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "is equivalent to:",
      "zh-CHS": "相当于："
    },
    {
      "indent": 5,
      "text": "choice interface-type {\n    case ethernet {\n        container ethernet { ... }\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The case identifier MUST be unique within a choice.",
      "zh-CHS": "案例标识符在选项中必须是唯一的。"
    },
    {
      "indent": 0,
      "text": "7.9.2.1. The case's Substatements",
      "section_title": true,
      "zh-CHS": "7.9.2.1. 本案的子条款"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| anyxml       | 7.10    | 0..n        |\n| choice       | 7.9     | 0..n        |\n| container    | 7.5     | 0..n        |\n| description  | 7.19.3  | 0..1        |\n| if-feature   | 7.18.2  | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| reference    | 7.19.4  | 0..1        |\n| status       | 7.19.2  | 0..1        |\n| uses         | 7.12    | 0..n        |\n| when         | 7.19.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.9.3. The choice's default Statement",
      "section_title": true,
      "zh-CHS": "7.9.3. 选项的默认语句"
    },
    {
      "indent": 3,
      "text": "The \"default\" statement indicates if a case should be considered as the default if no child nodes from any of the choice's cases exist. The argument is the identifier of the \"case\" statement. If the \"default\" statement is missing, there is no default case.",
      "zh-CHS": "“default”语句表示如果该选项的任何案例都不存在子节点，则该案例是否应被视为默认案例。参数是“case”语句的标识符。如果缺少“default”语句，则不存在默认情况。"
    },
    {
      "indent": 3,
      "text": "The \"default\" statement MUST NOT be present on choices where \"mandatory\" is true.",
      "zh-CHS": "“默认”语句不得出现在“强制”为真的选项上。"
    },
    {
      "indent": 3,
      "text": "The default case is only important when considering the default values of nodes under the cases. The default values for nodes under the default case are used if none of the nodes under any of the cases are present.",
      "zh-CHS": "只有在考虑案例下节点的默认值时，默认案例才很重要。如果任何情况下的节点均不存在，则使用默认情况下的节点的默认值。"
    },
    {
      "indent": 3,
      "text": "There MUST NOT be any mandatory nodes (Section 3.1) directly under the default case.",
      "zh-CHS": "默认情况下不得有任何强制节点（第3.1节）。"
    },
    {
      "indent": 3,
      "text": "Default values for child nodes under a case are only used if one of the nodes under that case is present, or if that case is the default case. If none of the nodes under a case are present and the case is not the default case, the default values of the cases' child nodes are ignored.",
      "zh-CHS": "仅当案例下的一个节点存在或该案例为默认案例时，才会使用该案例下的子节点的默认值。如果案例下的所有节点都不存在且案例不是默认案例，则案例子节点的默认值将被忽略。"
    },
    {
      "indent": 3,
      "text": "In this example, the choice defaults to \"interval\", and the default value will be used if none of \"daily\", \"time-of-day\", or \"manual\" are present. If \"daily\" is present, the default value for \"time-of-day\" will be used.",
      "zh-CHS": "在本例中，该选项默认为“interval”，如果“daily”、“time of day”或“manual”均不存在，则将使用默认值。如果存在“每日”，则将使用“每日时间”的默认值。"
    },
    {
      "indent": 5,
      "text": "container transfer {\n    choice how {\n        default interval;\n        case interval {\n            leaf interval {\n                type uint16;\n                default 30;\n                units minutes;\n            }\n        }\n        case daily {\n            leaf daily {\n                type empty;\n            }\n            leaf time-of-day {\n                type string;\n                units 24-hour-clock;\n                default 1am;\n            }\n        }\n        case manual {\n            leaf manual {\n                type empty;\n            }\n        }\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.9.4. The choice's mandatory Statement",
      "section_title": true,
      "zh-CHS": "7.9.4. 选择的强制性声明"
    },
    {
      "indent": 3,
      "text": "The \"mandatory\" statement, which is optional, takes as an argument the string \"true\" or \"false\", and puts a constraint on valid data. If \"mandatory\" is \"true\", at least one node from exactly one of the choice's case branches MUST exist.",
      "zh-CHS": "“mandatory”语句是可选的，它将字符串“true”或“false”作为参数，并对有效数据进行约束。如果“mandatory”为“true”，则必须至少存在一个节点，该节点恰好来自该选项的一个案例分支。"
    },
    {
      "indent": 3,
      "text": "If not specified, the default is \"false\".",
      "zh-CHS": "如果未指定，则默认值为“false”。"
    },
    {
      "indent": 3,
      "text": "The behavior of the constraint depends on the type of the choice's closest ancestor node in the schema tree which is not a non-presence container (see Section 7.5.1):",
      "zh-CHS": "约束的行为取决于模式树中选择的最近祖先节点的类型，该节点不是非存在容器（参见第7.5.1节）："
    },
    {
      "indent": 3,
      "text": "o If this ancestor is a case node, the constraint is enforced if any other node from the case exists.",
      "zh-CHS": "o 如果此祖先是案例节点，则如果案例中存在任何其他节点，则强制执行约束。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, it is enforced if the ancestor node exists.",
      "zh-CHS": "o 否则，如果祖先节点存在，则强制执行。"
    },
    {
      "indent": 3,
      "text": "The constraint is further enforced according to the rules in Section 8.",
      "zh-CHS": "根据第8节中的规则，进一步实施约束。"
    },
    {
      "indent": 0,
      "text": "7.9.5. XML Mapping Rules",
      "section_title": true,
      "zh-CHS": "7.9.5. XML映射规则"
    },
    {
      "indent": 3,
      "text": "The choice and case nodes are not visible in XML.",
      "zh-CHS": "choice和case节点在XML中不可见。"
    },
    {
      "indent": 3,
      "text": "The child nodes of the selected \"case\" statement MUST be encoded in the same order as they are defined in the \"case\" statement if they are part of an RPC input or output parameter definition. Otherwise, the subelements are encoded in any order.",
      "zh-CHS": "如果所选“case”语句的子节点是RPC输入或输出参数定义的一部分，则必须按照与“case”语句中定义的子节点相同的顺序对其进行编码。否则，子元素按任意顺序编码。"
    },
    {
      "indent": 0,
      "text": "7.9.6. NETCONF <edit-config> Operations",
      "section_title": true,
      "zh-CHS": "7.9.6. NETCONF<edit config>操作"
    },
    {
      "indent": 3,
      "text": "Since only one of the choice's cases can be valid at any time, the creation of a node from one case implicitly deletes all nodes from all other cases. If an <edit-config> operation creates a node from a case, the NETCONF server will delete any existing nodes that are defined in other cases inside the choice.",
      "zh-CHS": "由于在任何时候只有一个选项的案例是有效的，因此从一个案例创建节点会隐式删除所有其他案例中的所有节点。如果<edit config>操作从案例中创建节点，NETCONF服务器将删除在选项中的其他案例中定义的任何现有节点。"
    },
    {
      "indent": 0,
      "text": "7.9.7. Usage Example",
      "section_title": true,
      "zh-CHS": "7.9.7. 用法示例"
    },
    {
      "indent": 3,
      "text": "Given the following choice:",
      "zh-CHS": "鉴于以下选择："
    },
    {
      "indent": 5,
      "text": "container protocol {\n    choice name {\n        case a {\n            leaf udp {\n                type empty;\n            }\n        }\n        case b {\n            leaf tcp {\n               type empty;\n            }\n        }\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example:",
      "zh-CHS": "对应的XML实例示例："
    },
    {
      "indent": 5,
      "text": "<protocol>\n  <tcp/>\n</protocol>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "To change the protocol from tcp to udp:",
      "zh-CHS": "要将协议从tcp更改为udp，请执行以下操作："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <edit-config>\n    <target>\n      <running/>\n    </target>\n    <config>\n      <system xmlns=\"http://example.com/schema/config\">\n        <protocol>\n          <udp nc:operation=\"create\"/>\n        </protocol>\n      </system>\n    </config>\n  </edit-config>\n</rpc>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.10. The anyxml Statement",
      "section_title": true,
      "zh-CHS": "7.10. anyxml语句"
    },
    {
      "indent": 3,
      "text": "The \"anyxml\" statement defines an interior node in the schema tree. It takes one argument, which is an identifier, followed by a block of substatements that holds detailed anyxml information.",
      "zh-CHS": "“anyxml”语句在模式树中定义一个内部节点。它有一个参数，它是一个标识符，后跟一个包含详细的anyxml信息的子语句块。"
    },
    {
      "indent": 3,
      "text": "The \"anyxml\" statement is used to represent an unknown chunk of XML. No restrictions are placed on the XML. This can be useful, for example, in RPC replies. An example is the <filter> parameter in the <get-config> operation.",
      "zh-CHS": "“anyxml”语句用于表示未知的XML块。对XML没有任何限制。这可能很有用，例如，在RPC回复中。例如<get config>操作中的<filter>参数。"
    },
    {
      "indent": 3,
      "text": "An anyxml node cannot be augmented (see Section 7.15).",
      "zh-CHS": "不能扩充anyxml节点（参见第7.15节）。"
    },
    {
      "indent": 3,
      "text": "Since the use of anyxml limits the manipulation of the content, it is RECOMMENDED that the \"anyxml\" statement not be used to represent configuration data.",
      "zh-CHS": "由于anyxml的使用限制了对内容的操作，因此建议不要使用“anyxml”语句来表示配置数据。"
    },
    {
      "indent": 3,
      "text": "An anyxml node exists in zero or one instances in the data tree.",
      "zh-CHS": "anyxml节点存在于数据树中的零个或一个实例中。"
    },
    {
      "indent": 0,
      "text": "7.10.1. The anyxml's Substatements",
      "section_title": true,
      "zh-CHS": "7.10.1. anyxml的子语句"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| config       | 7.19.1  | 0..1        |\n| description  | 7.19.3  | 0..1        |\n| if-feature   | 7.18.2  | 0..n        |\n| mandatory    | 7.6.5   | 0..1        |\n| must         | 7.5.3   | 0..n        |\n| reference    | 7.19.4  | 0..1        |\n| status       | 7.19.2  | 0..1        |\n| when         | 7.19.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.10.2. XML Mapping Rules",
      "section_title": true,
      "zh-CHS": "7.10.2. XML映射规则"
    },
    {
      "indent": 3,
      "text": "An anyxml node is encoded as an XML element. The element's local name is the anyxml's identifier, and its namespace is the module's XML namespace (see Section 7.1.3). The value of the anyxml node is encoded as XML content of this element.",
      "zh-CHS": "anyxml节点编码为XML元素。元素的本地名称是anyxml的标识符，其名称空间是模块的XML名称空间（参见第7.1.3节）。anyxml节点的值被编码为该元素的XML内容。"
    },
    {
      "indent": 3,
      "text": "Note that any prefixes used in the encoding are local to each instance encoding. This means that the same XML may be encoded differently by different implementations.",
      "zh-CHS": "请注意，编码中使用的任何前缀都是每个实例编码的本地前缀。这意味着相同的XML可以通过不同的实现进行不同的编码。"
    },
    {
      "indent": 0,
      "text": "7.10.3. NETCONF <edit-config> Operations",
      "section_title": true,
      "zh-CHS": "7.10.3. NETCONF<edit config>操作"
    },
    {
      "indent": 3,
      "text": "An anyxml node is treated as an opaque chunk of data. This data can be modified in its entirety only.",
      "zh-CHS": "anyxml节点被视为不透明的数据块。此数据只能全部修改。"
    },
    {
      "indent": 3,
      "text": "Any \"operation\" attributes present on subelements of an anyxml node are ignored by the NETCONF server.",
      "zh-CHS": "NETCONF服务器将忽略anyxml节点子元素上的任何“操作”属性。"
    },
    {
      "indent": 3,
      "text": "When a NETCONF server processes an <edit-config> request, the elements of procedure for the anyxml node are:",
      "zh-CHS": "当NETCONF服务器处理<edit config>请求时，anyxml节点的过程元素包括："
    },
    {
      "indent": 6,
      "text": "If the operation is \"merge\" or \"replace\", the node is created if it does not exist, and its value is set to the XML content of the anyxml node found in the XML RPC data.",
      "zh-CHS": "如果操作为“merge”或“replace”，则将在节点不存在时创建该节点，并将其值设置为在XML RPC数据中找到的anyxml节点的XML内容。"
    },
    {
      "indent": 6,
      "text": "If the operation is \"create\", the node is created if it does not exist, and its value is set to the XML content of the anyxml node found in the XML RPC data. If the node already exists, a \"data-exists\" error is returned.",
      "zh-CHS": "如果操作为“create”，则将在节点不存在时创建该节点，并将其值设置为在XML RPC数据中找到的anyxml节点的XML内容。如果节点已经存在，则返回“数据存在”错误。"
    },
    {
      "indent": 6,
      "text": "If the operation is \"delete\", the node is deleted if it exists. If the node does not exist, a \"data-missing\" error is returned.",
      "zh-CHS": "如果操作为“删除”，则删除节点（如果存在）。如果节点不存在，则返回“数据丢失”错误。"
    },
    {
      "indent": 0,
      "text": "7.10.4. Usage Example",
      "section_title": true,
      "zh-CHS": "7.10.4. 用法示例"
    },
    {
      "indent": 3,
      "text": "Given the following \"anyxml\" statement:",
      "zh-CHS": "给出以下“anyxml”语句："
    },
    {
      "indent": 5,
      "text": "anyxml data;",
      "zh-CHS": "anyxml数据；"
    },
    {
      "indent": 3,
      "text": "The following are two valid encodings of the same anyxml value:",
      "zh-CHS": "以下是相同anyxml值的两个有效编码："
    },
    {
      "indent": 5,
      "text": "<data xmlns:if=\"http://example.com/ns/interface\">\n  <if:interface>\n    <if:ifIndex>1</if:ifIndex>\n  </if:interface>\n</data>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "<data>\n  <interface xmlns=\"http://example.com/ns/interface\">\n    <ifIndex>1</ifIndex>\n  </interface>\n</data>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.11. The grouping Statement",
      "section_title": true,
      "zh-CHS": "7.11. 分组语句"
    },
    {
      "indent": 3,
      "text": "The \"grouping\" statement is used to define a reusable block of nodes, which may be used locally in the module, in modules that include it, and by other modules that import from it, according to the rules in Section 5.5. It takes one argument, which is an identifier, followed by a block of substatements that holds detailed grouping information.",
      "zh-CHS": "“分组”语句用于定义一个可重用的节点块，根据第5.5节中的规则，该节点块可在模块、包含它的模块以及从中导入的其他模块中本地使用。它采用一个参数（标识符），后跟一个包含详细分组信息的子语句块。"
    },
    {
      "indent": 3,
      "text": "The \"grouping\" statement is not a data definition statement and, as such, does not define any nodes in the schema tree.",
      "zh-CHS": "“grouping”语句不是数据定义语句，因此不定义模式树中的任何节点。"
    },
    {
      "indent": 3,
      "text": "A grouping is like a \"structure\" or a \"record\" in conventional programming languages.",
      "zh-CHS": "分组就像传统编程语言中的“结构”或“记录”。"
    },
    {
      "indent": 3,
      "text": "Once a grouping is defined, it can be referenced in a \"uses\" statement (see Section 7.12). A grouping MUST NOT reference itself, neither directly nor indirectly through a chain of other groupings.",
      "zh-CHS": "定义分组后，可在“使用”语句中引用该分组（见第7.12节）。分组不得直接或间接通过其他分组链引用自身。"
    },
    {
      "indent": 3,
      "text": "If the grouping is defined at the top level of a YANG module or submodule, the grouping's identifier MUST be unique within the module.",
      "zh-CHS": "如果分组是在模块或子模块的顶层定义的，则分组的标识符在模块内必须是唯一的。"
    },
    {
      "indent": 3,
      "text": "A grouping is more than just a mechanism for textual substitution, but defines a collection of nodes. Identifiers appearing inside the grouping are resolved relative to the scope in which the grouping is defined, not where it is used. Prefix mappings, type names, grouping names, and extension usage are evaluated in the hierarchy where the \"grouping\" statement appears. For extensions, this means that extensions are applied to the grouping node, not the uses node.",
      "zh-CHS": "分组不仅仅是一种文本替换机制，还定义了一组节点。出现在分组中的标识符是相对于定义分组的范围而不是使用分组的位置来解析的。前缀映射、类型名称、分组名称和扩展使用在出现“grouping”语句的层次结构中进行评估。对于扩展，这意味着扩展应用于分组节点，而不是使用节点。"
    },
    {
      "indent": 0,
      "text": "7.11.1. The grouping's Substatements",
      "section_title": true,
      "zh-CHS": "7.11.1. 分组的子状态"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| anyxml       | 7.10    | 0..n        |\n| choice       | 7.9     | 0..n        |\n| container    | 7.5     | 0..n        |\n| description  | 7.19.3  | 0..1        |\n| grouping     | 7.11    | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| reference    | 7.19.4  | 0..1        |\n| status       | 7.19.2  | 0..1        |\n| typedef      | 7.3     | 0..n        |\n| uses         | 7.12    | 0..n        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.11.2. Usage Example",
      "section_title": true,
      "zh-CHS": "7.11.2. 用法示例"
    },
    {
      "indent": 5,
      "text": "import ietf-inet-types {\n    prefix \"inet\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "grouping endpoint {\n    description \"A reusable endpoint group.\";\n    leaf ip {\n        type inet:ip-address;\n    }\n    leaf port {\n        type inet:port-number;\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.12. The uses Statement",
      "section_title": true,
      "zh-CHS": "7.12. uses语句"
    },
    {
      "indent": 3,
      "text": "The \"uses\" statement is used to reference a \"grouping\" definition. It takes one argument, which is the name of the grouping.",
      "zh-CHS": "“uses”语句用于引用“grouping”定义。它接受一个参数，即分组的名称。"
    },
    {
      "indent": 3,
      "text": "The effect of a \"uses\" reference to a grouping is that the nodes defined by the grouping are copied into the current schema tree, and then updated according to the \"refine\" and \"augment\" statements.",
      "zh-CHS": "对分组的“uses”引用的效果是将分组定义的节点复制到当前模式树中，然后根据“refine”和“augment”语句进行更新。"
    },
    {
      "indent": 3,
      "text": "The identifiers defined in the grouping are not bound to a namespace until the contents of the grouping are added to the schema tree via a \"uses\" statement that does not appear inside a \"grouping\" statement, at which point they are bound to the namespace of the current module.",
      "zh-CHS": "分组中定义的标识符不会绑定到名称空间，直到分组的内容通过“uses”语句添加到架构树中，该语句不出现在“grouping”语句中，此时它们被绑定到当前模块的名称空间。"
    },
    {
      "indent": 0,
      "text": "7.12.1. The uses's Substatements",
      "section_title": true,
      "zh-CHS": "7.12.1. 用户的子状态"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| augment      | 7.15    | 0..1        |\n| description  | 7.19.3  | 0..1        |\n| if-feature   | 7.18.2  | 0..n        |\n| refine       | 7.12.2  | 0..1        |\n| reference    | 7.19.4  | 0..1        |\n| status       | 7.19.2  | 0..1        |\n| when         | 7.19.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.12.2. The refine Statement",
      "section_title": true,
      "zh-CHS": "7.12.2. 精炼语句"
    },
    {
      "indent": 3,
      "text": "Some of the properties of each node in the grouping can be refined with the \"refine\" statement. The argument is a string that identifies a node in the grouping. This node is called the refine's target node. If a node in the grouping is not present as a target node of a \"refine\" statement, it is not refined, and thus used exactly as it was defined in the grouping.",
      "zh-CHS": "分组中每个节点的某些属性可以使用“refine”语句进行细化。参数是标识分组中节点的字符串。此节点称为优化的目标节点。如果分组中的某个节点不作为“refine”语句的目标节点出现，则该节点不会被细化，因此其使用方式与分组中定义的完全相同。"
    },
    {
      "indent": 3,
      "text": "The argument string is a descendant schema node identifier (see Section 6.5).",
      "zh-CHS": "参数字符串是子模式节点标识符（参见第6.5节）。"
    },
    {
      "indent": 3,
      "text": "The following refinements can be done:",
      "zh-CHS": "可以进行以下改进："
    },
    {
      "indent": 3,
      "text": "o A leaf or choice node may get a default value, or a new default value if it already had one.",
      "zh-CHS": "o 叶节点或选择节点可能会获得默认值，如果已经有默认值，则可能会获得新的默认值。"
    },
    {
      "indent": 3,
      "text": "o Any node may get a specialized \"description\" string.",
      "zh-CHS": "o 任何节点都可以获得专门的“描述”字符串。"
    },
    {
      "indent": 3,
      "text": "o Any node may get a specialized \"reference\" string.",
      "zh-CHS": "o 任何节点都可以获得专门的“引用”字符串。"
    },
    {
      "indent": 3,
      "text": "o Any node may get a different \"config\" statement.",
      "zh-CHS": "o 任何节点都可能得到不同的“config”语句。"
    },
    {
      "indent": 3,
      "text": "o A leaf, anyxml, or choice node may get a different \"mandatory\" statement.",
      "zh-CHS": "o leaf、anyxml或choice节点可能会得到不同的“强制”语句。"
    },
    {
      "indent": 3,
      "text": "o A container node may get a \"presence\" statement.",
      "zh-CHS": "o 容器节点可能会得到“presence”语句。"
    },
    {
      "indent": 3,
      "text": "o A leaf, leaf-list, list, container, or anyxml node may get additional \"must\" expressions.",
      "zh-CHS": "o 叶、叶列表、列表、容器或任意XML节点可能会获得其他“必须”表达式。"
    },
    {
      "indent": 3,
      "text": "o A leaf-list or list node may get a different \"min-elements\" or \"max-elements\" statement.",
      "zh-CHS": "o 叶列表或列表节点可能会得到不同的“最小元素”或“最大元素”语句。"
    },
    {
      "indent": 0,
      "text": "7.12.3. XML Mapping Rules",
      "section_title": true,
      "zh-CHS": "7.12.3. XML映射规则"
    },
    {
      "indent": 3,
      "text": "Each node in the grouping is encoded as if it was defined inline, even if it is imported from another module with another XML namespace.",
      "zh-CHS": "分组中的每个节点都被编码为内联定义，即使它是从另一个具有另一个XML命名空间的模块导入的。"
    },
    {
      "indent": 0,
      "text": "7.12.4. Usage Example",
      "section_title": true,
      "zh-CHS": "7.12.4. 用法示例"
    },
    {
      "indent": 3,
      "text": "To use the \"endpoint\" grouping defined in Section 7.11.2 in a definition of an HTTP server in some other module, we can do:",
      "zh-CHS": "要在其他模块的HTTP服务器定义中使用第7.11.2节中定义的“端点”分组，我们可以执行以下操作："
    },
    {
      "indent": 5,
      "text": "import acme-system {\n    prefix \"acme\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "container http-server {\n    leaf name {\n        type string;\n    }\n    uses acme:endpoint;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example:",
      "zh-CHS": "对应的XML实例示例："
    },
    {
      "indent": 5,
      "text": "<http-server>\n  <name>extern-web</name>\n  <ip>192.0.2.1</ip>\n  <port>80</port>\n</http-server>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "If port 80 should be the default for the HTTP server, default can be added:",
      "zh-CHS": "如果HTTP服务器的默认端口为80，则可以添加默认端口："
    },
    {
      "indent": 5,
      "text": "container http-server {\n    leaf name {\n        type string;\n    }\n    uses acme:endpoint {\n        refine port {\n            default 80;\n        }\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "If we want to define a list of servers, and each server has the ip and port as keys, we can do:",
      "zh-CHS": "如果我们要定义一个服务器列表，并且每个服务器都有ip和端口作为密钥，我们可以执行以下操作："
    },
    {
      "indent": 5,
      "text": "list server {\n    key \"ip port\";\n    leaf name {\n        type string;\n    }\n    uses acme:endpoint;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The following is an error:",
      "zh-CHS": "以下是一个错误："
    },
    {
      "indent": 5,
      "text": "container http-server {\n    uses acme:endpoint;\n    leaf ip {          // illegal - same identifier \"ip\" used twice\n        type string;\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.13. The rpc Statement",
      "section_title": true,
      "zh-CHS": "7.13. rpc语句"
    },
    {
      "indent": 3,
      "text": "The \"rpc\" statement is used to define a NETCONF RPC operation. It takes one argument, which is an identifier, followed by a block of substatements that holds detailed rpc information. This argument is the name of the RPC, and is used as the element name directly under the <rpc> element, as designated by the substitution group \"rpcOperation\" in [RFC4741].",
      "zh-CHS": "“rpc”语句用于定义NETCONF rpc操作。它有一个参数，它是一个标识符，后跟一个包含详细rpc信息的子语句块。此参数是RPC的名称，直接用作<RPC>元素下的元素名称，由[RFC4741]中的替换组“rpcOperation”指定。"
    },
    {
      "indent": 3,
      "text": "The \"rpc\" statement defines an rpc node in the schema tree. Under the rpc node, a schema node with the name \"input\", and a schema node with the name \"output\" are also defined. The nodes \"input\" and \"output\" are defined in the module's namespace.",
      "zh-CHS": "“rpc”语句在模式树中定义了一个rpc节点。在rpc节点下，还定义了名为“input”的模式节点和名为“output”的模式节点。节点“输入”和“输出”在模块的命名空间中定义。"
    },
    {
      "indent": 0,
      "text": "7.13.1. The rpc's Substatements",
      "section_title": true,
      "zh-CHS": "7.13.1. rpc的子状态"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| description  | 7.19.3  | 0..1        |\n| grouping     | 7.11    | 0..n        |\n| if-feature   | 7.18.2  | 0..n        |\n| input        | 7.13.2  | 0..1        |\n| output       | 7.13.3  | 0..1        |\n| reference    | 7.19.4  | 0..1        |\n| status       | 7.19.2  | 0..1        |\n| typedef      | 7.3     | 0..n        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.13.2. The input Statement",
      "section_title": true,
      "zh-CHS": "7.13.2. 输入语句"
    },
    {
      "indent": 3,
      "text": "The \"input\" statement, which is optional, is used to define input parameters to the RPC operation. It does not take an argument. The substatements to \"input\" define nodes under the RPC's input node.",
      "zh-CHS": "“input”语句是可选的，用于定义RPC操作的输入参数。这不需要争论。“input”的子语句定义RPC输入节点下的节点。"
    },
    {
      "indent": 3,
      "text": "If a leaf in the input tree has a \"mandatory\" statement with the value \"true\", the leaf MUST be present in a NETCONF RPC invocation. Otherwise, the server MUST return a \"missing-element\" error.",
      "zh-CHS": "如果输入树中的某个叶具有值为“true”的“mandatory”语句，则该叶必须存在于NETCONF RPC调用中。否则，服务器必须返回“缺少元素”错误。"
    },
    {
      "indent": 3,
      "text": "If a leaf in the input tree has a default value, the NETCONF server MUST use this value in the same cases as described in Section 7.6.1. In these cases, the server MUST operationally behave as if the leaf was present in the NETCONF RPC invocation with the default value as its value.",
      "zh-CHS": "如果输入树中的叶具有默认值，则NETCONF服务器必须在与第7.6.1节所述相同的情况下使用该值。在这些情况下，服务器在操作上的行为必须与NETCONF RPC调用中存在的叶一样，并以默认值作为其值。"
    },
    {
      "indent": 3,
      "text": "If a \"config\" statement is present for any node in the input tree, the \"config\" statement is ignored.",
      "zh-CHS": "如果输入树中的任何节点都有“config”语句，则忽略“config”语句。"
    },
    {
      "indent": 3,
      "text": "If any node has a \"when\" statement that would evaluate to false, then this node MUST NOT be present in the input tree.",
      "zh-CHS": "如果任何节点的“when”语句的计算结果为false，则该节点不得出现在输入树中。"
    },
    {
      "indent": 0,
      "text": "7.13.2.1. The input's Substatements",
      "section_title": true,
      "zh-CHS": "7.13.2.1. 输入的子语句"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| anyxml       | 7.10    | 0..n        |\n| choice       | 7.9     | 0..n        |\n| container    | 7.5     | 0..n        |\n| grouping     | 7.11    | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| typedef      | 7.3     | 0..n        |\n| uses         | 7.12    | 0..n        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.13.3. The output Statement",
      "section_title": true,
      "zh-CHS": "7.13.3. 输出语句"
    },
    {
      "indent": 3,
      "text": "The \"output\" statement, which is optional, is used to define output parameters to the RPC operation. It does not take an argument. The substatements to \"output\" define nodes under the RPC's output node.",
      "zh-CHS": "“output”语句是可选的，用于定义RPC操作的输出参数。这不需要争论。“output”的子语句定义RPC的输出节点下的节点。"
    },
    {
      "indent": 3,
      "text": "If a leaf in the output tree has a \"mandatory\" statement with the value \"true\", the leaf MUST be present in a NETCONF RPC reply.",
      "zh-CHS": "如果输出树中的某个叶具有值为“true”的“mandatory”语句，则该叶必须出现在NETCONF RPC应答中。"
    },
    {
      "indent": 3,
      "text": "If a leaf in the output tree has a default value, the NETCONF client MUST use this value in the same cases as described in Section 7.6.1. In these cases, the client MUST operationally behave as if the leaf was present in the NETCONF RPC reply with the default value as its value.",
      "zh-CHS": "如果输出树中的叶具有默认值，NETCONF客户端必须在与第7.6.1节所述相同的情况下使用该值。在这些情况下，客户机必须在操作上表现得像NETCONF RPC应答中存在叶一样，并使用默认值作为其值。"
    },
    {
      "indent": 3,
      "text": "If a \"config\" statement is present for any node in the output tree, the \"config\" statement is ignored.",
      "zh-CHS": "如果输出树中的任何节点都有“config”语句，则忽略“config”语句。"
    },
    {
      "indent": 3,
      "text": "If any node has a \"when\" statement that would evaluate to false, then this node MUST NOT be present in the output tree.",
      "zh-CHS": "如果任何节点的“when”语句的计算结果为false，则该节点不得出现在输出树中。"
    },
    {
      "indent": 0,
      "text": "7.13.3.1. The output's Substatements",
      "section_title": true,
      "zh-CHS": "7.13.3.1. 输出的子语句"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| anyxml       | 7.10    | 0..n        |\n| choice       | 7.9     | 0..n        |\n| container    | 7.5     | 0..n        |\n| grouping     | 7.11    | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| typedef      | 7.3     | 0..n        |\n| uses         | 7.12    | 0..n        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.13.4. XML Mapping Rules",
      "section_title": true,
      "zh-CHS": "7.13.4. XML映射规则"
    },
    {
      "indent": 3,
      "text": "An rpc node is encoded as a child XML element to the <rpc> element defined in [RFC4741]. The element's local name is the rpc's identifier, and its namespace is the module's XML namespace (see Section 7.1.3).",
      "zh-CHS": "rpc节点被编码为[RFC4741]中定义的<rpc>元素的子XML元素。元素的本地名称是rpc的标识符，其名称空间是模块的XML名称空间（参见第7.1.3节）。"
    },
    {
      "indent": 3,
      "text": "Input parameters are encoded as child XML elements to the rpc node's XML element, in the same order as they are defined within the \"input\" statement.",
      "zh-CHS": "输入参数被编码为rpc节点XML元素的子XML元素，其顺序与“Input”语句中定义的顺序相同。"
    },
    {
      "indent": 3,
      "text": "If the RPC operation invocation succeeded, and no output parameters are returned, the <rpc-reply> contains a single <ok/> element defined in [RFC4741]. If output parameters are returned, they are encoded as child elements to the <rpc-reply> element defined in [RFC4741], in the same order as they are defined within the \"output\" statement.",
      "zh-CHS": "如果RPC操作调用成功，并且没有返回任何输出参数，<RPC reply>包含[RFC4741]中定义的单个<ok/>元素。如果返回输出参数，则将其编码为[RFC4741]中定义的<rpc reply>元素的子元素，其顺序与“output”语句中定义的顺序相同。"
    },
    {
      "indent": 0,
      "text": "7.13.5. Usage Example",
      "section_title": true,
      "zh-CHS": "7.13.5. 用法示例"
    },
    {
      "indent": 3,
      "text": "The following example defines an RPC operation:",
      "zh-CHS": "以下示例定义了RPC操作："
    },
    {
      "indent": 5,
      "text": "module rock {\n    namespace \"http://example.net/rock\";\n    prefix \"rock\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "    rpc rock-the-house {\n        input {\n            leaf zip-code {\n                type string;\n            }\n        }\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example of the complete rpc and rpc-reply:",
      "zh-CHS": "完整rpc和rpc应答的对应XML实例示例："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <rock-the-house xmlns=\"http://example.net/rock\">\n    <zip-code>27606-0100</zip-code>\n  </rock-the-house>\n</rpc>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "<rpc-reply message-id=\"101\"\n           xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <ok/>\n</rpc-reply>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.14. The notification Statement",
      "section_title": true,
      "zh-CHS": "7.14. 通知声明"
    },
    {
      "indent": 3,
      "text": "The \"notification\" statement is used to define a NETCONF notification. It takes one argument, which is an identifier, followed by a block of substatements that holds detailed notification information. The \"notification\" statement defines a notification node in the schema tree.",
      "zh-CHS": "“notification”语句用于定义NETCONF通知。它有一个参数，它是一个标识符，后跟一个包含详细通知信息的子语句块。“notification”语句在模式树中定义了一个通知节点。"
    },
    {
      "indent": 3,
      "text": "If a leaf in the notification tree has a \"mandatory\" statement with the value \"true\", the leaf MUST be present in a NETCONF notification.",
      "zh-CHS": "如果通知树中的某个叶具有值为“true”的“强制”语句，则该叶必须出现在NETCONF通知中。"
    },
    {
      "indent": 3,
      "text": "If a leaf in the notification tree has a default value, the NETCONF client MUST use this value in the same cases as described in Section 7.6.1. In these cases, the client MUST operationally behave as if the leaf was present in the NETCONF notification with the default value as its value.",
      "zh-CHS": "如果通知树中的叶具有默认值，则NETCONF客户端必须在与第7.6.1节所述相同的情况下使用该值。在这些情况下，客户机必须在操作上表现得像NETCONF通知中的叶一样，并以默认值作为其值。"
    },
    {
      "indent": 3,
      "text": "If a \"config\" statement is present for any node in the notification tree, the \"config\" statement is ignored.",
      "zh-CHS": "如果通知树中的任何节点都有“config”语句，则忽略“config”语句。"
    },
    {
      "indent": 0,
      "text": "7.14.1. The notification's Substatements",
      "section_title": true,
      "zh-CHS": "7.14.1. 通知的子语句"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| anyxml       | 7.10    | 0..n        |\n| choice       | 7.9     | 0..n        |\n| container    | 7.5     | 0..n        |\n| description  | 7.19.3  | 0..1        |\n| grouping     | 7.11    | 0..n        |\n| if-feature   | 7.18.2  | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| reference    | 7.19.4  | 0..1        |\n| status       | 7.19.2  | 0..1        |\n| typedef      | 7.3     | 0..n        |\n| uses         | 7.12    | 0..n        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.14.2. XML Mapping Rules",
      "section_title": true,
      "zh-CHS": "7.14.2. XML映射规则"
    },
    {
      "indent": 3,
      "text": "A notification node is encoded as a child XML element to the <notification> element defined in NETCONF Event Notifications [RFC5277]. The element's local name is the notification's identifier, and its namespace is the module's XML namespace (see Section 7.1.3).",
      "zh-CHS": "通知节点被编码为NETCONF事件通知[RFC5277]中定义的<notification>元素的子XML元素。元素的本地名称是通知的标识符，其名称空间是模块的XML名称空间（参见第7.1.3节）。"
    },
    {
      "indent": 0,
      "text": "7.14.3. Usage Example",
      "section_title": true,
      "zh-CHS": "7.14.3. 用法示例"
    },
    {
      "indent": 3,
      "text": "The following example defines a notification:",
      "zh-CHS": "以下示例定义了通知："
    },
    {
      "indent": 5,
      "text": "module event {",
      "zh-CHS": "模块事件{"
    },
    {
      "indent": 9,
      "text": "namespace \"http://example.com/event\";\nprefix \"ev\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "    notification event {\n        leaf event-class {\n            type string;\n        }\n        anyxml reporting-entity;\n        leaf severity {\n            type string;\n        }\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example of the complete notification:",
      "zh-CHS": "完整通知的对应XML实例示例："
    },
    {
      "indent": 5,
      "text": "<notification\n  xmlns=\"urn:ietf:params:xml:ns:netconf:notification:1.0\">\n  <eventTime>2008-07-08T00:01:00Z</eventTime>\n  <event xmlns=\"http://example.com/event\">\n    <event-class>fault</event-class>\n    <reporting-entity>\n      <card>Ethernet0</card>\n    </reporting-entity>\n    <severity>major</severity>\n  </event>\n</notification>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.15. The augment Statement",
      "section_title": true,
      "zh-CHS": "7.15. 增广语句"
    },
    {
      "indent": 3,
      "text": "The \"augment\" statement allows a module or submodule to add to the schema tree defined in an external module, or the current module and its submodules, and to add to the nodes from a grouping in a \"uses\" statement. The argument is a string that identifies a node in the schema tree. This node is called the augment's target node. The target node MUST be either a container, list, choice, case, input, output, or notification node. It is augmented with the nodes defined in the substatements that follow the \"augment\" statement.",
      "zh-CHS": "“augment”语句允许模块或子模块添加到外部模块或当前模块及其子模块中定义的模式树，并从“uses”语句中的分组添加到节点。参数是标识架构树中节点的字符串。此节点称为增强的目标节点。目标节点必须是容器、列表、选项、大小写、输入、输出或通知节点。它通过“augment”语句后面的子语句中定义的节点进行扩充。"
    },
    {
      "indent": 3,
      "text": "The argument string is a schema node identifier (see Section 6.5). If the \"augment\" statement is on the top level in a module or submodule, the absolute form (defined by the rule",
      "zh-CHS": "参数字符串是一个模式节点标识符（参见第6.5节）。如果“augment”语句位于模块或子模块的顶层，则绝对形式（由规则定义"
    },
    {
      "indent": 3,
      "text": "\"absolute-schema-nodeid\" in Section 12) of a schema node identifier MUST be used. If the \"augment\" statement is a substatement to the \"uses\" statement, the descendant form (defined by the rule \"descendant-schema-nodeid\" in Section 12) MUST be used.",
      "zh-CHS": "必须使用模式节点标识符第12）节中的“绝对模式节点ID”。如果“augment”语句是“uses”语句的子语句，则必须使用子体形式（由第12节中的“子体模式nodeid”规则定义）。"
    },
    {
      "indent": 3,
      "text": "If the target node is a container, list, case, input, output, or notification node, the \"container\", \"leaf\", \"list\", \"leaf-list\", \"uses\", and \"choice\" statements can be used within the \"augment\" statement.",
      "zh-CHS": "如果目标节点是容器、列表、案例、输入、输出或通知节点，“容器”、“叶”、“列表”、“叶列表”、“使用”和“选择”语句可以在“增强”语句中使用。"
    },
    {
      "indent": 3,
      "text": "If the target node is a choice node, the \"case\" statement, or a case shorthand statement (see Section 7.9.2) can be used within the \"augment\" statement.",
      "zh-CHS": "如果目标节点是选择节点，“case”语句或case速记语句（见第7.9.2节）可在“AUMMENT”语句中使用。"
    },
    {
      "indent": 3,
      "text": "If the target node is in another module, then nodes added by the augmentation MUST NOT be mandatory nodes (see Section 3.1).",
      "zh-CHS": "如果目标节点位于另一个模块中，则通过扩充添加的节点不得为强制节点（参见第3.1节）。"
    },
    {
      "indent": 3,
      "text": "The \"augment\" statement MUST NOT add multiple nodes with the same name from the same module to the target node.",
      "zh-CHS": "“augment”语句不能将同一模块中具有相同名称的多个节点添加到目标节点。"
    },
    {
      "indent": 0,
      "text": "7.15.1. The augment's Substatements",
      "section_title": true,
      "zh-CHS": "7.15.1. 增广子状态"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| anyxml       | 7.10    | 0..n        |\n| case         | 7.9.2   | 0..n        |\n| choice       | 7.9     | 0..n        |\n| container    | 7.5     | 0..n        |\n| description  | 7.19.3  | 0..1        |\n| if-feature   | 7.18.2  | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| reference    | 7.19.4  | 0..1        |\n| status       | 7.19.2  | 0..1        |\n| uses         | 7.12    | 0..n        |\n| when         | 7.19.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.15.2. XML Mapping Rules",
      "section_title": true,
      "zh-CHS": "7.15.2. XML映射规则"
    },
    {
      "indent": 3,
      "text": "All data nodes defined in the \"augment\" statement are defined as XML elements in the XML namespace of the module where the \"augment\" is specified.",
      "zh-CHS": "“augment”语句中定义的所有数据节点都在指定“augment”的模块的XML命名空间中定义为XML元素。"
    },
    {
      "indent": 3,
      "text": "When a node is augmented, the augmenting child nodes are encoded as subelements to the augmented node, in any order.",
      "zh-CHS": "当一个节点被扩充时，扩充的子节点以任何顺序被编码为扩充节点的子元素。"
    },
    {
      "indent": 0,
      "text": "7.15.3. Usage Example",
      "section_title": true,
      "zh-CHS": "7.15.3. 用法示例"
    },
    {
      "indent": 3,
      "text": "In namespace http://example.com/schema/interfaces, we have:",
      "zh-CHS": "在命名空间中http://example.com/schema/interfaces，我们有："
    },
    {
      "indent": 5,
      "text": "container interfaces {\n    list ifEntry {\n        key \"ifIndex\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "        leaf ifIndex {\n            type uint32;\n        }\n        leaf ifDescr {\n            type string;\n        }\n        leaf ifType {\n            type iana:IfType;\n        }\n        leaf ifMtu {\n            type int32;\n        }\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Then, in namespace http://example.com/schema/ds0, we have:",
      "zh-CHS": "然后，在命名空间中http://example.com/schema/ds0，我们有："
    },
    {
      "indent": 5,
      "text": "import interface-module {\n    prefix \"if\";\n}\naugment \"/if:interfaces/if:ifEntry\" {\n    when \"if:ifType='ds0'\";\n    leaf ds0ChannelNumber {\n        type ChannelNumber;\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example:",
      "zh-CHS": "对应的XML实例示例："
    },
    {
      "indent": 5,
      "text": "<interfaces xmlns=\"http://example.com/schema/interfaces\"\n            xmlns:ds0=\"http://example.com/schema/ds0\">\n  <ifEntry>\n    <ifIndex>1</ifIndex>\n    <ifDescr>Flintstone Inc Ethernet A562</ifDescr>\n    <ifType>ethernetCsmacd</ifType>\n    <ifMtu>1500</ifMtu>\n  </ifEntry>\n  <ifEntry>\n    <ifIndex>2</ifIndex>\n    <ifDescr>Flintstone Inc DS0</ifDescr>\n    <ifType>ds0</ifType>\n    <ds0:ds0ChannelNumber>1</ds0:ds0ChannelNumber>\n  </ifEntry>\n</interfaces>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "As another example, suppose we have the choice defined in Section 7.9.7. The following construct can be used to extend the protocol definition:",
      "zh-CHS": "作为另一个例子，假设我们有第7.9.7节中定义的选择。以下构造可用于扩展协议定义："
    },
    {
      "indent": 5,
      "text": "augment /ex:system/ex:protocol/ex:name {\n    case c {\n        leaf smtp {\n            type empty;\n        }\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example:",
      "zh-CHS": "对应的XML实例示例："
    },
    {
      "indent": 5,
      "text": "<ex:system>\n  <ex:protocol>\n    <ex:tcp/>\n  </ex:protocol>\n</ex:system>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "or",
      "zh-CHS": "或"
    },
    {
      "indent": 5,
      "text": "<ex:system>\n  <ex:protocol>\n    <other:smtp/>\n  </ex:protocol>\n</ex:system>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.16. The identity Statement",
      "section_title": true,
      "zh-CHS": "7.16. 身份声明"
    },
    {
      "indent": 3,
      "text": "The \"identity\" statement is used to define a new globally unique, abstract, and untyped identity. Its only purpose is to denote its name, semantics, and existence. An identity can either be defined from scratch or derived from a base identity. The identity's argument is an identifier that is the name of the identity. It is followed by a block of substatements that holds detailed identity information.",
      "zh-CHS": "“identity”语句用于定义新的全局唯一、抽象和非类型化标识。它的唯一目的是表示它的名称、语义和存在。标识可以从头定义，也可以从基本标识派生。标识的参数是标识名的标识符。它后面是一个包含详细身份信息的子状态块。"
    },
    {
      "indent": 3,
      "text": "The built-in datatype \"identityref\" (see Section 9.10) can be used to reference identities within a data model.",
      "zh-CHS": "内置数据类型“identityref”（见第9.10节）可用于引用数据模型中的标识。"
    },
    {
      "indent": 0,
      "text": "7.16.1. The identity's Substatements",
      "section_title": true,
      "zh-CHS": "7.16.1. 身份的子状态"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| base         | 7.16.2  | 0..1        |\n| description  | 7.19.3  | 0..1        |\n| reference    | 7.19.4  | 0..1        |\n| status       | 7.19.2  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.16.2. The base Statement",
      "section_title": true,
      "zh-CHS": "7.16.2. 基本语句"
    },
    {
      "indent": 3,
      "text": "The \"base\" statement, which is optional, takes as an argument a string that is the name of an existing identity, from which the new identity is derived. If no \"base\" statement is present, the identity is defined from scratch.",
      "zh-CHS": "“base”语句是可选的，它将一个字符串作为参数，该字符串是从中派生新标识的现有标识的名称。如果不存在“base”语句，则从零开始定义标识。"
    },
    {
      "indent": 3,
      "text": "If a prefix is present on the base name, it refers to an identity defined in the module that was imported with that prefix, or the local module if the prefix matches the local module's prefix. Otherwise, an identity with the matching name MUST be defined in the current module or an included submodule.",
      "zh-CHS": "如果基名称上存在前缀，则它将引用在使用该前缀导入的模块中定义的标识，如果前缀与本地模块的前缀匹配，则它将引用本地模块中定义的标识。否则，必须在当前模块或包含的子模块中定义具有匹配名称的标识。"
    },
    {
      "indent": 3,
      "text": "Since submodules cannot include the parent module, any identities in the module that need to be exposed to submodules MUST be defined in a submodule. Submodules can then include this submodule to find the definition of the identity.",
      "zh-CHS": "由于子模块不能包含父模块，因此必须在子模块中定义模块中需要向子模块公开的任何标识。然后子模块可以包含此子模块以查找标识的定义。"
    },
    {
      "indent": 3,
      "text": "An identity MUST NOT reference itself, neither directly nor indirectly through a chain of other identities.",
      "zh-CHS": "身份不能直接或间接地通过一系列其他身份来引用自身。"
    },
    {
      "indent": 0,
      "text": "7.16.3. Usage Example",
      "section_title": true,
      "zh-CHS": "7.16.3. 用法示例"
    },
    {
      "indent": 5,
      "text": "module crypto-base {\n    namespace \"http://example.com/crypto-base\";\n    prefix \"crypto\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "    identity crypto-alg {\n        description\n           \"Base identity from which all crypto algorithms\n            are derived.\";\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "module des {\n    namespace \"http://example.com/des\";\n    prefix \"des\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "import \"crypto-base\" {\n    prefix \"crypto\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "identity des {\n    base \"crypto:crypto-alg\";\n    description \"DES crypto algorithm\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "    identity des3 {\n        base \"crypto:crypto-alg\";\n        description \"Triple DES crypto algorithm\";\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.17. The extension Statement",
      "section_title": true,
      "zh-CHS": "7.17. 扩展语句"
    },
    {
      "indent": 3,
      "text": "The \"extension\" statement allows the definition of new statements within the YANG language. This new statement definition can be imported and used by other modules.",
      "zh-CHS": "“extension”语句允许在YANG语言中定义新语句。这个新的语句定义可以被其他模块导入和使用。"
    },
    {
      "indent": 3,
      "text": "The statement's argument is an identifier that is the new keyword for the extension and must be followed by a block of substatements that holds detailed extension information. The purpose of the \"extension\" statement is to define a keyword, so that it can be imported and used by other modules.",
      "zh-CHS": "语句的参数是一个标识符，它是扩展的新关键字，后面必须跟一个包含详细扩展信息的子语句块。“extension”语句的目的是定义一个关键字，以便其他模块可以导入和使用它。"
    },
    {
      "indent": 3,
      "text": "The extension can be used like a normal YANG statement, with the statement name followed by an argument if one is defined by the extension, and an optional block of substatements. The statement's name is created by combining the prefix of the module in which the",
      "zh-CHS": "扩展可以像普通的YANG语句一样使用，如果扩展定义了一个参数，则语句名后面会跟一个参数，并有一个可选的子语句块。该语句的名称是通过组合语句所在模块的前缀创建的"
    },
    {
      "indent": 3,
      "text": "extension was defined, a colon (\":\"), and the extension's keyword, with no interleaving whitespace. The substatements of an extension are defined by the extension, using some mechanism outside the scope of this specification. Syntactically, the substatements MUST be YANG statements, or also defined using \"extension\" statements. YANG statements in extensions MUST follow the syntactical rules in Section 12.",
      "zh-CHS": "定义了扩展名，一个冒号（“：”）和扩展名的关键字，没有交错的空格。扩展的子状态由扩展定义，使用本规范范围之外的某种机制。从语法上讲，子语句必须是YANG语句，或者也可以使用“extension”语句定义。扩展中的YANG语句必须遵循第12节中的语法规则。"
    },
    {
      "indent": 0,
      "text": "7.17.1. The extension's Substatements",
      "section_title": true,
      "zh-CHS": "7.17.1. 扩展的子状态"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| argument     | 7.17.2  | 0..1        |\n| description  | 7.19.3  | 0..1        |\n| reference    | 7.19.4  | 0..1        |\n| status       | 7.19.2  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.17.2. The argument Statement",
      "section_title": true,
      "zh-CHS": "7.17.2. 论点陈述"
    },
    {
      "indent": 3,
      "text": "The \"argument\" statement, which is optional, takes as an argument a string that is the name of the argument to the keyword. If no argument statement is present, the keyword expects no argument when it is used.",
      "zh-CHS": "“argument”语句是可选的，它将作为关键字参数名称的字符串作为参数。如果不存在参数语句，则使用关键字时不需要参数。"
    },
    {
      "indent": 3,
      "text": "The argument's name is used in the YIN mapping, where it is used as an XML attribute or element name, depending on the argument's \"yin-element\" statement.",
      "zh-CHS": "参数的名称在YIN映射中使用，根据参数的“YIN-element”语句，它被用作XML属性或元素名称。"
    },
    {
      "indent": 0,
      "text": "7.17.2.1. The argument's Substatements",
      "section_title": true,
      "zh-CHS": "7.17.2.1. 论点的子语句"
    },
    {
      "indent": 17,
      "text": "+--------------+----------+-------------+\n| substatement | section  | cardinality |\n+--------------+----------+-------------+\n| yin-element  | 7.17.2.2 | 0..1        |\n+--------------+----------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.17.2.2. The yin-element Statement",
      "section_title": true,
      "zh-CHS": "7.17.2.2. 阴素说"
    },
    {
      "indent": 3,
      "text": "The \"yin-element\" statement, which is optional, takes as an argument the string \"true\" or \"false\". This statement indicates if the argument is mapped to an XML element in YIN or to an XML attribute (see Section 11).",
      "zh-CHS": "“yin元素”语句是可选的，它将字符串“true”或“false”作为参数。此语句指示参数是映射到YIN中的XML元素还是映射到XML属性（请参见第11节）。"
    },
    {
      "indent": 3,
      "text": "If no \"yin-element\" statement is present, it defaults to \"false\".",
      "zh-CHS": "如果不存在“阴元素”语句，则默认为“false”。"
    },
    {
      "indent": 0,
      "text": "7.17.3. Usage Example",
      "section_title": true,
      "zh-CHS": "7.17.3. 用法示例"
    },
    {
      "indent": 3,
      "text": "To define an extension:",
      "zh-CHS": "要定义扩展，请执行以下操作："
    },
    {
      "indent": 5,
      "text": "module my-extensions { ...",
      "zh-CHS": "模块我的扩展{。。。"
    },
    {
      "indent": 5,
      "text": "  extension c-define {\n    description\n      \"Takes as argument a name string.\n      Makes the code generator use the given name in the\n      #define.\";\n    argument \"name\";\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "To use the extension:",
      "zh-CHS": "要使用扩展名，请执行以下操作："
    },
    {
      "indent": 5,
      "text": "module my-interfaces {\n  ...\n  import my-extensions {\n    prefix \"myext\";\n  }\n  ...",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "  container interfaces {\n    ...\n    myext:c-define \"MY_INTERFACES\";\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.18. Conformance-Related Statements",
      "section_title": true,
      "zh-CHS": "7.18. 一致性相关声明"
    },
    {
      "indent": 3,
      "text": "This section defines statements related to conformance, as described in Section 5.6.",
      "zh-CHS": "本节定义了与合规性相关的声明，如第5.6节所述。"
    },
    {
      "indent": 0,
      "text": "7.18.1. The feature Statement",
      "section_title": true,
      "zh-CHS": "7.18.1. 专题报道"
    },
    {
      "indent": 3,
      "text": "The \"feature\" statement is used to define a mechanism by which portions of the schema are marked as conditional. A feature name is defined that can later be referenced using the \"if-feature\" statement (see Section 7.18.2). Schema nodes tagged with a feature are ignored by the device unless the device supports the given feature. This allows portions of the YANG module to be conditional based on conditions on the device. The model can represent the abilities of the device within the model, giving a richer model that allows for differing device abilities and roles.",
      "zh-CHS": "“feature”语句用于定义一种机制，通过该机制将模式的某些部分标记为条件。定义了一个特征名称，可在以后使用“如果特征”语句引用该名称（见第7.18.2节）。除非设备支持给定功能，否则设备将忽略标记有功能的架构节点。这允许根据设备上的条件对模块的部分进行调节。该模型可以表示模型中设备的能力，提供更丰富的模型，允许不同的设备能力和角色。"
    },
    {
      "indent": 3,
      "text": "The argument to the \"feature\" statement is the name of the new feature, and follows the rules for identifiers in Section 6.2. This name is used by the \"if-feature\" statement to tie the schema nodes to the feature.",
      "zh-CHS": "“feature”语句的参数是新特性的名称，并遵循第6.2节中的标识符规则。“if-feature”语句使用此名称将架构节点绑定到该功能。"
    },
    {
      "indent": 3,
      "text": "In this example, a feature called \"local-storage\" represents the ability for a device to store syslog messages on local storage of some sort. This feature is used to make the \"local-storage-limit\" leaf conditional on the presence of some sort of local storage. If the device does not report that it supports this feature, the \"local-storage-limit\" node is not supported.",
      "zh-CHS": "在本例中，称为“本地存储”的功能表示设备能够在某种本地存储上存储系统日志消息。此功能用于使“本地存储限制”叶以存在某种本地存储为条件。如果设备未报告其支持此功能，则不支持“本地存储限制”节点。"
    },
    {
      "indent": 5,
      "text": "module syslog {\n    ...\n    feature local-storage {\n        description\n            \"This feature means the device supports local\n             storage (memory, flash or disk) that can be used to\n             store syslog messages.\";\n    }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "    container syslog {\n        leaf local-storage-limit {\n            if-feature local-storage;\n            type uint64;\n            units \"kilobyte\";\n            config false;\n            description\n                \"The amount of local storage that can be\n                 used to hold syslog messages.\";\n        }\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The \"if-feature\" statement can be used in many places within the YANG syntax. Definitions tagged with \"if-feature\" are ignored when the device does not support that feature.",
      "zh-CHS": "“if-feature”语句可以在YANG语法中的许多地方使用。当设备不支持“如果功能”时，将忽略标记为“如果功能”的定义。"
    },
    {
      "indent": 3,
      "text": "A feature MUST NOT reference itself, neither directly nor indirectly through a chain of other features.",
      "zh-CHS": "特征不得直接或间接通过一系列其他特征引用自身。"
    },
    {
      "indent": 3,
      "text": "In order for a device to implement a feature that is dependent on any other features (i.e., the feature has one or more \"if-feature\" sub-statements), the device MUST also implement all the dependant features.",
      "zh-CHS": "为了使设备实现依赖于任何其他功能的功能（即，该功能具有一个或多个“如果功能”子语句），设备还必须实现所有依赖功能。"
    },
    {
      "indent": 0,
      "text": "7.18.1.1. The feature's Substatements",
      "section_title": true,
      "zh-CHS": "7.18.1.1. 要素的子状态"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| description  | 7.19.3  | 0..1        |\n| if-feature   | 7.18.2  | 0..n        |\n| status       | 7.19.2  | 0..1        |\n| reference    | 7.19.4  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.18.2. The if-feature Statement",
      "section_title": true,
      "zh-CHS": "7.18.2. if-feature语句"
    },
    {
      "indent": 3,
      "text": "The \"if-feature\" statement makes its parent statement conditional. The argument is the name of a feature, as defined by a \"feature\" statement. The parent statement is implemented by servers that support this feature. If a prefix is present on the feature name, it refers to a feature defined in the module that was imported with that prefix, or the local module if the prefix matches the local module's prefix. Otherwise, a feature with the matching name MUST be defined in the current module or an included submodule.",
      "zh-CHS": "“if feature”语句使其父语句具有条件。参数是由“feature”语句定义的功能的名称。父语句由支持此功能的服务器实现。如果要素名称上存在前缀，则该前缀指的是使用该前缀导入的模块中定义的要素，如果前缀与本地模块的前缀匹配，则指的是本地模块。否则，必须在当前模块或包含的子模块中定义具有匹配名称的功能。"
    },
    {
      "indent": 3,
      "text": "Since submodules cannot include the parent module, any features in the module that need to be exposed to submodules MUST be defined in a submodule. Submodules can then include this submodule to find the definition of the feature.",
      "zh-CHS": "由于子模块不能包含父模块，因此必须在子模块中定义模块中需要向子模块公开的任何功能。然后子模块可以包含此子模块以查找特征的定义。"
    },
    {
      "indent": 0,
      "text": "7.18.3. The deviation Statement",
      "section_title": true,
      "zh-CHS": "7.18.3. 偏差陈述"
    },
    {
      "indent": 3,
      "text": "The \"deviation\" statement defines a hierarchy of a module that the device does not implement faithfully. The argument is a string that identifies the node in the schema tree where a deviation from the module occurs. This node is called the deviation's target node. The contents of the \"deviation\" statement give details about the deviation.",
      "zh-CHS": "“偏差”语句定义了设备无法忠实实现的模块层次结构。参数是一个字符串，用于标识模式树中发生模块偏差的节点。该节点称为偏差的目标节点。“偏差”声明的内容给出了偏差的详细信息。"
    },
    {
      "indent": 3,
      "text": "The argument string is an absolute schema node identifier (see Section 6.5).",
      "zh-CHS": "参数字符串是绝对模式节点标识符（参见第6.5节）。"
    },
    {
      "indent": 3,
      "text": "Deviations define the way a device or class of devices deviate from a standard. This means that deviations MUST never be part of a published standard, since they are the mechanism for learning how implementations vary from the standards.",
      "zh-CHS": "偏差定义了设备或设备类别偏离标准的方式。这意味着偏差决不能成为已发布标准的一部分，因为它们是了解实现如何与标准不同的机制。"
    },
    {
      "indent": 3,
      "text": "Device deviations are strongly discouraged and MUST only be used as a last resort. Telling the application how a device fails to follow a standard is no substitute for implementing the standard correctly. A device that deviates from a module is not fully compliant with the module.",
      "zh-CHS": "强烈反对设备偏差，并且只能作为最后手段使用。告诉应用程序一个设备如何不遵循标准并不能代替正确实施标准。偏离模块的设备与模块不完全兼容。"
    },
    {
      "indent": 3,
      "text": "However, in some cases, a particular device may not have the hardware or software ability to support parts of a standard module. When this occurs, the device makes a choice either to treat attempts to configure unsupported parts of the module as an error that is reported back to the unsuspecting application or ignore those incoming requests. Neither choice is acceptable.",
      "zh-CHS": "然而，在某些情况下，特定设备可能没有硬件或软件能力来支持标准模块的部分。发生这种情况时，设备会选择将配置模块不受支持部分的尝试视为一个错误，并报告给不知情的应用程序，或者忽略这些传入的请求。这两种选择都是不可接受的。"
    },
    {
      "indent": 3,
      "text": "Instead, YANG allows devices to document portions of a base module that are not supported or supported but with different syntax, by using the \"deviation\" statement.",
      "zh-CHS": "相反，YANG允许设备使用“偏差”语句记录基本模块中不受支持或支持但语法不同的部分。"
    },
    {
      "indent": 0,
      "text": "7.18.3.1. The deviation's Substatements",
      "section_title": true,
      "zh-CHS": "7.18.3.1. 偏差的子状态"
    },
    {
      "indent": 17,
      "text": "+--------------+----------+-------------+\n| substatement | section  | cardinality |\n+--------------+----------+-------------+\n| description  | 7.19.3   | 0..1        |\n| deviate      | 7.18.3.2 | 1..n        |\n| reference    | 7.19.4   | 0..1        |\n+--------------+----------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.18.3.2. The deviate Statement",
      "section_title": true,
      "zh-CHS": "7.18.3.2. 偏离陈述"
    },
    {
      "indent": 3,
      "text": "The \"deviate\" statement defines how the device's implementation of the target node deviates from its original definition. The argument is one of the strings \"not-supported\", \"add\", \"replace\", or \"delete\".",
      "zh-CHS": "“偏离”语句定义了设备对目标节点的实现如何偏离其原始定义。参数是字符串“不支持”、“添加”、“替换”或“删除”之一。"
    },
    {
      "indent": 3,
      "text": "The argument \"not-supported\" indicates that the target node is not implemented by this device.",
      "zh-CHS": "参数“not SUPPORED”表示此设备未实现目标节点。"
    },
    {
      "indent": 3,
      "text": "The argument \"add\" adds properties to the target node. The properties to add are identified by substatements to the \"deviate\" statement. If a property can only appear once, the property MUST NOT exist in the target node.",
      "zh-CHS": "参数“add”将属性添加到目标节点。要添加的属性由“偏离”语句的子语句标识。如果属性只能出现一次，则该属性不得存在于目标节点中。"
    },
    {
      "indent": 3,
      "text": "The argument \"replace\" replaces properties of the target node. The properties to replace are identified by substatements to the \"deviate\" statement. The properties to replace MUST exist in the target node.",
      "zh-CHS": "参数“replace”替换目标节点的属性。要替换的属性由“偏离”语句的子语句标识。要替换的属性必须存在于目标节点中。"
    },
    {
      "indent": 3,
      "text": "The argument \"delete\" deletes properties from the target node. The properties to delete are identified by substatements to the \"delete\" statement. The substatement's keyword MUST match a corresponding keyword in the target node, and the argument's string MUST be equal to the corresponding keyword's argument string in the target node.",
      "zh-CHS": "参数“delete”从目标节点删除属性。要删除的属性由“delete”语句的子语句标识。子状态的关键字必须与目标节点中相应的关键字匹配，并且参数的字符串必须等于目标节点中相应关键字的参数字符串。"
    },
    {
      "indent": 23,
      "text": "The deviates's Substatements",
      "zh-CHS": "偏离的子状态"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| config       | 7.19.1  | 0..1        |\n| default      | 7.6.4   | 0..1        |\n| mandatory    | 7.6.5   | 0..1        |\n| max-elements | 7.7.4   | 0..1        |\n| min-elements | 7.7.3   | 0..1        |\n| must         | 7.5.3   | 0..n        |\n| type         | 7.4     | 0..1        |\n| unique       | 7.8.3   | 0..n        |\n| units        | 7.3.3   | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.18.3.3. Usage Example",
      "section_title": true,
      "zh-CHS": "7.18.3.3. 用法示例"
    },
    {
      "indent": 3,
      "text": "In this example, the device is informing client applications that it does not support the \"daytime\" service in the style of RFC 867.",
      "zh-CHS": "在此示例中，设备正在通知客户端应用程序它不支持RFC 867样式的“日间”服务。"
    },
    {
      "indent": 5,
      "text": "deviation /base:system/base:daytime {\n    deviate not-supported;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The following example sets a device-specific default value to a leaf that does not have a default value defined:",
      "zh-CHS": "以下示例将特定于设备的默认值设置为未定义默认值的叶："
    },
    {
      "indent": 5,
      "text": "deviation /base:system/base:user/base:type {\n    deviate add {\n        default \"admin\"; // new users are 'admin' by default\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "In this example, the device limits the number of name servers to 3:",
      "zh-CHS": "在此示例中，设备将名称服务器的数量限制为3："
    },
    {
      "indent": 5,
      "text": "deviation /base:system/base:name-server {\n    deviate replace {\n        max-elements 3;\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "If the original definition is:",
      "zh-CHS": "如果原始定义为："
    },
    {
      "indent": 5,
      "text": "container system {\n    must \"daytime or time\";\n    ...\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "a device might remove this must constraint by doing:",
      "zh-CHS": "设备可以通过执行以下操作来删除此“必须”约束："
    },
    {
      "indent": 5,
      "text": "deviation \"/base:system\" {\n    deviate delete {\n        must \"daytime or time\";\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.19. Common Statements",
      "section_title": true,
      "zh-CHS": "7.19. 共同声明"
    },
    {
      "indent": 3,
      "text": "This section defines substatements common to several other statements.",
      "zh-CHS": "本节定义了几个其他语句共有的子语句。"
    },
    {
      "indent": 0,
      "text": "7.19.1. The config Statement",
      "section_title": true,
      "zh-CHS": "7.19.1. config语句"
    },
    {
      "indent": 3,
      "text": "The \"config\" statement takes as an argument the string \"true\" or \"false\". If \"config\" is \"true\", the definition represents configuration. Data nodes representing configuration will be part of the reply to a <get-config> request, and can be sent in a <copy-config> or <edit-config> request.",
      "zh-CHS": "“config”语句将字符串“true”或“false”作为参数。如果“config”为“true”，则定义表示配置。表示配置的数据节点将是对<get config>请求的响应的一部分，可以在<copy config>或<edit config>请求中发送。"
    },
    {
      "indent": 3,
      "text": "If \"config\" is \"false\", the definition represents state data. Data nodes representing state data will be part of the reply to a <get>, but not to a <get-config> request, and cannot be sent in a <copy-config> or <edit-config> request.",
      "zh-CHS": "如果“config”为“false”，则定义表示状态数据。表示状态数据的数据节点将是回复<get>请求的一部分，而不是回复<get config>请求的一部分，并且不能在<copy config>或<edit config>请求中发送。"
    },
    {
      "indent": 3,
      "text": "If \"config\" is not specified, the default is the same as the parent schema node's \"config\" value. If the parent node is a \"case\" node, the value is the same as the \"case\" node's parent \"choice\" node.",
      "zh-CHS": "如果未指定“config”，则默认值与父架构节点的“config”值相同。如果父节点是“案例”节点，则该值与“案例”节点的父“选择”节点相同。"
    },
    {
      "indent": 3,
      "text": "If the top node does not specify a \"config\" statement, the default is \"true\".",
      "zh-CHS": "如果顶部节点未指定“config”语句，则默认值为“true”。"
    },
    {
      "indent": 3,
      "text": "If a node has \"config\" set to \"false\", no node underneath it can have \"config\" set to \"true\".",
      "zh-CHS": "如果一个节点的“config”设置为“false”，那么它下面的任何节点都不能将“config”设置为“true”。"
    },
    {
      "indent": 0,
      "text": "7.19.2. The status Statement",
      "section_title": true,
      "zh-CHS": "7.19.2. 状态声明"
    },
    {
      "indent": 3,
      "text": "The \"status\" statement takes as an argument one of the strings \"current\", \"deprecated\", or \"obsolete\".",
      "zh-CHS": "“status”语句将字符串“current”、“deprecated”或“过时”中的一个作为参数。"
    },
    {
      "indent": 3,
      "text": "o \"current\" means that the definition is current and valid.",
      "zh-CHS": "o “当前”是指定义是当前有效的。"
    },
    {
      "indent": 3,
      "text": "o \"deprecated\" indicates an obsolete definition, but it permits new/ continued implementation in order to foster interoperability with older/existing implementations.",
      "zh-CHS": "o “弃用”表示一个过时的定义，但它允许新的/继续的实现，以促进与旧的/现有的实现的互操作性。"
    },
    {
      "indent": 3,
      "text": "o \"obsolete\" means the definition is obsolete and SHOULD NOT be implemented and/or can be removed from implementations.",
      "zh-CHS": "o “过时”是指该定义已过时，不应实施和/或可从实施中删除。"
    },
    {
      "indent": 3,
      "text": "If no status is specified, the default is \"current\".",
      "zh-CHS": "如果未指定状态，则默认为“当前”。"
    },
    {
      "indent": 3,
      "text": "If a definition is \"current\", it MUST NOT reference a \"deprecated\" or \"obsolete\" definition within the same module.",
      "zh-CHS": "如果定义是“当前的”，则它不得引用同一模块中的“已弃用”或“已过时”定义。"
    },
    {
      "indent": 3,
      "text": "If a definition is \"deprecated\", it MUST NOT reference an \"obsolete\" definition within the same module.",
      "zh-CHS": "如果定义是“不推荐的”，则它不得引用同一模块中的“过时”定义。"
    },
    {
      "indent": 3,
      "text": "For example, the following is illegal:",
      "zh-CHS": "例如，以下行为是非法的："
    },
    {
      "indent": 5,
      "text": "typedef my-type {\n  status deprecated;\n  type int32;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "leaf my-leaf {\n  status current;\n  type my-type; // illegal, since my-type is deprecated\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.19.3. The description Statement",
      "section_title": true,
      "zh-CHS": "7.19.3. 描述语句"
    },
    {
      "indent": 3,
      "text": "The \"description\" statement takes as an argument a string that contains a human-readable textual description of this definition. The text is provided in a language (or languages) chosen by the module developer; for the sake of interoperability, it is RECOMMENDED to choose a language that is widely understood among the community of network administrators who will use the module.",
      "zh-CHS": "“description”语句将包含此定义的可读文本描述的字符串作为参数。文本以模块开发人员选择的一种（或多种）语言提供；为了实现互操作性，建议选择一种将使用该模块的网络管理员社区广泛理解的语言。"
    },
    {
      "indent": 0,
      "text": "7.19.4. The reference Statement",
      "section_title": true,
      "zh-CHS": "7.19.4. 参考声明"
    },
    {
      "indent": 3,
      "text": "The \"reference\" statement takes as an argument a string that is used to specify a textual cross-reference to an external document, either another module that defines related management information, or a document that provides additional information relevant to this definition.",
      "zh-CHS": "“reference”语句将一个字符串作为参数，该字符串用于指定对外部文档、定义相关管理信息的另一个模块或提供与此定义相关的附加信息的文档的文本交叉引用。"
    },
    {
      "indent": 3,
      "text": "For example, a typedef for a \"uri\" data type could look like:",
      "zh-CHS": "例如，“uri”数据类型的typedef可能如下所示："
    },
    {
      "indent": 5,
      "text": "typedef uri {\n  type string;\n  reference\n    \"RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\";\n  ...\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.19.5. The when Statement",
      "section_title": true,
      "zh-CHS": "7.19.5. when语句"
    },
    {
      "indent": 3,
      "text": "The \"when\" statement makes its parent data definition statement conditional. The node defined by the parent data definition statement is only valid when the condition specified by the \"when\" statement is satisfied. The statement's argument is an XPath expression (see Section 6.4), which is used to formally specify this condition. If the XPath expression conceptually evaluates to \"true\" for a particular instance, then the node defined by the parent data definition statement is valid; otherwise, it is not.",
      "zh-CHS": "“when”语句使其父数据定义语句具有条件。父数据定义语句定义的节点仅在满足“when”语句指定的条件时有效。该语句的参数是一个XPath表达式（参见第6.4节），用于正式指定此条件。如果XPath表达式在概念上对特定实例的计算结果为“true”，则父数据定义语句定义的节点是有效的；否则，情况并非如此。"
    },
    {
      "indent": 3,
      "text": "See Section 8.3.2 for additional information.",
      "zh-CHS": "更多信息见第8.3.2节。"
    },
    {
      "indent": 3,
      "text": "The XPath expression is conceptually evaluated in the following context, in addition to the definition in Section 6.4.1:",
      "zh-CHS": "除了第6.4.1节中的定义外，XPath表达式在以下上下文中进行概念性评估："
    },
    {
      "indent": 3,
      "text": "o If the \"when\" statement is a child of an \"augment\" statement, then the context node is the augment's target node in the data tree, if the target node is a data node. Otherwise, the context node is the closest ancestor node to the target node that is also a data node.",
      "zh-CHS": "o 如果“when”语句是“augment”语句的子语句，则上下文节点是数据树中的augment的目标节点（如果目标节点是数据节点）。否则，上下文节点是距离目标节点（也是数据节点）最近的祖先节点。"
    },
    {
      "indent": 3,
      "text": "o If the \"when\" statement is a child of a \"uses\", \"choice\", or \"case\" statement, then the context node is the closest ancestor node to the \"uses\", \"choice\", or \"case\" node that is also a data node.",
      "zh-CHS": "o 如果“when”语句是“uses”、“choice”或“case”语句的子语句，则上下文节点是与“uses”、“choice”或“case”节点（也是数据节点）最近的祖先节点。"
    },
    {
      "indent": 3,
      "text": "o If the \"when\" statement is a child of any other data definition statement, the context node is the data definition's node in the data tree.",
      "zh-CHS": "o 如果“when”语句是任何其他数据定义语句的子语句，则上下文节点是数据树中数据定义的节点。"
    },
    {
      "indent": 3,
      "text": "o The accessible tree is made up of all nodes in the data tree, and all leafs with default values in use (see Section 7.6.1).",
      "zh-CHS": "o 可访问树由数据树中的所有节点和使用默认值的所有叶组成（见第7.6.1节）。"
    },
    {
      "indent": 3,
      "text": "The accessible tree depends on the context node:",
      "zh-CHS": "可访问树取决于上下文节点："
    },
    {
      "indent": 3,
      "text": "o If the context node represents configuration, the tree is the data in the NETCONF datastore where the context node exists. The XPath root node has all top-level configuration data nodes in all modules as children.",
      "zh-CHS": "o 如果上下文节点表示配置，则树是存在上下文节点的NETCONF数据存储中的数据。XPath根节点将所有模块中的所有顶级配置数据节点作为子节点。"
    },
    {
      "indent": 3,
      "text": "o If the context node represents state data, the tree is all state data on the device, and the <running/> datastore. The XPath root node has all top-level data nodes in all modules as children.",
      "zh-CHS": "o 如果上下文节点表示状态数据，则树是设备上的所有状态数据，以及<running/>数据存储。XPath根节点将所有模块中的所有顶级数据节点作为子节点。"
    },
    {
      "indent": 3,
      "text": "o If the context node represents notification content, the tree is the notification XML instance document. The XPath root node has the element representing the notification being defined as the only child.",
      "zh-CHS": "o 如果上下文节点表示通知内容，则树就是通知XML实例文档。XPath根节点具有表示被定义为唯一子节点的通知的元素。"
    },
    {
      "indent": 3,
      "text": "o If the context node represents RPC input parameters, the tree is the RPC XML instance document. The XPath root node has the element representing the RPC operation being defined as the only child.",
      "zh-CHS": "o 如果上下文节点表示RPC输入参数，则树就是RPC XML实例文档。XPath根节点将表示RPC操作的元素定义为唯一的子节点。"
    },
    {
      "indent": 3,
      "text": "o If the context node represents RPC output parameters, the tree is the RPC reply instance document. The XPath root node has the elements representing the RPC output parameters as children.",
      "zh-CHS": "o 如果上下文节点表示RPC输出参数，则树就是RPC应答实例文档。XPath根节点具有表示RPC输出参数的子元素。"
    },
    {
      "indent": 3,
      "text": "The result of the XPath expression is converted to a boolean value using the standard XPath rules.",
      "zh-CHS": "XPath表达式的结果使用标准XPath规则转换为布尔值。"
    },
    {
      "indent": 3,
      "text": "Note that the XPath expression is conceptually evaluated. This means that an implementation does not have to use an XPath evaluator on the device. The \"when\" statement can very well be implemented with specially written code.",
      "zh-CHS": "请注意，XPath表达式是在概念上进行计算的。这意味着实现不必在设备上使用XPath计算器。“when”语句可以用专门编写的代码很好地实现。"
    },
    {
      "indent": 0,
      "text": "8. Constraints",
      "section_title": true,
      "zh-CHS": "8. 约束条件"
    },
    {
      "indent": 0,
      "text": "8.1. Constraints on Data",
      "section_title": true,
      "zh-CHS": "8.1. 对数据的限制"
    },
    {
      "indent": 3,
      "text": "Several YANG statements define constraints on valid data. These constraints are enforced in different ways, depending on what type of data the statement defines.",
      "zh-CHS": "几个语句定义了对有效数据的约束。根据语句定义的数据类型，这些约束以不同的方式强制执行。"
    },
    {
      "indent": 3,
      "text": "o If the constraint is defined on configuration data, it MUST be true in a valid configuration data tree.",
      "zh-CHS": "o 如果约束是在配置数据上定义的，则在有效的配置数据树中必须为true。"
    },
    {
      "indent": 3,
      "text": "o If the constraint is defined on state data, it MUST be true in a reply to a <get> operation without a filter.",
      "zh-CHS": "o 如果约束是在状态数据上定义的，则在对<get>操作的答复中，该约束必须为true，而不使用过滤器。"
    },
    {
      "indent": 3,
      "text": "o If the constraint is defined on notification content, it MUST be true in any notification instance.",
      "zh-CHS": "o 如果约束是在通知内容上定义的，则在任何通知实例中都必须为true。"
    },
    {
      "indent": 3,
      "text": "o If the constraint is defined on RPC input parameters, it MUST be true in an invocation of the RPC operation.",
      "zh-CHS": "o 如果约束是在RPC输入参数上定义的，则在调用RPC操作时必须为true。"
    },
    {
      "indent": 3,
      "text": "o If the constraint is defined on RPC output parameters, it MUST be true in the RPC reply.",
      "zh-CHS": "o 如果约束是在RPC输出参数上定义的，则它在RPC应答中必须为true。"
    },
    {
      "indent": 0,
      "text": "8.2. Hierarchy of Constraints",
      "section_title": true,
      "zh-CHS": "8.2. 约束层次"
    },
    {
      "indent": 3,
      "text": "Conditions on parent nodes affect constraints on child nodes as a natural consequence of the hierarchy of nodes. \"must\", \"mandatory\", \"min-elements\", and \"max-elements\" constraints are not enforced if the parent node has a \"when\" or \"if-feature\" property that is not satisfied on the current device.",
      "zh-CHS": "父节点上的条件会影响子节点上的约束，这是节点层次结构的自然结果。如果父节点的“何时”或“如果功能”属性在当前设备上不满足，则不会强制执行“必须”、“必需”、“最小元素”和“最大元素”约束。"
    },
    {
      "indent": 3,
      "text": "In this example, the \"mandatory\" constraint on the \"longitude\" leaf are not enforced on devices that lack the \"has-gps\" feature:",
      "zh-CHS": "在本例中，“经度”叶上的“强制”约束不适用于缺少“具有gps”功能的设备："
    },
    {
      "indent": 7,
      "text": "container location {\n    if-feature has-gps;\n    leaf longitude {\n        mandatory true;\n        ...\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "8.3. Constraint Enforcement Model",
      "section_title": true,
      "zh-CHS": "8.3. 约束实施模型"
    },
    {
      "indent": 3,
      "text": "For configuration data, there are three windows when constraints MUST be enforced:",
      "zh-CHS": "对于配置数据，必须强制执行约束时有三个窗口："
    },
    {
      "indent": 3,
      "text": "o during parsing of RPC payloads",
      "zh-CHS": "o 在分析RPC有效负载期间"
    },
    {
      "indent": 3,
      "text": "o during processing of NETCONF operations",
      "zh-CHS": "o 在处理NETCONF操作期间"
    },
    {
      "indent": 3,
      "text": "o during validation",
      "zh-CHS": "o 验证期间"
    },
    {
      "indent": 3,
      "text": "Each of these scenarios is considered in the following sections.",
      "zh-CHS": "以下各节将考虑其中的每种情况。"
    },
    {
      "indent": 0,
      "text": "8.3.1. Payload Parsing",
      "section_title": true,
      "zh-CHS": "8.3.1. 有效负载解析"
    },
    {
      "indent": 3,
      "text": "When content arrives in RPC payloads, it MUST be well-formed XML, following the hierarchy and content rules defined by the set of models the device implements.",
      "zh-CHS": "当内容到达RPC有效负载时，它必须是格式良好的XML，遵循设备实现的模型集定义的层次结构和内容规则。"
    },
    {
      "indent": 3,
      "text": "o If a leaf data value does not match the type constraints for the leaf, including those defined in the type's \"range\", \"length\", and \"pattern\" properties, the server MUST reply with an \"invalid-value\" error-tag in the rpc-error, and with the error-app-tag and error-message associated with the constraint, if any exist.",
      "zh-CHS": "o 如果叶数据值与叶的类型约束（包括在类型的“范围”、“长度”和“模式”属性中定义的约束）不匹配，服务器必须在rpc错误中使用“无效值”错误标记以及与约束相关联的错误应用标记和错误消息（如果存在）进行回复。"
    },
    {
      "indent": 3,
      "text": "o If all keys of a list entry are not present, the server MUST reply with a \"missing-element\" error-tag in the rpc-error.",
      "zh-CHS": "o 如果列表项的所有键都不存在，服务器必须在rpc错误中使用“missing element”错误标记进行回复。"
    },
    {
      "indent": 3,
      "text": "o If data for more than one case branch of a choice is present, the server MUST reply with a \"bad-element\" in the rpc-error.",
      "zh-CHS": "o 如果存在一个选项的多个案例分支的数据，则服务器必须在rpc错误中使用“坏元素”进行回复。"
    },
    {
      "indent": 3,
      "text": "o If data for a node tagged with \"if-feature\" is present, and the feature is not supported by the device, the server MUST reply with an \"unknown-element\" error-tag in the rpc-error.",
      "zh-CHS": "o 如果存在标记为“If feature”的节点的数据，并且设备不支持该功能，则服务器必须在rpc错误中使用“unknown element”错误标记进行回复。"
    },
    {
      "indent": 3,
      "text": "o If data for a node tagged with \"when\" is present, and the \"when\" condition evaluates to \"false\", the server MUST reply with an \"unknown-element\" error-tag in the rpc-error.",
      "zh-CHS": "o 如果存在标记为“when”的节点的数据，并且“when”条件的计算结果为“false”，则服务器必须在rpc错误中使用“unknown element”错误标记进行回复。"
    },
    {
      "indent": 3,
      "text": "o For insert handling, if the value for the attributes \"before\" and \"after\" are not valid for the type of the appropriate key leafs, the server MUST reply with a \"bad-attribute\" error-tag in the rpc-error.",
      "zh-CHS": "o 对于插入处理，如果属性“before”和“after”的值对于相应密钥叶的类型无效，则服务器必须在rpc错误中使用“bad attribute”错误标记进行回复。"
    },
    {
      "indent": 3,
      "text": "o If the attributes \"before\" and \"after\" appears in any element that is not a list whose \"ordered-by\" property is \"user\", the server MUST reply with an \"unknown-attribute\" error-tag in the rpc-error.",
      "zh-CHS": "o 如果属性“before”和“after”出现在不是“ordered by”属性为“user”的列表的任何元素中，则服务器必须在rpc错误中使用“unknown attribute”错误标记进行回复。"
    },
    {
      "indent": 0,
      "text": "8.3.2. NETCONF <edit-config> Processing",
      "section_title": true,
      "zh-CHS": "8.3.2. NETCONF<edit config>处理"
    },
    {
      "indent": 3,
      "text": "After the incoming data is parsed, the NETCONF server performs the <edit-config> operation by applying the data to the configuration datastore. During this processing, the following errors MUST be detected:",
      "zh-CHS": "解析传入数据后，NETCONF服务器通过将数据应用于配置数据存储来执行<edit config>操作。在此处理过程中，必须检测到以下错误："
    },
    {
      "indent": 3,
      "text": "o Delete requests for non-existent data.",
      "zh-CHS": "o 删除对不存在数据的请求。"
    },
    {
      "indent": 3,
      "text": "o Create requests for existent data.",
      "zh-CHS": "o 创建对现有数据的请求。"
    },
    {
      "indent": 3,
      "text": "o Insert requests with \"before\" or \"after\" parameters that do not exist.",
      "zh-CHS": "o 使用不存在的“before”或“after”参数插入请求。"
    },
    {
      "indent": 3,
      "text": "During <edit-config> processing:",
      "zh-CHS": "在<edit config>处理过程中："
    },
    {
      "indent": 3,
      "text": "o If the NETCONF operation creates data nodes under a \"choice\", any existing nodes from other \"case\" branches are deleted by the server.",
      "zh-CHS": "o 如果NETCONF操作在“choice”下创建数据节点，则服务器将删除其他“case”分支中的任何现有节点。"
    },
    {
      "indent": 3,
      "text": "o If the NETCONF operation modifies a data node such that any node's \"when\" expression becomes false, then the node with the \"when\" expression is deleted by the server.",
      "zh-CHS": "o 如果NETCONF操作修改数据节点，使任何节点的“when”表达式变为false，则服务器将删除带有“when”表达式的节点。"
    },
    {
      "indent": 0,
      "text": "8.3.3. Validation",
      "section_title": true,
      "zh-CHS": "8.3.3. 验证"
    },
    {
      "indent": 3,
      "text": "When datastore processing is complete, the final contents MUST obey all validation constraints. This validation processing is performed at differing times according to the datastore. If the datastore is <running/> or <startup/>, these constraints MUST be enforced at the end of the <edit-config> or <copy-config> operation. If the datastore is <candidate/>, the constraint enforcement is delayed until a <commit> or <validate> operation.",
      "zh-CHS": "数据存储处理完成后，最终内容必须遵守所有验证约束。此验证处理根据数据存储在不同的时间执行。如果数据存储是<running/>或<startup/>，则必须在<edit config>或<copy config>操作结束时强制执行这些约束。如果数据存储是<candidate/>，则约束实施将延迟到<commit>或<validate>操作。"
    },
    {
      "indent": 3,
      "text": "o Any \"must\" constraints MUST evaluate to \"true\".",
      "zh-CHS": "o 任何“必须”约束都必须计算为“真”。"
    },
    {
      "indent": 3,
      "text": "o Any referential integrity constraints defined via the \"path\" statement MUST be satisfied.",
      "zh-CHS": "o 必须满足通过“path”语句定义的任何引用完整性约束。"
    },
    {
      "indent": 3,
      "text": "o Any \"unique\" constraints on lists MUST be satisfied.",
      "zh-CHS": "o 必须满足列表上的任何“唯一”约束。"
    },
    {
      "indent": 3,
      "text": "o The \"min-elements\" and \"max-elements\" constraints are enforced for lists and leaf-lists.",
      "zh-CHS": "o 列表和叶列表强制执行“最小元素”和“最大元素”约束。"
    },
    {
      "indent": 0,
      "text": "9. Built-In Types",
      "section_title": true,
      "zh-CHS": "9. 内置类型"
    },
    {
      "indent": 3,
      "text": "YANG has a set of built-in types, similar to those of many programming languages, but with some differences due to special requirements from the management information model.",
      "zh-CHS": "YANG有一组内置类型，类似于许多编程语言的类型，但由于管理信息模型的特殊要求而有所不同。"
    },
    {
      "indent": 3,
      "text": "Additional types may be defined, derived from those built-in types or from other derived types. Derived types may use subtyping to formally restrict the set of possible values.",
      "zh-CHS": "可以定义其他类型，从这些内置类型或其他派生类型派生。派生类型可以使用子类型来正式限制可能的值集。"
    },
    {
      "indent": 3,
      "text": "The different built-in types and their derived types allow different kinds of subtyping, namely length and regular expression restrictions of strings (Sections 9.4.4 and 9.4.6) and range restrictions of numeric types (Section 9.2.4).",
      "zh-CHS": "不同的内置类型及其派生类型允许不同类型的子类型，即字符串的长度和正则表达式限制（第9.4.4节和第9.4.6节）和数字类型的范围限制（第9.2.4节）。"
    },
    {
      "indent": 3,
      "text": "The lexical representation of a value of a certain type is used in the NETCONF messages and when specifying default values and numerical ranges in YANG modules.",
      "zh-CHS": "在NETCONF消息中以及在模块中指定默认值和数字范围时，使用特定类型值的词汇表示。"
    },
    {
      "indent": 0,
      "text": "9.1. Canonical Representation",
      "section_title": true,
      "zh-CHS": "9.1. 典范表示"
    },
    {
      "indent": 3,
      "text": "For most types, there is a single canonical representation of the type's values. Some types allow multiple lexical representations of the same value, for example, the positive integer \"17\" can be represented as \"+17\" or \"17\". Implementations MUST support all lexical representations specified in this document.",
      "zh-CHS": "对于大多数类型，该类型的值只有一个规范表示形式。某些类型允许相同值的多个词汇表示，例如，正整数“17”可以表示为“+17”或“17”。实现必须支持本文档中指定的所有词汇表示。"
    },
    {
      "indent": 3,
      "text": "When a NETCONF server sends data, it MUST be in the canonical form.",
      "zh-CHS": "NETCONF服务器发送数据时，数据必须是规范格式。"
    },
    {
      "indent": 3,
      "text": "Some types have a lexical representation that depends on the XML context in which they occur. These types do not have a canonical form.",
      "zh-CHS": "某些类型的词汇表示取决于它们出现的XML上下文。这些类型没有规范形式。"
    },
    {
      "indent": 0,
      "text": "9.2. The Integer Built-In Types",
      "section_title": true,
      "zh-CHS": "9.2. 内置类型的整数"
    },
    {
      "indent": 3,
      "text": "The integer built-in types are int8, int16, int32, int64, uint8, uint16, uint32, and uint64. They represent signed and unsigned integers of different sizes:",
      "zh-CHS": "内置的整数类型有int8、int16、int32、int64、uint8、uint16、uint32和uint64。它们表示大小不同的有符号和无符号整数："
    },
    {
      "indent": 3,
      "text": "int8 represents integer values between -128 and 127, inclusively.",
      "zh-CHS": "int8表示介于-128和127之间的整数值。"
    },
    {
      "indent": 3,
      "text": "int16 represents integer values between -32768 and 32767, inclusively.",
      "zh-CHS": "int16表示介于-32768和32767之间的整数值。"
    },
    {
      "indent": 3,
      "text": "int32 represents integer values between -2147483648 and 2147483647, inclusively.",
      "zh-CHS": "int32表示介于-2147483648和2147483647之间的整数值。"
    },
    {
      "indent": 3,
      "text": "int64 represents integer values between -9223372036854775808 and 9223372036854775807, inclusively.",
      "zh-CHS": "int64表示介于-9223372036854775808和9223372036854775807之间的整数值（包括）。"
    },
    {
      "indent": 3,
      "text": "uint8 represents integer values between 0 and 255, inclusively.",
      "zh-CHS": "uint8表示介于0和255之间的整数值（包括）。"
    },
    {
      "indent": 3,
      "text": "uint16 represents integer values between 0 and 65535, inclusively.",
      "zh-CHS": "uint16表示介于0和65535之间的整数值。"
    },
    {
      "indent": 3,
      "text": "uint32 represents integer values between 0 and 4294967295, inclusively.",
      "zh-CHS": "uint32表示0和4294967295之间的整数值，包括0和4294967295。"
    },
    {
      "indent": 3,
      "text": "uint64 represents integer values between 0 and 18446744073709551615, inclusively.",
      "zh-CHS": "uint64表示介于0和18446744073709551615之间的整数值。"
    },
    {
      "indent": 0,
      "text": "9.2.1. Lexical Representation",
      "section_title": true,
      "zh-CHS": "9.2.1. 词汇表征"
    },
    {
      "indent": 3,
      "text": "An integer value is lexically represented as an optional sign (\"+\" or \"-\"), followed by a sequence of decimal digits. If no sign is specified, \"+\" is assumed.",
      "zh-CHS": "整数值在词汇上表示为可选符号（“+”或“-”），后跟一系列十进制数字。如果未指定符号，则假定为“+”。"
    },
    {
      "indent": 3,
      "text": "For convenience, when specifying a default value for an integer in a YANG module, an alternative lexical representation can be used, which represents the value in a hexadecimal or octal notation. The hexadecimal notation consists of an optional sign (\"+\" or \"-\"), the characters \"0x\" followed a number of hexadecimal digits, where letters may be uppercase or lowercase. The octal notation consists of an optional sign (\"+\" or \"-\"), the character \"0\" followed a number of octal digits.",
      "zh-CHS": "为方便起见，在YANG模块中为整数指定默认值时，可以使用另一种词汇表示法，它以十六进制或八进制表示值。十六进制表示法由可选符号（“+”或“-”）组成，字符“0x”后跟许多十六进制数字，其中字母可以是大写或小写。八进制表示法由可选符号（“+”或“-”）组成，字符“0”后跟许多八进制数字。"
    },
    {
      "indent": 3,
      "text": "Note that if a default value in a YANG module has a leading zero (\"0\"), it is interpreted as an octal number. In the XML instance documents, an integer is always interpreted as a decimal number, and leading zeros are allowed.",
      "zh-CHS": "请注意，如果YANG模块中的默认值具有前导零（“0”），则会将其解释为八进制数。在XML实例文档中，整数始终被解释为十进制数，并且允许前导零。"
    },
    {
      "indent": 3,
      "text": "Examples:",
      "zh-CHS": "示例："
    },
    {
      "indent": 5,
      "text": "// legal values\n+4711                       // legal positive value\n4711                        // legal positive value\n-123                        // legal negative value\n0xf00f                      // legal positive hexadecimal value\n-0xf                        // legal negative hexadecimal value\n052                         // legal positive octal value",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "// illegal values\n- 1                         // illegal intermediate space",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "9.2.2. Canonical Form",
      "section_title": true,
      "zh-CHS": "9.2.2. 标准形"
    },
    {
      "indent": 3,
      "text": "The canonical form of a positive integer does not include the sign \"+\". Leading zeros are prohibited. The value zero is represented as \"0\".",
      "zh-CHS": "正整数的标准形式不包括符号“+”。禁止使用前导零。值0表示为“0”。"
    },
    {
      "indent": 0,
      "text": "9.2.3. Restrictions",
      "section_title": true,
      "zh-CHS": "9.2.3. 限制"
    },
    {
      "indent": 3,
      "text": "All integer types can be restricted with the \"range\" statement (Section 9.2.4).",
      "zh-CHS": "所有整数类型都可以用“range”语句进行限制（第9.2.4节）。"
    },
    {
      "indent": 0,
      "text": "9.2.4. The range Statement",
      "section_title": true,
      "zh-CHS": "9.2.4. 范围语句"
    },
    {
      "indent": 3,
      "text": "The \"range\" statement, which is an optional substatement to the \"type\" statement, takes as an argument a range expression string. It is used to restrict integer and decimal built-in types, or types derived from those.",
      "zh-CHS": "“range”语句是“type”语句的可选子语句，它将range表达式字符串作为参数。它用于限制整数和十进制内置类型，或从这些类型派生的类型。"
    },
    {
      "indent": 3,
      "text": "A range consists of an explicit value, or a lower-inclusive bound, two consecutive dots \"..\", and an upper-inclusive bound. Multiple values or ranges can be given, separated by \"|\". If multiple values or ranges are given, they all MUST be disjoint and MUST be in ascending order. If a range restriction is applied to an already range-restricted type, the new restriction MUST be equal or more limiting, that is raising the lower bounds, reducing the upper bounds, removing explicit values or ranges, or splitting ranges into multiple ranges with intermediate gaps. Each explicit value and range boundary value given in the range expression MUST match the type being restricted, or be one of the special values \"min\" or \"max\". \"min\" and \"max\" mean the minimum and maximum value accepted for the type being restricted, respectively.",
      "zh-CHS": "范围由一个显式值或一个包含下限、两个连续点“.”和一个包含上限组成。可以给出多个值或范围，以“|”分隔。如果给定了多个值或范围，则它们都必须是不相交的，并且必须按升序排列。如果将范围限制应用于已受范围限制的类型，则新限制必须等于或大于限制，即提高下限、降低上限、删除显式值或范围，或将范围拆分为具有中间间隙的多个范围。范围表达式中给出的每个显式值和范围边界值必须与受限制的类型匹配，或者是特殊值“min”或“max”之一。“最小值”和“最大值”分别指受限制类型可接受的最小值和最大值。"
    },
    {
      "indent": 3,
      "text": "The range expression syntax is formally defined by the rule \"range-arg\" in Section 12.",
      "zh-CHS": "范围表达式语法由第12节中的规则“range arg”正式定义。"
    },
    {
      "indent": 0,
      "text": "9.2.4.1. The range's Substatements",
      "section_title": true,
      "zh-CHS": "9.2.4.1. 范围的子状态"
    },
    {
      "indent": 17,
      "text": "+---------------+---------+-------------+\n| substatement  | section | cardinality |\n+---------------+---------+-------------+\n| description   | 7.19.3  | 0..1        |\n| error-app-tag | 7.5.4.2 | 0..1        |\n| error-message | 7.5.4.1 | 0..1        |\n| reference     | 7.19.4  | 0..1        |\n+---------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "9.2.5. Usage Example",
      "section_title": true,
      "zh-CHS": "9.2.5. 用法示例"
    },
    {
      "indent": 5,
      "text": "typedef my-base-int32-type {\n    type int32 {\n        range \"1..4 | 10..20\";\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "typedef my-type1 {\n    type my-base-int32-type {\n        // legal range restriction\n        range \"11..max\"; // 11..20\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "typedef my-type2 {\n    type my-base-int32-type {\n        // illegal range restriction\n        range \"11..100\";\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "9.3. The decimal64 Built-In Type",
      "section_title": true,
      "zh-CHS": "9.3. 小数64内置类型"
    },
    {
      "indent": 3,
      "text": "The decimal64 type represents a subset of the real numbers, which can be represented by decimal numerals. The value space of decimal64 is the set of numbers that can be obtained by multiplying a 64-bit signed integer by a negative power of ten, i.e., expressible as \"i x 10^-n\" where i is an integer64 and n is an integer between 1 and 18, inclusively.",
      "zh-CHS": "decimal64类型表示实数的子集，可以用十进制数字表示。小数64的值空间是可通过将64位有符号整数乘以10的负幂而获得的一组数字，即，可表示为“i x 10^-n”，其中i是整数64，n是介于1和18之间的整数。"
    },
    {
      "indent": 0,
      "text": "9.3.1. Lexical Representation",
      "section_title": true,
      "zh-CHS": "9.3.1. 词汇表征"
    },
    {
      "indent": 3,
      "text": "A decimal64 value is lexically represented as an optional sign (\"+\" or \"-\"), followed by a sequence of decimal digits, optionally followed by a period ('.') as a decimal indicator and a sequence of decimal digits. If no sign is specified, \"+\" is assumed.",
      "zh-CHS": "十进制64值在词汇上表示为可选符号（“+”或“-”），后跟十进制数字序列，可选后跟句点（“.”）作为十进制指示符和十进制数字序列。如果未指定符号，则假定为“+”。"
    },
    {
      "indent": 0,
      "text": "9.3.2. Canonical Form",
      "section_title": true,
      "zh-CHS": "9.3.2. 标准形"
    },
    {
      "indent": 3,
      "text": "The canonical form of a positive decimal64 does not include the sign \"+\". The decimal point is required. Leading and trailing zeros are prohibited, subject to the rule that there MUST be at least one digit before and after the decimal point. The value zero is represented as \"0.0\".",
      "zh-CHS": "正小数64的标准形式不包括符号“+”。小数点是必需的。禁止使用前导零和尾随零，前提是小数点前后必须至少有一位数字。值0表示为“0.0”。"
    },
    {
      "indent": 0,
      "text": "9.3.3. Restrictions",
      "section_title": true,
      "zh-CHS": "9.3.3. 限制"
    },
    {
      "indent": 3,
      "text": "A decimal64 type can be restricted with the \"range\" statement (Section 9.2.4).",
      "zh-CHS": "小数64类型可通过“范围”语句进行限制（第9.2.4节）。"
    },
    {
      "indent": 0,
      "text": "9.3.4. The fraction-digits Statement",
      "section_title": true,
      "zh-CHS": "9.3.4. 分数位数语句"
    },
    {
      "indent": 3,
      "text": "The \"fraction-digits\" statement, which is a substatement to the \"type\" statement, MUST be present if the type is \"decimal64\". It takes as an argument an integer between 1 and 18, inclusively. It controls the size of the minimum difference between values of a decimal64 type, by restricting the value space to numbers that are expressible as \"i x 10^-n\" where n is the fraction-digits argument.",
      "zh-CHS": "“小数位数”语句是“type”语句的子语句，如果类型为“decimal64”，则必须存在该语句。它接受一个介于1和18之间的整数作为参数。它通过将值空间限制为可表示为“i x 10^-n”的数字，其中n是小数位数参数，来控制小数64类型的值之间最小差值的大小。"
    },
    {
      "indent": 3,
      "text": "The following table lists the minimum and maximum value for each fraction-digit value:",
      "zh-CHS": "下表列出了每个分数位数的最小值和最大值："
    },
    {
      "indent": 5,
      "text": "+----------------+-----------------------+----------------------+\n| fraction-digit | min                   | max                  |\n+----------------+-----------------------+----------------------+\n| 1              | -922337203685477580.8 | 922337203685477580.7 |\n| 2              | -92233720368547758.08 | 92233720368547758.07 |\n| 3              | -9223372036854775.808 | 9223372036854775.807 |\n| 4              | -922337203685477.5808 | 922337203685477.5807 |\n| 5              | -92233720368547.75808 | 92233720368547.75807 |\n| 6              | -9223372036854.775808 | 9223372036854.775807 |\n| 7              | -922337203685.4775808 | 922337203685.4775807 |\n| 8              | -92233720368.54775808 | 92233720368.54775807 |\n| 9              | -9223372036.854775808 | 9223372036.854775807 |\n| 10             | -922337203.6854775808 | 922337203.6854775807 |\n| 11             | -92233720.36854775808 | 92233720.36854775807 |\n| 12             | -9223372.036854775808 | 9223372.036854775807 |\n| 13             | -922337.2036854775808 | 922337.2036854775807 |\n| 14             | -92233.72036854775808 | 92233.72036854775807 |\n| 15             | -9223.372036854775808 | 9223.372036854775807 |\n| 16             | -922.3372036854775808 | 922.3372036854775807 |\n| 17             | -92.23372036854775808 | 92.23372036854775807 |\n| 18             | -9.223372036854775808 | 9.223372036854775807 |\n+----------------+-----------------------+----------------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "9.3.5. Usage Example",
      "section_title": true,
      "zh-CHS": "9.3.5. 用法示例"
    },
    {
      "indent": 5,
      "text": "typedef my-decimal {\n    type decimal64 {\n        fraction-digits 2;\n        range \"1 .. 3.14 | 10 | 20..max\";\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "9.4. The string Built-In Type",
      "section_title": true,
      "zh-CHS": "9.4. 字符串内置类型"
    },
    {
      "indent": 3,
      "text": "The string built-in type represents human-readable strings in YANG. Legal characters are tab, carriage return, line feed, and the legal characters of Unicode and ISO/IEC 10646 [ISO.10646]:",
      "zh-CHS": "字符串内置类型表示YANG中的人类可读字符串。合法字符包括制表符、回车符、换行符以及Unicode和ISO/IEC 10646[ISO.10646]的合法字符："
    },
    {
      "indent": 5,
      "text": ";; any Unicode character, excluding the surrogate blocks,\n;; FFFE, and FFFF.\nstring = *char\nchar = %x9 / %xA / %xD / %x20-D7FF / %xE000-FFFD /\n       %x10000-10FFFF",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "9.4.1. Lexical Representation",
      "section_title": true,
      "zh-CHS": "9.4.1. 词汇表征"
    },
    {
      "indent": 3,
      "text": "A string value is lexically represented as character data in the XML instance documents.",
      "zh-CHS": "在XML实例文档中，字符串值在词汇上表示为字符数据。"
    },
    {
      "indent": 0,
      "text": "9.4.2. Canonical Form",
      "section_title": true,
      "zh-CHS": "9.4.2. 标准形"
    },
    {
      "indent": 3,
      "text": "The canonical form is the same as the lexical representation. No Unicode normalization is performed of string values.",
      "zh-CHS": "规范形式与词汇表示相同。不执行字符串值的Unicode规范化。"
    },
    {
      "indent": 0,
      "text": "9.4.3. Restrictions",
      "section_title": true,
      "zh-CHS": "9.4.3. 限制"
    },
    {
      "indent": 3,
      "text": "A string can be restricted with the \"length\" (Section 9.4.4) and \"pattern\" (Section 9.4.6) statements.",
      "zh-CHS": "可以使用“长度”（第9.4.4节）和“模式”（第9.4.6节）语句限制字符串。"
    },
    {
      "indent": 0,
      "text": "9.4.4. The length Statement",
      "section_title": true,
      "zh-CHS": "9.4.4. 长度语句"
    },
    {
      "indent": 3,
      "text": "The \"length\" statement, which is an optional substatement to the \"type\" statement, takes as an argument a length expression string. It is used to restrict the built-in type \"string\", or types derived from \"string\".",
      "zh-CHS": "“length”语句是“type”语句的可选子语句，它以长度表达式字符串作为参数。它用于限制内置类型“string”或从“string”派生的类型。"
    },
    {
      "indent": 3,
      "text": "A \"length\" statement restricts the number of Unicode characters in the string.",
      "zh-CHS": "“length”语句限制字符串中Unicode字符的数量。"
    },
    {
      "indent": 3,
      "text": "A length range consists of an explicit value, or a lower bound, two consecutive dots \"..\", and an upper bound. Multiple values or ranges can be given, separated by \"|\". Length-restricting values MUST NOT be negative. If multiple values or ranges are given, they all MUST be disjoint and MUST be in ascending order. If a length restriction is applied to an already length-restricted type, the new restriction MUST be equal or more limiting, that is, raising the lower bounds, reducing the upper bounds, removing explicit length values or ranges, or splitting ranges into multiple ranges with intermediate gaps. A length value is a non-negative integer, or one of the special values \"min\" or \"max\". \"min\" and \"max\" mean the minimum and maximum length accepted for the type being restricted, respectively. An implementation is not required to support a length value larger than 18446744073709551615.",
      "zh-CHS": "长度范围由一个显式值或一个下限、两个连续点“.”和一个上限组成。可以给出多个值或范围，以“|”分隔。长度限制值不得为负值。如果给定了多个值或范围，则它们都必须是不相交的，并且必须按升序排列。如果将长度限制应用于已受长度限制的类型，则新限制必须等于或大于限制，即提高下界、降低上界、删除显式长度值或范围，或将范围拆分为具有中间间隙的多个范围。长度值是非负整数，或特殊值“min”或“max”之一。“最小”和“最大”分别指受限制类型可接受的最小和最大长度。实现不需要支持大于18446744073709551615的长度值。"
    },
    {
      "indent": 3,
      "text": "The length expression syntax is formally defined by the rule \"length-arg\" in Section 12.",
      "zh-CHS": "长度表达式语法由第12节中的规则“length arg”正式定义。"
    },
    {
      "indent": 0,
      "text": "9.4.4.1. The length's Substatements",
      "section_title": true,
      "zh-CHS": "9.4.4.1. 长度的子状态"
    },
    {
      "indent": 17,
      "text": "+---------------+---------+-------------+\n| substatement  | section | cardinality |\n+---------------+---------+-------------+\n| description   | 7.19.3  | 0..1        |\n| error-app-tag | 7.5.4.2 | 0..1        |\n| error-message | 7.5.4.1 | 0..1        |\n| reference     | 7.19.4  | 0..1        |\n+---------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "9.4.5. Usage Example",
      "section_title": true,
      "zh-CHS": "9.4.5. 用法示例"
    },
    {
      "indent": 5,
      "text": "typedef my-base-str-type {\n    type string {\n        length \"1..255\";\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "type my-base-str-type {\n    // legal length refinement\n    length \"11 | 42..max\"; // 11 | 42..255\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "type my-base-str-type {\n    // illegal length refinement\n    length \"1..999\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "9.4.6. The pattern Statement",
      "section_title": true,
      "zh-CHS": "9.4.6. 模式语句"
    },
    {
      "indent": 3,
      "text": "The \"pattern\" statement, which is an optional substatement to the \"type\" statement, takes as an argument a regular expression string, as defined in [XSD-TYPES]. It is used to restrict the built-in type \"string\", or types derived from \"string\", to values that match the pattern.",
      "zh-CHS": "“pattern”语句是“type”语句的可选子语句，它将[XSD-TYPES]中定义的正则表达式字符串作为参数。它用于将内置类型“string”或从“string”派生的类型限制为与模式匹配的值。"
    },
    {
      "indent": 3,
      "text": "If the type has multiple \"pattern\" statements, the expressions are ANDed together, i.e., all such expressions have to match.",
      "zh-CHS": "如果类型有多个“模式”语句，则表达式将被AND放在一起，即所有此类表达式都必须匹配。"
    },
    {
      "indent": 3,
      "text": "If a pattern restriction is applied to an already pattern-restricted type, values must match all patterns in the base type, in addition to the new patterns.",
      "zh-CHS": "如果对已受模式限制的类型应用了模式限制，则值必须与基类型中的所有模式（除了新模式）匹配。"
    },
    {
      "indent": 0,
      "text": "9.4.6.1. The pattern's Substatements",
      "section_title": true,
      "zh-CHS": "9.4.6.1. 模式的子状态"
    },
    {
      "indent": 17,
      "text": "+---------------+---------+-------------+\n| substatement  | section | cardinality |\n+---------------+---------+-------------+\n| description   | 7.19.3  | 0..1        |\n| error-app-tag | 7.5.4.2 | 0..1        |\n| error-message | 7.5.4.1 | 0..1        |\n| reference     | 7.19.4  | 0..1        |\n+---------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "9.4.7. Usage Example",
      "section_title": true,
      "zh-CHS": "9.4.7. 用法示例"
    },
    {
      "indent": 3,
      "text": "With the following type:",
      "zh-CHS": "使用以下类型："
    },
    {
      "indent": 5,
      "text": "type string {\n    length \"0..4\";\n    pattern \"[0-9a-fA-F]*\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "the following strings match:",
      "zh-CHS": "以下字符串匹配："
    },
    {
      "indent": 5,
      "text": "AB          // legal\n9A00        // legal",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "and the following strings do not match:",
      "zh-CHS": "并且以下字符串不匹配："
    },
    {
      "indent": 5,
      "text": "00ABAB      // illegal, too long\nxx00        // illegal, bad characters",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "9.5. The boolean Built-In Type",
      "section_title": true,
      "zh-CHS": "9.5. 布尔型内置类型"
    },
    {
      "indent": 3,
      "text": "The boolean built-in type represents a boolean value.",
      "zh-CHS": "布尔内置类型表示布尔值。"
    },
    {
      "indent": 0,
      "text": "9.5.1. Lexical Representation",
      "section_title": true,
      "zh-CHS": "9.5.1. 词汇表征"
    },
    {
      "indent": 3,
      "text": "The lexical representation of a boolean value is a string with a value of \"true\" or \"false\". These values MUST be in lowercase.",
      "zh-CHS": "布尔值的词汇表示是一个值为“真”或“假”的字符串。这些值必须为小写。"
    },
    {
      "indent": 0,
      "text": "9.5.2. Canonical Form",
      "section_title": true,
      "zh-CHS": "9.5.2. 标准形"
    },
    {
      "indent": 3,
      "text": "The canonical form is the same as the lexical representation.",
      "zh-CHS": "规范形式与词汇表示相同。"
    },
    {
      "indent": 0,
      "text": "9.5.3. Restrictions",
      "section_title": true,
      "zh-CHS": "9.5.3. 限制"
    },
    {
      "indent": 3,
      "text": "A boolean cannot be restricted.",
      "zh-CHS": "布尔值不能被限制。"
    },
    {
      "indent": 0,
      "text": "9.6. The enumeration Built-In Type",
      "section_title": true,
      "zh-CHS": "9.6. 枚举内置类型"
    },
    {
      "indent": 3,
      "text": "The enumeration built-in type represents values from a set of assigned names.",
      "zh-CHS": "枚举内置类型表示一组指定名称中的值。"
    },
    {
      "indent": 0,
      "text": "9.6.1. Lexical Representation",
      "section_title": true,
      "zh-CHS": "9.6.1. 词汇表征"
    },
    {
      "indent": 3,
      "text": "The lexical representation of an enumeration value is the assigned name string.",
      "zh-CHS": "枚举值的词法表示是指定的名称字符串。"
    },
    {
      "indent": 0,
      "text": "9.6.2. Canonical Form",
      "section_title": true,
      "zh-CHS": "9.6.2. 标准形"
    },
    {
      "indent": 3,
      "text": "The canonical form is the assigned name string.",
      "zh-CHS": "规范形式是指定的名称字符串。"
    },
    {
      "indent": 0,
      "text": "9.6.3. Restrictions",
      "section_title": true,
      "zh-CHS": "9.6.3. 限制"
    },
    {
      "indent": 3,
      "text": "An enumeration cannot be restricted.",
      "zh-CHS": "不能限制枚举。"
    },
    {
      "indent": 0,
      "text": "9.6.4. The enum Statement",
      "section_title": true,
      "zh-CHS": "9.6.4. enum语句"
    },
    {
      "indent": 3,
      "text": "The \"enum\" statement, which is a substatement to the \"type\" statement, MUST be present if the type is \"enumeration\". It is repeatedly used to specify each assigned name of an enumeration type. It takes as an argument a string which is the assigned name. The string MUST NOT be empty and MUST NOT have any leading or trailing whitespace characters. The use of Unicode control codes SHOULD be avoided.",
      "zh-CHS": "“enum”语句是“type”语句的子语句，如果类型为“enumeration”，则必须存在该语句。它反复用于指定枚举类型的每个指定名称。它将指定名称的字符串作为参数。字符串不得为空，且不得有任何前导或尾随空格字符。应避免使用Unicode控制代码。"
    },
    {
      "indent": 3,
      "text": "The statement is optionally followed by a block of substatements that holds detailed enum information.",
      "zh-CHS": "该语句后面有一个包含详细枚举信息的子语句块（可选）。"
    },
    {
      "indent": 3,
      "text": "All assigned names in an enumeration MUST be unique.",
      "zh-CHS": "枚举中所有分配的名称都必须是唯一的。"
    },
    {
      "indent": 0,
      "text": "9.6.4.1. The enum's Substatements",
      "section_title": true,
      "zh-CHS": "9.6.4.1. 枚举的子语句"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| description  | 7.19.3  | 0..1        |\n| reference    | 7.19.4  | 0..1        |\n| status       | 7.19.2  | 0..1        |\n| value        | 9.6.4.2 | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "9.6.4.2. The value Statement",
      "section_title": true,
      "zh-CHS": "9.6.4.2. 价值陈述"
    },
    {
      "indent": 3,
      "text": "The \"value\" statement, which is optional, is used to associate an integer value with the assigned name for the enum. This integer value MUST be in the range -2147483648 to 2147483647, and it MUST be unique within the enumeration type. The value is unused by YANG and the XML encoding, but is carried as a convenience to implementors.",
      "zh-CHS": "“value”语句是可选的，用于将整数值与枚举的指定名称相关联。此整数值必须在-2147483648到2147483647之间，并且在枚举类型中必须是唯一的。YANG和XML编码未使用该值，但为方便实现者而携带该值。"
    },
    {
      "indent": 3,
      "text": "If a value is not specified, then one will be automatically assigned. If the \"enum\" substatement is the first one defined, the assigned value is zero (0); otherwise, the assigned value is one greater than the current highest enum value.",
      "zh-CHS": "如果未指定值，则将自动指定一个值。如果“enum”子状态是第一个定义的子状态，则赋值为零（0）；否则，指定的值比当前最高枚举值大一个。"
    },
    {
      "indent": 3,
      "text": "If the current highest value is equal to 2147483647, then an enum value MUST be specified for \"enum\" substatements following the one with the current highest value.",
      "zh-CHS": "如果当前最大值等于2147483647，则必须为具有当前最大值的子状态之后的“enum”子状态指定枚举值。"
    },
    {
      "indent": 0,
      "text": "9.6.5. Usage Example",
      "section_title": true,
      "zh-CHS": "9.6.5. 用法示例"
    },
    {
      "indent": 5,
      "text": "leaf myenum {\n    type enumeration {\n        enum zero;\n        enum one;\n        enum seven {\n            value 7;\n        }\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The lexical representation of the leaf \"myenum\" with value \"seven\" is:",
      "zh-CHS": "值为“seven”的叶“myenum”的词汇表示为："
    },
    {
      "indent": 5,
      "text": "<myenum>seven</myenum>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "9.7. The bits Built-In Type",
      "section_title": true,
      "zh-CHS": "9.7. 内置式钻头"
    },
    {
      "indent": 3,
      "text": "The bits built-in type represents a bit set. That is, a bits value is a set of flags identified by small integer position numbers starting at 0. Each bit number has an assigned name.",
      "zh-CHS": "bits内置类型表示位集。也就是说，位值是由从0开始的小整数位置号标识的一组标志。每个位号都有一个指定的名称。"
    },
    {
      "indent": 0,
      "text": "9.7.1. Restrictions",
      "section_title": true,
      "zh-CHS": "9.7.1. 限制"
    },
    {
      "indent": 3,
      "text": "A bits type cannot be restricted.",
      "zh-CHS": "不能限制位类型。"
    },
    {
      "indent": 0,
      "text": "9.7.2. Lexical Representation",
      "section_title": true,
      "zh-CHS": "9.7.2. 词汇表征"
    },
    {
      "indent": 3,
      "text": "The lexical representation of the bits type is a space-separated list of the individual bit values that are set. An empty string thus represents a value where no bits are set.",
      "zh-CHS": "bits类型的词法表示是设置的单个位值的空格分隔列表。因此，空字符串表示未设置位的值。"
    },
    {
      "indent": 0,
      "text": "9.7.3. Canonical Form",
      "section_title": true,
      "zh-CHS": "9.7.3. 标准形"
    },
    {
      "indent": 3,
      "text": "In the canonical form, the bit values are separated by a single space character and they appear ordered by their position (see Section 9.7.4.2).",
      "zh-CHS": "在标准格式中，位值由单个空格字符分隔，并按其位置排列（见第9.7.4.2节）。"
    },
    {
      "indent": 0,
      "text": "9.7.4. The bit Statement",
      "section_title": true,
      "zh-CHS": "9.7.4. bit语句"
    },
    {
      "indent": 3,
      "text": "The \"bit\" statement, which is a substatement to the \"type\" statement, MUST be present if the type is \"bits\". It is repeatedly used to specify each assigned named bit of a bits type. It takes as an argument a string that is the assigned name of the bit. It is followed by a block of substatements that holds detailed bit information. The assigned name follows the same syntax rules as an identifier (see Section 6.2).",
      "zh-CHS": "“bit”语句是“type”语句的子语句，如果类型为“bits”，则必须存在该语句。它反复用于指定位类型的每个指定的命名位。它接受一个字符串作为参数，该字符串是位的指定名称。它后面是一个包含详细位信息的子语句块。分配的名称遵循与标识符相同的语法规则（参见第6.2节）。"
    },
    {
      "indent": 3,
      "text": "All assigned names in a bits type MUST be unique.",
      "zh-CHS": "bits类型中所有分配的名称必须是唯一的。"
    },
    {
      "indent": 0,
      "text": "9.7.4.1. The bit's Substatements",
      "section_title": true,
      "zh-CHS": "9.7.4.1. 钻头的子级"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| description  | 7.19.3  | 0..1        |\n| reference    | 7.19.4  | 0..1        |\n| status       | 7.19.2  | 0..1        |\n| position     | 9.7.4.2 | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "9.7.4.2. The position Statement",
      "section_title": true,
      "zh-CHS": "9.7.4.2. 立场声明"
    },
    {
      "indent": 3,
      "text": "The \"position\" statement, which is optional, takes as an argument a non-negative integer value that specifies the bit's position within a hypothetical bit field. The position value MUST be in the range 0 to 4294967295, and it MUST be unique within the bits type. The value is unused by YANG and the NETCONF messages, but is carried as a convenience to implementors.",
      "zh-CHS": "“position”语句是可选的，它接受一个非负整数值作为参数，该数值指定位在假设位字段中的位置。位置值必须在0到4294967295之间，并且在bits类型中必须是唯一的。YANG和NETCONF消息未使用该值，但为方便实现者而携带该值。"
    },
    {
      "indent": 3,
      "text": "If a bit position is not specified, then one will be automatically assigned. If the \"bit\" substatement is the first one defined, the assigned value is zero (0); otherwise, the assigned value is one greater than the current highest bit position.",
      "zh-CHS": "如果未指定位位置，则将自动分配一个位位置。如果“位”子状态是第一个定义的子状态，则赋值为零（0）；否则，分配的值比当前最高位位置大一个。"
    },
    {
      "indent": 3,
      "text": "If the current highest bit position value is equal to 4294967295, then a position value MUST be specified for \"bit\" substatements following the one with the current highest position value.",
      "zh-CHS": "如果当前最高位位置值等于4294967295，则必须为具有当前最高位置值的子状态之后的“位”子状态指定位置值。"
    },
    {
      "indent": 0,
      "text": "9.7.5. Usage Example",
      "section_title": true,
      "zh-CHS": "9.7.5. 用法示例"
    },
    {
      "indent": 3,
      "text": "Given the following leaf:",
      "zh-CHS": "鉴于以下情况："
    },
    {
      "indent": 5,
      "text": "leaf mybits {\n    type bits {\n        bit disable-nagle {\n            position 0;\n        }\n        bit auto-sense-speed {\n            position 1;\n        }\n        bit 10-Mb-only {\n            position 2;\n        }\n    }\n    default \"auto-sense-speed\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The lexical representation of this leaf with bit values disable-nagle and 10-Mb-only set would be:",
      "zh-CHS": "此叶的词法表示（位值为disable nagle且仅设置了10 Mb）为："
    },
    {
      "indent": 5,
      "text": "<mybits>disable-nagle 10-Mb-only</mybits>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "9.8. The binary Built-In Type",
      "section_title": true,
      "zh-CHS": "9.8. 二进制内置类型"
    },
    {
      "indent": 3,
      "text": "The binary built-in type represents any binary data, i.e., a sequence of octets.",
      "zh-CHS": "二进制内置类型表示任何二进制数据，即八位字节序列。"
    },
    {
      "indent": 0,
      "text": "9.8.1. Restrictions",
      "section_title": true,
      "zh-CHS": "9.8.1. 限制"
    },
    {
      "indent": 3,
      "text": "A binary can be restricted with the \"length\" (Section 9.4.4) statement. The length of a binary value is the number of octets it contains.",
      "zh-CHS": "二进制文件可以用“长度”（第9.4.4节）语句进行限制。二进制值的长度是它包含的八位字节数。"
    },
    {
      "indent": 0,
      "text": "9.8.2. Lexical Representation",
      "section_title": true,
      "zh-CHS": "9.8.2. 词汇表征"
    },
    {
      "indent": 3,
      "text": "Binary values are encoded with the base64 encoding scheme (see [RFC4648], Section 4).",
      "zh-CHS": "二进制值采用base64编码方案进行编码（参见[RFC4648]，第4节）。"
    },
    {
      "indent": 0,
      "text": "9.8.3. Canonical Form",
      "section_title": true,
      "zh-CHS": "9.8.3. 标准形"
    },
    {
      "indent": 3,
      "text": "The canonical form of a binary value follows the rules in [RFC4648].",
      "zh-CHS": "二进制值的标准形式遵循[RFC4648]中的规则。"
    },
    {
      "indent": 0,
      "text": "9.9. The leafref Built-In Type",
      "section_title": true,
      "zh-CHS": "9.9. leafref内置类型"
    },
    {
      "indent": 3,
      "text": "The leafref type is used to reference a particular leaf instance in the data tree. The \"path\" substatement (Section 9.9.2) selects a set of leaf instances, and the leafref value space is the set of values of these leaf instances.",
      "zh-CHS": "leafref类型用于引用数据树中的特定叶实例。“路径”子状态（第9.9.2节）选择一组叶实例，叶引用值空间是这些叶实例的值集。"
    },
    {
      "indent": 3,
      "text": "If the leaf with the leafref type represents configuration data, the leaf it refers to MUST also represent configuration. Such a leaf puts a constraint on valid data. All leafref nodes MUST reference existing leaf instances or leafs with default values in use (see Section 7.6.1) for the data to be valid. This constraint is enforced according to the rules in Section 8.",
      "zh-CHS": "如果leafref类型的叶表示配置数据，则其引用的叶也必须表示配置。这样的叶子对有效数据施加了约束。所有leafref节点必须引用现有叶实例或使用默认值的叶（见第7.6.1节），数据才有效。此约束根据第8节中的规则强制执行。"
    },
    {
      "indent": 3,
      "text": "There MUST NOT be any circular chains of leafrefs.",
      "zh-CHS": "叶参照不得有任何环形链。"
    },
    {
      "indent": 3,
      "text": "If the leaf that the leafref refers to is conditional based on one or more features (see Section 7.18.2), then the leaf with the leafref type MUST also be conditional based on at least the same set of features.",
      "zh-CHS": "如果leafref引用的叶基于一个或多个特征（见第7.18.2节），则具有leafref类型的叶也必须基于至少相同的特征集。"
    },
    {
      "indent": 0,
      "text": "9.9.1. Restrictions",
      "section_title": true,
      "zh-CHS": "9.9.1. 限制"
    },
    {
      "indent": 3,
      "text": "A leafref cannot be restricted.",
      "zh-CHS": "不能限制leafref。"
    },
    {
      "indent": 0,
      "text": "9.9.2. The path Statement",
      "section_title": true,
      "zh-CHS": "9.9.2. path语句"
    },
    {
      "indent": 3,
      "text": "The \"path\" statement, which is a substatement to the \"type\" statement, MUST be present if the type is \"leafref\". It takes as an argument a string that MUST refer to a leaf or leaf-list node.",
      "zh-CHS": "“path”语句是“type”语句的子语句，如果类型为“leafref”，则必须存在该语句。它接受一个必须引用叶或叶列表节点的字符串作为参数。"
    },
    {
      "indent": 3,
      "text": "The syntax for a path argument is a subset of the XPath abbreviated syntax. Predicates are used only for constraining the values for the key nodes for list entries. Each predicate consists of exactly one equality test per key, and multiple adjacent predicates MAY be present if a list has multiple keys. The syntax is formally defined by the rule \"path-arg\" in Section 12.",
      "zh-CHS": "path参数的语法是XPath缩写语法的子集。谓词仅用于约束列表项的关键节点的值。每个谓词对于每个键只包含一个相等测试，如果列表有多个键，则可能存在多个相邻谓词。语法由第12节中的规则“path arg”正式定义。"
    },
    {
      "indent": 3,
      "text": "The predicates are only used when more than one key reference is needed to uniquely identify a leaf instance. This occurs if a list has multiple keys, or a reference to a leaf other than the key in a list is needed. In these cases, multiple leafrefs are typically specified, and predicates are used to tie them together.",
      "zh-CHS": "谓词仅在需要多个键引用来唯一标识叶实例时使用。如果列表有多个键，或者需要对列表中键以外的叶的引用，则会发生这种情况。在这些情况下，通常会指定多个leafref，并使用谓词将它们连接在一起。"
    },
    {
      "indent": 3,
      "text": "The \"path\" expression evaluates to a node set consisting of zero, one, or more nodes. If the leaf with the leafref type represents configuration data, this node set MUST be non-empty.",
      "zh-CHS": "“路径”表达式的计算结果是由零个、一个或多个节点组成的节点集。如果leafref类型的叶表示配置数据，则此节点集必须为非空。"
    },
    {
      "indent": 3,
      "text": "The \"path\" XPath expression is conceptually evaluated in the following context, in addition to the definition in Section 6.4.1:",
      "zh-CHS": "除了第6.4.1节中的定义外，还将在以下上下文中对“path”XPath表达式进行概念性评估："
    },
    {
      "indent": 3,
      "text": "o The context node is the node in the data tree for which the \"path\" statement is defined.",
      "zh-CHS": "o 上下文节点是数据树中定义了“path”语句的节点。"
    },
    {
      "indent": 3,
      "text": "The accessible tree depends on the context node:",
      "zh-CHS": "可访问树取决于上下文节点："
    },
    {
      "indent": 3,
      "text": "o If the context node represents configuration data, the tree is the data in the NETCONF datastore where the context node exists. The XPath root node has all top-level configuration data nodes in all modules as children.",
      "zh-CHS": "o 如果上下文节点表示配置数据，则树是存在上下文节点的NETCONF数据存储中的数据。XPath根节点将所有模块中的所有顶级配置数据节点作为子节点。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, the tree is all state data on the device, and the <running/> datastore. The XPath root node has all top-level data nodes in all modules as children.",
      "zh-CHS": "o 否则，树就是设备上的所有状态数据和<running/>数据存储。XPath根节点将所有模块中的所有顶级数据节点作为子节点。"
    },
    {
      "indent": 0,
      "text": "9.9.3. Lexical Representation",
      "section_title": true,
      "zh-CHS": "9.9.3. 词汇表征"
    },
    {
      "indent": 3,
      "text": "A leafref value is encoded the same way as the leaf it references.",
      "zh-CHS": "leafref值的编码方式与其引用的叶相同。"
    },
    {
      "indent": 0,
      "text": "9.9.4. Canonical Form",
      "section_title": true,
      "zh-CHS": "9.9.4. 标准形"
    },
    {
      "indent": 3,
      "text": "The canonical form of a leafref is the same as the canonical form of the leaf it references.",
      "zh-CHS": "leafref的标准形式与它引用的叶的标准形式相同。"
    },
    {
      "indent": 0,
      "text": "9.9.5. Usage Example",
      "section_title": true,
      "zh-CHS": "9.9.5. 用法示例"
    },
    {
      "indent": 3,
      "text": "With the following list:",
      "zh-CHS": "以下是："
    },
    {
      "indent": 5,
      "text": "list interface {\n    key \"name\";\n    leaf name {\n        type string;\n    }\n    leaf admin-status {\n        type admin-status;\n    }\n    list address {\n        key \"ip\";\n        leaf ip {\n            type yang:ip-address;\n        }\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The following leafref refers to an existing interface:",
      "zh-CHS": "以下leafref引用现有接口："
    },
    {
      "indent": 5,
      "text": "leaf mgmt-interface {\n    type leafref {\n        path \"../interface/name\";\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "An example of a corresponding XML snippet:",
      "zh-CHS": "对应的XML代码段示例："
    },
    {
      "indent": 5,
      "text": "<interface>\n  <name>eth0</name>\n</interface>\n<interface>\n  <name>lo</name>\n</interface>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "<mgmt-interface>eth0</mgmt-interface>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The following leafrefs refer to an existing address of an interface:",
      "zh-CHS": "以下叶引用引用接口的现有地址："
    },
    {
      "indent": 5,
      "text": "container default-address {\n    leaf ifname {\n        type leafref {\n            path \"../../interface/name\";\n        }\n    }\n    leaf address {\n        type leafref {\n            path \"../../interface[name = current()/../ifname]\"\n               + \"/address/ip\";\n        }\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "An example of a corresponding XML snippet:",
      "zh-CHS": "对应的XML代码段示例："
    },
    {
      "indent": 5,
      "text": "<interface>\n  <name>eth0</name>\n  <admin-status>up</admin-status>\n  <address>\n    <ip>192.0.2.1</ip>\n  </address>\n  <address>\n    <ip>192.0.2.2</ip>\n  </address>\n</interface>\n<interface>\n  <name>lo</name>\n  <admin-status>up</admin-status>\n  <address>\n    <ip>127.0.0.1</ip>\n  </address>\n</interface>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "<default-address>\n  <ifname>eth0</ifname>\n  <address>192.0.2.2</address>\n</default-address>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The following list uses a leafref for one of its keys. This is similar to a foreign key in a relational database.",
      "zh-CHS": "下面的列表使用leafref作为其键之一。这类似于关系数据库中的外键。"
    },
    {
      "indent": 5,
      "text": "list packet-filter {\n    key \"if-name filter-id\";\n    leaf if-name {\n        type leafref {\n            path \"/interface/name\";\n        }\n    }\n    leaf filter-id {\n        type uint32;\n    }\n    ...\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "An example of a corresponding XML snippet:",
      "zh-CHS": "对应的XML代码段示例："
    },
    {
      "indent": 5,
      "text": "<interface>\n  <name>eth0</name>\n  <admin-status>up</admin-status>\n  <address>\n    <ip>192.0.2.1</ip>\n  </address>\n  <address>\n    <ip>192.0.2.2</ip>\n  </address>\n</interface>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "<packet-filter>\n  <if-name>eth0</if-name>\n  <filter-id>1</filter-id>\n  ...\n</packet-filter>\n<packet-filter>\n  <if-name>eth0</if-name>\n  <filter-id>2</filter-id>\n  ...\n</packet-filter>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The following notification defines two leafrefs to refer to an existing admin-status:",
      "zh-CHS": "以下通知定义了两个LeafRef以引用现有管理员状态："
    },
    {
      "indent": 5,
      "text": "notification link-failure {\n    leaf if-name {\n        type leafref {\n            path \"/interface/name\";\n        }\n    }\n    leaf admin-status {\n        type leafref {\n            path\n              \"/interface[name = current()/../if-name]\"\n            + \"/admin-status\";\n        }\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "An example of a corresponding XML notification:",
      "zh-CHS": "相应的XML通知示例如下："
    },
    {
      "indent": 5,
      "text": "<notification\n  xmlns=\"urn:ietf:params:xml:ns:netconf:notification:1.0\">\n  <eventTime>2008-04-01T00:01:00Z</eventTime>\n  <link-failure xmlns=\"http://acme.example.com/system\">\n    <if-name>eth0</if-name>\n    <admin-status>up</admin-status>\n  </link-failure>\n</notification>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "9.10. The identityref Built-In Type",
      "section_title": true,
      "zh-CHS": "9.10. identityref内置类型"
    },
    {
      "indent": 3,
      "text": "The identityref type is used to reference an existing identity (see Section 7.16).",
      "zh-CHS": "identityref类型用于引用现有标识（参见第7.16节）。"
    },
    {
      "indent": 0,
      "text": "9.10.1. Restrictions",
      "section_title": true,
      "zh-CHS": "9.10.1. 限制"
    },
    {
      "indent": 3,
      "text": "An identityref cannot be restricted.",
      "zh-CHS": "无法限制identityref。"
    },
    {
      "indent": 0,
      "text": "9.10.2. The identityref's base Statement",
      "section_title": true,
      "zh-CHS": "9.10.2. identityref的base语句"
    },
    {
      "indent": 3,
      "text": "The \"base\" statement, which is a substatement to the \"type\" statement, MUST be present if the type is \"identityref\". The argument is the name of an identity, as defined by an \"identity\" statement. If a prefix is present on the identity name, it refers to an identity defined in the module that was imported with that prefix. Otherwise, an identity with the matching name MUST be defined in the current module or an included submodule.",
      "zh-CHS": "如果类型为“identityref”，则作为“type”语句的子语句的“base”语句必须存在。参数是由“identity”语句定义的标识的名称。如果标识名上存在前缀，则它指的是使用该前缀导入的模块中定义的标识。否则，必须在当前模块或包含的子模块中定义具有匹配名称的标识。"
    },
    {
      "indent": 3,
      "text": "Valid values for an identityref are any identities derived from the identityref's base identity. On a particular server, the valid values are further restricted to the set of identities defined in the modules supported by the server.",
      "zh-CHS": "identityref的有效值是从identityref的基本标识派生的任何标识。在特定服务器上，有效值进一步限制为服务器支持的模块中定义的标识集。"
    },
    {
      "indent": 0,
      "text": "9.10.3. Lexical Representation",
      "section_title": true,
      "zh-CHS": "9.10.3. 词汇表征"
    },
    {
      "indent": 3,
      "text": "An identityref is encoded as the referred identity's qualified name as defined in [XML-NAMES]. If the prefix is not present, the namespace of the identityref is the default namespace in effect on the element that contains the identityref value.",
      "zh-CHS": "identityref编码为[XML-NAMES]中定义的引用标识的限定名称。如果前缀不存在，则identityref的命名空间是对包含identityref值的元素有效的默认命名空间。"
    },
    {
      "indent": 3,
      "text": "When an identityref is given a default value using the \"default\" statement, the identity name in the default value MAY have a prefix. If a prefix is present on the identity name, it refers to an identity defined in the module that was imported with that prefix. Otherwise, an identity with the matching name MUST be defined in the current module or an included submodule.",
      "zh-CHS": "当使用“default”语句为identityref指定默认值时，默认值中的标识名可能有前缀。如果标识名上存在前缀，则它指的是使用该前缀导入的模块中定义的标识。否则，必须在当前模块或包含的子模块中定义具有匹配名称的标识。"
    },
    {
      "indent": 0,
      "text": "9.10.4. Canonical Form",
      "section_title": true,
      "zh-CHS": "9.10.4. 标准形"
    },
    {
      "indent": 3,
      "text": "Since the lexical form depends on the XML context in which the value occurs, this type does not have a canonical form.",
      "zh-CHS": "由于词汇形式取决于值出现的XML上下文，因此该类型没有规范形式。"
    },
    {
      "indent": 0,
      "text": "9.10.5. Usage Example",
      "section_title": true,
      "zh-CHS": "9.10.5. 用法示例"
    },
    {
      "indent": 3,
      "text": "With the identity definitions in Section 7.16.3 and the following module:",
      "zh-CHS": "使用第7.16.3节中的标识定义和以下模块："
    },
    {
      "indent": 5,
      "text": "module my-crypto {",
      "zh-CHS": "模块my crypto{"
    },
    {
      "indent": 9,
      "text": "namespace \"http://example.com/my-crypto\";\nprefix mc;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "import \"crypto-base\" {\n    prefix \"crypto\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "identity aes {\n    base \"crypto:crypto-alg\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "    leaf crypto {\n        type identityref {\n            base \"crypto:crypto-alg\";\n        }\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "the leaf \"crypto\" will be encoded as follows, if the value is the \"des3\" identity defined in the \"des\" module:",
      "zh-CHS": "如果值是“des”模块中定义的“des3”标识，则叶“crypto”将按如下方式编码："
    },
    {
      "indent": 5,
      "text": "<crypto xmlns:des=\"http://example.com/des\">des:des3</crypto>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Any prefixes used in the encoding are local to each instance encoding. This means that the same identityref may be encoded differently by different implementations. For example, the following example encodes the same leaf as above:",
      "zh-CHS": "编码中使用的任何前缀都是每个实例编码的本地前缀。这意味着相同的identityref可以通过不同的实现进行不同的编码。例如，以下示例对与上面相同的叶进行编码："
    },
    {
      "indent": 5,
      "text": "<crypto xmlns:x=\"http://example.com/des\">x:des3</crypto>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "If the \"crypto\" leaf's value instead is \"aes\" defined in the \"my-crypto\" module, it can be encoded as:",
      "zh-CHS": "如果“加密”叶的值改为“我的加密”模块中定义的“aes”，则可以将其编码为："
    },
    {
      "indent": 5,
      "text": "<crypto xmlns:mc=\"http://example.com/my-crypto\">mc:aes</crypto>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "or, using the default namespace:",
      "zh-CHS": "或者，使用默认名称空间："
    },
    {
      "indent": 5,
      "text": "<crypto>aes</crypto>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "9.11. The empty Built-In Type",
      "section_title": true,
      "zh-CHS": "9.11. 空的内置类型"
    },
    {
      "indent": 3,
      "text": "The empty built-in type represents a leaf that does not have any value, it conveys information by its presence or absence.",
      "zh-CHS": "空的内置类型表示没有任何值的叶，它通过存在或不存在来传递信息。"
    },
    {
      "indent": 3,
      "text": "An empty type cannot have a default value.",
      "zh-CHS": "空类型不能有默认值。"
    },
    {
      "indent": 0,
      "text": "9.11.1. Restrictions",
      "section_title": true,
      "zh-CHS": "9.11.1. 限制"
    },
    {
      "indent": 3,
      "text": "An empty type cannot be restricted.",
      "zh-CHS": "不能限制空类型。"
    },
    {
      "indent": 0,
      "text": "9.11.2. Lexical Representation",
      "section_title": true,
      "zh-CHS": "9.11.2. 词汇表征"
    },
    {
      "indent": 3,
      "text": "Not applicable.",
      "zh-CHS": "不适用。"
    },
    {
      "indent": 0,
      "text": "9.11.3. Canonical Form",
      "section_title": true,
      "zh-CHS": "9.11.3. 标准形"
    },
    {
      "indent": 3,
      "text": "Not applicable.",
      "zh-CHS": "不适用。"
    },
    {
      "indent": 0,
      "text": "9.11.4. Usage Example",
      "section_title": true,
      "zh-CHS": "9.11.4. 用法示例"
    },
    {
      "indent": 3,
      "text": "The following leaf",
      "zh-CHS": "下一页"
    },
    {
      "indent": 5,
      "text": "leaf enable-qos {\n    type empty;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "will be encoded as",
      "zh-CHS": "将被编码为"
    },
    {
      "indent": 5,
      "text": "<enable-qos/>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "if it exists.",
      "zh-CHS": "如果存在的话。"
    },
    {
      "indent": 0,
      "text": "9.12. The union Built-In Type",
      "section_title": true,
      "zh-CHS": "9.12. 内置式工会"
    },
    {
      "indent": 3,
      "text": "The union built-in type represents a value that corresponds to one of its member types.",
      "zh-CHS": "union内置类型表示与其成员类型之一对应的值。"
    },
    {
      "indent": 3,
      "text": "When the type is \"union\", the \"type\" statement (Section 7.4) MUST be present. It is used to repeatedly specify each member type of the union. It takes as an argument a string that is the name of a member type.",
      "zh-CHS": "当类型为“union”时，“type”语句（第7.4节）必须存在。它用于重复指定联合的每个成员类型。它接受一个字符串作为参数，该字符串是成员类型的名称。"
    },
    {
      "indent": 3,
      "text": "A member type can be of any built-in or derived type, except it MUST NOT be one of the built-in types \"empty\" or \"leafref\".",
      "zh-CHS": "成员类型可以是任何内置类型或派生类型，但不能是内置类型“empty”或“leafref”之一。"
    },
    {
      "indent": 3,
      "text": "When a string representing a union data type is validated, the string is validated against each member type, in the order they are specified in the \"type\" statement, until a match is found.",
      "zh-CHS": "验证表示联合数据类型的字符串时，将按照“type”语句中指定的顺序针对每个成员类型验证该字符串，直到找到匹配项为止。"
    },
    {
      "indent": 3,
      "text": "Any default value or \"units\" property defined in the member types is not inherited by the union type.",
      "zh-CHS": "联合类型不会继承成员类型中定义的任何默认值或“units”属性。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "zh-CHS": "例子："
    },
    {
      "indent": 5,
      "text": "type union {\n    type int32;\n    type enumeration {\n        enum \"unbounded\";\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "9.12.1. Restrictions",
      "section_title": true,
      "zh-CHS": "9.12.1. 限制"
    },
    {
      "indent": 3,
      "text": "A union cannot be restricted. However, each member type can be restricted, based on the rules defined in Section 9.",
      "zh-CHS": "工会不能受到限制。但是，根据第9节中定义的规则，可以限制每种成员类型。"
    },
    {
      "indent": 0,
      "text": "9.12.2. Lexical Representation",
      "section_title": true,
      "zh-CHS": "9.12.2. 词汇表征"
    },
    {
      "indent": 3,
      "text": "The lexical representation of a union is a value that corresponds to the representation of any one of the member types.",
      "zh-CHS": "联合的词法表示是与任何一种成员类型的表示相对应的值。"
    },
    {
      "indent": 0,
      "text": "9.12.3. Canonical Form",
      "section_title": true,
      "zh-CHS": "9.12.3. 标准形"
    },
    {
      "indent": 3,
      "text": "The canonical form of a union value is the same as the canonical form of the member type of the value.",
      "zh-CHS": "联合值的标准形式与值的成员类型的标准形式相同。"
    },
    {
      "indent": 0,
      "text": "9.13. The instance-identifier Built-In Type",
      "section_title": true,
      "zh-CHS": "9.13. 内置类型的实例标识符"
    },
    {
      "indent": 3,
      "text": "The instance-identifier built-in type is used to uniquely identify a particular instance node in the data tree.",
      "zh-CHS": "实例标识符内置类型用于唯一标识数据树中的特定实例节点。"
    },
    {
      "indent": 3,
      "text": "The syntax for an instance-identifier is a subset of the XPath abbreviated syntax, formally defined by the rule \"instance-identifier\" in Section 12. It is used to uniquely identify a node in the data tree. Predicates are used only for specifying the values for the key nodes for list entries, a value of a leaf-list entry, or a positional index for a list without keys. For identifying list entries with keys, each predicate consists of one equality test per key, and each key MUST have a corresponding predicate.",
      "zh-CHS": "实例标识符的语法是XPath缩写语法的子集，由第12节中的规则“实例标识符”正式定义。它用于唯一标识数据树中的节点。谓词仅用于指定列表项的键节点值、叶列表项的值或无键列表的位置索引。为了用键标识列表项，每个谓词由每个键的一个相等性测试组成，每个键必须有一个对应的谓词。"
    },
    {
      "indent": 3,
      "text": "If the leaf with the instance-identifier type represents configuration data, and the \"require-instance\" property (Section 9.13.2) is \"true\", the node it refers to MUST also represent configuration. Such a leaf puts a constraint on valid data. All such leaf nodes MUST reference existing nodes or leaf nodes with their default value in use (see Section 7.6.1) for the data to be valid. This constraint is enforced according to the rules in Section 8.",
      "zh-CHS": "如果具有实例标识符类型的叶表示配置数据，并且“require instance”属性（第9.13.2节）为“true”，则其引用的节点也必须表示配置。这样的叶子对有效数据施加了约束。所有此类叶节点必须引用现有节点或使用默认值的叶节点（见第7.6.1节），数据才有效。此约束根据第8节中的规则强制执行。"
    },
    {
      "indent": 3,
      "text": "The \"instance-identifier\" XPath expression is conceptually evaluated in the following context, in addition to the definition in Section 6.4.1:",
      "zh-CHS": "除了第6.4.1节中的定义外，“实例标识符”XPath表达式在以下上下文中进行概念性评估："
    },
    {
      "indent": 3,
      "text": "o The context node is the root node in the accessible tree.",
      "zh-CHS": "o 上下文节点是可访问树中的根节点。"
    },
    {
      "indent": 3,
      "text": "The accessible tree depends on the leaf with the instance-identifier type:",
      "zh-CHS": "可访问树取决于具有实例标识符类型的叶："
    },
    {
      "indent": 3,
      "text": "o If this leaf represents configuration data, the tree is the data in the NETCONF datastore where the leaf exists. The XPath root node has all top-level configuration data nodes in all modules as children.",
      "zh-CHS": "o 如果此叶表示配置数据，则树是叶所在的NETCONF数据存储中的数据。XPath根节点将所有模块中的所有顶级配置数据节点作为子节点。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, the tree is all state data on the device, and the <running/> datastore. The XPath root node has all top-level data nodes in all modules as children.",
      "zh-CHS": "o 否则，树就是设备上的所有状态数据和<running/>数据存储。XPath根节点将所有模块中的所有顶级数据节点作为子节点。"
    },
    {
      "indent": 0,
      "text": "9.13.1. Restrictions",
      "section_title": true,
      "zh-CHS": "9.13.1. 限制"
    },
    {
      "indent": 3,
      "text": "An instance-identifier can be restricted with the \"require-instance\" statement (Section 9.13.2).",
      "zh-CHS": "实例标识符可以通过“require instance”语句进行限制（第9.13.2节）。"
    },
    {
      "indent": 0,
      "text": "9.13.2. The require-instance Statement",
      "section_title": true,
      "zh-CHS": "9.13.2. require实例语句"
    },
    {
      "indent": 3,
      "text": "The \"require-instance\" statement, which is a substatement to the \"type\" statement, MAY be present if the type is \"instance-identifier\". It takes as an argument the string \"true\" or \"false\". If this statement is not present, it defaults to \"true\".",
      "zh-CHS": "“require instance”语句是“type”语句的子语句，如果类型是“instance identifier”，则可能存在该语句。它将字符串“true”或“false”作为参数。如果此语句不存在，则默认为“true”。"
    },
    {
      "indent": 3,
      "text": "If \"require-instance\" is \"true\", it means that the instance being referred MUST exist for the data to be valid. This constraint is enforced according to the rules in Section 8.",
      "zh-CHS": "如果“require instance”为“true”，则表示引用的实例必须存在才能使数据有效。此约束根据第8节中的规则强制执行。"
    },
    {
      "indent": 3,
      "text": "If \"require-instance\" is \"false\", it means that the instance being referred MAY exist in valid data.",
      "zh-CHS": "如果“require instance”为“false”，则表示引用的实例可能存在于有效数据中。"
    },
    {
      "indent": 0,
      "text": "9.13.3. Lexical Representation",
      "section_title": true,
      "zh-CHS": "9.13.3. 词汇表征"
    },
    {
      "indent": 3,
      "text": "An instance-identifier value is lexically represented as a string. All node names in an instance-identifier value MUST be qualified with explicit namespace prefixes, and these prefixes MUST be declared in the XML namespace scope in the instance-identifier's XML element.",
      "zh-CHS": "实例标识符值在词汇上表示为字符串。实例标识符值中的所有节点名称都必须使用显式命名空间前缀限定，并且这些前缀必须在实例标识符的XML元素的XML命名空间范围中声明。"
    },
    {
      "indent": 3,
      "text": "Any prefixes used in the encoding are local to each instance encoding. This means that the same instance-identifier may be encoded differently by different implementations.",
      "zh-CHS": "编码中使用的任何前缀都是每个实例编码的本地前缀。这意味着相同的实例标识符可以通过不同的实现进行不同的编码。"
    },
    {
      "indent": 0,
      "text": "9.13.4. Canonical Form",
      "section_title": true,
      "zh-CHS": "9.13.4. 标准形"
    },
    {
      "indent": 3,
      "text": "Since the lexical form depends on the XML context in which the value occurs, this type does not have a canonical form.",
      "zh-CHS": "由于词汇形式取决于值出现的XML上下文，因此该类型没有规范形式。"
    },
    {
      "indent": 0,
      "text": "9.13.5. Usage Example",
      "section_title": true,
      "zh-CHS": "9.13.5. 用法示例"
    },
    {
      "indent": 3,
      "text": "The following are examples of instance identifiers:",
      "zh-CHS": "以下是实例标识符的示例："
    },
    {
      "indent": 5,
      "text": "/* instance-identifier for a container */\n/ex:system/ex:services/ex:ssh",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "/* instance-identifier for a leaf */\n/ex:system/ex:services/ex:ssh/ex:port",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "/* instance-identifier for a list entry */\n/ex:system/ex:user[ex:name='fred']",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "/* instance-identifier for a leaf in a list entry */\n/ex:system/ex:user[ex:name='fred']/ex:type",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "/* instance-identifier for a list entry with two keys */\n/ex:system/ex:server[ex:ip='192.0.2.1'][ex:port='80']",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "/* instance-identifier for a leaf-list entry */\n/ex:system/ex:services/ex:ssh/ex:cipher[.='blowfish-cbc']",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "/* instance-identifier for a list entry without keys */\n/ex:stats/ex:port[3]",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "10. Updating a Module",
      "section_title": true,
      "zh-CHS": "10. 更新模块"
    },
    {
      "indent": 3,
      "text": "As experience is gained with a module, it may be desirable to revise that module. However, changes are not allowed if they have any potential to cause interoperability problems between a client using an original specification and a server using an updated specification.",
      "zh-CHS": "由于从一个模块中获得了经验，因此可能需要修改该模块。但是，如果更改可能导致使用原始规范的客户端和使用更新规范的服务器之间的互操作性问题，则不允许进行更改。"
    },
    {
      "indent": 3,
      "text": "For any published change, a new \"revision\" statement (Section 7.1.9) MUST be included in front of the existing \"revision\" statements. If there are no existing \"revision\" statements, then one MUST be added to identify the new revision. Furthermore, any necessary changes MUST be applied to any meta-data statements, including the \"organization\" and \"contact\" statements (Sections 7.1.7, 7.1.8).",
      "zh-CHS": "对于任何已发布的变更，必须在现有“修订”声明之前包含新的“修订”声明（第7.1.9节）。如果没有现有的“修订”声明，则必须添加一个以标识新修订。此外，任何必要的更改都必须应用于任何元数据语句，包括“组织”和“联系”语句（第7.1.7、7.1.8节）。"
    },
    {
      "indent": 3,
      "text": "Note that definitions contained in a module are available to be imported by any other module, and are referenced in \"import\" statements via the module name. Thus, a module name MUST NOT be changed. Furthermore, the \"namespace\" statement MUST NOT be changed, since all XML elements are qualified by the namespace.",
      "zh-CHS": "请注意，模块中包含的定义可由任何其他模块导入，并且在“导入”语句中通过模块名称引用。因此，模块名称不得更改。此外，“namespace”语句不能更改，因为所有XML元素都由名称空间限定。"
    },
    {
      "indent": 3,
      "text": "Obsolete definitions MUST NOT be removed from modules since their identifiers may still be referenced by other modules.",
      "zh-CHS": "不能从模块中删除过时的定义，因为它们的标识符仍可能被其他模块引用。"
    },
    {
      "indent": 3,
      "text": "A definition may be revised in any of the following ways:",
      "zh-CHS": "定义可通过以下任何方式进行修订："
    },
    {
      "indent": 3,
      "text": "o An \"enumeration\" type may have new enums added, provided the old enums's values do not change.",
      "zh-CHS": "o “枚举”类型可以添加新的枚举，前提是旧枚举的值不变。"
    },
    {
      "indent": 3,
      "text": "o A \"bits\" type may have new bits added, provided the old bit positions do not change.",
      "zh-CHS": "o “位”类型可以添加新位，前提是旧位位置不变。"
    },
    {
      "indent": 3,
      "text": "o A \"range\", \"length\", or \"pattern\" statement may expand the allowed value space.",
      "zh-CHS": "o “range”、“length”或“pattern”语句可以扩展允许的值空间。"
    },
    {
      "indent": 3,
      "text": "o A \"default\" statement may be added to a leaf that does not have a default value (either directly or indirectly through its type).",
      "zh-CHS": "o “default”语句可以添加到没有默认值（直接或通过其类型间接）的叶中。"
    },
    {
      "indent": 3,
      "text": "o A \"units\" statement may be added.",
      "zh-CHS": "o 可以添加“单位”语句。"
    },
    {
      "indent": 3,
      "text": "o A \"reference\" statement may be added or updated.",
      "zh-CHS": "o 可以添加或更新“参考”声明。"
    },
    {
      "indent": 3,
      "text": "o A \"must\" statement may be removed or its constraint relaxed.",
      "zh-CHS": "o 可以删除“必须”语句或放松其约束。"
    },
    {
      "indent": 3,
      "text": "o A \"mandatory\" statement may be removed or changed from \"true\" to \"false\".",
      "zh-CHS": "o “强制性”声明可以删除或从“真”改为“假”。"
    },
    {
      "indent": 3,
      "text": "o A \"min-elements\" statement may be removed, or changed to require fewer elements.",
      "zh-CHS": "o “min elements”语句可以删除，也可以更改为需要更少的元素。"
    },
    {
      "indent": 3,
      "text": "o A \"max-elements\" statement may be removed, or changed to allow more elements.",
      "zh-CHS": "o “max elements”语句可以删除，也可以更改以允许更多元素。"
    },
    {
      "indent": 3,
      "text": "o A \"description\" statement may be added or clarified without changing the semantics of the definition.",
      "zh-CHS": "o 在不改变定义语义的情况下，可以添加或澄清“描述”语句。"
    },
    {
      "indent": 3,
      "text": "o New typedefs, groupings, rpcs, notifications, extensions, features, and identities may be added.",
      "zh-CHS": "o 可以添加新的类型定义、分组、RPC、通知、扩展、功能和标识。"
    },
    {
      "indent": 3,
      "text": "o New data definition statements may be added if they do not add mandatory nodes (Section 3.1) to existing nodes or at the top level in a module or submodule, or if they are conditionally dependent on a new feature (i.e., have an \"if-feature\" statement that refers to a new feature).",
      "zh-CHS": "o 如果新的数据定义语句没有向现有节点或模块或子模块的顶层添加强制性节点（第3.1节），或者如果它们有条件地依赖于新功能（即，具有引用新功能的“如果功能”语句），则可以添加新的数据定义语句。"
    },
    {
      "indent": 3,
      "text": "o A new \"case\" statement may be added.",
      "zh-CHS": "o 可以添加新的“案例”陈述。"
    },
    {
      "indent": 3,
      "text": "o A node that represented state data may be changed to represent configuration, provided it is not mandatory (Section 3.1).",
      "zh-CHS": "o 表示状态数据的节点可以更改为表示配置，前提是它不是强制性的（第3.1节）。"
    },
    {
      "indent": 3,
      "text": "o An \"if-feature\" statement may be removed, provided its node is not mandatory (Section 3.1).",
      "zh-CHS": "o 如果其节点不是强制性的，则可以删除“如果特征”语句（第3.1节）。"
    },
    {
      "indent": 3,
      "text": "o A \"status\" statement may be added, or changed from \"current\" to \"deprecated\" or \"obsolete\", or from \"deprecated\" to \"obsolete\".",
      "zh-CHS": "o 可以添加“状态”语句，或将其从“当前”更改为“已弃用”或“过时”，或从“已弃用”更改为“过时”。"
    },
    {
      "indent": 3,
      "text": "o A \"type\" statement may be replaced with another \"type\" statement that does not change the syntax or semantics of the type. For example, an inline type definition may be replaced with a typedef, but an int8 type cannot be replaced by an int16, since the syntax would change.",
      "zh-CHS": "o “type”语句可以替换为另一个“type”语句，该语句不会更改该类型的语法或语义。例如，内联类型定义可以替换为typedef，但int8类型不能替换为int16，因为语法会发生变化。"
    },
    {
      "indent": 3,
      "text": "o Any set of data definition nodes may be replaced with another set of syntactically and semantically equivalent nodes. For example, a set of leafs may be replaced by a uses of a grouping with the same leafs.",
      "zh-CHS": "o 任何一组数据定义节点都可以用另一组语法和语义上等价的节点来替换。例如，一组叶子可以被使用具有相同叶子的分组所代替。"
    },
    {
      "indent": 3,
      "text": "o A module may be split into a set of submodules, or a submodule may be removed, provided the definitions in the module do not change in any other way than allowed here.",
      "zh-CHS": "o 一个模块可以拆分为一组子模块，也可以删除子模块，前提是该模块中的定义不会以此处允许的任何其他方式发生更改。"
    },
    {
      "indent": 3,
      "text": "o The \"prefix\" statement may be changed, provided all local uses of the prefix also are changed.",
      "zh-CHS": "o “prefix”语句可能会更改，前提是前缀的所有本地使用也会更改。"
    },
    {
      "indent": 3,
      "text": "Otherwise, if the semantics of any previous definition are changed (i.e., if a non-editorial change is made to any definition other than those specifically allowed above), then this MUST be achieved by a new definition with a new identifier.",
      "zh-CHS": "否则，如果更改了任何先前定义的语义（即，如果对除上述明确允许的定义以外的任何定义进行了非编辑性更改），则必须通过使用新标识符的新定义来实现。"
    },
    {
      "indent": 3,
      "text": "In statements that have any data definition statements as substatements, those data definition substatements MUST NOT be reordered.",
      "zh-CHS": "在将任何数据定义语句作为子语句的语句中，不得对这些数据定义子语句重新排序。"
    },
    {
      "indent": 0,
      "text": "11. YIN",
      "section_title": true,
      "zh-CHS": "11. 尹"
    },
    {
      "indent": 3,
      "text": "A YANG module can be translated into an alternative XML-based syntax called YIN. The translated module is called a YIN module. This section describes symmetric mapping rules between the two formats.",
      "zh-CHS": "YANG模块可以转换为另一种基于XML的语法，称为YIN。翻译后的模块称为阴模块。本节介绍两种格式之间的对称映射规则。"
    },
    {
      "indent": 3,
      "text": "The YANG and YIN formats contain equivalent information using different notations. The YIN notation enables developers to represent YANG data models in XML and therefore use the rich set of XML-based tools for data filtering and validation, automated generation of code and documentation, and other tasks. Tools like XSLT or XML validators can be utilized.",
      "zh-CHS": "阳和阴格式包含使用不同符号的等效信息。YIN符号使开发人员能够用XML表示YANG数据模型，从而使用丰富的基于XML的工具集进行数据过滤和验证、代码和文档的自动生成以及其他任务。可以使用XSLT或XML验证器等工具。"
    },
    {
      "indent": 3,
      "text": "The mapping between YANG and YIN does not modify the information content of the model. Comments and whitespace are not preserved.",
      "zh-CHS": "阳与阴之间的映射不会修改模型的信息内容。注释和空白不保留。"
    },
    {
      "indent": 0,
      "text": "11.1. Formal YIN Definition",
      "section_title": true,
      "zh-CHS": "11.1. 形式阴定义"
    },
    {
      "indent": 3,
      "text": "There is a one-to-one correspondence between YANG keywords and YIN elements. The local name of a YIN element is identical to the corresponding YANG keyword. This means, in particular, that the document element (root) of a YIN document is always <module> or <submodule>.",
      "zh-CHS": "阳关键词和阴元素之间有一对一的对应关系。阴元素的本地名称与对应的阳关键字相同。这特别意味着，YIN文档的文档元素（根）总是<module>或<submodule>。"
    },
    {
      "indent": 3,
      "text": "YIN elements corresponding to the YANG keywords belong to the namespace whose associated URI is \"urn:ietf:params:xml:ns:yang:yin:1\".",
      "zh-CHS": "与YANG关键字对应的YIN元素属于名称空间，其关联URI为“urn:ietf:params:xml:ns:YANG:YIN:1”。"
    },
    {
      "indent": 3,
      "text": "YIN elements corresponding to extension keywords belong to the namespace of the YANG module where the extension keyword is declared via the \"extension\" statement.",
      "zh-CHS": "与扩展关键字对应的YIN元素属于YANG模块的名称空间，在该名称空间中，扩展关键字通过“extension”语句声明。"
    },
    {
      "indent": 3,
      "text": "The names of all YIN elements MUST be properly qualified with their namespaces specified above using the standard mechanisms of [XML-NAMES], i.e., \"xmlns\" and \"xmlns:xxx\" attributes.",
      "zh-CHS": "所有YIN元素的名称必须使用[XML-names]的标准机制，即“xmlns”和“xmlns:xxx”属性，使用上面指定的名称空间进行适当限定。"
    },
    {
      "indent": 3,
      "text": "The argument of a YANG statement is represented in YIN either as an XML attribute or a subelement of the keyword element. Table 1 defines the mapping for the set of YANG keywords. For extensions, the argument mapping is specified within the \"extension\" statement (see Section 7.17). The following rules hold for arguments:",
      "zh-CHS": "YANG语句的参数用YIN表示为XML属性或keyword元素的子元素。表1定义了YANG关键字集的映射。对于扩展，参数映射在“extension”语句中指定（参见第7.17节）。以下规则适用于参数："
    },
    {
      "indent": 3,
      "text": "o If the argument is represented as an attribute, this attribute has no namespace.",
      "zh-CHS": "o 如果参数表示为属性，则此属性没有命名空间。"
    },
    {
      "indent": 3,
      "text": "o If the argument is represented as an element, it is qualified by the same namespace as its parent keyword element.",
      "zh-CHS": "o 如果参数表示为一个元素，则它由与其父关键字元素相同的命名空间限定。"
    },
    {
      "indent": 3,
      "text": "o If the argument is represented as an element, it MUST be the first child of the keyword element.",
      "zh-CHS": "o 如果参数表示为元素，则它必须是关键字元素的第一个子元素。"
    },
    {
      "indent": 3,
      "text": "Substatements of a YANG statement are represented as (additional) children of the keyword element and their relative order MUST be the same as the order of substatements in YANG.",
      "zh-CHS": "YANG语句的子语句表示为关键字元素的（附加）子语句，它们的相对顺序必须与YANG语句中的子语句的顺序相同。"
    },
    {
      "indent": 3,
      "text": "Comments in YANG MAY be mapped to XML comments.",
      "zh-CHS": "YANG中的注释可以映射到XML注释。"
    },
    {
      "indent": 15,
      "text": "Mapping of arguments of the YANG statements.",
      "zh-CHS": "YANG语句的参数映射。"
    },
    {
      "indent": 12,
      "text": "+------------------+---------------+-------------+\n| keyword          | argument name | yin-element |\n+------------------+---------------+-------------+\n| anyxml           | name          | false       |\n| argument         | name          | false       |\n| augment          | target-node   | false       |\n| base             | name          | false       |\n| belongs-to       | module        | false       |\n| bit              | name          | false       |\n| case             | name          | false       |\n| choice           | name          | false       |\n| config           | value         | false       |\n| contact          | text          | true        |\n| container        | name          | false       |\n| default          | value         | false       |\n| description      | text          | true        |\n| deviate          | value         | false       |\n| deviation        | target-node   | false       |\n| enum             | name          | false       |\n| error-app-tag    | value         | false       |\n| error-message    | value         | true        |\n| extension        | name          | false       |\n| feature          | name          | false       |\n| fraction-digits  | value         | false       |\n| grouping         | name          | false       |\n| identity         | name          | false       |\n| if-feature       | name          | false       |\n| import           | module        | false       |\n| include          | module        | false       |\n| input            | <no argument> | n/a         |\n| key              | value         | false       |\n| leaf             | name          | false       |\n| leaf-list        | name          | false       |\n| length           | value         | false       |\n| list             | name          | false       |\n| mandatory        | value         | false       |\n| max-elements     | value         | false       |\n| min-elements     | value         | false       |\n| module           | name          | false       |\n| must             | condition     | false       |\n| namespace        | uri           | false       |\n| notification     | name          | false       |\n| ordered-by       | value         | false       |\n| organization     | text          | true        |\n| output           | <no argument> | n/a         |\n| path             | value         | false       |",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 12,
      "text": "| pattern          | value         | false       |\n| position         | value         | false       |\n| prefix           | value         | false       |\n| presence         | value         | false       |\n| range            | value         | false       |\n| reference        | text          | true        |\n| refine           | target-node   | false       |\n| require-instance | value         | false       |\n| revision         | date          | false       |\n| revision-date    | date          | false       |\n| rpc              | name          | false       |\n| status           | value         | false       |\n| submodule        | name          | false       |\n| type             | name          | false       |\n| typedef          | name          | false       |\n| unique           | tag           | false       |\n| units            | name          | false       |\n| uses             | name          | false       |\n| value            | value         | false       |\n| when             | condition     | false       |\n| yang-version     | value         | false       |\n| yin-element      | value         | false       |\n+------------------+---------------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 34,
      "text": "Table 1",
      "zh-CHS": "表1"
    },
    {
      "indent": 0,
      "text": "11.1.1. Usage Example",
      "section_title": true,
      "zh-CHS": "11.1.1. 用法示例"
    },
    {
      "indent": 3,
      "text": "The following YANG module:",
      "zh-CHS": "以下模块："
    },
    {
      "indent": 5,
      "text": "module acme-foo {\n    namespace \"http://acme.example.com/foo\";\n    prefix \"acfoo\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "import my-extensions {\n    prefix \"myext\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "list interface {\n    key \"name\";\n    leaf name {\n        type string;\n    }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "        leaf mtu {\n            type uint32;\n            description \"The MTU of the interface.\";\n            myext:c-define \"MY_MTU\";\n        }\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "where the extension \"c-define\" is defined in Section 7.17.3, is translated into the following YIN:",
      "zh-CHS": "如果第7.17.3节中定义了扩展名“c-define”，则将其翻译为以下内容："
    },
    {
      "indent": 5,
      "text": "<module name=\"acme-foo\"\n        xmlns=\"urn:ietf:params:xml:ns:yang:yin:1\"\n        xmlns:acfoo=\"http://acme.example.com/foo\"\n        xmlns:myext=\"http://example.com/my-extensions\">",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "<namespace uri=\"http://acme.example.com/foo\"/>\n<prefix value=\"acfoo\"/>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "<import module=\"my-extensions\">\n  <prefix value=\"myext\"/>\n</import>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "  <list name=\"interface\">\n    <key value=\"name\"/>\n    <leaf name=\"name\">\n      <type name=\"string\"/>\n    </leaf>\n    <leaf name=\"mtu\">\n      <type name=\"uint32\"/>\n      <description>\n        <text>The MTU of the interface.</text>\n      </description>\n      <myext:c-define name=\"MY_MTU\"/>\n    </leaf>\n  </list>\n</module>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "12. YANG ABNF Grammar",
      "section_title": true,
      "zh-CHS": "12. 杨氏语法"
    },
    {
      "indent": 3,
      "text": "In YANG, almost all statements are unordered. The ABNF grammar [RFC5234] defines the canonical order. To improve module readability, it is RECOMMENDED that clauses be entered in this order.",
      "zh-CHS": "在杨，几乎所有的陈述都是无序的。ABNF语法[RFC5234]定义了规范顺序。为了提高模块的可读性，建议按此顺序输入子句。"
    },
    {
      "indent": 3,
      "text": "Within the ABNF grammar, unordered statements are marked with comments.",
      "zh-CHS": "在ABNF语法中，无序语句用注释标记。"
    },
    {
      "indent": 3,
      "text": "This grammar assumes that the scanner replaces YANG comments with a single space character.",
      "zh-CHS": "此语法假定扫描程序使用单个空格字符替换注释。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS> file \"yang.abnf\"",
      "zh-CHS": "<CODE start>文件“yang.abnf”"
    },
    {
      "indent": 3,
      "text": "module-stmt = optsep module-keyword sep identifier-arg-str optsep \"{\" stmtsep module-header-stmts linkage-stmts meta-stmts revision-stmts body-stmts \"}\" optsep",
      "zh-CHS": "模块stmt=optsep模块关键字sep标识符arg str optsep“{”stmtsep模块头stmts链接stmts元stmts修订stmts正文stmts“}”optsep"
    },
    {
      "indent": 3,
      "text": "submodule-stmt = optsep submodule-keyword sep identifier-arg-str optsep \"{\" stmtsep submodule-header-stmts linkage-stmts meta-stmts revision-stmts body-stmts \"}\" optsep",
      "zh-CHS": "子模块stmt=optsep子模块关键字sep标识符arg str optsep“{”stmtsep子模块头stmts链接stmts元stmts修订stmts正文stmts“}”optsep"
    },
    {
      "indent": 3,
      "text": "module-header-stmts = ;; these stmts can appear in any order [yang-version-stmt stmtsep] namespace-stmt stmtsep prefix-stmt stmtsep",
      "zh-CHS": "模块头stmts=；；这些stmt可以以任何顺序出现[yang version stmt stmtsep]命名空间stmt stmtsep前缀stmt stmtsep"
    },
    {
      "indent": 3,
      "text": "submodule-header-stmts = ;; these stmts can appear in any order [yang-version-stmt stmtsep] belongs-to-stmt stmtsep",
      "zh-CHS": "子模块头stmts=；；这些stmt可以以任何顺序出现[yang version stmt STMTSP]属于stmt STMTSP"
    },
    {
      "indent": 3,
      "text": "meta-stmts          = ;; these stmts can appear in any order\n                      [organization-stmt stmtsep]\n                      [contact-stmt stmtsep]\n                      [description-stmt stmtsep]\n                      [reference-stmt stmtsep]",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "linkage-stmts       = ;; these stmts can appear in any order\n                      *(import-stmt stmtsep)\n                      *(include-stmt stmtsep)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "revision-stmts      = *(revision-stmt stmtsep)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "body-stmts          = *((extension-stmt /\n                         feature-stmt /\n                         identity-stmt /\n                         typedef-stmt /\n                         grouping-stmt /\n                         data-def-stmt /\n                         augment-stmt /\n                         rpc-stmt /\n                         notification-stmt /\n                         deviation-stmt) stmtsep)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "data-def-stmt = container-stmt / leaf-stmt / leaf-list-stmt / list-stmt / choice-stmt / anyxml-stmt / uses-stmt",
      "zh-CHS": "data def stmt=容器stmt/leaf stmt/leaf list stmt/list stmt/choice stmt/anyxml stmt/uses stmt"
    },
    {
      "indent": 3,
      "text": "yang-version-stmt = yang-version-keyword sep yang-version-arg-str optsep stmtend",
      "zh-CHS": "yang version stmt=yang version关键字sep yang version arg str optsep stmtend"
    },
    {
      "indent": 3,
      "text": "yang-version-arg-str = < a string that matches the rule\n                        yang-version-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "yang-version-arg    = \"1\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "import-stmt = import-keyword sep identifier-arg-str optsep \"{\" stmtsep prefix-stmt stmtsep [revision-date-stmt stmtsep] \"}\"",
      "zh-CHS": "import stmt=导入关键字sep标识符arg str optsep“{”stmtsep prefix stmt stmtsep[修订日期stmt stmtsep]“}”"
    },
    {
      "indent": 3,
      "text": "include-stmt = include-keyword sep identifier-arg-str optsep (\";\" / \"{\" stmtsep [revision-date-stmt stmtsep] \"}\")",
      "zh-CHS": "include stmt=include关键字sep标识符arg str optsep（“；”/“{”stmtsep[修订日期stmt stmtsep]“}”）"
    },
    {
      "indent": 3,
      "text": "namespace-stmt = namespace-keyword sep uri-str optsep stmtend",
      "zh-CHS": "namespace stmt=命名空间关键字sep uri str optsep stmtend"
    },
    {
      "indent": 3,
      "text": "uri-str             = < a string that matches the rule\n                        URI in RFC 3986 >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "prefix-stmt = prefix-keyword sep prefix-arg-str optsep stmtend",
      "zh-CHS": "前缀stmt=前缀关键字sep prefix arg str optsep stmtend"
    },
    {
      "indent": 3,
      "text": "belongs-to-stmt = belongs-to-keyword sep identifier-arg-str optsep \"{\" stmtsep prefix-stmt stmtsep \"}\"",
      "zh-CHS": "属于stmt=属于关键字sep标识符arg str optsep“{”stmtsep prefix stmt stmtsep“}”"
    },
    {
      "indent": 3,
      "text": "organization-stmt = organization-keyword sep string optsep stmtend",
      "zh-CHS": "组织stmt=组织关键字sep字符串optsep stmtend"
    },
    {
      "indent": 3,
      "text": "contact-stmt = contact-keyword sep string optsep stmtend",
      "zh-CHS": "contact stmt=联系人关键字sep string optsep stmtend"
    },
    {
      "indent": 3,
      "text": "description-stmt = description-keyword sep string optsep stmtend",
      "zh-CHS": "description stmt=description关键字sep string optsep stmtend"
    },
    {
      "indent": 3,
      "text": "reference-stmt = reference-keyword sep string optsep stmtend",
      "zh-CHS": "reference stmt=参考关键字sep string optsep stmtend"
    },
    {
      "indent": 3,
      "text": "units-stmt          = units-keyword sep string optsep stmtend",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "revision-stmt = revision-keyword sep revision-date optsep (\";\" / \"{\" stmtsep [description-stmt stmtsep] [reference-stmt stmtsep] \"}\")",
      "zh-CHS": "修订stmt=修订关键字sep修订日期optsep（“；”/“{”STMTSP[说明stmt STMTSP][参考stmt STMTSP]“}”）"
    },
    {
      "indent": 3,
      "text": "revision-date       =  date-arg-str",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "revision-date-stmt = revision-date-keyword sep revision-date stmtend",
      "zh-CHS": "修订日期stmt=修订日期关键字sep修订日期stmtend"
    },
    {
      "indent": 3,
      "text": "extension-stmt      = extension-keyword sep identifier-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [argument-stmt stmtsep]\n                           [status-stmt stmtsep]\n                           [description-stmt stmtsep]\n                           [reference-stmt stmtsep]\n                       \"}\")",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "argument-stmt = argument-keyword sep identifier-arg-str optsep (\";\" / \"{\" stmtsep [yin-element-stmt stmtsep] \"}\")",
      "zh-CHS": "参数stmt=参数关键字sep标识符arg str optsep（“；”/“{”stmtsep[yin元素stmt stmtsep]“}”）"
    },
    {
      "indent": 3,
      "text": "yin-element-stmt = yin-element-keyword sep yin-element-arg-str stmtend",
      "zh-CHS": "yin element stmt=yin element关键字sep yin element arg str stmtend"
    },
    {
      "indent": 3,
      "text": "yin-element-arg-str = < a string that matches the rule\n                        yin-element-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "yin-element-arg     = true-keyword / false-keyword",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "identity-stmt       = identity-keyword sep identifier-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [base-stmt stmtsep]\n                           [status-stmt stmtsep]\n                           [description-stmt stmtsep]\n                           [reference-stmt stmtsep]\n                       \"}\")",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "base-stmt = base-keyword sep identifier-ref-arg-str optsep stmtend",
      "zh-CHS": "base stmt=基本关键字sep标识符ref arg str optsep stmtend"
    },
    {
      "indent": 3,
      "text": "feature-stmt        = feature-keyword sep identifier-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           *(if-feature-stmt stmtsep)\n                           [status-stmt stmtsep]\n                           [description-stmt stmtsep]\n                           [reference-stmt stmtsep]\n                       \"}\")",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "if-feature-stmt = if-feature-keyword sep identifier-ref-arg-str optsep stmtend",
      "zh-CHS": "if feature stmt=if feature关键字sep identifier ref arg str optsep stmtend"
    },
    {
      "indent": 3,
      "text": "typedef-stmt        = typedef-keyword sep identifier-arg-str optsep\n                      \"{\" stmtsep\n                          ;; these stmts can appear in any order\n                          type-stmt stmtsep\n                          [units-stmt stmtsep]\n                          [default-stmt stmtsep]\n                          [status-stmt stmtsep]\n                          [description-stmt stmtsep]\n                          [reference-stmt stmtsep]\n                       \"}\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "type-stmt = type-keyword sep identifier-ref-arg-str optsep (\";\" / \"{\" stmtsep type-body-stmts \"}\")",
      "zh-CHS": "type stmt=type关键字sep标识符ref arg str optsep（“；”/“{”stmtsep type body stmts“}”）"
    },
    {
      "indent": 3,
      "text": "type-body-stmts = numerical-restrictions / decimal64-specification / string-restrictions / enum-specification / leafref-specification / identityref-specification / instance-identifier-specification / bits-specification / union-specification",
      "zh-CHS": "类型body stmts=数字限制/小数64规范/字符串限制/枚举规范/leafref规范/identityref规范/实例标识符规范/位规范/联合规范"
    },
    {
      "indent": 3,
      "text": "numerical-restrictions = range-stmt stmtsep",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "range-stmt          = range-keyword sep range-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [error-message-stmt stmtsep]\n                           [error-app-tag-stmt stmtsep]\n                           [description-stmt stmtsep]\n                           [reference-stmt stmtsep]\n                        \"}\")",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "decimal64-specification = fraction-digits-stmt",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "fraction-digits-stmt = fraction-digits-keyword sep fraction-digits-arg-str stmtend",
      "zh-CHS": "分数位数stmt=分数位数关键字sep分数位数arg str stmtend"
    },
    {
      "indent": 3,
      "text": "fraction-digits-arg-str = < a string that matches the rule\n                           fraction-digits-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "fraction-digits-arg = (\"1\" [\"0\" / \"1\" / \"2\" / \"3\" / \"4\" /\n                            \"5\" / \"6\" / \"7\" / \"8\"])\n                      / \"2\" / \"3\" / \"4\" / \"5\" / \"6\" / \"7\" / \"8\" / \"9\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "string-restrictions = ;; these stmts can appear in any order [length-stmt stmtsep] *(pattern-stmt stmtsep)",
      "zh-CHS": "字符串限制=；；这些stmt可以按任意顺序显示[长度stmt STMTSP]*（模式stmt STMTSP）"
    },
    {
      "indent": 3,
      "text": "length-stmt         = length-keyword sep length-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [error-message-stmt stmtsep]\n                           [error-app-tag-stmt stmtsep]\n                           [description-stmt stmtsep]\n                           [reference-stmt stmtsep]\n                        \"}\")",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "pattern-stmt        = pattern-keyword sep string optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [error-message-stmt stmtsep]\n                           [error-app-tag-stmt stmtsep]\n                           [description-stmt stmtsep]\n                           [reference-stmt stmtsep]\n                        \"}\")",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "default-stmt        = default-keyword sep string stmtend",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "enum-specification  = 1*(enum-stmt stmtsep)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "enum-stmt           = enum-keyword sep string optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [value-stmt stmtsep]\n                           [status-stmt stmtsep]\n                           [description-stmt stmtsep]\n                           [reference-stmt stmtsep]\n                        \"}\")",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "leafref-specification = ;; these stmts can appear in any order path-stmt stmtsep [require-instance-stmt stmtsep]",
      "zh-CHS": "leafref规范=；；这些stmt可以以任何顺序出现路径stmt STMTSP[需要实例stmt STMTSP]"
    },
    {
      "indent": 3,
      "text": "path-stmt           = path-keyword sep path-arg-str stmtend",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "require-instance-stmt = require-instance-keyword sep require-instance-arg-str stmtend",
      "zh-CHS": "require instance stmt=require instance关键字sep require instance arg str stmtend"
    },
    {
      "indent": 3,
      "text": "require-instance-arg-str = < a string that matches the rule\n                           require-instance-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "require-instance-arg = true-keyword / false-keyword",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "instance-identifier-specification = [require-instance-stmt stmtsep]",
      "zh-CHS": "实例标识符规范=[require instance stmt stmtsep]"
    },
    {
      "indent": 3,
      "text": "identityref-specification =\n                      base-stmt stmtsep",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "union-specification = 1*(type-stmt stmtsep)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "bits-specification  = 1*(bit-stmt stmtsep)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "bit-stmt            = bit-keyword sep identifier-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [position-stmt stmtsep]\n                           [status-stmt stmtsep]\n                           [description-stmt stmtsep]\n                           [reference-stmt stmtsep]\n                         \"}\"\n                       \"}\")",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "position-stmt = position-keyword sep position-value-arg-str stmtend",
      "zh-CHS": "position stmt=位置关键字sep位置值arg str stmtend"
    },
    {
      "indent": 3,
      "text": "position-value-arg-str = < a string that matches the rule\n                           position-value-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "position-value-arg  = non-negative-integer-value",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "status-stmt = status-keyword sep status-arg-str stmtend",
      "zh-CHS": "status stmt=状态关键字sep status arg str stmtend"
    },
    {
      "indent": 3,
      "text": "status-arg-str      = < a string that matches the rule\n                        status-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "status-arg = current-keyword / obsolete-keyword / deprecated-keyword",
      "zh-CHS": "状态参数=当前关键字/过时关键字/弃用关键字"
    },
    {
      "indent": 3,
      "text": "config-stmt = config-keyword sep config-arg-str stmtend",
      "zh-CHS": "config stmt=config关键字sep config arg str stmtend"
    },
    {
      "indent": 3,
      "text": "config-arg-str      = < a string that matches the rule\n                        config-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "config-arg          = true-keyword / false-keyword",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "mandatory-stmt = mandatory-keyword sep mandatory-arg-str stmtend",
      "zh-CHS": "mandatory stmt=强制关键字sep mandatory arg str stmtend"
    },
    {
      "indent": 3,
      "text": "mandatory-arg-str   = < a string that matches the rule\n                        mandatory-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "mandatory-arg       = true-keyword / false-keyword",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "presence-stmt       = presence-keyword sep string stmtend",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "ordered-by-stmt = ordered-by-keyword sep ordered-by-arg-str stmtend",
      "zh-CHS": "按stmt排序=按关键字sep排序按arg str stmtend排序"
    },
    {
      "indent": 3,
      "text": "ordered-by-arg-str  = < a string that matches the rule\n                        ordered-by-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "ordered-by-arg      = user-keyword / system-keyword",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "must-stmt           = must-keyword sep string optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [error-message-stmt stmtsep]\n                           [error-app-tag-stmt stmtsep]\n                           [description-stmt stmtsep]\n                           [reference-stmt stmtsep]\n                        \"}\")",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "error-message-stmt  = error-message-keyword sep string stmtend",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "error-app-tag-stmt  = error-app-tag-keyword sep string stmtend",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "min-elements-stmt = min-elements-keyword sep min-value-arg-str stmtend",
      "zh-CHS": "最小元素stmt=min元素关键字sep最小值arg str stmtend"
    },
    {
      "indent": 3,
      "text": "min-value-arg-str   = < a string that matches the rule\n                        min-value-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "min-value-arg       = non-negative-integer-value",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "max-elements-stmt = max-elements-keyword sep max-value-arg-str stmtend",
      "zh-CHS": "max elements stmt=max elements关键字sep max value arg str stmtend"
    },
    {
      "indent": 3,
      "text": "max-value-arg-str   = < a string that matches the rule\n                        max-value-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "max-value-arg = unbounded-keyword / positive-integer-value",
      "zh-CHS": "最大值arg=无界关键字/正整数值"
    },
    {
      "indent": 3,
      "text": "value-stmt          = value-keyword sep integer-value stmtend",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "grouping-stmt       = grouping-keyword sep identifier-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [status-stmt stmtsep]\n                           [description-stmt stmtsep]\n                           [reference-stmt stmtsep]\n                           *((typedef-stmt /\n                              grouping-stmt) stmtsep)\n                           *(data-def-stmt stmtsep)\n                       \"}\")",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "container-stmt      = container-keyword sep identifier-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [when-stmt stmtsep]\n                           *(if-feature-stmt stmtsep)\n                           *(must-stmt stmtsep)\n                           [presence-stmt stmtsep]\n                           [config-stmt stmtsep]\n                           [status-stmt stmtsep]\n                           [description-stmt stmtsep]\n                           [reference-stmt stmtsep]\n                           *((typedef-stmt /\n                              grouping-stmt) stmtsep)\n                           *(data-def-stmt stmtsep)\n                       \"}\")",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "leaf-stmt           = leaf-keyword sep identifier-arg-str optsep\n                      \"{\" stmtsep\n                          ;; these stmts can appear in any order\n                          [when-stmt stmtsep]\n                          *(if-feature-stmt stmtsep)\n                          type-stmt stmtsep\n                          [units-stmt stmtsep]\n                          *(must-stmt stmtsep)\n                          [default-stmt stmtsep]\n                          [config-stmt stmtsep]\n                          [mandatory-stmt stmtsep]\n                          [status-stmt stmtsep]\n                          [description-stmt stmtsep]\n                          [reference-stmt stmtsep]\n                       \"}\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "leaf-list-stmt      = leaf-list-keyword sep identifier-arg-str optsep\n                      \"{\" stmtsep\n                          ;; these stmts can appear in any order\n                          [when-stmt stmtsep]\n                          *(if-feature-stmt stmtsep)\n                          type-stmt stmtsep\n                          [units-stmt stmtsep]\n                          *(must-stmt stmtsep)\n                          [config-stmt stmtsep]\n                          [min-elements-stmt stmtsep]\n                          [max-elements-stmt stmtsep]\n                          [ordered-by-stmt stmtsep]\n                          [status-stmt stmtsep]\n                          [description-stmt stmtsep]\n                          [reference-stmt stmtsep]\n                       \"}\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "list-stmt           = list-keyword sep identifier-arg-str optsep\n                      \"{\" stmtsep\n                          ;; these stmts can appear in any order\n                          [when-stmt stmtsep]\n                          *(if-feature-stmt stmtsep)\n                          *(must-stmt stmtsep)\n                          [key-stmt stmtsep]\n                          *(unique-stmt stmtsep)\n                          [config-stmt stmtsep]\n                          [min-elements-stmt stmtsep]\n                          [max-elements-stmt stmtsep]\n                          [ordered-by-stmt stmtsep]\n                          [status-stmt stmtsep]\n                          [description-stmt stmtsep]\n                          [reference-stmt stmtsep]",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 26,
      "text": " *((typedef-stmt / grouping-stmt) stmtsep) 1*(data-def-stmt stmtsep) \"}\"",
      "zh-CHS": "*（（类型定义stmt/分组stmt）STMTSP）1*（数据定义stmt STMTSP）“}”"
    },
    {
      "indent": 3,
      "text": "key-stmt            = key-keyword sep key-arg-str stmtend",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "key-arg-str         = < a string that matches the rule\n                        key-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "key-arg = node-identifier *(sep node-identifier)",
      "zh-CHS": "key arg=节点标识符*（sep节点标识符）"
    },
    {
      "indent": 3,
      "text": "unique-stmt = unique-keyword sep unique-arg-str stmtend",
      "zh-CHS": "unique stmt=unique关键字sep unique arg str stmtend"
    },
    {
      "indent": 3,
      "text": "unique-arg-str      = < a string that matches the rule\n                        unique-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "unique-arg = descendant-schema-nodeid *(sep descendant-schema-nodeid)",
      "zh-CHS": "唯一arg=子代架构nodeid*（sep子代架构nodeid）"
    },
    {
      "indent": 3,
      "text": "choice-stmt         = choice-keyword sep identifier-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [when-stmt stmtsep]\n                           *(if-feature-stmt stmtsep)\n                           [default-stmt stmtsep]\n                           [config-stmt stmtsep]\n                           [mandatory-stmt stmtsep]\n                           [status-stmt stmtsep]\n                           [description-stmt stmtsep]\n                           [reference-stmt stmtsep]\n                           *((short-case-stmt / case-stmt) stmtsep)\n                       \"}\")",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "short-case-stmt = container-stmt / leaf-stmt / leaf-list-stmt / list-stmt / anyxml-stmt",
      "zh-CHS": "short case stmt=容器stmt/leaf stmt/leaf list stmt/list stmt/anyxml stmt"
    },
    {
      "indent": 3,
      "text": "case-stmt = case-keyword sep identifier-arg-str optsep (\";\" / \"{\" stmtsep ;; these stmts can appear in any order [when-stmt stmtsep] *(if-feature-stmt stmtsep) [status-stmt stmtsep]",
      "zh-CHS": "case stmt=case关键字sep标识符arg str optsep（“；”/“{”stmtsep；；这些stmt可以以任何顺序出现[当stmt stmtsep]*（如果功能stmtsep）[状态stmtsep]"
    },
    {
      "indent": 26,
      "text": " [description-stmt stmtsep] [reference-stmt stmtsep] *(data-def-stmt stmtsep) \"}\")",
      "zh-CHS": "[说明stmt STMTSP][参考stmt STMTSP]*（数据定义stmt STMTSP）“}”）"
    },
    {
      "indent": 3,
      "text": "anyxml-stmt         = anyxml-keyword sep identifier-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [when-stmt stmtsep]\n                           *(if-feature-stmt stmtsep)\n                           *(must-stmt stmtsep)\n                           [config-stmt stmtsep]\n                           [mandatory-stmt stmtsep]\n                           [status-stmt stmtsep]\n                           [description-stmt stmtsep]\n                           [reference-stmt stmtsep]\n                        \"}\")",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "uses-stmt           = uses-keyword sep identifier-ref-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [when-stmt stmtsep]\n                           *(if-feature-stmt stmtsep)\n                           [status-stmt stmtsep]\n                           [description-stmt stmtsep]\n                           [reference-stmt stmtsep]\n                           *(refine-stmt stmtsep)\n                           *(uses-augment-stmt stmtsep)\n                       \"}\")",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "refine-stmt = refine-keyword sep refine-arg-str optsep (\";\" / \"{\" stmtsep (refine-container-stmts / refine-leaf-stmts / refine-leaf-list-stmts / refine-list-stmts / refine-choice-stmts / refine-case-stmts / refine-anyxml-stmts) \"}\")",
      "zh-CHS": "refine stmt=refine关键字sep refine arg str optsep（“；”/“{”stmtsep（refine container stmts/refine leaf stmts/refine leaf list stmts/refine choice stmts/refine case stmts/refine anyxml stmts）”）"
    },
    {
      "indent": 3,
      "text": "refine-arg-str      = < a string that matches the rule\n                        refine-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "refine-arg          = descendant-schema-nodeid",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "refine-container-stmts =\n                      ;; these stmts can appear in any order\n                      *(must-stmt stmtsep)\n                      [presence-stmt stmtsep]\n                      [config-stmt stmtsep]\n                      [description-stmt stmtsep]\n                      [reference-stmt stmtsep]",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "refine-leaf-stmts   = ;; these stmts can appear in any order\n                      *(must-stmt stmtsep)\n                      [default-stmt stmtsep]\n                      [config-stmt stmtsep]\n                      [mandatory-stmt stmtsep]\n                      [description-stmt stmtsep]\n                      [reference-stmt stmtsep]",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "refine-leaf-list-stmts =\n                      ;; these stmts can appear in any order\n                      *(must-stmt stmtsep)\n                      [config-stmt stmtsep]\n                      [min-elements-stmt stmtsep]\n                      [max-elements-stmt stmtsep]\n                      [description-stmt stmtsep]\n                      [reference-stmt stmtsep]",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "refine-list-stmts   = ;; these stmts can appear in any order\n                      *(must-stmt stmtsep)\n                      [config-stmt stmtsep]\n                      [min-elements-stmt stmtsep]\n                      [max-elements-stmt stmtsep]\n                      [description-stmt stmtsep]\n                      [reference-stmt stmtsep]",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "refine-choice-stmts = ;; these stmts can appear in any order\n                      [default-stmt stmtsep]\n                      [config-stmt stmtsep]\n                      [mandatory-stmt stmtsep]\n                      [description-stmt stmtsep]\n                      [reference-stmt stmtsep]",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "refine-case-stmts = ;; these stmts can appear in any order [description-stmt stmtsep] [reference-stmt stmtsep]",
      "zh-CHS": "优化案例stmts=；；这些stmt可以以任何顺序出现[说明stmt STMTSP][参考stmt STMTSP]"
    },
    {
      "indent": 3,
      "text": "refine-anyxml-stmts = ;; these stmts can appear in any order *(must-stmt stmtsep) [config-stmt stmtsep]",
      "zh-CHS": "优化anyxml stmts=；；这些stmt可以以任何顺序出现*（必须是stmt STMTSP）[config stmt STMTSP]"
    },
    {
      "indent": 25,
      "text": "[mandatory-stmt stmtsep]\n[description-stmt stmtsep]\n[reference-stmt stmtsep]",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "uses-augment-stmt   = augment-keyword sep uses-augment-arg-str optsep\n                      \"{\" stmtsep\n                          ;; these stmts can appear in any order\n                          [when-stmt stmtsep]\n                          *(if-feature-stmt stmtsep)\n                          [status-stmt stmtsep]\n                          [description-stmt stmtsep]\n                          [reference-stmt stmtsep]\n                          1*((data-def-stmt stmtsep) /\n                             (case-stmt stmtsep))\n                       \"}\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "uses-augment-arg-str = < a string that matches the rule\n                         uses-augment-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "uses-augment-arg    = descendant-schema-nodeid",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "augment-stmt        = augment-keyword sep augment-arg-str optsep\n                      \"{\" stmtsep\n                          ;; these stmts can appear in any order\n                          [when-stmt stmtsep]\n                          *(if-feature-stmt stmtsep)\n                          [status-stmt stmtsep]\n                          [description-stmt stmtsep]\n                          [reference-stmt stmtsep]\n                          1*((data-def-stmt stmtsep) /\n                             (case-stmt stmtsep))\n                       \"}\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "augment-arg-str     = < a string that matches the rule\n                        augment-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "augment-arg         = absolute-schema-nodeid",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "unknown-statement   = prefix \":\" identifier [sep string] optsep\n                      (\";\" / \"{\" *unknown-statement2 \"}\")",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "unknown-statement2   = [prefix \":\"] identifier [sep string] optsep\n                      (\";\" / \"{\" *unknown-statement2 \"}\")",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "when-stmt           = when-keyword sep string optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 27,
      "text": " [description-stmt stmtsep] [reference-stmt stmtsep] \"}\")",
      "zh-CHS": "[说明stmt STMTSP][参考stmt STMTSP]“}”）"
    },
    {
      "indent": 3,
      "text": "rpc-stmt            = rpc-keyword sep identifier-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           *(if-feature-stmt stmtsep)\n                           [status-stmt stmtsep]\n                           [description-stmt stmtsep]\n                           [reference-stmt stmtsep]\n                           *((typedef-stmt /\n                              grouping-stmt) stmtsep)\n                           [input-stmt stmtsep]\n                           [output-stmt stmtsep]\n                       \"}\")",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "input-stmt          = input-keyword optsep\n                      \"{\" stmtsep\n                          ;; these stmts can appear in any order\n                          *((typedef-stmt /\n                             grouping-stmt) stmtsep)\n                          1*(data-def-stmt stmtsep)\n                      \"}\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "output-stmt         = output-keyword optsep\n                      \"{\" stmtsep\n                          ;; these stmts can appear in any order\n                          *((typedef-stmt /\n                             grouping-stmt) stmtsep)\n                          1*(data-def-stmt stmtsep)\n                      \"}\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "notification-stmt   = notification-keyword sep\n                      identifier-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           *(if-feature-stmt stmtsep)\n                           [status-stmt stmtsep]\n                           [description-stmt stmtsep]\n                           [reference-stmt stmtsep]\n                           *((typedef-stmt /\n                              grouping-stmt) stmtsep)\n                           *(data-def-stmt stmtsep)\n                       \"}\")",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "deviation-stmt = deviation-keyword sep deviation-arg-str optsep \"{\" stmtsep ;; these stmts can appear in any order [description-stmt stmtsep] [reference-stmt stmtsep] (deviate-not-supported-stmt / 1*(deviate-add-stmt / deviate-replace-stmt / deviate-delete-stmt)) \"}\"",
      "zh-CHS": "偏差stmt=偏差关键字sep DEVISION arg str optsep“{”STMTSP；；这些stmt可以以任何顺序出现[说明stmt STMTSP][参考stmt STMTSP]（不支持偏差stmt/1*（偏差添加stmt/偏差替换stmt/偏差删除stmt））“}”"
    },
    {
      "indent": 3,
      "text": "deviation-arg-str   = < a string that matches the rule\n                        deviation-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "deviation-arg       = absolute-schema-nodeid",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "deviate-not-supported-stmt = deviate-keyword sep not-supported-keyword optsep (\";\" / \"{\" stmtsep \"}\")",
      "zh-CHS": "偏离不受支持的stmt=偏离关键字sep不受支持的关键字optsep（“；”/“{”STMTSP“}”）"
    },
    {
      "indent": 3,
      "text": "deviate-add-stmt    = deviate-keyword sep add-keyword optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           [units-stmt stmtsep]\n                           *(must-stmt stmtsep)\n                           *(unique-stmt stmtsep)\n                           [default-stmt stmtsep]\n                           [config-stmt stmtsep]\n                           [mandatory-stmt stmtsep]\n                           [min-elements-stmt stmtsep]\n                           [max-elements-stmt stmtsep]\n                       \"}\")",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "deviate-delete-stmt = deviate-keyword sep delete-keyword optsep (\";\" / \"{\" stmtsep [units-stmt stmtsep] *(must-stmt stmtsep) *(unique-stmt stmtsep) [default-stmt stmtsep] \"}\")",
      "zh-CHS": "DELEVEL delete stmt=DELEVEL关键字sep delete关键字optsep（“；”/“{”STMTSP[单位stmt STMTSP]*（必须是stmt STMTSP）*（唯一stmt STMTSP）[默认stmt STMTSP]“}”）"
    },
    {
      "indent": 3,
      "text": "deviate-replace-stmt = deviate-keyword sep replace-keyword optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           [type-stmt stmtsep]\n                           [units-stmt stmtsep]\n                           [default-stmt stmtsep]\n                           [config-stmt stmtsep]\n                           [mandatory-stmt stmtsep]\n                           [min-elements-stmt stmtsep]\n                           [max-elements-stmt stmtsep]\n                       \"}\")",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": ";; Ranges",
      "zh-CHS": ";; 范围"
    },
    {
      "indent": 3,
      "text": "range-arg-str       = < a string that matches the rule\n                        range-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "range-arg = range-part *(optsep \"|\" optsep range-part)",
      "zh-CHS": "范围参数=范围部分*（optsep“|”optsep范围部分）"
    },
    {
      "indent": 3,
      "text": "range-part = range-boundary [optsep \"..\" optsep range-boundary]",
      "zh-CHS": "范围部分=范围边界[optsep”。“optsep范围边界]"
    },
    {
      "indent": 3,
      "text": "range-boundary      = min-keyword / max-keyword /\n                      integer-value / decimal-value",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": ";; Lengths",
      "zh-CHS": ";; 长度"
    },
    {
      "indent": 3,
      "text": "length-arg-str      = < a string that matches the rule\n                        length-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "length-arg = length-part *(optsep \"|\" optsep length-part)",
      "zh-CHS": "长度arg=长度部分*（optsep“|”optsep长度部分）"
    },
    {
      "indent": 3,
      "text": "length-part = length-boundary [optsep \"..\" optsep length-boundary]",
      "zh-CHS": "长度部分=长度边界[optsep”。“optsep长度边界]"
    },
    {
      "indent": 3,
      "text": "length-boundary = min-keyword / max-keyword / non-negative-integer-value",
      "zh-CHS": "长度边界=最小关键字/最大关键字/非负整数值"
    },
    {
      "indent": 3,
      "text": ";; Date",
      "zh-CHS": ";; 日期"
    },
    {
      "indent": 3,
      "text": "date-arg-str        = < a string that matches the rule\n                        date-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "date-arg = 4DIGIT \"-\" 2DIGIT \"-\" 2DIGIT",
      "zh-CHS": "日期arg=4DIGIT“-”2DIGIT“-”2DIGIT"
    },
    {
      "indent": 3,
      "text": ";; Schema Node Identifiers",
      "zh-CHS": ";; 模式节点标识符"
    },
    {
      "indent": 3,
      "text": "schema-nodeid = absolute-schema-nodeid / descendant-schema-nodeid",
      "zh-CHS": "schema nodeid=绝对模式nodeid/后代模式nodeid"
    },
    {
      "indent": 3,
      "text": "absolute-schema-nodeid = 1*(\"/\" node-identifier)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "descendant-schema-nodeid = node-identifier absolute-schema-nodeid",
      "zh-CHS": "子代架构nodeid=节点标识符绝对架构nodeid"
    },
    {
      "indent": 3,
      "text": "node-identifier     = [prefix \":\"] identifier",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": ";; Instance Identifiers",
      "zh-CHS": ";; 实例标识符"
    },
    {
      "indent": 3,
      "text": "instance-identifier = 1*(\"/\" (node-identifier *predicate))",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "predicate           = \"[\" *WSP (predicate-expr / pos) *WSP \"]\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "predicate-expr      = (node-identifier / \".\") *WSP \"=\" *WSP\n                      ((DQUOTE string DQUOTE) /\n                       (SQUOTE string SQUOTE))",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "pos                 = non-negative-integer-value",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": ";; leafref path",
      "zh-CHS": ";; 叶参考路径"
    },
    {
      "indent": 3,
      "text": "path-arg-str        = < a string that matches the rule\n                        path-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "path-arg            = absolute-path / relative-path",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "absolute-path       = 1*(\"/\" (node-identifier *path-predicate))",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "relative-path       = 1*(\"..\" \"/\") descendant-path",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "descendant-path = node-identifier [*path-predicate absolute-path]",
      "zh-CHS": "子体路径=节点标识符[*路径谓词绝对路径]"
    },
    {
      "indent": 3,
      "text": "path-predicate      = \"[\" *WSP path-equality-expr *WSP \"]\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "path-equality-expr  = node-identifier *WSP \"=\" *WSP path-key-expr",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "path-key-expr       = current-function-invocation *WSP \"/\" *WSP\n                      rel-path-keyexpr",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "rel-path-keyexpr    = 1*(\"..\" *WSP \"/\" *WSP)\n                      *(node-identifier *WSP \"/\" *WSP)\n                      node-identifier",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": ";;; Keywords, using abnfgen's syntax for case-sensitive strings",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": ";; statement keywords anyxml-keyword = 'anyxml' argument-keyword = 'argument' augment-keyword = 'augment' base-keyword = 'base' belongs-to-keyword = 'belongs-to' bit-keyword = 'bit' case-keyword = 'case' choice-keyword = 'choice' config-keyword = 'config' contact-keyword = 'contact' container-keyword = 'container' default-keyword = 'default' description-keyword = 'description' enum-keyword = 'enum' error-app-tag-keyword = 'error-app-tag' error-message-keyword = 'error-message' extension-keyword = 'extension' deviation-keyword = 'deviation' deviate-keyword = 'deviate' feature-keyword = 'feature' fraction-digits-keyword = 'fraction-digits' grouping-keyword = 'grouping' identity-keyword = 'identity' if-feature-keyword = 'if-feature' import-keyword = 'import' include-keyword = 'include' input-keyword = 'input' key-keyword = 'key' leaf-keyword = 'leaf' leaf-list-keyword = 'leaf-list' length-keyword = 'length' list-keyword = 'list' mandatory-keyword = 'mandatory' max-elements-keyword = 'max-elements' min-elements-keyword = 'min-elements' module-keyword = 'module' must-keyword = 'must' namespace-keyword = 'namespace' notification-keyword= 'notification' ordered-by-keyword = 'ordered-by' organization-keyword= 'organization'",
      "zh-CHS": ";; 语句关键字anyxml关键字='anyxml'参数关键字='argument'augment关键字='augment'base关键字='base'属于关键字='属于'bit关键字='bit'case关键字='case'选择关键字='choice'配置关键字='config'联系人关键字='contact'容器关键字='container'默认关键字='default'description关键字='description'enum关键字='enum'error-app-tag关键字='error-app-tag'错误消息关键字='error-message'扩展关键字='extension'偏差关键字='develope'偏差关键字='develope'特征关键字='feature'分数数字关键字='分数数字'分组关键字='grouping'标识关键字='identity'if feature keyword='if feature'导入关键字='import'include关键字='include'输入关键字='key'叶关键字='leaf'叶列表关键字='leaf'长度关键字='length'列表关键字='list'强制关键字='mandable'max elements关键字='max elements'min elements关键字=“最小元素”模块关键字=“模块”必须关键字=“必须”命名空间关键字=“命名空间”通知关键字=“通知”按关键字排序=“按组织关键字排序=“组织”"
    },
    {
      "indent": 3,
      "text": "output-keyword = 'output' path-keyword = 'path' pattern-keyword = 'pattern' position-keyword = 'position' prefix-keyword = 'prefix' presence-keyword = 'presence' range-keyword = 'range' reference-keyword = 'reference' refine-keyword = 'refine' require-instance-keyword = 'require-instance' revision-keyword = 'revision' revision-date-keyword = 'revision-date' rpc-keyword = 'rpc' status-keyword = 'status' submodule-keyword = 'submodule' type-keyword = 'type' typedef-keyword = 'typedef' unique-keyword = 'unique' units-keyword = 'units' uses-keyword = 'uses' value-keyword = 'value' when-keyword = 'when' yang-version-keyword= 'yang-version' yin-element-keyword = 'yin-element'",
      "zh-CHS": "输出关键字='output'path关键字='path'pattern关键字='pattern'position关键字='position'前缀关键字='prefix'presence关键字='presence'范围关键字='range'引用关键字='reference'优化关键字='reference'require实例关键字='require实例'修订关键字='revision'修订日期关键字=“修订日期”rpc关键字=“rpc”状态关键字=“状态”子模块关键字=“子模块”类型关键字=“类型”类型定义关键字=“类型定义”唯一关键字=“唯一”单位关键字=“单位”使用关键字=“使用”值关键字=“值”当关键字=“阳版关键字=“阳版”阴元素关键字=“阴元素”"
    },
    {
      "indent": 3,
      "text": ";; other keywords",
      "zh-CHS": ";; 其他关键字"
    },
    {
      "indent": 3,
      "text": "add-keyword = 'add' current-keyword = 'current' delete-keyword = 'delete' deprecated-keyword = 'deprecated' false-keyword = 'false' max-keyword = 'max' min-keyword = 'min' not-supported-keyword = 'not-supported' obsolete-keyword = 'obsolete' replace-keyword = 'replace' system-keyword = 'system' true-keyword = 'true' unbounded-keyword = 'unbounded' user-keyword = 'user'",
      "zh-CHS": "add关键字='add'current关键字='current'删除关键字='delete'弃用关键字='Disprecated'假关键字='false'最大关键字='max'最小关键字='min'不受支持关键字='not supported'过时关键字='Observed'替换关键字='replace'系统关键字='system'true关键字='true'无界关键字='unbounded'用户关键字='user'"
    },
    {
      "indent": 3,
      "text": "current-function-invocation = current-keyword *WSP \"(\" *WSP \")\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": ";; Basic Rules",
      "zh-CHS": ";; 基本规则"
    },
    {
      "indent": 3,
      "text": "prefix-arg-str      = < a string that matches the rule\n                        prefix-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "prefix-arg          = prefix",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "prefix              = identifier",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "identifier-arg-str  = < a string that matches the rule\n                        identifier-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "identifier-arg      = identifier",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": ";; An identifier MUST NOT start with (('X'|'x') ('M'|'m') ('L'|'l'))\nidentifier          = (ALPHA / \"_\")\n                      *(ALPHA / DIGIT / \"_\" / \"-\" / \".\")",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "identifier-ref-arg-str = < a string that matches the rule\n                        identifier-ref-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "identifier-ref-arg  = [prefix \":\"] identifier",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "string              = < an unquoted string as returned by\n                        the scanner >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "integer-value       = (\"-\" non-negative-integer-value)  /\n                       non-negative-integer-value",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "non-negative-integer-value = \"0\" / positive-integer-value",
      "zh-CHS": "非负整数值=“0”/正整数值"
    },
    {
      "indent": 3,
      "text": "positive-integer-value = (non-zero-digit *DIGIT)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "zero-integer-value  = 1*DIGIT",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "stmtend             = \";\" / \"{\" *unknown-statement \"}\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "sep                 = 1*(WSP / line-break)\n                      ; unconditional separator",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "optsep              = *(WSP / line-break)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "stmtsep             = *(WSP / line-break / unknown-statement)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "line-break          = CRLF / LF",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "non-zero-digit      = %x31-39",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "decimal-value = integer-value (\".\" zero-integer-value)",
      "zh-CHS": "十进制值=整数值（“.”零整数值）"
    },
    {
      "indent": 3,
      "text": "SQUOTE              = %x27\n                      ; ' (Single Quote)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": ";;\n;; RFC 5234 core rules.\n;;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "ALPHA               = %x41-5A / %x61-7A\n                      ; A-Z / a-z",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "CR                  = %x0D\n                      ; carriage return",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "CRLF = CR LF ; Internet standard new line",
      "zh-CHS": "CRLF=CRLF；互联网标准新线"
    },
    {
      "indent": 3,
      "text": "DIGIT               = %x30-39\n                      ; 0-9",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "DQUOTE              = %x22\n                      ; \" (Double Quote)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "HEXDIG              = DIGIT /\n                      %x61 / %x62 / %x63 / %x64 / %x65 / %x66\n                      ; only lower-case a..f",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "HTAB                = %x09\n                      ; horizontal tab",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "LF                  = %x0A\n                      ; linefeed",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "SP                  = %x20\n                      ; space",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "VCHAR               = %x21-7E\n                      ; visible (printing) characters",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "WSP = SP / HTAB ; whitespace",
      "zh-CHS": "WSP=SP/HTAB；空白"
    },
    {
      "indent": 3,
      "text": "<CODE ENDS>",
      "zh-CHS": "<代码结束>"
    },
    {
      "indent": 0,
      "text": "13. Error Responses for YANG Related Errors",
      "section_title": true,
      "zh-CHS": "13. 与YANG相关错误的错误响应"
    },
    {
      "indent": 3,
      "text": "A number of NETCONF error responses are defined for error cases related to the data-model handling. If the relevant YANG statement has an \"error-app-tag\" substatement, that overrides the default value specified below.",
      "zh-CHS": "为与数据模型处理相关的错误案例定义了许多NETCONF错误响应。如果相关语句具有“error-app-tag”子语句，则会覆盖下面指定的默认值。"
    },
    {
      "indent": 0,
      "text": "13.1. Error Message for Data That Violates a unique Statement",
      "section_title": true,
      "zh-CHS": "13.1. 违反唯一语句的数据的错误消息"
    },
    {
      "indent": 3,
      "text": "If a NETCONF operation would result in configuration data where a unique constraint is invalidated, the following error is returned:",
      "zh-CHS": "如果NETCONF操作将导致唯一约束失效的配置数据，则返回以下错误："
    },
    {
      "indent": 5,
      "text": "error-tag: operation-failed error-app-tag: data-not-unique error-info: <non-unique>: Contains an instance identifier that points to a leaf that invalidates the unique constraint. This element is present once for each non-unique leaf.",
      "zh-CHS": "错误标记：操作失败错误应用程序标记：数据不唯一错误信息：<non-unique>：包含指向使唯一约束无效的叶的实例标识符。对于每个非唯一叶，此元素存在一次。"
    },
    {
      "indent": 21,
      "text": "The <non-unique> element is in the YANG namespace (\"urn:ietf:params:xml:ns:yang:1\").",
      "zh-CHS": "<non-unique>元素位于YANG名称空间（“urn:ietf:params:xml:ns:YANG:1”）中。"
    },
    {
      "indent": 0,
      "text": "13.2. Error Message for Data That Violates a max-elements Statement",
      "section_title": true,
      "zh-CHS": "13.2. 违反max elements语句的数据的错误消息"
    },
    {
      "indent": 3,
      "text": "If a NETCONF operation would result in configuration data where a list or a leaf-list would have too many entries the following error is returned:",
      "zh-CHS": "如果NETCONF操作将导致配置数据，其中列表或叶列表的条目过多，则返回以下错误："
    },
    {
      "indent": 5,
      "text": "error-tag: operation-failed error-app-tag: too-many-elements",
      "zh-CHS": "错误标记：操作失败错误应用标记：元素太多"
    },
    {
      "indent": 3,
      "text": "This error is returned once, with the error-path identifying the list node, even if there are more than one extra child present.",
      "zh-CHS": "此错误返回一次，错误路径标识列表节点，即使存在多个子节点。"
    },
    {
      "indent": 0,
      "text": "13.3. Error Message for Data That Violates a min-elements Statement",
      "section_title": true,
      "zh-CHS": "13.3. 违反min elements语句的数据的错误消息"
    },
    {
      "indent": 3,
      "text": "If a NETCONF operation would result in configuration data where a list or a leaf-list would have too few entries the following error is returned:",
      "zh-CHS": "如果NETCONF操作将导致配置数据，其中列表或叶列表的条目太少，则返回以下错误："
    },
    {
      "indent": 5,
      "text": "error-tag: operation-failed error-app-tag: too-few-elements",
      "zh-CHS": "错误标记：操作失败错误应用标记：元素太少"
    },
    {
      "indent": 3,
      "text": "This error is returned once, with the error-path identifying the list node, even if there are more than one child missing.",
      "zh-CHS": "此错误返回一次，错误路径标识列表节点，即使缺少多个子节点也是如此。"
    },
    {
      "indent": 0,
      "text": "13.4. Error Message for Data That Violates a must Statement",
      "section_title": true,
      "zh-CHS": "13.4. 违反must语句的数据的错误消息"
    },
    {
      "indent": 3,
      "text": "If a NETCONF operation would result in configuration data where the restrictions imposed by a \"must\" statement is violated the following error is returned, unless a specific \"error-app-tag\" substatement is present for the \"must\" statement.",
      "zh-CHS": "如果NETCONF操作将导致配置数据违反“必须”语句施加的限制，则返回以下错误，除非“必须”语句存在特定的“错误应用程序标记”子语句。"
    },
    {
      "indent": 5,
      "text": "error-tag: operation-failed error-app-tag: must-violation",
      "zh-CHS": "错误标记：操作失败错误应用标记：必须违反"
    },
    {
      "indent": 0,
      "text": "13.5. Error Message for Data That Violates a require-instance Statement",
      "section_title": true,
      "zh-CHS": "13.5. 违反require instance语句的数据的错误消息"
    },
    {
      "indent": 3,
      "text": "If a NETCONF operation would result in configuration data where a leaf of type \"instance-identifier\" marked with require-instance \"true\" refers to a non-existing instance, the following error is returned:",
      "zh-CHS": "如果NETCONF操作将导致配置数据中带有require instance“true”标记的“instance identifier”类型的叶引用不存在的实例，则返回以下错误："
    },
    {
      "indent": 5,
      "text": "error-tag: data-missing error-app-tag: instance-required error-path: Path to the instance-identifier leaf.",
      "zh-CHS": "错误标记：数据丢失错误应用标记：实例所需错误路径：实例标识符叶的路径。"
    },
    {
      "indent": 0,
      "text": "13.6. Error Message for Data That Does Not Match a leafref Type",
      "section_title": true,
      "zh-CHS": "13.6. 与leafref类型不匹配的数据的错误消息"
    },
    {
      "indent": 3,
      "text": "If a NETCONF operation would result in configuration data where a leaf of type \"leafref\" refers to a non-existing instance, the following error is returned:",
      "zh-CHS": "如果NETCONF操作将导致配置数据，其中类型为“leafref”的叶引用不存在的实例，则返回以下错误："
    },
    {
      "indent": 5,
      "text": "error-tag: data-missing error-app-tag: instance-required error-path: Path to the leafref leaf.",
      "zh-CHS": "错误标记：数据丢失错误应用程序标记：实例所需错误路径：指向leafref叶的路径。"
    },
    {
      "indent": 0,
      "text": "13.7. Error Message for Data That Violates a mandatory choice Statement",
      "section_title": true,
      "zh-CHS": "13.7. 违反强制选择语句的数据的错误消息"
    },
    {
      "indent": 3,
      "text": "If a NETCONF operation would result in configuration data where no nodes exists in a mandatory choice, the following error is returned:",
      "zh-CHS": "如果NETCONF操作将导致配置数据中不存在强制选项中的节点，则返回以下错误："
    },
    {
      "indent": 5,
      "text": "error-tag: data-missing error-app-tag: missing-choice error-path: Path to the element with the missing choice. error-info: <missing-choice>: Contains the name of the missing mandatory choice.",
      "zh-CHS": "错误标记：数据丢失错误应用程序标记：缺少选项错误路径：缺少选项的元素的路径。错误信息：<missing choice>：包含缺少的强制选项的名称。"
    },
    {
      "indent": 21,
      "text": "The <missing-choice> element is in the YANG namespace (\"urn:ietf:params:xml:ns:yang:1\").",
      "zh-CHS": "<missing choice>元素位于YANG名称空间（“urn:ietf:params:xml:ns:YANG:1”）中。"
    },
    {
      "indent": 0,
      "text": "13.8. Error Message for the \"insert\" Operation",
      "section_title": true,
      "zh-CHS": "13.8. “插入”操作的错误消息"
    },
    {
      "indent": 3,
      "text": "If the \"insert\" and \"key\" or \"value\" attributes are used in an <edit-config> for a list or leaf-list node, and the \"key\" or \"value\" refers to a non-existing instance, the following error is returned:",
      "zh-CHS": "如果在列表或叶列表节点的<edit config>中使用了“insert”和“key”或“value”属性，并且“key”或“value”指的是不存在的实例，则返回以下错误："
    },
    {
      "indent": 5,
      "text": "error-tag: bad-attribute error-app-tag: missing-instance",
      "zh-CHS": "错误标记：错误属性错误应用标记：缺少实例"
    },
    {
      "indent": 0,
      "text": "14. IANA Considerations",
      "section_title": true,
      "zh-CHS": "14. IANA考虑"
    },
    {
      "indent": 3,
      "text": "This document defines a registry for YANG module and submodule names. The name of the registry is \"YANG Module Names\".",
      "zh-CHS": "本文档定义了模块和子模块名称的注册表。注册表的名称为“模块名称”。"
    },
    {
      "indent": 3,
      "text": "The registry shall record for each entry:",
      "zh-CHS": "登记处应记录每个条目："
    },
    {
      "indent": 3,
      "text": "o the name of the module or submodule",
      "zh-CHS": "o 模块或子模块的名称"
    },
    {
      "indent": 3,
      "text": "o for modules, the assigned XML namespace",
      "zh-CHS": "o 对于模块，指定的XML名称空间"
    },
    {
      "indent": 3,
      "text": "o for modules, the prefix of the module",
      "zh-CHS": "o 对于模块，为模块的前缀"
    },
    {
      "indent": 3,
      "text": "o for submodules, the name of the module it belongs to",
      "zh-CHS": "o 对于子模块，它所属模块的名称"
    },
    {
      "indent": 3,
      "text": "o a reference to the (sub)module's documentation (e.g., the RFC number)",
      "zh-CHS": "o （子）模块文件的参考（如RFC编号）"
    },
    {
      "indent": 3,
      "text": "There are no initial assignments.",
      "zh-CHS": "没有初始任务。"
    },
    {
      "indent": 3,
      "text": "For allocation, RFC publication is required as per RFC 5226 [RFC5226]. All registered YANG module names MUST comply with the rules for identifiers stated in Section 6.2, and MUST have a module name prefix.",
      "zh-CHS": "按照RFC 5226[RFC5226]的规定，分配时需要发布RFC。所有注册模块名称必须符合第6.2节中规定的标识符规则，并且必须具有模块名称前缀。"
    },
    {
      "indent": 3,
      "text": "The module name prefix 'ietf-' is reserved for IETF stream documents [RFC4844], while the module name prefix 'irtf-' is reserved for IRTF stream documents. Modules published in other RFC streams MUST have a similar suitable prefix.",
      "zh-CHS": "模块名称前缀“ietf-”保留给ietf流文档[RFC4844]，而模块名称前缀“irtf-”保留给irtf流文档。在其他RFC流中发布的模块必须具有类似的合适前缀。"
    },
    {
      "indent": 3,
      "text": "All module and submodule names in the registry MUST be unique.",
      "zh-CHS": "注册表中的所有模块和子模块名称必须唯一。"
    },
    {
      "indent": 3,
      "text": "All XML namespaces in the registry MUST be unique.",
      "zh-CHS": "注册表中的所有XML命名空间都必须是唯一的。"
    },
    {
      "indent": 3,
      "text": "This document registers two URIs for the YANG and YIN XML namespaces in the IETF XML registry [RFC3688]. Following the format in RFC 3688, the following have been registered.",
      "zh-CHS": "本文档在IETF XML注册表[RFC3688]中为阳和阴XML名称空间注册了两个URI。按照RFC 3688中的格式，注册了以下文件。"
    },
    {
      "indent": 5,
      "text": "URI: urn:ietf:params:xml:ns:yang:yin:1",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "URI: urn:ietf:params:xml:ns:yang:1",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "Registrant Contact: The IESG.",
      "zh-CHS": "注册人联系人：IESG。"
    },
    {
      "indent": 5,
      "text": "XML: N/A, the requested URIs are XML namespaces.",
      "zh-CHS": "XML：不适用，请求的URI是XML名称空间。"
    },
    {
      "indent": 3,
      "text": "This document registers two new media types as defined in the following sections.",
      "zh-CHS": "本文档注册了两种新的媒体类型，如下节所述。"
    },
    {
      "indent": 0,
      "text": "14.1. Media type application/yang",
      "section_title": true,
      "zh-CHS": "14.1. 媒体类型应用程序/yang"
    },
    {
      "indent": 2,
      "text": "MIME media type name: application",
      "zh-CHS": "MIME媒体类型名称：应用程序"
    },
    {
      "indent": 2,
      "text": "MIME subtype name: yang",
      "zh-CHS": "MIME子类型名称：yang"
    },
    {
      "indent": 2,
      "text": "Mandatory parameters: none",
      "zh-CHS": "强制参数：无"
    },
    {
      "indent": 2,
      "text": "Optional parameters: none",
      "zh-CHS": "可选参数：无"
    },
    {
      "indent": 2,
      "text": "Encoding considerations: 8-bit",
      "zh-CHS": "编码注意事项：8位"
    },
    {
      "indent": 2,
      "text": "Security considerations: See Section 15 in RFC 6020",
      "zh-CHS": "安全注意事项：见RFC 6020第15节"
    },
    {
      "indent": 2,
      "text": "Interoperability considerations: None",
      "zh-CHS": "互操作性注意事项：无"
    },
    {
      "indent": 2,
      "text": "Published specification: RFC 6020",
      "zh-CHS": "已发布规范：RFC 6020"
    },
    {
      "indent": 2,
      "text": "Applications that use this media type:",
      "zh-CHS": "使用此媒体类型的应用程序："
    },
    {
      "indent": 4,
      "text": "YANG module validators, web servers used for downloading YANG modules, email clients, etc.",
      "zh-CHS": "YANG模块验证程序、用于下载YANG模块的web服务器、电子邮件客户端等。"
    },
    {
      "indent": 2,
      "text": "Additional information:",
      "zh-CHS": "其他信息："
    },
    {
      "indent": 5,
      "text": "Magic Number: None",
      "zh-CHS": "神奇数字：无"
    },
    {
      "indent": 5,
      "text": "File Extension: .yang",
      "zh-CHS": "文件扩展名：.yang"
    },
    {
      "indent": 5,
      "text": "Macintosh file type code: 'TEXT'",
      "zh-CHS": "Macintosh文件类型代码：“文本”"
    },
    {
      "indent": 2,
      "text": "Personal and email address for further information:\n   Martin Bjorklund <mbj@tail-f.com>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "Intended usage: COMMON",
      "zh-CHS": "预期用途：普通"
    },
    {
      "indent": 2,
      "text": "Author: This specification is a work item of the IETF NETMOD working group, with mailing list address <netmod@ietf.org>.",
      "zh-CHS": "作者：本规范是IETF NETMOD工作组的工作项，具有邮件列表地址<netmod@ietf.org>."
    },
    {
      "indent": 2,
      "text": "Change controller:\n   The IESG <iesg@ietf.org>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "14.2. Media type application/yin+xml",
      "section_title": true,
      "zh-CHS": "14.2. 媒体类型应用程序/yin+xml"
    },
    {
      "indent": 2,
      "text": "MIME media type name: application",
      "zh-CHS": "MIME媒体类型名称：应用程序"
    },
    {
      "indent": 2,
      "text": "MIME subtype name: yin+xml",
      "zh-CHS": "MIME子类型名称：yin+xml"
    },
    {
      "indent": 2,
      "text": "Mandatory parameters: none",
      "zh-CHS": "强制参数：无"
    },
    {
      "indent": 2,
      "text": "Optional parameters:",
      "zh-CHS": "可选参数："
    },
    {
      "indent": 5,
      "text": "\"charset\": This parameter has identical semantics to the charset parameter of the \"application/xml\" media type as specified in [RFC3023].",
      "zh-CHS": "“charset”：此参数与[RFC3023]中指定的“application/xml”媒体类型的charset参数具有相同的语义。"
    },
    {
      "indent": 2,
      "text": "Encoding considerations:",
      "zh-CHS": "编码注意事项："
    },
    {
      "indent": 5,
      "text": "Identical to those of \"application/xml\" as described in [RFC3023], Section 3.2.",
      "zh-CHS": "与[RFC3023]第3.2节所述的“应用程序/xml”相同。"
    },
    {
      "indent": 2,
      "text": "Security considerations: See Section 15 in RFC 6020",
      "zh-CHS": "安全注意事项：见RFC 6020第15节"
    },
    {
      "indent": 2,
      "text": "Interoperability considerations: None",
      "zh-CHS": "互操作性注意事项：无"
    },
    {
      "indent": 2,
      "text": "Published specification: RFC 6020",
      "zh-CHS": "已发布规范：RFC 6020"
    },
    {
      "indent": 2,
      "text": "Applications that use this media type:",
      "zh-CHS": "使用此媒体类型的应用程序："
    },
    {
      "indent": 4,
      "text": "YANG module validators, web servers used for downloading YANG modules, email clients, etc.",
      "zh-CHS": "YANG模块验证程序、用于下载YANG模块的web服务器、电子邮件客户端等。"
    },
    {
      "indent": 2,
      "text": "Additional information:",
      "zh-CHS": "其他信息："
    },
    {
      "indent": 5,
      "text": "Magic Number: As specified for \"application/xml\" in [RFC3023], Section 3.2.",
      "zh-CHS": "幻数：如[RFC3023]第3.2节中“应用程序/xml”所述。"
    },
    {
      "indent": 5,
      "text": "File Extension: .yin",
      "zh-CHS": "文件扩展名：.yin"
    },
    {
      "indent": 5,
      "text": "Macintosh file type code: 'TEXT'",
      "zh-CHS": "Macintosh文件类型代码：“文本”"
    },
    {
      "indent": 2,
      "text": "Personal and email address for further information:\n   Martin Bjorklund <mbj@tail-f.com>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "Intended usage: COMMON",
      "zh-CHS": "预期用途：普通"
    },
    {
      "indent": 2,
      "text": "Author: This specification is a work item of the IETF NETMOD working group, with mailing list address <netmod@ietf.org>.",
      "zh-CHS": "作者：本规范是IETF NETMOD工作组的工作项，具有邮件列表地址<netmod@ietf.org>."
    },
    {
      "indent": 2,
      "text": "Change controller:\n   The IESG <iesg@ietf.org>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "15. Security Considerations",
      "section_title": true,
      "zh-CHS": "15. 安全考虑"
    },
    {
      "indent": 3,
      "text": "This document defines a language with which to write and read descriptions of management information. The language itself has no security impact on the Internet.",
      "zh-CHS": "本文档定义了一种用于编写和读取管理信息描述的语言。这种语言本身对互联网没有安全影响。"
    },
    {
      "indent": 3,
      "text": "The same considerations are relevant as for the base NETCONF protocol (see [RFC4741], Section 9).",
      "zh-CHS": "与基本NETCONF协议相关的注意事项相同（参见[RFC4741]，第9节）。"
    },
    {
      "indent": 3,
      "text": "Data modeled in YANG might contain sensitive information. RPCs or notifications defined in YANG might transfer sensitive information.",
      "zh-CHS": "在YANG中建模的数据可能包含敏感信息。中定义的RPC或通知可能会传输敏感信息。"
    },
    {
      "indent": 3,
      "text": "Security issues are related to the usage of data modeled in YANG. Such issues shall be dealt with in documents describing the data models and documents about the interfaces used to manipulate the data e.g., the NETCONF documents.",
      "zh-CHS": "安全问题与YANG中建模的数据的使用有关。此类问题应在描述数据模型的文件和用于操作数据的接口文件（如NETCONF文件）中处理。"
    },
    {
      "indent": 3,
      "text": "Data modeled in YANG is dependent upon:",
      "zh-CHS": "在YANG中建模的数据取决于："
    },
    {
      "indent": 3,
      "text": "o the security of the transmission infrastructure used to send sensitive information.",
      "zh-CHS": "o 用于发送敏感信息的传输基础设施的安全性。"
    },
    {
      "indent": 3,
      "text": "o the security of applications that store or release such sensitive information.",
      "zh-CHS": "o 存储或发布此类敏感信息的应用程序的安全性。"
    },
    {
      "indent": 3,
      "text": "o adequate authentication and access control mechanisms to restrict the usage of sensitive data.",
      "zh-CHS": "o 充分的身份验证和访问控制机制，以限制敏感数据的使用。"
    },
    {
      "indent": 3,
      "text": "YANG parsers need to be robust with respect to malformed documents. Reading malformed documents from unknown or untrusted sources could result in an attacker gaining privileges of the user running the YANG parser. In an extreme situation, the entire machine could be compromised.",
      "zh-CHS": "YANG解析器需要对格式错误的文档具有健壮性。从未知或不受信任的来源读取格式错误的文档可能会导致攻击者获得运行语法分析器的用户的权限。在极端情况下，整个机器可能受到威胁。"
    },
    {
      "indent": 0,
      "text": "16. Contributors",
      "section_title": true,
      "zh-CHS": "16. 贡献者"
    },
    {
      "indent": 3,
      "text": "The following people all contributed significantly to the initial YANG document:",
      "zh-CHS": "以下人员都对最初的YANG文件做出了重大贡献："
    },
    {
      "indent": 4,
      "text": "- Andy Bierman (Brocade) - Balazs Lengyel (Ericsson) - David Partain (Ericsson) - Juergen Schoenwaelder (Jacobs University Bremen) - Phil Shafer (Juniper Networks)",
      "zh-CHS": "- Andy Bierman（Brocade）-Balazs Lengyel（爱立信）-David Partain（爱立信）-Juergen Schoenwaeld（不来梅雅各布大学）-Phil Shafer（Juniper Networks）"
    },
    {
      "indent": 0,
      "text": "17. Acknowledgements",
      "section_title": true,
      "zh-CHS": "17. 致谢"
    },
    {
      "indent": 3,
      "text": "The editor wishes to thank the following individuals, who all provided helpful comments on various versions of this document: Mehmet Ersue, Washam Fan, Joel Halpern, Leif Johansson, Ladislav Lhotka, Gerhard Muenz, Tom Petch, Randy Presuhn, David Reid, and Bert Wijnen.",
      "zh-CHS": "编辑希望感谢以下个人，他们都对本文件的不同版本提供了有益的评论：Mehmet Ersue、Washam Fan、Joel Halpern、Leif Johansson、Ladislav Lhotka、Gerhard Muenz、Tom Petch、Randy Presohn、David Reid和Bert Wijnen。"
    },
    {
      "indent": 0,
      "text": "18. References",
      "section_title": true,
      "zh-CHS": "18. 工具书类"
    },
    {
      "indent": 0,
      "text": "18.1. Normative References",
      "section_title": true,
      "zh-CHS": "18.1. 规范性引用文件"
    },
    {
      "indent": 3,
      "text": "[ISO.10646] International Organization for Standardization, \"Information Technology - Universal Multiple-Octet Coded Character Set (UCS)\", ISO Standard 10646:2003, 2003.",
      "zh-CHS": "[ISO.10646]国际标准化组织，“信息技术-通用多八位编码字符集（UCS）”，ISO标准10646:2003，2003。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "zh-CHS": "[RFC2119]Bradner，S.，“RFC中用于表示需求水平的关键词”，BCP 14，RFC 2119，1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3023] Murata, M., St. Laurent, S., and D. Kohn, \"XML Media Types\", RFC 3023, January 2001.",
      "zh-CHS": "[RFC3023]Murata，M.，St.Laurent，S.，和D.Kohn，“XML媒体类型”，RFC 3023，2001年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, November 2003.",
      "zh-CHS": "[RFC3629]Yergeau，F.，“UTF-8，ISO 10646的转换格式”，STD 63，RFC 3629，2003年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC3688] Mealling, M., \"The IETF XML Registry\", BCP 81, RFC 3688, January 2004.",
      "zh-CHS": "[RFC3688]Mealling，M.“IETF XML注册表”，BCP 81，RFC 3688，2004年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, January 2005.",
      "zh-CHS": "[RFC3986]Berners Lee，T.，Fielding，R.，和L.Masinter，“统一资源标识符（URI）：通用语法”，STD 66，RFC 3986，2005年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC4648] Josefsson, S., \"The Base16, Base32, and Base64 Data Encodings\", RFC 4648, October 2006.",
      "zh-CHS": "[RFC4648]Josefsson，S.，“Base16、Base32和Base64数据编码”，RFC4648，2006年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC4741] Enns, R., \"NETCONF Configuration Protocol\", RFC 4741, December 2006.",
      "zh-CHS": "[RFC4741]Enns，R.，“网络配置协议”，RFC 47412006年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, May 2008.",
      "zh-CHS": "[RFC5226]Narten，T.和H.Alvestrand，“在RFCs中编写IANA注意事项部分的指南”，BCP 26，RFC 5226，2008年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, January 2008.",
      "zh-CHS": "[RFC5234]Crocker，D.和P.Overell，“语法规范的扩充BNF:ABNF”，STD 68，RFC 5234，2008年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC5277] Chisholm, S. and H. Trevino, \"NETCONF Event Notifications\", RFC 5277, July 2008.",
      "zh-CHS": "[RFC5277]Chisholm，S.和H.Trevino，“NETCONF事件通知”，RFC 5277，2008年7月。"
    },
    {
      "indent": 3,
      "text": "[XML-NAMES] Hollander, D., Tobin, R., Thompson, H., Bray, T., and A. Layman, \"Namespaces in XML 1.0 (Third Edition)\", World Wide Web Consortium Recommendation REC-xml-names-20091208, December 2009, <http://www.w3.org/TR/2009/REC-xml-names-20091208>.",
      "zh-CHS": "[XML-NAMES]Hollander，D.，Tobin，R.，Thompson，H.，Bray，T.，和A.Layman，“XML 1.0中的名称空间（第三版）”，万维网联盟建议REC-XML-NAMES-20091208，2009年12月<http://www.w3.org/TR/2009/REC-xml-names-20091208>."
    },
    {
      "indent": 3,
      "text": "[XPATH] Clark, J. and S. DeRose, \"XML Path Language (XPath) Version 1.0\", World Wide Web Consortium Recommendation REC-xpath-19991116, November 1999, <http://www.w3.org/TR/1999/REC-xpath-19991116>.",
      "zh-CHS": "[XPATH]Clark，J.和S.DeRose，“XML路径语言（XPATH）1.0版”，万维网联盟建议REC-XPATH-19991116，1999年11月<http://www.w3.org/TR/1999/REC-xpath-19991116>."
    },
    {
      "indent": 3,
      "text": "[XSD-TYPES] Malhotra, A. and P. Biron, \"XML Schema Part 2: Datatypes Second Edition\", World Wide Web Consortium Recommendation REC-xmlschema-2-20041028, October 2004, <http://www.w3.org/TR/2004/REC-xmlschema-2-20041028>.",
      "zh-CHS": "[XSD-TYPES]Malhotra，A.和P.Biron，“XML模式第2部分：数据类型第二版”，万维网联盟建议REC-xmlschema-2-20041028，2004年10月<http://www.w3.org/TR/2004/REC-xmlschema-2-20041028>."
    },
    {
      "indent": 0,
      "text": "18.2. Informative References",
      "section_title": true,
      "zh-CHS": "18.2. 资料性引用"
    },
    {
      "indent": 3,
      "text": "[RFC2578] McCloghrie, K., Ed., Perkins, D., Ed., and J. Schoenwaelder, Ed., \"Structure of Management Information Version 2 (SMIv2)\", STD 58, RFC 2578, April 1999.",
      "zh-CHS": "[RFC2578]McCloghrie，K.，Ed.，Perkins，D.，Ed.，和J.Schoenwaeld，Ed.“管理信息的结构版本2（SMIv2）”，STD 58，RFC 2578，1999年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC2579] McCloghrie, K., Ed., Perkins, D., Ed., and J. Schoenwaelder, Ed., \"Textual Conventions for SMIv2\", STD 58, RFC 2579, April 1999.",
      "zh-CHS": "[RFC2579]McCloghrie，K.，Ed.，Perkins，D.，Ed.，和J.Schoenwaeld，Ed.“SMIv2的文本约定”，STD 58，RFC 2579，1999年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC3780] Strauss, F. and J. Schoenwaelder, \"SMIng - Next Generation Structure of Management Information\", RFC 3780, May 2004.",
      "zh-CHS": "[RFC3780]Strauss，F.和J.Schoenwaeld，“SMIng-下一代管理信息结构”，RFC 3780，2004年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC4844] Daigle, L. and Internet Architecture Board, \"The RFC Series and RFC Editor\", RFC 4844, July 2007.",
      "zh-CHS": "[RFC4844]Daigle，L.和互联网架构委员会，“RFC系列和RFC编辑器”，RFC 48442007年7月。"
    },
    {
      "indent": 3,
      "text": "[XPATH2.0] Berglund, A., Boag, S., Chamberlin, D., Fernandez, M., Kay, M., Robie, J., and J. Simeon, \"XML Path Language (XPath) 2.0\", World Wide Web Consortium Recommendation REC-xpath20-20070123, January 2007, <http://www.w3.org/TR/2007/REC-xpath20-20070123>.",
      "zh-CHS": "[XPATH2.0]Berglund，A.，Boag，S.，Chamberlin，D.，Fernandez，M.，Kay，M.，Robie，J.，和J.Simeon，“XML路径语言（XPath）2.0”，万维网联盟建议REC-xpath20-20070123，2007年1月<http://www.w3.org/TR/2007/REC-xpath20-20070123>."
    },
    {
      "indent": 3,
      "text": "[XSLT] Clark, J., \"XSL Transformations (XSLT) Version 1.0\", World Wide Web Consortium Recommendation REC-xslt-19991116, November 1999, <http://www.w3.org/TR/1999/REC-xslt-19991116>.",
      "zh-CHS": "[XSLT]Clark，J.，“XSL转换（XSLT）1.0版”，万维网联盟建议REC-XSLT-19991116，1999年11月<http://www.w3.org/TR/1999/REC-xslt-19991116>."
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "zh-CHS": "作者地址"
    },
    {
      "indent": 3,
      "text": "Martin Bjorklund (editor) Tail-f Systems",
      "zh-CHS": "Martin Bjorklund（编辑）Tail-f系统"
    },
    {
      "indent": 3,
      "text": "EMail: mbj@tail-f.com",
      "raw": true,
      "zh-CHS": " "
    }
  ]
}