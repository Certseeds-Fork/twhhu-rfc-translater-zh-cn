{
  "title": {
    "text": "RFC 6234: US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)",
    "zh-CHS": "RFC 6234"
  },
  "number": 6234,
  "created_at": "2021-11-05 17:13:29.056928+08:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                   D. Eastlake 3rd\nRequest for Comments: 6234                                        Huawei\nObsoletes: 4634                                                T. Hansen\nUpdates: 3174                                                  AT&T Labs\nCategory: Informational                                         May 2011\nISSN: 2070-1721",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 19,
      "text": " US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)",
      "zh-CHS": "美国安全散列算法（SHA和基于SHA的HMAC和HKDF）"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "zh-CHS": "摘要"
    },
    {
      "indent": 3,
      "text": "The United States of America has adopted a suite of Secure Hash Algorithms (SHAs), including four beyond SHA-1, as part of a Federal Information Processing Standard (FIPS), namely SHA-224, SHA-256, SHA-384, and SHA-512. This document makes open source code performing these SHA hash functions conveniently available to the Internet community. The sample code supports input strings of arbitrary bit length. Much of the text herein was adapted by the authors from FIPS 180-2.",
      "zh-CHS": "美国采用了一套安全哈希算法（SHA），包括四种SHA-1以外的算法，作为联邦信息处理标准（FIPS）的一部分，即SHA-224、SHA-256、SHA-384和SHA-512。本文档使执行这些SHA哈希函数的开放源代码方便地提供给互联网社区。示例代码支持任意位长度的输入字符串。本文的大部分内容由FIPS 180-2的作者改编。"
    },
    {
      "indent": 3,
      "text": "This document replaces RFC 4634, fixing errata and adding code for an HMAC-based extract-and-expand Key Derivation Function, HKDF (RFC 5869). As with RFC 4634, code to perform SHA-based Hashed Message Authentication Codes (HMACs) is also included.",
      "zh-CHS": "本文档取代RFC 4634，修复了勘误表，并为基于HMAC的提取和扩展键派生函数HKDF（RFC 5869）添加了代码。与RFC4634一样，还包括用于执行基于SHA的哈希消息认证码（HMAC）的代码。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "zh-CHS": "关于下段备忘"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "zh-CHS": "本文件不是互联网标准跟踪规范；它是为了提供信息而发布的。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "zh-CHS": "本文件是互联网工程任务组（IETF）的产品。它代表了IETF社区的共识。它已经接受了公众审查，并已被互联网工程指导小组（IESG）批准出版。并非IESG批准的所有文件都适用于任何级别的互联网标准；见RFC 5741第2节。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6234.",
      "zh-CHS": "有关本文件当前状态、任何勘误表以及如何提供反馈的信息，请访问http://www.rfc-editor.org/info/rfc6234."
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "zh-CHS": "版权公告"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2011 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "zh-CHS": "版权所有（c）2011 IETF信托基金和确定为文件作者的人员。版权所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "zh-CHS": "本文件受BCP 78和IETF信托有关IETF文件的法律规定的约束(http://trustee.ietf.org/license-info)自本文件出版之日起生效。请仔细阅读这些文件，因为它们描述了您对本文件的权利和限制。从本文件中提取的代码组件必须包括信托法律条款第4.e节中所述的简化BSD许可证文本，并提供简化BSD许可证中所述的无担保。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "zh-CHS": "目录"
    },
    {
      "indent": 3,
      "text": "1. Overview of Contents ............................................4\n2. Notation for Bit Strings and Integers ...........................5\n3. Operations on Words .............................................6\n4. Message Padding and Parsing .....................................8\n   4.1. SHA-224 and SHA-256 ........................................8\n   4.2. SHA-384 and SHA-512 ........................................9\n5. Functions and Constants Used ...................................10\n   5.1. SHA-224 and SHA-256 .......................................10\n   5.2. SHA-384 and SHA-512 .......................................11\n6. Computing the Message Digest ...................................12\n   6.1. SHA-224 and SHA-256 Initialization ........................12\n   6.2. SHA-224 and SHA-256 Processing ............................13\n   6.3. SHA-384 and SHA-512 Initialization ........................14\n   6.4. SHA-384 and SHA-512 Processing ............................15\n7. HKDF- and SHA-Based HMACs ......................................17\n   7.1. SHA-Based HMACs ...........................................17\n   7.2. HKDF ......................................................17\n8. C Code for SHAs, HMAC, and HKDF ................................17\n   8.1. The Header Files ..........................................21\n        8.1.1. The .h file ........................................21\n        8.1.2. stdint-example.h ...................................29\n        8.1.3. sha-private.h ......................................29\n   8.2. The SHA Code ..............................................30\n        8.2.1. sha1.c .............................................30\n        8.2.2. sha224-256.c .......................................39\n        8.2.3. sha384-512.c .......................................51\n        8.2.4. usha.c .............................................73\n   8.3. The HMAC Code .............................................79\n   8.4. The HKDF Code .............................................84\n   8.5. The Test Driver ...........................................91\n9. Security Considerations .......................................123\n10. Acknowledgements .............................................123\n11. References ...................................................124\n   11.1. Normative References ....................................124\n   11.2. Informative References ..................................124\nAppendix: Changes from RFC 4634...................................126",
      "raw": true,
      "toc": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "1. Overview of Contents",
      "section_title": true,
      "zh-CHS": "1. 内容概述"
    },
    {
      "indent": 3,
      "text": "This document includes specifications for the United States of America (USA) Federal Information Processing Standard (FIPS) Secure Hash Algorithms (SHAs), code to implement the SHAs, code to implement HMAC (Hashed Message Authentication Code, [RFC2104]) based on the SHAs, and code to implement HKDF (HMAC-based Key Derivation Function, [RFC5869]) based on HMAC. Specifications for HMAC and HKDF are not included as they appear elsewhere in the RFC series [RFC2104] [RFC5869].",
      "zh-CHS": "本文件包括美国联邦信息处理标准（FIPS）安全哈希算法（SHAs）规范、实现SHAs的代码、基于SHAs实现HMAC（哈希消息认证码[RFC2104]）的代码以及实现HKDF（基于HMAC的密钥派生函数[RFC5869]）的代码基于HMAC。HMAC和HKDF的规范不包括在内，因为它们出现在RFC系列[RFC2104][RFC5869]的其他地方。"
    },
    {
      "indent": 3,
      "text": "NOTE: Much of the text below is taken from [SHS], and the assertions of the security of the hash algorithms described therein are made by the US Government, the author of [SHS], not by the listed authors of this document. See also [RFC6194] concerning the security of SHA-1.",
      "zh-CHS": "注：以下大部分文本摘自[SHS]，其中所述散列算法的安全性声明由[SHS]的作者美国政府提出，而非本文件的列表作者。关于SHA-1的安全性，另见[RFC6194]。"
    },
    {
      "indent": 3,
      "text": "The text below specifies Secure Hash Algorithms, SHA-224 [RFC3874], SHA-256, SHA-384, and SHA-512, for computing a condensed representation of a message or a data file. (SHA-1 is specified in [RFC3174].) When a message of any length < 2^64 bits (for SHA-224 and SHA-256) or < 2^128 bits (for SHA-384 and SHA-512) is input to one of these algorithms, the result is an output called a message digest. The message digests range in length from 224 to 512 bits, depending on the algorithm. Secure Hash Algorithms are typically used with other cryptographic algorithms, such as digital signature algorithms and keyed-hash authentication codes, the generation of random numbers [RFC4086], or in key derivation functions.",
      "zh-CHS": "下面的文本指定了安全哈希算法SHA-224[RFC3874]、SHA-256、SHA-384和SHA-512，用于计算消息或数据文件的压缩表示。（SHA-1在[RFC3174]中指定）当任何长度<2^64位（对于SHA-224和SHA-256）或<2^128位（对于SHA-384和SHA-512）的消息输入到其中一个算法时，结果是称为消息摘要的输出。消息摘要的长度范围为224到512位，具体取决于算法。安全散列算法通常与其他加密算法一起使用，例如数字签名算法和密钥散列认证码、随机数的生成[RFC4086]或密钥派生函数。"
    },
    {
      "indent": 3,
      "text": "The algorithms specified in this document are called secure because it is computationally infeasible to (1) find a message that corresponds to a given message digest, or (2) find two different messages that produce the same message digest. Any change to a message in transit will, with very high probability, result in a different message digest. This will result in a verification failure when the Secure Hash Algorithm is used with a digital signature algorithm or a keyed-hash message authentication algorithm.",
      "zh-CHS": "本文档中指定的算法称为安全算法，因为（1）查找与给定消息摘要相对应的消息或（2）查找生成相同消息摘要的两条不同消息在计算上是不可行的。对传输中的消息的任何更改都极有可能导致不同的消息摘要。当安全哈希算法与数字签名算法或密钥哈希消息认证算法一起使用时，这将导致验证失败。"
    },
    {
      "indent": 3,
      "text": "The code provided herein supports input strings of arbitrary bit length. SHA-1's sample code from [RFC3174] has also been updated to handle input strings of arbitrary bit length. Permission is granted for all uses, commercial and non-commercial, of this code.",
      "zh-CHS": "本文提供的代码支持任意位长度的输入字符串。[RFC3174]中SHA-1的示例代码也已更新，以处理任意位长度的输入字符串。本规范的所有商业和非商业用途均获得许可。"
    },
    {
      "indent": 3,
      "text": "This document obsoletes [RFC4634], and the changes from that RFC are summarized in the Appendix.",
      "zh-CHS": "本文件废除了[RFC4634]，附录中总结了该RFC的变更。"
    },
    {
      "indent": 3,
      "text": "ASN.1 OIDs (Object Identifiers) for the SHA algorithms, taken from [RFC4055], are as follows:",
      "zh-CHS": "SHA算法的ASN.1 OID（对象标识符）取自[RFC4055]，如下所示："
    },
    {
      "indent": 3,
      "text": "id-sha1  OBJECT IDENTIFIER  ::=  { iso(1)\n                      identified-organization(3) oiw(14)\n                      secsig(3) algorithms(2) 26 }\n id-sha224  OBJECT IDENTIFIER  ::=  {{ joint-iso-itu-t(2)\n                      country(16) us(840) organization(1) gov(101)\n                      csor(3) nistalgorithm(4) hashalgs(2) 4 }\n id-sha256  OBJECT IDENTIFIER  ::=  { joint-iso-itu-t(2)\n                      country(16) us(840) organization(1) gov(101)\n                      csor(3) nistalgorithm(4) hashalgs(2) 1 }\n id-sha384  OBJECT IDENTIFIER  ::=  { joint-iso-itu-t(2)\n                      country(16) us(840) organization(1) gov(101)\n                      csor(3) nistalgorithm(4) hashalgs(2) 2 }\n id-sha512  OBJECT IDENTIFIER  ::=  { joint-iso-itu-t(2)\n                      country(16) us(840) organization(1) gov(101)\n                      csor(3) nistalgorithm(4) hashalgs(2) 3 }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Section 2 below defines the terminology and functions used as building blocks to form these algorithms. Section 3 describes the fundamental operations on words from which these algorithms are built. Section 4 describes how messages are padded up to an integral multiple of the required block size and then parsed into blocks. Section 5 defines the constants and the composite functions used to specify the hash algorithms. Section 6 gives the actual specification for the SHA-224, SHA-256, SHA-384, and SHA-512 functions. Section 7 provides pointers to the specification of HMAC keyed message authentication codes and to the specification of an extract-and-expand key derivation function based on HMAC.",
      "zh-CHS": "下面的第2节定义了构成这些算法的构建块所使用的术语和函数。第3节描述了构建这些算法的单词的基本操作。第4节描述了如何将消息填充到所需块大小的整数倍，然后解析为块。第5节定义了用于指定哈希算法的常量和复合函数。第6节给出了SHA-224、SHA-256、SHA-384和SHA-512功能的实际规范。第7节提供了指向HMAC键控消息认证码规范和基于HMAC的提取和扩展密钥派生函数规范的指针。"
    },
    {
      "indent": 3,
      "text": "Section 8 gives sample code for the SHA algorithms, for SHA-based HMACs, and for HMAC-based extract-and-expand key derivation function.",
      "zh-CHS": "第8节给出了SHA算法、基于SHA的HMAC以及基于HMAC的提取和扩展密钥派生函数的示例代码。"
    },
    {
      "indent": 0,
      "text": "2. Notation for Bit Strings and Integers",
      "section_title": true,
      "zh-CHS": "2. 位字符串和整数的表示法"
    },
    {
      "indent": 3,
      "text": "The following terminology related to bit strings and integers will be used:",
      "zh-CHS": "将使用以下与位字符串和整数相关的术语："
    },
    {
      "indent": 3,
      "text": "a. A hex digit is an element of the set {0, 1, ... , 9, A, ... , F}. A hex digit is the representation of a 4-bit string. Examples: 7 = 0111, A = 1010.",
      "zh-CHS": "a. 十六进制数字是集合{0，1，…，9，A，…，F}的一个元素。十六进制数字是4位字符串的表示形式。示例：7=0111，A=1010。"
    },
    {
      "indent": 6,
      "text": "b. A word equals a 32-bit or 64-bit string that may be represented as a sequence of 8 or 16 hex digits, respectively. To convert a word to hex digits, each 4-bit string is converted to its hex equivalent as described in (a) above. Example:",
      "zh-CHS": "b. 一个字等于一个32位或64位字符串，可以分别表示为8位或16位十六进制数字的序列。要将一个字转换为十六进制数字，每个4位字符串将转换为其十六进制等效值，如上文（a）所述。例子："
    },
    {
      "indent": 9,
      "text": "1010 0001 0000 0011 1111 1110 0010 0011 = A103FE23.",
      "zh-CHS": "1010 0001 0000 0011 1111 1110 0010 0011=A103FE23。"
    },
    {
      "indent": 6,
      "text": "Throughout this document, the \"big-endian\" convention is used when expressing both 32-bit and 64-bit words, so that within each word the most significant bit is shown in the leftmost bit position.",
      "zh-CHS": "在本文档中，表达32位和64位单词时使用“big-endian”约定，因此每个单词中最重要的位显示在最左边的位位置。"
    },
    {
      "indent": 6,
      "text": "c. An integer may be represented as a word or pair of words.",
      "zh-CHS": "c. 整数可以表示为一个字或一对字。"
    },
    {
      "indent": 6,
      "text": "An integer between 0 and 2^32 - 1 inclusive may be represented as a 32-bit word. The least significant four bits of the integer are represented by the rightmost hex digit of the word representation. Example: the integer 291 = 2^8+2^5+2^1+2^0 = 256+32+2+1 is represented by the hex word 00000123.",
      "zh-CHS": "介于0和2^32-1（含）之间的整数可以表示为32位字。整数的最低有效位由字表示法的最右边的十六进制数字表示。示例：整数291=2^8+2^5+2^1+2^0=256+32+2+1由十六进制字00000123表示。"
    },
    {
      "indent": 6,
      "text": "The same holds true for an integer between 0 and 2^64-1 inclusive, which may be represented as a 64-bit word.",
      "zh-CHS": "对于介于0和2^64-1（含2^64-1）之间的整数也是如此，它可以表示为64位字。"
    },
    {
      "indent": 6,
      "text": "If Z is an integer, 0 <= z < 2^64, then z = (2^32)x + y where\n0 <= x < 2^32 and 0 <= y < 2^32.  Since x and y can be represented\nas words X and Y, respectively, z can be represented as the pair\nof words (X,Y).",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "Again, the \"big-endian\" convention is used and the most significant word is in the leftmost word position for values represented by multiple-words.",
      "zh-CHS": "同样，使用“big-endian”约定，对于由多个单词表示的值，最重要的单词位于最左边的单词位置。"
    },
    {
      "indent": 6,
      "text": "d. block = 512-bit or 1024-bit string. A block (e.g., B) may be represented as a sequence of 32-bit or 64-bit words.",
      "zh-CHS": "d. 块=512位或1024位字符串。块（例如，B）可以表示为32位或64位字的序列。"
    },
    {
      "indent": 0,
      "text": "3. Operations on Words",
      "section_title": true,
      "zh-CHS": "3. 文字操作"
    },
    {
      "indent": 3,
      "text": "The following logical operators will be applied to words in all four hash operations specified herein. SHA-224 and SHA-256 operate on 32-bit words while SHA-384 and SHA-512 operate on 64-bit words.",
      "zh-CHS": "以下逻辑运算符将应用于本文指定的所有四个哈希操作中的字。SHA-224和SHA-256操作32位字，而SHA-384和SHA-512操作64位字。"
    },
    {
      "indent": 3,
      "text": "In the operations below, x<<n is obtained as follows: discard the leftmost n bits of x and then pad the result with n zeroed bits on the right (the result will still be the same number of bits). Similarly, x>>n is obtained as follows: discard the rightmost n bits of x and then prepend the result with n zeroed bits on the left (the result will still be the same number of bits).",
      "zh-CHS": "在下面的操作中，x<<n如下所示：丢弃x的最左边的n位，然后在右边用n个零位填充结果（结果仍然是相同的位数）。类似地，x>>n的获得如下：丢弃x的最右边的n位，然后在结果的左边加上n个零位（结果仍然是相同数量的位）。"
    },
    {
      "indent": 3,
      "text": "a. Bitwise logical word operations",
      "zh-CHS": "a. 按位逻辑字运算"
    },
    {
      "indent": 9,
      "text": "X AND Y = bitwise logical \"and\" of X and Y.",
      "zh-CHS": "X和Y=X和Y的按位逻辑“AND”。"
    },
    {
      "indent": 9,
      "text": "X OR Y = bitwise logical \"inclusive-or\" of X and Y.",
      "zh-CHS": "X或Y=X和Y的按位逻辑“包含或”。"
    },
    {
      "indent": 9,
      "text": "X XOR Y = bitwise logical \"exclusive-or\" of X and Y.",
      "zh-CHS": "X XOR Y=X和Y的按位逻辑“异或”。"
    },
    {
      "indent": 9,
      "text": "NOT X = bitwise logical \"complement\" of X.",
      "zh-CHS": "NOT X=X的按位逻辑“补码”。"
    },
    {
      "indent": 9,
      "text": "Example:\n         01101100101110011101001001111011\n   XOR   01100101110000010110100110110111\n         --------------------------------\n     =   00001001011110001011101111001100",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "b. The operation X + Y is defined as follows: words X and Y represent\n   w-bit integers x and y, where 0 <= x < 2^w and 0 <= y < 2^w.  For\n   positive integers n and m, let",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "n mod m",
      "zh-CHS": "n模m"
    },
    {
      "indent": 6,
      "text": "be the remainder upon dividing n by m. Compute",
      "zh-CHS": "n除以m后的余数。计算"
    },
    {
      "indent": 9,
      "text": "z  =  (x + y) mod 2^w.",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "Then 0 <= z < 2^w. Convert z to a word, Z, and define Z = X + Y.",
      "zh-CHS": "然后0<=z<2^w。将z转换为单词z，并定义z=X+Y。"
    },
    {
      "indent": 3,
      "text": "c. The right shift operation SHR^n(x), where x is a w-bit word and n\n   is an integer with 0 <= n < w, is defined by",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "SHR^n(x) = x>>n",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "d. The rotate right (circular right shift) operation ROTR^n(x), where\n   x is a w-bit word and n is an integer with 0 <= n < w, is defined\n   by",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "ROTR^n(x) = (x>>n) OR (x<<(w-n))",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "e. The rotate left (circular left shift) operation ROTL^n(x), where x\n   is a w-bit word and n is an integer with 0 <= n < w, is defined by",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "ROTL^n(X) = (x<<n) OR (x>>(w-n))",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "Note the following equivalence relationships, where w is fixed in each relationship:",
      "zh-CHS": "注意以下等价关系，其中w在每个关系中是固定的："
    },
    {
      "indent": 9,
      "text": "ROTL^n(x) = ROTR^(w-n)(x)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "ROTR^n(x) = ROTL^(w-n)(x)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "4. Message Padding and Parsing",
      "section_title": true,
      "zh-CHS": "4. 消息填充和解析"
    },
    {
      "indent": 3,
      "text": "The hash functions specified herein are used to compute a message digest for a message or data file that is provided as input. The message or data file should be considered to be a bit string. The length of the message is the number of bits in the message (the empty message has length 0). If the number of bits in a message is a multiple of 8, for compactness we can represent the message in hex. The purpose of message padding is to make the total length of a padded message a multiple of 512 for SHA-224 and SHA-256 or a multiple of 1024 for SHA-384 and SHA-512.",
      "zh-CHS": "本文中指定的散列函数用于计算作为输入提供的消息或数据文件的消息摘要。消息或数据文件应视为位字符串。消息的长度是消息中的位数（空消息的长度为0）。如果消息中的位数是8的倍数，为了简洁起见，我们可以用十六进制表示消息。消息填充的目的是使填充消息的总长度对于SHA-224和SHA-256为512的倍数，或者对于SHA-384和SHA-512为1024的倍数。"
    },
    {
      "indent": 3,
      "text": "The following specifies how this padding shall be performed. As a summary, a \"1\" followed by m \"0\"s followed by a 64-bit or 128-bit integer are appended to the end of the message to produce a padded message of length 512*n or 1024*n. The appended integer is the length of the original message. The padded message is then processed by the hash function as n 512-bit or 1024-bit blocks.",
      "zh-CHS": "以下规定了应如何进行填充。作为总结，将“1”后跟m“0”后跟64位或128位整数附加到消息末尾，以生成长度为512*n或1024*n的填充消息。追加的整数是原始消息的长度。填充的消息然后由哈希函数作为n 512位或1024位块进行处理。"
    },
    {
      "indent": 0,
      "text": "4.1. SHA-224 and SHA-256",
      "section_title": true,
      "zh-CHS": "4.1. SHA-224和SHA-256"
    },
    {
      "indent": 3,
      "text": "Suppose a message has length L < 2^64. Before it is input to the hash function, the message is padded on the right as follows:",
      "zh-CHS": "假设一条消息的长度L<2^64。在将消息输入到哈希函数之前，消息在右侧填充，如下所示："
    },
    {
      "indent": 3,
      "text": "a. \"1\" is appended. Example: if the original message is \"01010000\", this is padded to \"010100001\".",
      "zh-CHS": "a. 附加“1”。示例：如果原始消息为“01010000”，则填充为“010100001”。"
    },
    {
      "indent": 3,
      "text": "b. K \"0\"s are appended where K is the smallest, non-negative solution to the equation",
      "zh-CHS": "b. 附加K“0”，其中K是方程的最小非负解"
    },
    {
      "indent": 9,
      "text": "( L + 1 + K ) mod 512 = 448",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "c. Then append the 64-bit block that is L in binary representation. After appending this block, the length of the message will be a multiple of 512 bits.",
      "zh-CHS": "c. 然后附加以二进制表示的L表示的64位块。附加此块后，消息的长度将是512位的倍数。"
    },
    {
      "indent": 6,
      "text": "Example: Suppose the original message is the bit string",
      "zh-CHS": "示例：假设原始消息是位字符串"
    },
    {
      "indent": 9,
      "text": "01100001 01100010 01100011 01100100 01100101",
      "zh-CHS": "01100001 01100010 01100011 01100100 01100101"
    },
    {
      "indent": 6,
      "text": "After step (a) this gives",
      "zh-CHS": "在步骤（a）之后，给出"
    },
    {
      "indent": 9,
      "text": "01100001 01100010 01100011 01100100 01100101 1",
      "zh-CHS": "01100001 01100010 01100011 01100100 01100101 1"
    },
    {
      "indent": 6,
      "text": "Since L = 40, the number of bits in the above is 41 and K = 407 \"0\"s are appended, making the total now 448. This gives the following in hex:",
      "zh-CHS": "因为L=40，上面的位数是41，加上K=407“0”，总数现在是448。这以十六进制表示如下内容："
    },
    {
      "indent": 9,
      "text": "61626364 65800000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000",
      "zh-CHS": "61626364 65800000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000"
    },
    {
      "indent": 6,
      "text": "The 64-bit representation of L = 40 is hex 00000000 00000028. Hence the final padded message is the following hex",
      "zh-CHS": "L=40的64位表示形式为十六进制00000000000028。因此，最后的填充消息是以下十六进制"
    },
    {
      "indent": 9,
      "text": "61626364 65800000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000028",
      "zh-CHS": "61626364 65800000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000028"
    },
    {
      "indent": 0,
      "text": "4.2. SHA-384 and SHA-512",
      "section_title": true,
      "zh-CHS": "4.2. SHA-384和SHA-512"
    },
    {
      "indent": 3,
      "text": "Suppose a message has length L < 2^128. Before it is input to the hash function, the message is padded on the right as follows:",
      "zh-CHS": "假设一条消息的长度L<2^128。在将消息输入到哈希函数之前，消息在右侧填充，如下所示："
    },
    {
      "indent": 3,
      "text": "a. \"1\" is appended. Example: if the original message is \"01010000\", this is padded to \"010100001\".",
      "zh-CHS": "a. 附加“1”。示例：如果原始消息为“01010000”，则填充为“010100001”。"
    },
    {
      "indent": 3,
      "text": "b. K \"0\"s are appended where K is the smallest, non-negative solution to the equation",
      "zh-CHS": "b. 附加K“0”，其中K是方程的最小非负解"
    },
    {
      "indent": 9,
      "text": "( L + 1 + K ) mod 1024 = 896",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "c. Then append the 128-bit block that is L in binary representation. After appending this block, the length of the message will be a multiple of 1024 bits.",
      "zh-CHS": "c. 然后附加以二进制表示的L表示的128位块。附加此块后，消息的长度将是1024位的倍数。"
    },
    {
      "indent": 6,
      "text": "Example: Suppose the original message is the bit string",
      "zh-CHS": "示例：假设原始消息是位字符串"
    },
    {
      "indent": 9,
      "text": "01100001 01100010 01100011 01100100 01100101",
      "zh-CHS": "01100001 01100010 01100011 01100100 01100101"
    },
    {
      "indent": 6,
      "text": "After step (a) this gives",
      "zh-CHS": "在步骤（a）之后，给出"
    },
    {
      "indent": 9,
      "text": "01100001 01100010 01100011 01100100 01100101 1",
      "zh-CHS": "01100001 01100010 01100011 01100100 01100101 1"
    },
    {
      "indent": 6,
      "text": "Since L = 40, the number of bits in the above is 41 and K = 855 \"0\"s are appended, making the total now 896. This gives the following in hex:",
      "zh-CHS": "因为L=40，上面的位数是41，加上K=855“0”，总数现在是896。这以十六进制表示如下内容："
    },
    {
      "indent": 9,
      "text": "61626364 65800000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000",
      "zh-CHS": "61626364 65800000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000"
    },
    {
      "indent": 6,
      "text": "The 128-bit representation of L = 40 is hex 00000000 00000000 00000000 00000028. Hence the final padded message is the following hex:",
      "zh-CHS": "L=40的128位表示形式为十六进制00000000000000000000000000000028。因此，最后的填充消息如下所示："
    },
    {
      "indent": 9,
      "text": "61626364 65800000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000028",
      "zh-CHS": "61626364 65800000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000028"
    },
    {
      "indent": 0,
      "text": "5. Functions and Constants Used",
      "section_title": true,
      "zh-CHS": "5. 使用的函数和常量"
    },
    {
      "indent": 3,
      "text": "The following subsections give the six logical functions and the table of constants used in each of the hash functions.",
      "zh-CHS": "以下小节给出了六个逻辑函数以及每个哈希函数中使用的常量表。"
    },
    {
      "indent": 0,
      "text": "5.1. SHA-224 and SHA-256",
      "section_title": true,
      "zh-CHS": "5.1. SHA-224和SHA-256"
    },
    {
      "indent": 3,
      "text": "SHA-224 and SHA-256 use six logical functions, where each function operates on 32-bit words, which are represented as x, y, and z. The result of each function is a new 32-bit word.",
      "zh-CHS": "SHA-224和SHA-256使用六个逻辑函数，其中每个函数对32位字进行操作，这些字表示为x、y和z。每个函数的结果是一个新的32位字。"
    },
    {
      "indent": 6,
      "text": "CH( x, y, z) = (x AND y) XOR ( (NOT x) AND z)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "MAJ( x, y, z) = (x AND y) XOR (x AND z) XOR (y AND z)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "BSIG0(x) = ROTR^2(x) XOR ROTR^13(x) XOR ROTR^22(x)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "BSIG1(x) = ROTR^6(x) XOR ROTR^11(x) XOR ROTR^25(x)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "SSIG0(x) = ROTR^7(x) XOR ROTR^18(x) XOR SHR^3(x)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "SSIG1(x) = ROTR^17(x) XOR ROTR^19(x) XOR SHR^10(x)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "SHA-224 and SHA-256 use the same sequence of sixty-four constant 32-bit words, K0, K1, ..., K63. These words represent the first 32 bits of the fractional parts of the cube roots of the first sixty-four prime numbers. In hex, these constant words are as follows (from left to right):",
      "zh-CHS": "SHA-224和SHA-256使用64个恒定32位字K0、K1、…、K63的相同序列。这些字代表前64个素数的立方根的小数部分的前32位。在十六进制中，这些常量单词如下（从左到右）："
    },
    {
      "indent": 6,
      "text": "428a2f98 71374491 b5c0fbcf e9b5dba5 3956c25b 59f111f1 923f82a4 ab1c5ed5 d807aa98 12835b01 243185be 550c7dc3 72be5d74 80deb1fe 9bdc06a7 c19bf174 e49b69c1 efbe4786 0fc19dc6 240ca1cc 2de92c6f 4a7484aa 5cb0a9dc 76f988da 983e5152 a831c66d b00327c8 bf597fc7 c6e00bf3 d5a79147 06ca6351 14292967 27b70a85 2e1b2138 4d2c6dfc 53380d13 650a7354 766a0abb 81c2c92e 92722c85 a2bfe8a1 a81a664b c24b8b70 c76c51a3 d192e819 d6990624 f40e3585 106aa070 19a4c116 1e376c08 2748774c 34b0bcb5 391c0cb3 4ed8aa4a 5b9cca4f 682e6ff3 748f82ee 78a5636f 84c87814 8cc70208 90befffa a4506ceb bef9a3f7 c67178f2",
      "zh-CHS": "428a2f98 71374491 b5c0fbcf e9b5dba5 3956c25b 59f111f1 923f82a4 ab1c5ed5 d807aa98 12835b01 243185be 550c7dc3 72B5D74B5D7B5C06A7 c19bf174 e49b69c1 efbe4786 0fc19dc6 240CA1C 2de92c6f 4A7484848484 AA 5B0A9DC 76f988da 983e5152 A8366D b00327c8 bf597fc7 C60BF7C06A7 C1747B9B69C1 efbe4786 0fc19dc6 240ca1cc 2D380788DF088D988B7B7B7676768B7B7B7B5B5B7676768B8B8B8B5B5B5B5B8B5B5B5B7B7C581c2c92e 92722c85 a2bfe8a1 a81a664b c24b8b70 c76c51a3 d192e819 D690624 f40e3585 106aa070 19a4c116 1e376c08 2748774c 34b0bcb5 391c0cb3 4ed8aa4a 5b9cca4f 682e6ff3 748F82E 78a5636f 84c87814 8cc70208 90BEFFA a4506ceb BEF7C67178F2"
    },
    {
      "indent": 0,
      "text": "5.2. SHA-384 and SHA-512",
      "section_title": true,
      "zh-CHS": "5.2. SHA-384和SHA-512"
    },
    {
      "indent": 3,
      "text": "SHA-384 and SHA-512 each use six logical functions, where each function operates on 64-bit words, which are represented as x, y, and z. The result of each function is a new 64-bit word.",
      "zh-CHS": "SHA-384和SHA-512各使用六个逻辑函数，其中每个函数对64位字进行操作，这些字表示为x、y和z。每个函数的结果是一个新的64位字。"
    },
    {
      "indent": 6,
      "text": "CH( x, y, z) = (x AND y) XOR ( (NOT x) AND z)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "MAJ( x, y, z) = (x AND y) XOR (x AND z) XOR (y AND z)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "BSIG0(x) = ROTR^28(x) XOR ROTR^34(x) XOR ROTR^39(x)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "BSIG1(x) = ROTR^14(x) XOR ROTR^18(x) XOR ROTR^41(x)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "SSIG0(x) = ROTR^1(x) XOR ROTR^8(x) XOR SHR^7(x)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "SSIG1(x) = ROTR^19(x) XOR ROTR^61(x) XOR SHR^6(x)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "SHA-384 and SHA-512 use the same sequence of eighty constant 64-bit words, K0, K1, ... K79. These words represent the first 64 bits of the fractional parts of the cube roots of the first eighty prime numbers. In hex, these constant words are as follows (from left to right):",
      "zh-CHS": "SHA-384和SHA-512使用80个恒定64位字的相同序列，K0，K1。。。K79。这些字表示前80个素数的立方根的小数部分的前64位。在十六进制中，这些常量单词如下（从左到右）："
    },
    {
      "indent": 3,
      "text": "428a2f98d728ae22 7137449123ef65cd b5c0fbcfec4d3b2f e9b5dba58189dbbc 3956c25bf348b538 59f111f1b605d019 923f82a4af194f9b ab1c5ed5da6d8118 d807aa98a3030242 12835b0145706fbe 243185be4ee4b28c 550c7dc3d5ffb4e2 72be5d74f27b896f 80deb1fe3b1696b1 9bdc06a725c71235 c19bf174cf692694 e49b69c19ef14ad2 efbe4786384f25e3 0fc19dc68b8cd5b5 240ca1cc77ac9c65 2de92c6f592b0275 4a7484aa6ea6e483 5cb0a9dcbd41fbd4 76f988da831153b5 983e5152ee66dfab a831c66d2db43210 b00327c898fb213f bf597fc7beef0ee4 c6e00bf33da88fc2 d5a79147930aa725 06ca6351e003826f 142929670a0e6e70 27b70a8546d22ffc 2e1b21385c26c926 4d2c6dfc5ac42aed 53380d139d95b3df 650a73548baf63de 766a0abb3c77b2a8 81c2c92e47edaee6 92722c851482353b a2bfe8a14cf10364 a81a664bbc423001 c24b8b70d0f89791 c76c51a30654be30 d192e819d6ef5218 d69906245565a910 f40e35855771202a 106aa07032bbd1b8 19a4c116b8d2d0c8 1e376c085141ab53 2748774cdf8eeb99 34b0bcb5e19b48a8 391c0cb3c5c95a63 4ed8aa4ae3418acb 5b9cca4f7763e373 682e6ff3d6b2b8a3 748f82ee5defb2fc 78a5636f43172f60 84c87814a1f0ab72 8cc702081a6439ec 90befffa23631e28 a4506cebde82bde9 bef9a3f7b2c67915 c67178f2e372532b ca273eceea26619c d186b8c721c0c207 eada7dd6cde0eb1e f57d4f7fee6ed178 06f067aa72176fba 0a637dc5a2c898a6 113f9804bef90dae 1b710b35131c471b 28db77f523047d84 32caab7b40c72493 3c9ebe0a15c9bebc 431d67c49c100d4c 4cc5d4becb3e42b6 597f299cfc657e2a 5fcb6fab3ad6faec 6c44198c4a475817",
      "zh-CHS": "428a2f98d728ae22 7137449123ef65cd b5c0fbcfec4d3b2f e9b5dba58189dbbc 3956c25bf348b538 59F111B605D019 923F82A4 AF194F9B ab1c5ed5da6d8118 d807aa98a3030242 12835b0145706fbe 243185BE4B28C 550C7DC3D5FFB4E2725D74F27B896F 80DEB1696B1 9BDC06A725C717BF696B9CF69269E492EFC145706B9CFC1758CFC1758CFC1757B6CFC1757B6CFC CA52de92c6f592b0275 4A74844AA6EA6E483 5cb0a9dcbd41fbd4 76f988da831153b5 983e5152ee66dfab a831c66d2db43210 b00327c898fb213f BF597FC7EEF04 c6e00bf33da88fc2 d5a79147930aa725 06ca6351e003826f 142929670E6E70 27B70A8546D22Fc 2B1285C26C926 4D2C66DFC50327C898FB213F BF597FC7FC7FC7EEEE4 C6038BF338BF338DF 65A73357C2727C2738B727C2737C2738B7C2738B8B927C2738B738B7C2738B6D8B738B738B738B738D8Ba2bfe8a14cf10364 a81a664bbc423001 c24b8b70d0f89791 c76c51a30654be30 d192e819d6ef5218 D6906245565A910 f40e35855771202a 106aa07032bbd1b8 19a4c116b8d2d0c8 1e376c085141ab53 27487774CDF8EEB99 34b0bcb5e19b48a8 391CB3C595A63 4ed8aa4ae3418acb 5B9CCA4F77638E5672EB8277CF28787B726CFB1676CF786B787B786EC90BEFFA23631E28 a4506cebde82bde9 bef9a3f7b2c67915 c67178f2e372532b CA273ECEA26619C D186B8C721C207 eada7dd6cde0eb1e F57D4F7D7F7F7F7F7F7F7F7F7F7F7D7FEE178 06f067aa72176fba 0A637DC5A2C898A6113F9804BEF7D7B7B35131B1B 2877F523047D84 CAAB7B40C72493 3CEBE0A15C 431D7C467C49C100D7CFC4657F7B7B7B7B7B7B7B7B7B7B7B7B7B7B7B7B7B7B7B7B7B7B7B7B7B7B"
    },
    {
      "indent": 0,
      "text": "6. Computing the Message Digest",
      "section_title": true,
      "zh-CHS": "6. 计算消息摘要"
    },
    {
      "indent": 3,
      "text": "The output of each of the secure hash functions, after being applied to a message of N blocks, is the hash quantity H(N). For SHA-224 and SHA-256, H(i) can be considered to be eight 32-bit words, H(i)0, H(i)1, ... H(i)7. For SHA-384 and SHA-512, it can be considered to be eight 64-bit words, H(i)0, H(i)1, ..., H(i)7.",
      "zh-CHS": "在应用于N个块的消息之后，每个安全散列函数的输出是散列量H（N）。对于SHA-224和SHA-256，H（i）可以被认为是八个32位字，H（i）0，H（i）1。。。H（i）7。对于SHA-384和SHA-512，它可以被认为是八个64位字，H（i）0，H（i）1，…，H（i）7。"
    },
    {
      "indent": 3,
      "text": "As described below, the hash words are initialized, modified as each message block is processed, and finally concatenated after processing the last block to yield the output. For SHA-256 and SHA-512, all of the H(N) variables are concatenated while the SHA-224 and SHA-384 hashes are produced by omitting some from the final concatenation.",
      "zh-CHS": "如下所述，在处理每个消息块时初始化、修改散列字，并在处理最后一个块后最终连接以产生输出。对于SHA-256和SHA-512，所有H（N）变量都被串联，而SHA-224和SHA-384散列是通过从最终串联中省略一些来生成的。"
    },
    {
      "indent": 0,
      "text": "6.1. SHA-224 and SHA-256 Initialization",
      "section_title": true,
      "zh-CHS": "6.1. SHA-224和SHA-256初始化"
    },
    {
      "indent": 3,
      "text": "For SHA-224, the initial hash value, H(0), consists of the following 32-bit words in hex:",
      "zh-CHS": "对于SHA-224，初始哈希值H（0）由以下十六进制32位字组成："
    },
    {
      "indent": 6,
      "text": "H(0)0 = c1059ed8\nH(0)1 = 367cd507\nH(0)2 = 3070dd17\nH(0)3 = f70e5939\nH(0)4 = ffc00b31\nH(0)5 = 68581511\nH(0)6 = 64f98fa7\nH(0)7 = befa4fa4",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "For SHA-256, the initial hash value, H(0), consists of the following eight 32-bit words, in hex. These words were obtained by taking the first 32 bits of the fractional parts of the square roots of the first eight prime numbers.",
      "zh-CHS": "对于SHA-256，初始哈希值H（0）由以下八个32位十六进制字组成。这些字是通过取前八个素数的平方根的小数部分的前32位获得的。"
    },
    {
      "indent": 6,
      "text": "H(0)0 = 6a09e667\nH(0)1 = bb67ae85\nH(0)2 = 3c6ef372\nH(0)3 = a54ff53a\nH(0)4 = 510e527f\nH(0)5 = 9b05688c\nH(0)6 = 1f83d9ab\nH(0)7 = 5be0cd19",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "6.2. SHA-224 and SHA-256 Processing",
      "section_title": true,
      "zh-CHS": "6.2. SHA-224和SHA-256处理"
    },
    {
      "indent": 3,
      "text": "SHA-224 and SHA-256 perform identical processing on message blocks and differ only in how H(0) is initialized and how they produce their final output. They may be used to hash a message, M, having a length of L bits, where 0 <= L < 2^64. The algorithm uses (1) a message schedule of sixty-four 32-bit words, (2) eight working variables of 32 bits each, and (3) a hash value of eight 32-bit words.",
      "zh-CHS": "SHA-224和SHA-256对消息块执行相同的处理，仅在H（0）的初始化方式和生成最终输出的方式上有所不同。它们可用于散列长度为L位的消息M，其中0<=L<2^64。该算法使用（1）64个32位字的消息调度，（2）每个32位的8个工作变量，以及（3）8个32位字的哈希值。"
    },
    {
      "indent": 3,
      "text": "The words of the message schedule are labeled W0, W1, ..., W63. The eight working variables are labeled a, b, c, d, e, f, g, and h. The words of the hash value are labeled H(i)0, H(i)1, ..., H(i)7, which will hold the initial hash value, H(0), replaced by each successive intermediate hash value (after each message block is processed), H(i), and ending with the final hash value, H(N), after all N blocks are processed. They also use two temporary words, T1 and T2.",
      "zh-CHS": "消息调度的单词标记为W0、W1、…、W63。八个工作变量分别标记为a、b、c、d、e、f、g和h。散列值的字被标记为H（i）0、H（i）1、…、H（i）7，其将保持初始散列值H（0），由每个连续的中间散列值（在处理每个消息块之后）H（i）替换，并在处理所有N个块之后以最终散列值H（N）结束。他们还使用两个临时单词，T1和T2。"
    },
    {
      "indent": 3,
      "text": "The input message is padded as described in Section 4.1 above, then parsed into 512-bit blocks that are considered to be composed of sixteen 32-bit words M(i)0, M(i)1, ..., M(i)15. The following computations are then performed for each of the N message blocks. All addition is performed modulo 2^32.",
      "zh-CHS": "如上文第4.1节所述，对输入消息进行填充，然后将其解析为512位块，这些块被视为由十六个32位字M（i）0、M（i）1、…、M（i）15组成。然后对N个消息块中的每一个执行以下计算。所有加法均以2^32的模进行。"
    },
    {
      "indent": 3,
      "text": "For i = 1 to N",
      "zh-CHS": "对于i=1到N"
    },
    {
      "indent": 6,
      "text": "1. Prepare the message schedule W: For t = 0 to 15 Wt = M(i)t For t = 16 to 63 Wt = SSIG1(W(t-2)) + W(t-7) + SSIG0(w(t-15)) + W(t-16)",
      "zh-CHS": "1. 准备消息时间表W：对于t=0到15，Wt=M（i）t对于t=16到63，Wt=SSIG1（W（t-2））+W（t-7）+SSIG0（W（t-15））+W（t-16）"
    },
    {
      "indent": 6,
      "text": "2. Initialize the working variables: a = H(i-1)0 b = H(i-1)1 c = H(i-1)2 d = H(i-1)3 e = H(i-1)4 f = H(i-1)5 g = H(i-1)6 h = H(i-1)7",
      "zh-CHS": "2. 初始化工作变量：a=H（i-1）0b=H（i-1）1c=H（i-1）2d=H（i-1）3e=H（i-1）4f=H（i-1）5g=H（i-1）6h=H（i-1）7"
    },
    {
      "indent": 6,
      "text": "3. Perform the main hash computation: For t = 0 to 63 T1 = h + BSIG1(e) + CH(e,f,g) + Kt + Wt T2 = BSIG0(a) + MAJ(a,b,c) h = g g = f f = e e = d + T1 d = c c = b b = a a = T1 + T2",
      "zh-CHS": "3. 执行主散列计算：对于t=0到63 T1=h+BSIG1（e）+CH（e，f，g）+Kt+Wt T2=BSIG0（a）+MAJ（a，b，c）h=g g=f=e=d+T1 d=c=b=a=T1+T2"
    },
    {
      "indent": 6,
      "text": "4. Compute the intermediate hash value H(i) H(i)0 = a + H(i-1)0 H(i)1 = b + H(i-1)1 H(i)2 = c + H(i-1)2 H(i)3 = d + H(i-1)3 H(i)4 = e + H(i-1)4 H(i)5 = f + H(i-1)5 H(i)6 = g + H(i-1)6 H(i)7 = h + H(i-1)7",
      "zh-CHS": "4. 计算中间散列值H（i）H（i）0=a+H（i-1）0h（i）1=b+H（i-1）1h（i）2=c+H（i-1）2h（i）3=d+H（i-1）3h（i）4=e+H（i-1）4h（i）5=f+H（i-1）5h（i）6=g+H（i-1）6h（i）7=H+H（i-1）7"
    },
    {
      "indent": 3,
      "text": "After the above computations have been sequentially performed for all of the blocks in the message, the final output is calculated. For SHA-256, this is the concatenation of all of H(N)0, H(N)1, through H(N)7. For SHA-224, this is the concatenation of H(N)0, H(N)1, through H(N)6.",
      "zh-CHS": "在对消息中的所有块顺序执行上述计算之后，计算最终输出。对于SHA-256，这是所有H（N）0、H（N）1到H（N）7的串联。对于SHA-224，这是H（N）0，H（N）1到H（N）6的串联。"
    },
    {
      "indent": 0,
      "text": "6.3. SHA-384 and SHA-512 Initialization",
      "section_title": true,
      "zh-CHS": "6.3. SHA-384和SHA-512初始化"
    },
    {
      "indent": 3,
      "text": "For SHA-384, the initial hash value, H(0), consists of the following eight 64-bit words, in hex. These words were obtained by taking the first 64 bits of the fractional parts of the square roots of the ninth through sixteenth prime numbers.",
      "zh-CHS": "对于SHA-384，初始哈希值H（0）由以下八个64位十六进制字组成。这些字是从第九个到第十六个素数的平方根的小数部分的前64位获得的。"
    },
    {
      "indent": 9,
      "text": "H(0)0 = cbbb9d5dc1059ed8\nH(0)1 = 629a292a367cd507\nH(0)2 = 9159015a3070dd17\nH(0)3 = 152fecd8f70e5939\nH(0)4 = 67332667ffc00b31\nH(0)5 = 8eb44a8768581511\nH(0)6 = db0c2e0d64f98fa7\nH(0)7 = 47b5481dbefa4fa4",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "For SHA-512, the initial hash value, H(0), consists of the following eight 64-bit words, in hex. These words were obtained by taking the first 64 bits of the fractional parts of the square roots of the first eight prime numbers.",
      "zh-CHS": "对于SHA-512，初始哈希值H（0）由以下八个64位十六进制字组成。这些字是通过取前八个素数的平方根的分数部分的前64位获得的。"
    },
    {
      "indent": 9,
      "text": "H(0)0 = 6a09e667f3bcc908\nH(0)1 = bb67ae8584caa73b\nH(0)2 = 3c6ef372fe94f82b\nH(0)3 = a54ff53a5f1d36f1\nH(0)4 = 510e527fade682d1\nH(0)5 = 9b05688c2b3e6c1f\nH(0)6 = 1f83d9abfb41bd6b\nH(0)7 = 5be0cd19137e2179",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "6.4. SHA-384 and SHA-512 Processing",
      "section_title": true,
      "zh-CHS": "6.4. SHA-384和SHA-512处理"
    },
    {
      "indent": 3,
      "text": "SHA-384 and SHA-512 perform identical processing on message blocks and differ only in how H(0) is initialized and how they produce their final output. They may be used to hash a message, M, having a length of L bits, where 0 <= L < 2^128. The algorithm uses (1) a message schedule of eighty 64-bit words, (2) eight working variables of 64 bits each, and (3) a hash value of eight 64-bit words.",
      "zh-CHS": "SHA-384和SHA-512对消息块执行相同的处理，不同之处仅在于H（0）的初始化方式和生成最终输出的方式。它们可用于散列长度为L位的消息M，其中0<=L<2^128。该算法使用（1）八十个64位字的消息调度，（2）每个64位的八个工作变量，以及（3）八个64位字的哈希值。"
    },
    {
      "indent": 3,
      "text": "The words of the message schedule are labeled W0, W1, ..., W79. The eight working variables are labeled a, b, c, d, e, f, g, and h. The words of the hash value are labeled H(i)0, H(i)1, ..., H(i)7, which will hold the initial hash value, H(0), replaced by each successive intermediate hash value (after each message block is processed), H(i), and ending with the final hash value, H(N) after all N blocks are processed.",
      "zh-CHS": "消息调度的单词标记为W0、W1、…、W79。八个工作变量分别标记为a、b、c、d、e、f、g和h。散列值的字被标记为H（i）0、H（i）1、…、H（i）7，其将保持初始散列值H（0），由每个连续的中间散列值（在处理每个消息块之后）H（i）替换，并在处理所有N个块之后以最终散列值H（N）结束。"
    },
    {
      "indent": 3,
      "text": "The input message is padded as described in Section 4.2 above, then parsed into 1024-bit blocks that are considered to be composed of sixteen 64-bit words M(i)0, M(i)1, ..., M(i)15. The following computations are then performed for each of the N message blocks. All addition is performed modulo 2^64.",
      "zh-CHS": "如上文第4.2节所述，对输入消息进行填充，然后将其解析为1024位块，这些块被视为由十六个64位字M（i）0、M（i）1、…、M（i）15组成。然后对N个消息块中的每一个执行以下计算。所有加法均以2^64模进行。"
    },
    {
      "indent": 3,
      "text": "For i = 1 to N",
      "zh-CHS": "对于i=1到N"
    },
    {
      "indent": 6,
      "text": "1. Prepare the message schedule W: For t = 0 to 15 Wt = M(i)t For t = 16 to 79 Wt = SSIG1(W(t-2)) + W(t-7) + SSIG0(W(t-15)) + W(t-16)",
      "zh-CHS": "1. 准备消息时间表W：对于t=0到15 Wt=M（i）t对于t=16到79 Wt=SSIG1（W（t-2））+W（t-7）+SSIG0（W（t-15））+W（t-16）"
    },
    {
      "indent": 6,
      "text": "2. Initialize the working variables: a = H(i-1)0 b = H(i-1)1 c = H(i-1)2 d = H(i-1)3 e = H(i-1)4 f = H(i-1)5 g = H(i-1)6 h = H(i-1)7",
      "zh-CHS": "2. 初始化工作变量：a=H（i-1）0b=H（i-1）1c=H（i-1）2d=H（i-1）3e=H（i-1）4f=H（i-1）5g=H（i-1）6h=H（i-1）7"
    },
    {
      "indent": 6,
      "text": "3. Perform the main hash computation: For t = 0 to 79 T1 = h + BSIG1(e) + CH(e,f,g) + Kt + Wt T2 = BSIG0(a) + MAJ(a,b,c) h = g g = f f = e e = d + T1 d = c c = b b = a a = T1 + T2",
      "zh-CHS": "3. 执行主散列计算：对于t=0到79 T1=h+BSIG1（e）+CH（e，f，g）+Kt+Wt T2=BSIG0（a）+MAJ（a，b，c）h=g g=f=e=d+T1 d=c=b=a=T1+T2"
    },
    {
      "indent": 9,
      "text": "4. Compute the intermediate hash value H(i) H(i)0 = a + H(i-1)0 H(i)1 = b + H(i-1)1 H(i)2 = c + H(i-1)2 H(i)3 = d + H(i-1)3 H(i)4 = e + H(i-1)4 H(i)5 = f + H(i-1)5 H(i)6 = g + H(i-1)6 H(i)7 = h + H(i-1)7",
      "zh-CHS": "4. 计算中间散列值H（i）H（i）0=a+H（i-1）0h（i）1=b+H（i-1）1h（i）2=c+H（i-1）2h（i）3=d+H（i-1）3h（i）4=e+H（i-1）4h（i）5=f+H（i-1）5h（i）6=g+H（i-1）6h（i）7=H+H（i-1）7"
    },
    {
      "indent": 3,
      "text": "After the above computations have been sequentially performed for all of the blocks in the message, the final output is calculated. For SHA-512, this is the concatenation of all of H(N)0, H(N)1, through H(N)7. For SHA-384, this is the concatenation of H(N)0, H(N)1, through H(N)5.",
      "zh-CHS": "在对消息中的所有块顺序执行上述计算之后，计算最终输出。对于SHA-512，这是所有H（N）0、H（N）1到H（N）7的串联。对于SHA-384，这是H（N）0，H（N）1到H（N）5的串联。"
    },
    {
      "indent": 0,
      "text": "7. HKDF- and SHA-Based HMACs",
      "section_title": true,
      "zh-CHS": "7. 香港国防军-以沙田及沙田为基地的医疗卫生中心"
    },
    {
      "indent": 3,
      "text": "Below are brief descriptions and pointers to more complete descriptions and code for (1) SHA-based HMACs and (2) an HMAC-based extract-and-expand key derivation function. Both HKDF and HMAC were devised by Hugo Krawczyk.",
      "zh-CHS": "下面是（1）基于SHA的HMAC和（2）基于HMAC的提取和扩展密钥派生函数的更完整描述和代码的简要说明和指针。HKDF和HMAC都是由雨果·克劳奇克设计的。"
    },
    {
      "indent": 0,
      "text": "7.1. SHA-Based HMACs",
      "section_title": true,
      "zh-CHS": "7.1. 基于SHA的HMAC"
    },
    {
      "indent": 3,
      "text": "HMAC is a method for computing a keyed MAC (Message Authentication Code) using a hash function as described in [RFC2104]. It uses a key to mix in with the input text to produce the final hash.",
      "zh-CHS": "HMAC是一种使用[RFC2104]中所述的哈希函数计算密钥MAC（消息认证码）的方法。它使用一个键与输入文本混合生成最终的散列。"
    },
    {
      "indent": 3,
      "text": "Sample code is also provided, in Section 8.3 below, to perform HMAC based on any of the SHA algorithms described herein. The sample code found in [RFC2104] was written in terms of a specified text size. Since SHA is defined in terms of an arbitrary number of bits, the sample HMAC code has been written to allow the text input to HMAC to have an arbitrary number of octets and bits. A fixed-length interface is also provided.",
      "zh-CHS": "下面第8.3节还提供了示例代码，用于根据本文所述的任何SHA算法执行HMAC。[RFC2104]中的示例代码是按照指定的文本大小编写的。由于SHA是根据任意数量的位定义的，因此编写的示例HMAC代码允许输入到HMAC的文本具有任意数量的八位字节和位。还提供了固定长度的接口。"
    },
    {
      "indent": 0,
      "text": "7.2. HKDF",
      "section_title": true,
      "zh-CHS": "7.2. 香港发展基金"
    },
    {
      "indent": 3,
      "text": "HKDF is a specific Key Derivation Function (KDF), that is, a function of initial keying material from which the KDF derives one or more cryptographically strong secret keys. HKDF, which is described in [RFC5869], is based on HMAC.",
      "zh-CHS": "HKDF是一种特定密钥派生函数（KDF），即初始密钥材料的函数，KDF从中派生一个或多个加密强密钥。[RFC5869]中描述的HKDF基于HMAC。"
    },
    {
      "indent": 3,
      "text": "Sample code for HKDF is provided in Section 8.4 below.",
      "zh-CHS": "HKDF的示例代码见下文第8.4节。"
    },
    {
      "indent": 0,
      "text": "8. C Code for SHAs, HMAC, and HKDF",
      "section_title": true,
      "zh-CHS": "8. C SHAs、HMAC和HKDF的代码"
    },
    {
      "indent": 3,
      "text": "Below is a demonstration implementation of these secure hash functions in C. Section 8.1 contains the header file sha.h that declares all constants, structures, and functions used by the SHA and HMAC functions. It includes conditionals based on the state of definition of USE_32BIT_ONLY that, if that symbol is defined at compile time, avoids 64-bit operations. It also contains sha-private.h that provides some declarations common to all the SHA functions. Section 8.2 contains the C code for sha1.c, sha224-256.c, sha384-512.c, and usha.c. Section 8.3 contains the C code for the HMAC functions, and Section 8.4 contains the C code for HKDF. Section 8.5 contains a test driver to exercise the code.",
      "zh-CHS": "下面是C中这些安全哈希函数的演示实现。第8.1节包含头文件sha.h，它声明了sha和HMAC函数使用的所有常量、结构和函数。它包括基于USE_32BIT_定义状态的条件，如果该符号是在编译时定义的，则该条件可以避免64位操作。它还包含sha private.h，它提供了所有sha函数通用的一些声明。第8.2节包含sha1.C、sha224-256.C、sha384-512.C和usha.C的C代码。第8.3节包含HMAC功能的C代码，第8.4节包含HKDF的C代码。第8.5节包含一个测试驱动程序，用于执行代码。"
    },
    {
      "indent": 3,
      "text": "For each of the digest lengths $$$, there is the following set of constants, a structure, and functions:",
      "zh-CHS": "对于每个摘要长度$$$，有以下一组常量、结构和函数："
    },
    {
      "indent": 3,
      "text": "Constants: SHA$$$HashSize number of octets in the hash SHA$$$HashSizeBits number of bits in the hash SHA$$$_Message_Block_Size number of octets used in the intermediate message blocks Most functions return an enum value that is one of: shaSuccess(0) on success shaNull(1) when presented with a null pointer parameter shaInputTooLong(2) when the input data is too long shaStateError(3) when SHA$$$Input is called after SHA$$$FinalBits or SHA$$$Result",
      "zh-CHS": "常量：SHA$$$HashSize哈希中的八位字节数SHA$$$HashSizeBits哈希中的位数SHA$$$\\u消息\\u块\\u中间消息块中使用的八位字节数大多数函数在显示空指针参数SHAINTOOLONG（2）时返回的枚举值为：SHASCESS（0）on success shaNull（1）之一输入数据过长时，在SHA$$$$FinalBits或SHA$$$Result之后调用SHA$$$$input时出现错误（3）"
    },
    {
      "indent": 3,
      "text": "Structure: typedef SHA$$$Context an opaque structure holding the complete state for producing the hash",
      "zh-CHS": "Structure:typedef SHA$$$Context一个不透明的结构，包含生成哈希的完整状态"
    },
    {
      "indent": 3,
      "text": "Functions:\n   int SHA$$$Reset(SHA$$$Context *context);\n         Reset the hash context state.\n   int SHA$$$Input(SHA$$$Context *context, const uint8_t *octets,\n               unsigned int bytecount);\n         Incorporate bytecount octets into the hash.\n   int SHA$$$FinalBits(SHA$$$Context *, const uint8_t octet,\n               unsigned int bitcount);\n         Incorporate bitcount bits into the hash.  The bits are in\n         the upper portion of the octet.  SHA$$$Input() cannot be\n         called after this.\n   int SHA$$$Result(SHA$$$Context *,\n               uint8_t Message_Digest[SHA$$$HashSize]);\n         Do the final calculations on the hash and copy the value\n         into Message_Digest.",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "In addition, functions with the prefix USHA are provided that take a SHAversion value (SHA$$$) to select the SHA function suite. They add the following constants, structure, and functions:",
      "zh-CHS": "此外，还提供了前缀为USHA的函数，这些函数采用SHAversion值（SHA$$$）来选择SHA函数套件。它们添加了以下常量、结构和函数："
    },
    {
      "indent": 3,
      "text": "Constants: shaBadParam(4) constant returned by USHA functions when presented with a bad SHAversion (SHA$$$) parameter or other illegal parameter values USAMaxHashSize maximum of the SHA hash sizes SHA$$$ SHAversion enumeration values, used by USHA, HMAC, and HKDF functions to select the SHA function suite",
      "zh-CHS": "常量：USHA函数在显示错误的SHAversion（SHA$$$）参数或其他非法参数值时返回的ShabaParam（4）常量USAMaxHashSize SHA哈希大小SHA$$$SHAversion枚举值的最大值，USHA、HMAC和HKDF函数用于选择SHA函数套件"
    },
    {
      "indent": 3,
      "text": "Structure: typedef USHAContext an opaque structure holding the complete state for producing the hash",
      "zh-CHS": "Structure:typedef-USHAContext一个不透明的结构，包含生成散列的完整状态"
    },
    {
      "indent": 3,
      "text": "Functions:\n   int USHAReset(USHAContext *context, SHAversion whichSha);\n         Reset the hash context state.\n   int USHAInput(USHAContext context*,\n               const uint8_t *bytes, unsigned int bytecount);\n         Incorporate bytecount octets into the hash.\n   int USHAFinalBits(USHAContext *context,\n               const uint8_t bits, unsigned int bitcount);\n         Incorporate bitcount bits into the hash.\n   int USHAResult(USHAContext *context,\n               uint8_t Message_Digest[USHAMaxHashSize]);\n         Do the final calculations on the hash and copy the value\n         into Message_Digest.  Octets in Message_Digest beyond\n         USHAHashSize(whichSha) are left untouched.\n   int USHAHashSize(enum SHAversion whichSha);\n         The number of octets in the given hash.\n   int USHAHashSizeBits(enum SHAversion whichSha);\n         The number of bits in the given hash.\n   int USHABlockSize(enum SHAversion whichSha);\n         The internal block size for the given hash.\n   const char *USHAHashName(enum SHAversion whichSha);\n         This function will return the name of the given SHA\n         algorithm as a string.",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The HMAC functions follow the same pattern to allow any length of text input to be used.",
      "zh-CHS": "HMAC函数遵循相同的模式，允许使用任意长度的文本输入。"
    },
    {
      "indent": 3,
      "text": "Structure: typedef HMACContext an opaque structure holding the complete state for producing the keyed message digest (MAC)",
      "zh-CHS": "Structure:typedef hmacontext一种不透明结构，用于保存生成键控消息摘要（MAC）的完整状态"
    },
    {
      "indent": 3,
      "text": "Functions:\n   int hmacReset(HMACContext *ctx, enum SHAversion whichSha,\n               const unsigned char *key, int key_len);\n         Reset the MAC context state.\n   int hmacInput(HMACContext *ctx, const unsigned char *text,\n               int text_len);\n         Incorporate text_len octets into the MAC.\n   int hmacFinalBits(HMACContext *ctx, const uint8_t bits,\n               unsigned int bitcount);\n         Incorporate bitcount bits into the MAC.\n   int hmacResult(HMACContext *ctx,\n               uint8_t Message_Digest[USHAMaxHashSize]);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 12,
      "text": "Do the final calculations on the MAC and copy the value into Message_Digest. Octets in Message_Digest beyond USHAHashSize(whichSha) are left untouched.",
      "zh-CHS": "在MAC上进行最终计算，并将值复制到消息摘要中。信息摘要中的八位位组在USHAHashSize（whichSha）之外保持不变。"
    },
    {
      "indent": 3,
      "text": "In addition, a combined interface is provided, similar to that shown in [RFC2104], that allows a fixed-length text input to be used.",
      "zh-CHS": "此外，还提供了一个类似于[RFC2104]中所示的组合接口，该接口允许使用固定长度的文本输入。"
    },
    {
      "indent": 6,
      "text": "int hmac(SHAversion whichSha, const unsigned char *text, int text_len, const unsigned char *key, int key_len, uint8_t Message_Digest[USHAMaxHashSize]); Calculate the given digest for the given text and key, and return the resulting MAC. Octets in Message_Digest beyond USHAHashSize(whichSha) are left untouched.",
      "zh-CHS": "int-hmac（SHAversion whichha，const unsigned char*text，int text_len，const unsigned char*key，int key_len，uint8_t Message_Digest[USHAMaxHashSize]）；计算给定文本和键的给定摘要，并返回结果MAC。信息摘要中的八位位组在USHAHashSize（whichSha）之外保持不变。"
    },
    {
      "indent": 3,
      "text": "The HKDF functions follow the same pattern to allow any length of text input to be used.",
      "zh-CHS": "HKDF函数遵循相同的模式，允许使用任意长度的文本输入。"
    },
    {
      "indent": 3,
      "text": "Structure: typedef HKDFContext an opaque structure holding the complete state for producing the keying material Functions: int hkdfReset(HKDFContext *context, enum SHAversion whichSha, const unsigned char *salt, int salt_len) Reset the key derivation state and initialize it with the salt_len octets of the optional salt. int hkdfInput(HKDFContext *context, const unsigned char *ikm, int ikm_len) Incorporate ikm_len octets into the entropy extractor. int hkdfFinalBits(HKDFContext *context, uint8_t ikm_bits, unsigned int ikm_bit_count) Incorporate ikm_bit_count bits into the entropy extractor. int hkdfResult(HKDFContext *context, uint8_t prk[USHAMaxHashSize], const unsigned char *info, int info_len, uint8_t okm[ ], int okm_len) Finish the HKDF extraction and perform the final HKDF expansion, storing the okm_len octets into output keying material (okm). Optionally store the pseudo-random key (prk) that is generated internally.",
      "zh-CHS": "结构：typedef HKDFContext一个不透明的结构，保存生成键控材质函数的完整状态：int hkdfsreset（HKDFContext*context，enum SHAversion whichha，const unsigned char*salt，int salt_len）重置键派生状态，并用可选salt的salt_len八位字节对其进行初始化。int hkdfInput（HKDFContext*context，const unsigned char*ikm，int ikm_len）将ikm_len八位字节合并到熵提取器中。int hkdfFinalBits（HKDFContext*上下文、uint8_t ikm_位、无符号int ikm_位计数）将ikm_位计数位合并到熵提取器中。int hkdfResult（HKDFContext*context，uint8_t prk[USHAMaxHashSize]，const unsigned char*info，int info_len，uint8_t okm[]，int okm_len）完成HKDF提取并执行最终HKDF扩展，将okm_len八位字节存储到输出键控材料（okm）中。可以选择存储内部生成的伪随机密钥（prk）。"
    },
    {
      "indent": 3,
      "text": "In addition, combined interfaces are provided, similar to that shown in [RFC5869], that allows a fixed-length text input to be used.",
      "zh-CHS": "此外，还提供了与[RFC5869]中所示类似的组合接口，允许使用固定长度的文本输入。"
    },
    {
      "indent": 6,
      "text": "int hkdfExtract(SHAversion whichSha, const unsigned char *salt, int salt_len, const unsigned char *ikm, int ikm_len, uint8_t prk[USHAMaxHashSize])",
      "zh-CHS": "int hkdfExtract（sha、const unsigned char*salt、int salt_len、const unsigned char*ikm、int ikm_len、uint8_t prk[USHAMaxHashSize]）"
    },
    {
      "indent": 12,
      "text": "Perform HKDF extraction, combining the salt_len octets of the optional salt with the ikm_len octets of the input keying material (ikm) to form the pseudo-random key prk. The output prk must be large enough to hold the octets appropriate for the given hash type.",
      "zh-CHS": "执行HKDF提取，将可选salt的salt_len八位字节与输入键控材料（ikm）的ikm len八位字节组合，以形成伪随机密钥prk。输出prk必须足够大，以容纳适合给定哈希类型的八位字节。"
    },
    {
      "indent": 6,
      "text": "int hkdfExpand(SHAversion whichSha, const uint8_t prk[ ], int prk_len, const unsigned char *info, int info_len, uint8_t okm[ ], int okm_len) Perform HKDF expansion, combining the prk_len octets of the pseudo-random key prk with the info_len octets of info to form the okm_len octets stored in okm.",
      "zh-CHS": "int hkdfExpand（sha，const uint8_t prk[]，int prk_len，const unsigned char*info，int info_len，uint8_t okm[]，int okm_len）执行HKDF扩展，将伪随机密钥prk的prk_len八进制与info的info_len八进制组合，形成存储在okm中的okm_len八进制。"
    },
    {
      "indent": 6,
      "text": "int hkdf(SHAversion whichSha, const unsigned char *salt, int salt_len, const unsigned char *ikm, int ikm_len, const unsigned char *info, int info_len, uint8_t okm[ ], int okm_len) This combined interface performs both HKDF extraction and expansion. The variables are the same as in hkdfExtract() and hkdfExpand().",
      "zh-CHS": "int hkdf（SHAversion whichSha，const unsigned char*salt，int salt_len，const unsigned char*ikm，int ikm_len，const unsigned char*info，int info_len，uint8_t okm[]，int okm_len）此组合接口执行hkdf提取和扩展。变量与hkdfExtract（）和hkdfExpand（）中的变量相同。"
    },
    {
      "indent": 0,
      "text": "8.1. The Header Files",
      "section_title": true,
      "zh-CHS": "8.1. 头文件"
    },
    {
      "indent": 0,
      "text": "8.1.1. The .h file",
      "section_title": true,
      "zh-CHS": "8.1.1. .h文件"
    },
    {
      "indent": 3,
      "text": "The following sha.h file, as stated in the comments within the file, assumes that <stdint.h> is available on your system. If it is not, you should change to including <stdint-example.h>, provided in Section 8.1.2, or the like.",
      "zh-CHS": "下面的sha.h文件（如文件中的注释所述）假定<stdint.h>在您的系统上可用。如果不是，则应更改为包括第8.1.2节中提供的<stdint example.h>，或类似内容。"
    },
    {
      "indent": 0,
      "text": "/**************************** sha.h ****************************/\n/***************** See RFC 6234 for details. *******************/\n/*\n   Copyright (c) 2011 IETF Trust and the persons identified as\n   authors of the code.  All rights reserved.",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:",
      "zh-CHS": "在满足以下条件的情况下，允许以源代码和二进制格式重新分发和使用，无论是否修改："
    },
    {
      "indent": 3,
      "text": "- Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.",
      "zh-CHS": "- 源代码的重新分发必须保留上述版权声明、此条件列表和以下免责声明。"
    },
    {
      "indent": 3,
      "text": "- Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.",
      "zh-CHS": "- 以二进制形式重新分发时，必须在分发时提供的文档和/或其他材料中复制上述版权声明、本条件列表和以下免责声明。"
    },
    {
      "indent": 3,
      "text": "- Neither the name of Internet Society, IETF or IETF Trust, nor the names of specific contributors, may be used to endorse or promote products derived from this software without specific prior written permission.",
      "zh-CHS": "- 未经事先书面许可，不得使用互联网协会、IETF或IETF Trust的名称或特定贡献者的名称来认可或推广源自本软件的产品。"
    },
    {
      "indent": 0,
      "text": " THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */ #ifndef _SHA_H_ #define _SHA_H_",
      "zh-CHS": "本软件由版权所有者和贡献者“按原样”提供，不承担任何明示或暗示的担保，包括但不限于对适销性和特定用途适用性的暗示担保。在任何情况下，版权所有人或贡献者均不对任何直接、间接、偶然、特殊、惩戒性或后果性损害（包括但不限于替代商品或服务的采购；使用、数据或利润的损失；或业务中断）负责，无论是在合同中还是在任何责任理论下，严格责任，或因使用本软件而产生的侵权行为（包括疏忽或其他），即使告知可能发生此类损害。*/#如果没有定义_"
    },
    {
      "indent": 0,
      "text": "/*\n *  Description:\n *      This file implements the Secure Hash Algorithms\n *      as defined in the U.S. National Institute of Standards\n *      and Technology Federal Information Processing Standards\n *      Publication (FIPS PUB) 180-3 published in October 2008\n *      and formerly defined in its predecessors, FIPS PUB 180-1\n *      and FIP PUB 180-2.\n *\n *      A combined document showing all algorithms is available at\n *              http://csrc.nist.gov/publications/fips/\n *                     fips180-3/fips180-3_final.pdf\n *\n *      The five hashes are defined in these sizes:\n *              SHA-1           20 byte / 160 bit\n *              SHA-224         28 byte / 224 bit\n *              SHA-256         32 byte / 256 bit\n *              SHA-384         48 byte / 384 bit\n *              SHA-512         64 byte / 512 bit\n *",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 1,
      "text": "* Compilation Note: * These files may be compiled with two options: * USE_32BIT_ONLY - use 32-bit arithmetic only, for systems * without 64-bit integers * * USE_MODIFIED_MACROS - use alternate form of the SHA_Ch() * and SHA_Maj() macros that are equivalent * and potentially faster on many systems * */",
      "zh-CHS": "* 编译说明：*这些文件可以使用两个选项进行编译：*仅使用_32位\\u-仅使用32位算术，对于没有64位整数的系统**使用修改的_宏-使用替代形式的SHA_Ch（）*和SHA_Maj（）宏，这两种宏等效*并且在许多系统上可能更快**/"
    },
    {
      "indent": 0,
      "text": "#include <stdint.h>\n/*\n * If you do not have the ISO standard stdint.h header file, then you\n * must typedef the following:\n *    name              meaning\n *  uint64_t         unsigned 64-bit integer\n *  uint32_t         unsigned 32-bit integer\n *  uint8_t          unsigned 8-bit integer (i.e., unsigned char)\n *  int_least16_t    integer of >= 16 bits\n *\n * See stdint-example.h\n */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "#ifndef _SHA_enum_\n#define _SHA_enum_\n/*\n *  All SHA functions return one of these values.\n */\nenum {\n    shaSuccess = 0,\n    shaNull,            /* Null pointer parameter */\n    shaInputTooLong,    /* input data too long */\n    shaStateError,      /* called Input after FinalBits or Result */\n    shaBadParam         /* passed a bad parameter */\n};\n#endif /* _SHA_enum_ */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n *  These constants hold size information for each of the SHA\n *  hashing operations\n */\nenum {\n    SHA1_Message_Block_Size = 64, SHA224_Message_Block_Size = 64,\n    SHA256_Message_Block_Size = 64, SHA384_Message_Block_Size = 128,\n    SHA512_Message_Block_Size = 128,\n    USHA_Max_Message_Block_Size = SHA512_Message_Block_Size,",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "SHA1HashSize = 20, SHA224HashSize = 28, SHA256HashSize = 32, SHA384HashSize = 48, SHA512HashSize = 64, USHAMaxHashSize = SHA512HashSize,",
      "zh-CHS": "SHA1HashSize=20，SHA224HashSize=28，SHA256HashSize=32，SHA384HashSize=48，SHA512HashSize=64，USHAMaxHashSize=SHA512HashSize，"
    },
    {
      "indent": 0,
      "text": "    SHA1HashSizeBits = 160, SHA224HashSizeBits = 224,\n    SHA256HashSizeBits = 256, SHA384HashSizeBits = 384,\n    SHA512HashSizeBits = 512, USHAMaxHashSizeBits = SHA512HashSizeBits\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n *  These constants are used in the USHA (Unified SHA) functions.\n */\ntypedef enum SHAversion {\n    SHA1, SHA224, SHA256, SHA384, SHA512\n} SHAversion;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n *  This structure will hold context information for the SHA-1\n *  hashing operation.\n */\ntypedef struct SHA1Context {\n    uint32_t Intermediate_Hash[SHA1HashSize/4]; /* Message Digest */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "uint32_t Length_High;               /* Message length in bits */\nuint32_t Length_Low;                /* Message length in bits */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "int_least16_t Message_Block_Index;  /* Message_Block array index */\n                                    /* 512-bit message blocks */\nuint8_t Message_Block[SHA1_Message_Block_Size];",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "    int Computed;                   /* Is the hash computed? */\n    int Corrupted;                  /* Cumulative corruption code */\n} SHA1Context;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n *  This structure will hold context information for the SHA-256\n *  hashing operation.\n */\ntypedef struct SHA256Context {\n    uint32_t Intermediate_Hash[SHA256HashSize/4]; /* Message Digest */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "uint32_t Length_High;               /* Message length in bits */\nuint32_t Length_Low;                /* Message length in bits */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "int_least16_t Message_Block_Index;  /* Message_Block array index */\n                                    /* 512-bit message blocks */\nuint8_t Message_Block[SHA256_Message_Block_Size];",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "    int Computed;                   /* Is the hash computed? */\n    int Corrupted;                  /* Cumulative corruption code */\n} SHA256Context;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n *  This structure will hold context information for the SHA-512\n *  hashing operation.\n */\ntypedef struct SHA512Context {\n#ifdef USE_32BIT_ONLY\n    uint32_t Intermediate_Hash[SHA512HashSize/4]; /* Message Digest  */\n    uint32_t Length[4];                 /* Message length in bits */\n#else /* !USE_32BIT_ONLY */\n    uint64_t Intermediate_Hash[SHA512HashSize/8]; /* Message Digest */\n    uint64_t Length_High, Length_Low;   /* Message length in bits */\n#endif /* USE_32BIT_ONLY */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "int_least16_t Message_Block_Index;  /* Message_Block array index */\n                                    /* 1024-bit message blocks */\nuint8_t Message_Block[SHA512_Message_Block_Size];",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "    int Computed;                   /* Is the hash computed?*/\n    int Corrupted;                  /* Cumulative corruption code */\n} SHA512Context;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n *  This structure will hold context information for the SHA-224\n *  hashing operation.  It uses the SHA-256 structure for computation.\n */\ntypedef struct SHA256Context SHA224Context;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n *  This structure will hold context information for the SHA-384\n *  hashing operation.  It uses the SHA-512 structure for computation.\n */\ntypedef struct SHA512Context SHA384Context;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n *  This structure holds context information for all SHA\n *  hashing operations.\n */\ntypedef struct USHAContext {\n    int whichSha;               /* which SHA is being used */\n    union {\n      SHA1Context sha1Context;\n      SHA224Context sha224Context; SHA256Context sha256Context;\n      SHA384Context sha384Context; SHA512Context sha512Context;\n    } ctx;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "} USHAContext;",
      "zh-CHS": "}文本；"
    },
    {
      "indent": 0,
      "text": "/*\n *  This structure will hold context information for the HMAC\n *  keyed-hashing operation.\n */\ntypedef struct HMACContext {\n    int whichSha;               /* which SHA is being used */\n    int hashSize;               /* hash size of SHA being used */\n    int blockSize;              /* block size of SHA being used */\n    USHAContext shaContext;     /* SHA context */\n    unsigned char k_opad[USHA_Max_Message_Block_Size];\n                        /* outer padding - key XORd with opad */\n    int Computed;               /* Is the MAC computed? */\n    int Corrupted;              /* Cumulative corruption code */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "} HMACContext;",
      "zh-CHS": "}hmacontext；"
    },
    {
      "indent": 0,
      "text": "/*\n *  This structure will hold context information for the HKDF\n *  extract-and-expand Key Derivation Functions.\n */\ntypedef struct HKDFContext {\n    int whichSha;               /* which SHA is being used */\n    HMACContext hmacContext;\n    int hashSize;               /* hash size of SHA being used */\n    unsigned char prk[USHAMaxHashSize];\n                        /* pseudo-random key - output of hkdfInput */\n    int Computed;               /* Is the key material computed? */\n    int Corrupted;              /* Cumulative corruption code */\n} HKDFContext;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n *  Function Prototypes\n */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/* SHA-1 */\nextern int SHA1Reset(SHA1Context *);\nextern int SHA1Input(SHA1Context *, const uint8_t *bytes,\n                     unsigned int bytecount);\nextern int SHA1FinalBits(SHA1Context *, uint8_t bits,\n                         unsigned int bit_count);\nextern int SHA1Result(SHA1Context *,\n                      uint8_t Message_Digest[SHA1HashSize]);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/* SHA-224 */\nextern int SHA224Reset(SHA224Context *);\nextern int SHA224Input(SHA224Context *, const uint8_t *bytes,\n                       unsigned int bytecount);\nextern int SHA224FinalBits(SHA224Context *, uint8_t bits,\n                           unsigned int bit_count);\nextern int SHA224Result(SHA224Context *,\n                        uint8_t Message_Digest[SHA224HashSize]);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/* SHA-256 */\nextern int SHA256Reset(SHA256Context *);\nextern int SHA256Input(SHA256Context *, const uint8_t *bytes,\n                       unsigned int bytecount);\nextern int SHA256FinalBits(SHA256Context *, uint8_t bits,\n                           unsigned int bit_count);\nextern int SHA256Result(SHA256Context *,\n                        uint8_t Message_Digest[SHA256HashSize]);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/* SHA-384 */\nextern int SHA384Reset(SHA384Context *);\nextern int SHA384Input(SHA384Context *, const uint8_t *bytes,\n                       unsigned int bytecount);\nextern int SHA384FinalBits(SHA384Context *, uint8_t bits,\n                           unsigned int bit_count);\nextern int SHA384Result(SHA384Context *,\n                        uint8_t Message_Digest[SHA384HashSize]);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/* SHA-512 */\nextern int SHA512Reset(SHA512Context *);\nextern int SHA512Input(SHA512Context *, const uint8_t *bytes,\n                       unsigned int bytecount);\nextern int SHA512FinalBits(SHA512Context *, uint8_t bits,\n                           unsigned int bit_count);\nextern int SHA512Result(SHA512Context *,\n                        uint8_t Message_Digest[SHA512HashSize]);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/* Unified SHA functions, chosen by whichSha */\nextern int USHAReset(USHAContext *context, SHAversion whichSha);\nextern int USHAInput(USHAContext *context,\n                     const uint8_t *bytes, unsigned int bytecount);\nextern int USHAFinalBits(USHAContext *context,\n                         uint8_t bits, unsigned int bit_count);\nextern int USHAResult(USHAContext *context,\n                      uint8_t Message_Digest[USHAMaxHashSize]);\nextern int USHABlockSize(enum SHAversion whichSha);\nextern int USHAHashSize(enum SHAversion whichSha);\nextern int USHAHashSizeBits(enum SHAversion whichSha);\nextern const char *USHAHashName(enum SHAversion whichSha);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * HMAC Keyed-Hashing for Message Authentication, RFC 2104,\n * for all SHAs.\n * This interface allows a fixed-length text input to be used.\n */\nextern int hmac(SHAversion whichSha, /* which SHA algorithm to use */\n    const unsigned char *text,     /* pointer to data stream */\n    int text_len,                  /* length of data stream */\n    const unsigned char *key,      /* pointer to authentication key */\n    int key_len,                   /* length of authentication key */\n    uint8_t digest[USHAMaxHashSize]); /* caller digest to fill in */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * HMAC Keyed-Hashing for Message Authentication, RFC 2104,\n * for all SHAs.\n * This interface allows any length of text input to be used.\n */\nextern int hmacReset(HMACContext *context, enum SHAversion whichSha,\n                     const unsigned char *key, int key_len);\nextern int hmacInput(HMACContext *context, const unsigned char *text,\n                     int text_len);\nextern int hmacFinalBits(HMACContext *context, uint8_t bits,\n                         unsigned int bit_count);\nextern int hmacResult(HMACContext *context,\n                      uint8_t digest[USHAMaxHashSize]);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * HKDF HMAC-based Extract-and-Expand Key Derivation Function,\n * RFC 5869, for all SHAs.\n */\nextern int hkdf(SHAversion whichSha, const unsigned char *salt,\n                int salt_len, const unsigned char *ikm, int ikm_len,\n                const unsigned char *info, int info_len,\n                uint8_t okm[ ], int okm_len);\nextern int hkdfExtract(SHAversion whichSha, const unsigned char *salt,\n                       int salt_len, const unsigned char *ikm,\n                       int ikm_len, uint8_t prk[USHAMaxHashSize]);\nextern int hkdfExpand(SHAversion whichSha, const uint8_t prk[ ],\n                      int prk_len, const unsigned char *info,\n                      int info_len, uint8_t okm[ ], int okm_len);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * HKDF HMAC-based Extract-and-Expand Key Derivation Function,\n * RFC 5869, for all SHAs.\n * This interface allows any length of text input to be used.\n */\nextern int hkdfReset(HKDFContext *context, enum SHAversion whichSha,\n                     const unsigned char *salt, int salt_len);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "extern int hkdfInput(HKDFContext *context, const unsigned char *ikm,\n                     int ikm_len);\nextern int hkdfFinalBits(HKDFContext *context, uint8_t ikm_bits,\n                         unsigned int ikm_bit_count);\nextern int hkdfResult(HKDFContext *context,\n                      uint8_t prk[USHAMaxHashSize],\n                      const unsigned char *info, int info_len,\n                      uint8_t okm[USHAMaxHashSize], int okm_len);\n#endif /* _SHA_H_ */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "8.1.2. stdint-example.h",
      "section_title": true,
      "zh-CHS": "8.1.2. stdint示例"
    },
    {
      "indent": 0,
      "text": "If your system does not have <stdint.h>, the following should be adequate as a substitute for compiling the other code in this document.",
      "zh-CHS": "如果您的系统没有<stdint.h>，以下内容应足以替代编译本文档中的其他代码。"
    },
    {
      "indent": 0,
      "text": "/*********************** stdint-example.h **********************/\n/**** Use this file if your system does not have a stdint.h. ***/\n/***************** See RFC 6234 for details. *******************/\n#ifndef STDINT_H\n#define STDINT_H",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "typedef unsigned long long uint64_t;    /* unsigned 64-bit integer */\ntypedef unsigned int       uint32_t;    /* unsigned 32-bit integer */\ntypedef unsigned char      uint8_t;     /* unsigned 8-bit integer */\n                                        /* (i.e., unsigned char) */\ntypedef int int_least32_t;              /* integer of >= 32 bits */\ntypedef short int_least16_t;            /* integer of >= 16 bits */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "#endif /* STDINT_H */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "8.1.3. sha-private.h",
      "section_title": true,
      "zh-CHS": "8.1.3. 私人医院"
    },
    {
      "indent": 3,
      "text": "The sha-private.h header file contains definitions that should only be needed internally in the other code in this document. These definitions should not be needed in application code calling the code provided in this document.",
      "zh-CHS": "sha private.h头文件包含的定义仅在本文档的其他代码中内部需要。在调用本文档中提供的代码的应用程序代码中不需要这些定义。"
    },
    {
      "indent": 0,
      "text": "/************************ sha-private.h ************************/\n/***************** See RFC 6234 for details. *******************/\n#ifndef _SHA_PRIVATE__H\n#define _SHA_PRIVATE__H\n/*\n * These definitions are defined in FIPS 180-3, section 4.1.\n * Ch() and Maj() are defined identically in sections 4.1.1,\n * 4.1.2, and 4.1.3.\n *\n * The definitions used in FIPS 180-3 are as follows:\n */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "#ifndef USE_MODIFIED_MACROS\n#define SHA_Ch(x,y,z)        (((x) & (y)) ^ ((~(x)) & (z)))\n#define SHA_Maj(x,y,z)       (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))\n#else /* USE_MODIFIED_MACROS */\n/*\n * The following definitions are equivalent and potentially faster.\n */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "#define SHA_Ch(x, y, z)      (((x) & ((y) ^ (z))) ^ (z))\n#define SHA_Maj(x, y, z)     (((x) & ((y) | (z))) | ((y) & (z)))",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "#endif /* USE_MODIFIED_MACROS */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "#define SHA_Parity(x, y, z)  ((x) ^ (y) ^ (z))",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "#endif /* _SHA_PRIVATE__H */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "8.2. The SHA Code",
      "section_title": true,
      "zh-CHS": "8.2. SHA代码"
    },
    {
      "indent": 3,
      "text": "This code is primarily intended as expository reference code and could be optimized further. For example, the assignment rotations through the variables a, b, ..., h could be treated as a cycle and the loop unrolled, rather than doing the explicit copying.",
      "zh-CHS": "此代码主要用作说明性参考代码，可以进一步优化。例如，通过变量a、b、…、h的赋值旋转可以视为一个循环，循环展开，而不是进行显式复制。"
    },
    {
      "indent": 3,
      "text": "Note that there are alternative representations of the Ch() and Maj() functions controlled by an ifdef.",
      "zh-CHS": "请注意，有由ifdef控制的Ch（）和Maj（）函数的替代表示形式。"
    },
    {
      "indent": 0,
      "text": "8.2.1. sha1.c",
      "section_title": true,
      "zh-CHS": "8.2.1. sha1.c"
    },
    {
      "indent": 0,
      "text": "/**************************** sha1.c ***************************/\n/***************** See RFC 6234 for details. *******************/\n/* Copyright (c) 2011 IETF Trust and the persons identified as */\n/* authors of the code.  All rights reserved.                  */\n/* See sha.h for terms of use and redistribution.              */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n *  Description:\n *      This file implements the Secure Hash Algorithm SHA-1\n *      as defined in the U.S. National Institute of Standards\n *      and Technology Federal Information Processing Standards\n *      Publication (FIPS PUB) 180-3 published in October 2008\n *      and formerly defined in its predecessors, FIPS PUB 180-1\n *      and FIP PUB 180-2.\n *\n *      A combined document showing all algorithms is available at\n *              http://csrc.nist.gov/publications/fips/\n *                     fips180-3/fips180-3_final.pdf\n *",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 1,
      "text": "* The SHA-1 algorithm produces a 160-bit message digest for a * given data stream that can serve as a means of providing a * \"fingerprint\" for a message. * * Portability Issues: * SHA-1 is defined in terms of 32-bit \"words\". This code * uses <stdint.h> (included via \"sha.h\") to define 32- and * 8-bit unsigned integer types. If your C compiler does * not support 32-bit unsigned integers, this code is not * appropriate. * * Caveats: * SHA-1 is designed to work with messages less than 2^64 bits * long. This implementation uses SHA1Input() to hash the bits * that are a multiple of the size of an 8-bit octet, and then * optionally uses SHA1FinalBits() to hash the final few bits of * the input. */",
      "zh-CHS": "* SHA-1算法为*给定数据流生成160位消息摘要，该数据流可用作为消息提供*指纹的手段。**可移植性问题：*SHA-1是根据32位“字”定义的。此代码*使用<stdint.h>（通过“sha.h”包含）定义32位和*8位无符号整数类型。如果您的C编译器*不支持32位无符号整数，则此代码不*合适。**注意事项：*SHA-1设计用于处理长度小于2^64位*的消息。此实现使用SHA1Input（）散列8位八位组大小的倍数*位，然后*可选地使用SHA1FinalBits（）散列*输入的最后几位*/"
    },
    {
      "indent": 0,
      "text": "#include \"sha.h\" #include \"sha-private.h\"",
      "zh-CHS": "#包括“sha.h”#包括“sha private.h”"
    },
    {
      "indent": 0,
      "text": "/*\n *  Define the SHA1 circular left shift macro\n */\n#define SHA1_ROTL(bits,word) \\\n                (((word) << (bits)) | ((word) >> (32-(bits))))",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * Add \"length\" to the length.\n * Set Corrupted when overflow has occurred.\n */\nstatic uint32_t addTemp;\n#define SHA1AddLength(context, length)                     \\\n    (addTemp = (context)->Length_Low,                      \\\n     (context)->Corrupted =                                \\\n        (((context)->Length_Low += (length)) < addTemp) && \\\n        (++(context)->Length_High == 0) ? shaInputTooLong  \\\n                                        : (context)->Corrupted )",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/* Local Function Prototypes */\nstatic void SHA1ProcessMessageBlock(SHA1Context *context);\nstatic void SHA1Finalize(SHA1Context *context, uint8_t Pad_Byte);\nstatic void SHA1PadMessage(SHA1Context *context, uint8_t Pad_Byte);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n *  SHA1Reset\n *\n *  Description:\n *      This function will initialize the SHA1Context in preparation\n *      for computing a new SHA1 message digest.\n *\n *  Parameters:\n *      context: [in/out]\n *          The context to reset.\n *\n *  Returns:\n *      sha Error Code.\n *\n */\nint SHA1Reset(SHA1Context *context)\n{\n  if (!context) return shaNull;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "context->Length_High = context->Length_Low = 0;\ncontext->Message_Block_Index = 0;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "/* Initial Hash Values: FIPS 180-3 section 5.3.1 */\ncontext->Intermediate_Hash[0]   = 0x67452301;\ncontext->Intermediate_Hash[1]   = 0xEFCDAB89;\ncontext->Intermediate_Hash[2]   = 0x98BADCFE;\ncontext->Intermediate_Hash[3]   = 0x10325476;\ncontext->Intermediate_Hash[4]   = 0xC3D2E1F0;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "context->Computed   = 0;\ncontext->Corrupted  = shaSuccess;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "  return shaSuccess;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n *  SHA1Input\n *\n *  Description:\n *      This function accepts an array of octets as the next portion\n *      of the message.\n *\n *  Parameters:\n *      context: [in/out]\n *          The SHA context to update.\n *      message_array[ ]: [in]\n *          An array of octets representing the next portion of\n *          the message.",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": " *      length: [in]\n *          The length of the message in message_array.\n *\n *  Returns:\n *      sha Error Code.\n *\n */\nint SHA1Input(SHA1Context *context,\n    const uint8_t *message_array, unsigned length)\n{\n  if (!context) return shaNull;\n  if (!length) return shaSuccess;\n  if (!message_array) return shaNull;\n  if (context->Computed) return context->Corrupted = shaStateError;\n  if (context->Corrupted) return context->Corrupted;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "while (length--) {\n  context->Message_Block[context->Message_Block_Index++] =\n    *message_array;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "if ((SHA1AddLength(context, 8) == shaSuccess) &&\n  (context->Message_Block_Index == SHA1_Message_Block_Size))\n  SHA1ProcessMessageBlock(context);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "  message_array++;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "  return context->Corrupted;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * SHA1FinalBits\n *\n * Description:\n *   This function will add in any final bits of the message.\n *\n * Parameters:\n *   context: [in/out]\n *     The SHA context to update.\n *   message_bits: [in]\n *     The final bits of the message, in the upper portion of the\n *     byte.  (Use 0b###00000 instead of 0b00000### to input the\n *     three bits ###.)\n *   length: [in]\n *     The number of bits in message_bits, between 1 and 7.\n *\n * Returns:\n *   sha Error Code.",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": " */\nint SHA1FinalBits(SHA1Context *context, uint8_t message_bits,\n    unsigned int length)\n{\n  static uint8_t masks[8] = {\n      /* 0 0b00000000 */ 0x00, /* 1 0b10000000 */ 0x80,\n      /* 2 0b11000000 */ 0xC0, /* 3 0b11100000 */ 0xE0,\n      /* 4 0b11110000 */ 0xF0, /* 5 0b11111000 */ 0xF8,\n      /* 6 0b11111100 */ 0xFC, /* 7 0b11111110 */ 0xFE\n  };",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "static uint8_t markbit[8] = {\n    /* 0 0b10000000 */ 0x80, /* 1 0b01000000 */ 0x40,\n    /* 2 0b00100000 */ 0x20, /* 3 0b00010000 */ 0x10,\n    /* 4 0b00001000 */ 0x08, /* 5 0b00000100 */ 0x04,\n    /* 6 0b00000010 */ 0x02, /* 7 0b00000001 */ 0x01\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "if (!context) return shaNull;\nif (!length) return shaSuccess;\nif (context->Corrupted) return context->Corrupted;\nif (context->Computed) return context->Corrupted = shaStateError;\nif (length >= 8) return context->Corrupted = shaBadParam;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "SHA1AddLength(context, length);\nSHA1Finalize(context,\n  (uint8_t) ((message_bits & masks[length]) | markbit[length]));",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "  return context->Corrupted;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * SHA1Result\n *\n * Description:\n *   This function will return the 160-bit message digest\n *   into the Message_Digest array provided by the caller.\n *   NOTE:\n *    The first octet of hash is stored in the element with index 0,\n *      the last octet of hash in the element with index 19.\n *\n * Parameters:\n *   context: [in/out]\n *     The context to use to calculate the SHA-1 hash.\n *   Message_Digest[ ]: [out]\n *     Where the digest is returned.\n *",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": " * Returns:\n *   sha Error Code.\n *\n */\nint SHA1Result(SHA1Context *context,\n    uint8_t Message_Digest[SHA1HashSize])\n{\n  int i;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "if (!context) return shaNull;\nif (!Message_Digest) return shaNull;\nif (context->Corrupted) return context->Corrupted;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "if (!context->Computed)\n  SHA1Finalize(context, 0x80);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "for (i = 0; i < SHA1HashSize; ++i)\n  Message_Digest[i] = (uint8_t) (context->Intermediate_Hash[i>>2]\n                                 >> (8 * ( 3 - ( i & 0x03 ) )));",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "  return shaSuccess;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * SHA1ProcessMessageBlock\n *\n * Description:\n *   This helper function will process the next 512 bits of the\n *   message stored in the Message_Block array.\n *\n * Parameters:\n *   context: [in/out]\n *     The SHA context to update.\n *\n * Returns:\n *   Nothing.\n *\n * Comments:\n *   Many of the variable names in this code, especially the\n *   single character names, were used because those were the\n *   names used in the Secure Hash Standard.\n */\nstatic void SHA1ProcessMessageBlock(SHA1Context *context)\n{\n  /* Constants defined in FIPS 180-3, section 4.2.1 */\n  const uint32_t K[4] = {\n      0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6\n  };",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "int        t;               /* Loop counter */\nuint32_t   temp;            /* Temporary word value */\nuint32_t   W[80];           /* Word sequence */\nuint32_t   A, B, C, D, E;   /* Word buffers */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "/*\n * Initialize the first 16 words in the array W\n */\nfor (t = 0; t < 16; t++) {\n  W[t]  = ((uint32_t)context->Message_Block[t * 4]) << 24;\n  W[t] |= ((uint32_t)context->Message_Block[t * 4 + 1]) << 16;\n  W[t] |= ((uint32_t)context->Message_Block[t * 4 + 2]) << 8;\n  W[t] |= ((uint32_t)context->Message_Block[t * 4 + 3]);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "for (t = 16; t < 80; t++)\n  W[t] = SHA1_ROTL(1, W[t-3] ^ W[t-8] ^ W[t-14] ^ W[t-16]);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "A = context->Intermediate_Hash[0];\nB = context->Intermediate_Hash[1];\nC = context->Intermediate_Hash[2];\nD = context->Intermediate_Hash[3];\nE = context->Intermediate_Hash[4];",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "for (t = 0; t < 20; t++) {\n  temp = SHA1_ROTL(5,A) + SHA_Ch(B, C, D) + E + W[t] + K[0];\n  E = D;\n  D = C;\n  C = SHA1_ROTL(30,B);\n  B = A;\n  A = temp;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "for (t = 20; t < 40; t++) {\n  temp = SHA1_ROTL(5,A) + SHA_Parity(B, C, D) + E + W[t] + K[1];\n  E = D;\n  D = C;\n  C = SHA1_ROTL(30,B);\n  B = A;\n  A = temp;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "for (t = 40; t < 60; t++) {\n  temp = SHA1_ROTL(5,A) + SHA_Maj(B, C, D) + E + W[t] + K[2];\n  E = D;\n  D = C;\n  C = SHA1_ROTL(30,B);\n  B = A;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "  A = temp;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "for (t = 60; t < 80; t++) {\n  temp = SHA1_ROTL(5,A) + SHA_Parity(B, C, D) + E + W[t] + K[3];\n  E = D;\n  D = C;\n  C = SHA1_ROTL(30,B);\n  B = A;\n  A = temp;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "  context->Intermediate_Hash[0] += A;\n  context->Intermediate_Hash[1] += B;\n  context->Intermediate_Hash[2] += C;\n  context->Intermediate_Hash[3] += D;\n  context->Intermediate_Hash[4] += E;\n  context->Message_Block_Index = 0;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * SHA1Finalize\n *\n * Description:\n *   This helper function finishes off the digest calculations.\n *\n * Parameters:\n *   context: [in/out]\n *     The SHA context to update.\n *   Pad_Byte: [in]\n *     The last byte to add to the message block before the 0-padding\n *     and length.  This will contain the last bits of the message\n *     followed by another single bit.  If the message was an\n *     exact multiple of 8-bits long, Pad_Byte will be 0x80.\n *\n * Returns:\n *   sha Error Code.\n *\n */\nstatic void SHA1Finalize(SHA1Context *context, uint8_t Pad_Byte)\n{\n  int i;\n  SHA1PadMessage(context, Pad_Byte);\n  /* message may be sensitive, clear it out */\n  for (i = 0; i < SHA1_Message_Block_Size; ++i)\n    context->Message_Block[i] = 0;\n  context->Length_High = 0;     /* and clear length */\n  context->Length_Low = 0;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "  context->Computed = 1;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * SHA1PadMessage\n *\n * Description:\n *   According to the standard, the message must be padded to the next\n *   even multiple of 512 bits.  The first padding bit must be a '1'.\n *   The last 64 bits represent the length of the original message.\n *   All bits in between should be 0.  This helper function will pad\n *   the message according to those rules by filling the Message_Block\n *   array accordingly.  When it returns, it can be assumed that the\n *   message digest has been computed.\n *\n * Parameters:\n *   context: [in/out]\n *     The context to pad.\n *   Pad_Byte: [in]\n *     The last byte to add to the message block before the 0-padding\n *     and length.  This will contain the last bits of the message\n *     followed by another single bit.  If the message was an\n *     exact multiple of 8-bits long, Pad_Byte will be 0x80.\n *\n * Returns:\n *   Nothing.\n */\nstatic void SHA1PadMessage(SHA1Context *context, uint8_t Pad_Byte)\n{\n  /*\n   * Check to see if the current message block is too small to hold\n   * the initial padding bits and length.  If so, we will pad the\n   * block, process it, and then continue padding into a second\n   * block.\n   */\n  if (context->Message_Block_Index >= (SHA1_Message_Block_Size - 8)) {\n    context->Message_Block[context->Message_Block_Index++] = Pad_Byte;\n    while (context->Message_Block_Index < SHA1_Message_Block_Size)\n      context->Message_Block[context->Message_Block_Index++] = 0;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "  SHA1ProcessMessageBlock(context);\n} else\n  context->Message_Block[context->Message_Block_Index++] = Pad_Byte;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "while (context->Message_Block_Index < (SHA1_Message_Block_Size - 8))\n  context->Message_Block[context->Message_Block_Index++] = 0;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "/*\n * Store the message length as the last 8 octets\n */\ncontext->Message_Block[56] = (uint8_t) (context->Length_High >> 24);\ncontext->Message_Block[57] = (uint8_t) (context->Length_High >> 16);\ncontext->Message_Block[58] = (uint8_t) (context->Length_High >> 8);\ncontext->Message_Block[59] = (uint8_t) (context->Length_High);\ncontext->Message_Block[60] = (uint8_t) (context->Length_Low >> 24);\ncontext->Message_Block[61] = (uint8_t) (context->Length_Low >> 16);\ncontext->Message_Block[62] = (uint8_t) (context->Length_Low >> 8);\ncontext->Message_Block[63] = (uint8_t) (context->Length_Low);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "  SHA1ProcessMessageBlock(context);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "8.2.2. sha224-256.c",
      "section_title": true,
      "zh-CHS": "8.2.2. sha224-256.c"
    },
    {
      "indent": 0,
      "text": "/************************* sha224-256.c ************************/\n/***************** See RFC 6234 for details. *******************/\n/* Copyright (c) 2011 IETF Trust and the persons identified as */\n/* authors of the code.  All rights reserved.                  */\n/* See sha.h for terms of use and redistribution.              */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * Description:\n *   This file implements the Secure Hash Algorithms SHA-224 and\n *   SHA-256 as defined in the U.S. National Institute of Standards\n *   and Technology Federal Information Processing Standards\n *   Publication (FIPS PUB) 180-3 published in October 2008\n *   and formerly defined in its predecessors, FIPS PUB 180-1\n *   and FIP PUB 180-2.\n *\n *   A combined document showing all algorithms is available at\n *       http://csrc.nist.gov/publications/fips/\n *              fips180-3/fips180-3_final.pdf\n *\n *   The SHA-224 and SHA-256 algorithms produce 224-bit and 256-bit\n *   message digests for a given data stream.  It should take about\n *   2**n steps to find a message with the same digest as a given\n *   message and 2**(n/2) to find any two messages with the same\n *   digest, when n is the digest size in bits.  Therefore, this\n *   algorithm can serve as a means of providing a\n *   \"fingerprint\" for a message.\n *\n * Portability Issues:\n *   SHA-224 and SHA-256 are defined in terms of 32-bit \"words\".\n *   This code uses <stdint.h> (included via \"sha.h\") to define 32-\n *   and 8-bit unsigned integer types.  If your C compiler does not",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 1,
      "text": "* support 32-bit unsigned integers, this code is not * appropriate. * * Caveats: * SHA-224 and SHA-256 are designed to work with messages less * than 2^64 bits long. This implementation uses SHA224/256Input() * to hash the bits that are a multiple of the size of an 8-bit * octet, and then optionally uses SHA224/256FinalBits() * to hash the final few bits of the input. */",
      "zh-CHS": "* 支持32位无符号整数，此代码不适用。**注意事项：*SHA-224和SHA-256设计用于处理长度小于*2^64位的消息。此实现使用SHA224/256Input（）*对8位*八位字节大小的倍数进行散列，然后可选地使用SHA224/256FinalBits（）*对输入的最后几位进行散列*/"
    },
    {
      "indent": 0,
      "text": "#include \"sha.h\" #include \"sha-private.h\"",
      "zh-CHS": "#包括“sha.h”#包括“sha private.h”"
    },
    {
      "indent": 0,
      "text": "/* Define the SHA shift, rotate left, and rotate right macros */\n#define SHA256_SHR(bits,word)      ((word) >> (bits))\n#define SHA256_ROTL(bits,word)                         \\\n  (((word) << (bits)) | ((word) >> (32-(bits))))\n#define SHA256_ROTR(bits,word)                         \\\n  (((word) >> (bits)) | ((word) << (32-(bits))))",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/* Define the SHA SIGMA and sigma macros */\n#define SHA256_SIGMA0(word)   \\\n  (SHA256_ROTR( 2,word) ^ SHA256_ROTR(13,word) ^ SHA256_ROTR(22,word))\n#define SHA256_SIGMA1(word)   \\\n  (SHA256_ROTR( 6,word) ^ SHA256_ROTR(11,word) ^ SHA256_ROTR(25,word))\n#define SHA256_sigma0(word)   \\\n  (SHA256_ROTR( 7,word) ^ SHA256_ROTR(18,word) ^ SHA256_SHR( 3,word))\n#define SHA256_sigma1(word)   \\\n  (SHA256_ROTR(17,word) ^ SHA256_ROTR(19,word) ^ SHA256_SHR(10,word))",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * Add \"length\" to the length.\n * Set Corrupted when overflow has occurred.\n */\nstatic uint32_t addTemp;\n#define SHA224_256AddLength(context, length)               \\\n  (addTemp = (context)->Length_Low, (context)->Corrupted = \\\n    (((context)->Length_Low += (length)) < addTemp) &&     \\\n    (++(context)->Length_High == 0) ? shaInputTooLong :    \\\n                                      (context)->Corrupted )",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/* Local Function Prototypes */\nstatic int SHA224_256Reset(SHA256Context *context, uint32_t *H0);\nstatic void SHA224_256ProcessMessageBlock(SHA256Context *context);\nstatic void SHA224_256Finalize(SHA256Context *context,\n  uint8_t Pad_Byte);\nstatic void SHA224_256PadMessage(SHA256Context *context,",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "  uint8_t Pad_Byte);\nstatic int SHA224_256ResultN(SHA256Context *context,\n  uint8_t Message_Digest[ ], int HashSize);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/* Initial Hash Values: FIPS 180-3 section 5.3.2 */\nstatic uint32_t SHA224_H0[SHA256HashSize/4] = {\n    0xC1059ED8, 0x367CD507, 0x3070DD17, 0xF70E5939,\n    0xFFC00B31, 0x68581511, 0x64F98FA7, 0xBEFA4FA4\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/* Initial Hash Values: FIPS 180-3 section 5.3.3 */\nstatic uint32_t SHA256_H0[SHA256HashSize/4] = {\n  0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A,\n  0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * SHA224Reset\n *\n * Description:\n *   This function will initialize the SHA224Context in preparation\n *   for computing a new SHA224 message digest.\n *\n * Parameters:\n *   context: [in/out]\n *     The context to reset.\n *\n * Returns:\n *   sha Error Code.\n */\nint SHA224Reset(SHA224Context *context)\n{\n  return SHA224_256Reset(context, SHA224_H0);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * SHA224Input\n *\n * Description:\n *   This function accepts an array of octets as the next portion\n *   of the message.\n *\n * Parameters:\n *   context: [in/out]\n *     The SHA context to update.\n *   message_array[ ]: [in]\n *     An array of octets representing the next portion of\n *     the message.",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": " *   length: [in]\n *     The length of the message in message_array.\n *\n * Returns:\n *   sha Error Code.\n *\n */\nint SHA224Input(SHA224Context *context, const uint8_t *message_array,\n    unsigned int length)\n{\n  return SHA256Input(context, message_array, length);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * SHA224FinalBits\n *\n * Description:\n *   This function will add in any final bits of the message.\n *\n * Parameters:\n *   context: [in/out]\n *     The SHA context to update.\n *   message_bits: [in]\n *     The final bits of the message, in the upper portion of the\n *     byte.  (Use 0b###00000 instead of 0b00000### to input the\n *     three bits ###.)\n *   length: [in]\n *     The number of bits in message_bits, between 1 and 7.\n *\n * Returns:\n *   sha Error Code.\n */\nint SHA224FinalBits(SHA224Context *context,\n                    uint8_t message_bits, unsigned int length)\n{\n  return SHA256FinalBits(context, message_bits, length);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * SHA224Result\n *\n * Description:\n *   This function will return the 224-bit message digest\n *   into the Message_Digest array provided by the caller.\n *   NOTE:\n *    The first octet of hash is stored in the element with index 0,\n *    the last octet of hash in the element with index 27.\n *",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": " * Parameters:\n *   context: [in/out]\n *     The context to use to calculate the SHA hash.\n *   Message_Digest[ ]: [out]\n *     Where the digest is returned.\n *\n * Returns:\n *   sha Error Code.\n */\nint SHA224Result(SHA224Context *context,\n    uint8_t Message_Digest[SHA224HashSize])\n{\n  return SHA224_256ResultN(context, Message_Digest, SHA224HashSize);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * SHA256Reset\n *\n * Description:\n *   This function will initialize the SHA256Context in preparation\n *   for computing a new SHA256 message digest.\n *\n * Parameters:\n *   context: [in/out]\n *     The context to reset.\n *\n * Returns:\n *   sha Error Code.\n */\nint SHA256Reset(SHA256Context *context)\n{\n  return SHA224_256Reset(context, SHA256_H0);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * SHA256Input\n *\n * Description:\n *   This function accepts an array of octets as the next portion\n *   of the message.\n *\n * Parameters:\n *   context: [in/out]\n *     The SHA context to update.\n *   message_array[ ]: [in]\n *     An array of octets representing the next portion of\n *     the message.",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": " *   length: [in]\n *     The length of the message in message_array.\n *\n * Returns:\n *   sha Error Code.\n */\nint SHA256Input(SHA256Context *context, const uint8_t *message_array,\n    unsigned int length)\n{\n  if (!context) return shaNull;\n  if (!length) return shaSuccess;\n  if (!message_array) return shaNull;\n  if (context->Computed) return context->Corrupted = shaStateError;\n  if (context->Corrupted) return context->Corrupted;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "while (length--) {\n  context->Message_Block[context->Message_Block_Index++] =\n          *message_array;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "if ((SHA224_256AddLength(context, 8) == shaSuccess) &&\n  (context->Message_Block_Index == SHA256_Message_Block_Size))\n  SHA224_256ProcessMessageBlock(context);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "  message_array++;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "return context->Corrupted;",
      "zh-CHS": "返回上下文->已损坏；"
    },
    {
      "indent": 0,
      "text": "}",
      "zh-CHS": "}"
    },
    {
      "indent": 0,
      "text": "/*\n * SHA256FinalBits\n *\n * Description:\n *   This function will add in any final bits of the message.\n *\n * Parameters:\n *   context: [in/out]\n *     The SHA context to update.\n *   message_bits: [in]\n *     The final bits of the message, in the upper portion of the\n *     byte.  (Use 0b###00000 instead of 0b00000### to input the\n *     three bits ###.)\n *   length: [in]\n *     The number of bits in message_bits, between 1 and 7.\n *\n * Returns:\n *   sha Error Code.",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": " */\nint SHA256FinalBits(SHA256Context *context,\n                    uint8_t message_bits, unsigned int length)\n{\n  static uint8_t masks[8] = {\n      /* 0 0b00000000 */ 0x00, /* 1 0b10000000 */ 0x80,\n      /* 2 0b11000000 */ 0xC0, /* 3 0b11100000 */ 0xE0,\n      /* 4 0b11110000 */ 0xF0, /* 5 0b11111000 */ 0xF8,\n      /* 6 0b11111100 */ 0xFC, /* 7 0b11111110 */ 0xFE\n  };\n  static uint8_t markbit[8] = {\n      /* 0 0b10000000 */ 0x80, /* 1 0b01000000 */ 0x40,\n      /* 2 0b00100000 */ 0x20, /* 3 0b00010000 */ 0x10,\n      /* 4 0b00001000 */ 0x08, /* 5 0b00000100 */ 0x04,\n      /* 6 0b00000010 */ 0x02, /* 7 0b00000001 */ 0x01\n  };",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "if (!context) return shaNull;\nif (!length) return shaSuccess;\nif (context->Corrupted) return context->Corrupted;\nif (context->Computed) return context->Corrupted = shaStateError;\nif (length >= 8) return context->Corrupted = shaBadParam;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "SHA224_256AddLength(context, length);\nSHA224_256Finalize(context, (uint8_t)\n  ((message_bits & masks[length]) | markbit[length]));",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "  return context->Corrupted;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * SHA256Result\n *\n * Description:\n *   This function will return the 256-bit message digest\n *   into the Message_Digest array provided by the caller.\n *   NOTE:\n *    The first octet of hash is stored in the element with index 0,\n *    the last octet of hash in the element with index 31.\n *\n * Parameters:\n *   context: [in/out]\n *     The context to use to calculate the SHA hash.\n *   Message_Digest[ ]: [out]\n *     Where the digest is returned.\n *\n * Returns:\n *   sha Error Code.",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": " */\nint SHA256Result(SHA256Context *context,\n                 uint8_t Message_Digest[SHA256HashSize])\n{\n  return SHA224_256ResultN(context, Message_Digest, SHA256HashSize);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * SHA224_256Reset\n *\n * Description:\n *   This helper function will initialize the SHA256Context in\n *   preparation for computing a new SHA-224 or SHA-256 message digest.\n *\n * Parameters:\n *   context: [in/out]\n *     The context to reset.\n *   H0[ ]: [in]\n *     The initial hash value array to use.\n *\n * Returns:\n *   sha Error Code.\n */\nstatic int SHA224_256Reset(SHA256Context *context, uint32_t *H0)\n{\n  if (!context) return shaNull;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "context->Length_High = context->Length_Low = 0;\ncontext->Message_Block_Index  = 0;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "context->Intermediate_Hash[0] = H0[0];\ncontext->Intermediate_Hash[1] = H0[1];\ncontext->Intermediate_Hash[2] = H0[2];\ncontext->Intermediate_Hash[3] = H0[3];\ncontext->Intermediate_Hash[4] = H0[4];\ncontext->Intermediate_Hash[5] = H0[5];\ncontext->Intermediate_Hash[6] = H0[6];\ncontext->Intermediate_Hash[7] = H0[7];",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "context->Computed  = 0;\ncontext->Corrupted = shaSuccess;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "  return shaSuccess;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * SHA224_256ProcessMessageBlock\n *",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": " * Description:\n *   This helper function will process the next 512 bits of the\n *   message stored in the Message_Block array.\n *\n * Parameters:\n *   context: [in/out]\n *     The SHA context to update.\n *\n * Returns:\n *   Nothing.\n *\n * Comments:\n *   Many of the variable names in this code, especially the\n *   single character names, were used because those were the\n *   names used in the Secure Hash Standard.\n */\nstatic void SHA224_256ProcessMessageBlock(SHA256Context *context)\n{\n  /* Constants defined in FIPS 180-3, section 4.2.2 */\n  static const uint32_t K[64] = {\n      0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b,\n      0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01,\n      0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7,\n      0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n      0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152,\n      0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,\n      0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc,\n      0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n      0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819,\n      0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08,\n      0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f,\n      0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n      0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n  };\n  int        t, t4;                   /* Loop counter */\n  uint32_t   temp1, temp2;            /* Temporary word value */\n  uint32_t   W[64];                   /* Word sequence */\n  uint32_t   A, B, C, D, E, F, G, H;  /* Word buffers */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "/*\n * Initialize the first 16 words in the array W\n */\nfor (t = t4 = 0; t < 16; t++, t4 += 4)\n  W[t] = (((uint32_t)context->Message_Block[t4]) << 24) |\n         (((uint32_t)context->Message_Block[t4 + 1]) << 16) |\n         (((uint32_t)context->Message_Block[t4 + 2]) << 8) |\n         (((uint32_t)context->Message_Block[t4 + 3]));",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "for (t = 16; t < 64; t++)\n  W[t] = SHA256_sigma1(W[t-2]) + W[t-7] +\n      SHA256_sigma0(W[t-15]) + W[t-16];",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "A = context->Intermediate_Hash[0];\nB = context->Intermediate_Hash[1];\nC = context->Intermediate_Hash[2];\nD = context->Intermediate_Hash[3];\nE = context->Intermediate_Hash[4];\nF = context->Intermediate_Hash[5];\nG = context->Intermediate_Hash[6];\nH = context->Intermediate_Hash[7];",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "for (t = 0; t < 64; t++) {\n  temp1 = H + SHA256_SIGMA1(E) + SHA_Ch(E,F,G) + K[t] + W[t];\n  temp2 = SHA256_SIGMA0(A) + SHA_Maj(A,B,C);\n  H = G;\n  G = F;\n  F = E;\n  E = D + temp1;\n  D = C;\n  C = B;\n  B = A;\n  A = temp1 + temp2;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "context->Intermediate_Hash[0] += A;\ncontext->Intermediate_Hash[1] += B;\ncontext->Intermediate_Hash[2] += C;\ncontext->Intermediate_Hash[3] += D;\ncontext->Intermediate_Hash[4] += E;\ncontext->Intermediate_Hash[5] += F;\ncontext->Intermediate_Hash[6] += G;\ncontext->Intermediate_Hash[7] += H;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "  context->Message_Block_Index = 0;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * SHA224_256Finalize\n *\n * Description:\n *   This helper function finishes off the digest calculations.\n *\n * Parameters:\n *   context: [in/out]\n *     The SHA context to update.\n *   Pad_Byte: [in]",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": " *     The last byte to add to the message block before the 0-padding\n *     and length.  This will contain the last bits of the message\n *     followed by another single bit.  If the message was an\n *     exact multiple of 8-bits long, Pad_Byte will be 0x80.\n *\n * Returns:\n *   sha Error Code.\n */\nstatic void SHA224_256Finalize(SHA256Context *context,\n    uint8_t Pad_Byte)\n{\n  int i;\n  SHA224_256PadMessage(context, Pad_Byte);\n  /* message may be sensitive, so clear it out */\n  for (i = 0; i < SHA256_Message_Block_Size; ++i)\n    context->Message_Block[i] = 0;\n  context->Length_High = 0;     /* and clear length */\n  context->Length_Low = 0;\n  context->Computed = 1;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * SHA224_256PadMessage\n *\n * Description:\n *   According to the standard, the message must be padded to the next\n *   even multiple of 512 bits.  The first padding bit must be a '1'.\n *   The last 64 bits represent the length of the original message.\n *   All bits in between should be 0.  This helper function will pad\n *   the message according to those rules by filling the\n *   Message_Block array accordingly.  When it returns, it can be\n *   assumed that the message digest has been computed.\n *\n * Parameters:\n *   context: [in/out]\n *     The context to pad.\n *   Pad_Byte: [in]\n *     The last byte to add to the message block before the 0-padding\n *     and length.  This will contain the last bits of the message\n *     followed by another single bit.  If the message was an\n *     exact multiple of 8-bits long, Pad_Byte will be 0x80.\n *\n * Returns:\n *   Nothing.\n */\nstatic void SHA224_256PadMessage(SHA256Context *context,\n    uint8_t Pad_Byte)\n{",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "/*\n * Check to see if the current message block is too small to hold\n * the initial padding bits and length.  If so, we will pad the\n * block, process it, and then continue padding into a second\n * block.\n */\nif (context->Message_Block_Index >= (SHA256_Message_Block_Size-8)) {\n  context->Message_Block[context->Message_Block_Index++] = Pad_Byte;\n  while (context->Message_Block_Index < SHA256_Message_Block_Size)\n    context->Message_Block[context->Message_Block_Index++] = 0;\n  SHA224_256ProcessMessageBlock(context);\n} else\n  context->Message_Block[context->Message_Block_Index++] = Pad_Byte;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "while (context->Message_Block_Index < (SHA256_Message_Block_Size-8))\n  context->Message_Block[context->Message_Block_Index++] = 0;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "/*\n * Store the message length as the last 8 octets\n */\ncontext->Message_Block[56] = (uint8_t)(context->Length_High >> 24);\ncontext->Message_Block[57] = (uint8_t)(context->Length_High >> 16);\ncontext->Message_Block[58] = (uint8_t)(context->Length_High >> 8);\ncontext->Message_Block[59] = (uint8_t)(context->Length_High);\ncontext->Message_Block[60] = (uint8_t)(context->Length_Low >> 24);\ncontext->Message_Block[61] = (uint8_t)(context->Length_Low >> 16);\ncontext->Message_Block[62] = (uint8_t)(context->Length_Low >> 8);\ncontext->Message_Block[63] = (uint8_t)(context->Length_Low);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "  SHA224_256ProcessMessageBlock(context);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * SHA224_256ResultN\n *\n * Description:\n *   This helper function will return the 224-bit or 256-bit message\n *   digest into the Message_Digest array provided by the caller.\n *   NOTE:\n *    The first octet of hash is stored in the element with index 0,\n *    the last octet of hash in the element with index 27/31.\n *\n * Parameters:\n *   context: [in/out]\n *     The context to use to calculate the SHA hash.\n *   Message_Digest[ ]: [out]\n *     Where the digest is returned.\n *   HashSize: [in]",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": " *     The size of the hash, either 28 or 32.\n *\n * Returns:\n *   sha Error Code.\n */\nstatic int SHA224_256ResultN(SHA256Context *context,\n    uint8_t Message_Digest[ ], int HashSize)\n{\n  int i;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "if (!context) return shaNull;\nif (!Message_Digest) return shaNull;\nif (context->Corrupted) return context->Corrupted;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "if (!context->Computed)\n  SHA224_256Finalize(context, 0x80);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "for (i = 0; i < HashSize; ++i)\n  Message_Digest[i] = (uint8_t)\n    (context->Intermediate_Hash[i>>2] >> 8 * ( 3 - ( i & 0x03 ) ));",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "  return shaSuccess;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "8.2.3. sha384-512.c",
      "section_title": true,
      "zh-CHS": "8.2.3. sha384-512.c"
    },
    {
      "indent": 0,
      "text": "/************************* sha384-512.c ************************/\n/***************** See RFC 6234 for details. *******************/\n/* Copyright (c) 2011 IETF Trust and the persons identified as */\n/* authors of the code.  All rights reserved.                  */\n/* See sha.h for terms of use and redistribution.              */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * Description:\n *   This file implements the Secure Hash Algorithms SHA-384 and\n *   SHA-512 as defined in the U.S. National Institute of Standards\n *   and Technology Federal Information Processing Standards\n *   Publication (FIPS PUB) 180-3 published in October 2008\n *   and formerly defined in its predecessors, FIPS PUB 180-1\n *   and FIP PUB 180-2.\n *\n *   A combined document showing all algorithms is available at\n *       http://csrc.nist.gov/publications/fips/\n *              fips180-3/fips180-3_final.pdf\n *\n *   The SHA-384 and SHA-512 algorithms produce 384-bit and 512-bit\n *   message digests for a given data stream.  It should take about\n *   2**n steps to find a message with the same digest as a given",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 1,
      "text": "* message and 2**(n/2) to find any two messages with the same * digest, when n is the digest size in bits. Therefore, this * algorithm can serve as a means of providing a * \"fingerprint\" for a message. * * Portability Issues: * SHA-384 and SHA-512 are defined in terms of 64-bit \"words\", * but if USE_32BIT_ONLY is #defined, this code is implemented in * terms of 32-bit \"words\". This code uses <stdint.h> (included * via \"sha.h\") to define the 64-, 32- and 8-bit unsigned integer * types. If your C compiler does not support 64-bit unsigned * integers and you do not #define USE_32BIT_ONLY, this code is * not appropriate. * * Caveats: * SHA-384 and SHA-512 are designed to work with messages less * than 2^128 bits long. This implementation uses SHA384/512Input() * to hash the bits that are a multiple of the size of an 8-bit * octet, and then optionally uses SHA384/256FinalBits() * to hash the final few bits of the input. * */",
      "zh-CHS": "* message和2**（n/2）查找具有相同*摘要的任意两条消息，其中n是以位为单位的摘要大小。因此，此*算法可作为为消息提供*指纹的一种方法。**可移植性问题：*SHA-384和SHA-512是根据64位“字”定义的，*但如果定义了“仅使用32位”，则此代码是根据*32位“字”实现的。此代码使用<stdint.h>（通过“sha.h”包含*来定义64、32和8位无符号整数*类型。如果您的C编译器不支持64位无符号*整数，并且您不#定义仅使用_32位_，则此代码*不适用。**注意事项：*SHA-384和SHA-512设计用于处理长度小于*2^128位的消息。此实现使用SHA384/512Input（）*散列8位*八位字节大小的倍数，然后可选地使用SHA384/256FinalBits（）*散列输入的最后几位。**/"
    },
    {
      "indent": 0,
      "text": "#include \"sha.h\"",
      "zh-CHS": "#包括“sha.h”"
    },
    {
      "indent": 0,
      "text": "#ifdef USE_32BIT_ONLY\n/*\n * Define 64-bit arithmetic in terms of 32-bit arithmetic.\n * Each 64-bit number is represented in a 2-word array.\n * All macros are defined such that the result is the last parameter.\n */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * Define shift, rotate left, and rotate right functions\n */\n#define SHA512_SHR(bits, word, ret) (                          \\\n    /* (((uint64_t)((word))) >> (bits)) */                     \\\n    (ret)[0] = (((bits) < 32) && ((bits) >= 0)) ?              \\\n      ((word)[0] >> (bits)) : 0,                               \\\n    (ret)[1] = ((bits) > 32) ? ((word)[0] >> ((bits) - 32)) :  \\\n      ((bits) == 32) ? (word)[0] :                             \\\n      ((bits) >= 0) ?                                          \\\n        (((word)[0] << (32 - (bits))) |                        \\\n        ((word)[1] >> (bits))) : 0 )",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "#define SHA512_SHL(bits, word, ret) (                          \\\n    /* (((uint64_t)(word)) << (bits)) */                       \\\n    (ret)[0] = ((bits) > 32) ? ((word)[1] << ((bits) - 32)) :  \\",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "     ((bits) == 32) ? (word)[1] :                          \\\n     ((bits) >= 0) ?                                       \\\n       (((word)[0] << (bits)) |                            \\\n       ((word)[1] >> (32 - (bits)))) :                     \\\n     0,                                                    \\\n(ret)[1] = (((bits) < 32) && ((bits) >= 0)) ?              \\\n    ((word)[1] << (bits)) : 0 )",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * Define 64-bit OR\n */\n#define SHA512_OR(word1, word2, ret) (                         \\\n    (ret)[0] = (word1)[0] | (word2)[0],                        \\\n    (ret)[1] = (word1)[1] | (word2)[1] )",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * Define 64-bit XOR\n */\n#define SHA512_XOR(word1, word2, ret) (                        \\\n    (ret)[0] = (word1)[0] ^ (word2)[0],                        \\\n    (ret)[1] = (word1)[1] ^ (word2)[1] )",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * Define 64-bit AND\n */\n#define SHA512_AND(word1, word2, ret) (                        \\\n    (ret)[0] = (word1)[0] & (word2)[0],                        \\\n    (ret)[1] = (word1)[1] & (word2)[1] )",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * Define 64-bit TILDA\n */\n#define SHA512_TILDA(word, ret)                                \\\n  ( (ret)[0] = ~(word)[0], (ret)[1] = ~(word)[1] )",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * Define 64-bit ADD\n */\n#define SHA512_ADD(word1, word2, ret) (                        \\\n    (ret)[1] = (word1)[1], (ret)[1] += (word2)[1],             \\\n    (ret)[0] = (word1)[0] + (word2)[0] + ((ret)[1] < (word1)[1]) )",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * Add the 4word value in word2 to word1.\n */\nstatic uint32_t ADDTO4_temp, ADDTO4_temp2;\n#define SHA512_ADDTO4(word1, word2) (                          \\\n    ADDTO4_temp = (word1)[3],                                  \\",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "(word1)[3] += (word2)[3],                                  \\\nADDTO4_temp2 = (word1)[2],                                 \\\n(word1)[2] += (word2)[2] + ((word1)[3] < ADDTO4_temp),     \\\nADDTO4_temp = (word1)[1],                                  \\\n(word1)[1] += (word2)[1] + ((word1)[2] < ADDTO4_temp2),    \\\n(word1)[0] += (word2)[0] + ((word1)[1] < ADDTO4_temp) )",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * Add the 2word value in word2 to word1.\n */\nstatic uint32_t ADDTO2_temp;\n#define SHA512_ADDTO2(word1, word2) (                          \\\n    ADDTO2_temp = (word1)[1],                                  \\\n    (word1)[1] += (word2)[1],                                  \\\n    (word1)[0] += (word2)[0] + ((word1)[1] < ADDTO2_temp) )",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * SHA rotate   ((word >> bits) | (word << (64-bits)))\n */\nstatic uint32_t ROTR_temp1[2], ROTR_temp2[2];\n#define SHA512_ROTR(bits, word, ret) (                         \\\n    SHA512_SHR((bits), (word), ROTR_temp1),                    \\\n    SHA512_SHL(64-(bits), (word), ROTR_temp2),                 \\\n    SHA512_OR(ROTR_temp1, ROTR_temp2, (ret)) )",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * Define the SHA SIGMA and sigma macros\n *\n *  SHA512_ROTR(28,word) ^ SHA512_ROTR(34,word) ^ SHA512_ROTR(39,word)\n */\nstatic uint32_t SIGMA0_temp1[2], SIGMA0_temp2[2],\n  SIGMA0_temp3[2], SIGMA0_temp4[2];\n#define SHA512_SIGMA0(word, ret) (                             \\\n    SHA512_ROTR(28, (word), SIGMA0_temp1),                     \\\n    SHA512_ROTR(34, (word), SIGMA0_temp2),                     \\\n    SHA512_ROTR(39, (word), SIGMA0_temp3),                     \\\n    SHA512_XOR(SIGMA0_temp2, SIGMA0_temp3, SIGMA0_temp4),      \\\n    SHA512_XOR(SIGMA0_temp1, SIGMA0_temp4, (ret)) )",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * SHA512_ROTR(14,word) ^ SHA512_ROTR(18,word) ^ SHA512_ROTR(41,word)\n */\nstatic uint32_t SIGMA1_temp1[2], SIGMA1_temp2[2],\n  SIGMA1_temp3[2], SIGMA1_temp4[2];\n#define SHA512_SIGMA1(word, ret) (                             \\\n    SHA512_ROTR(14, (word), SIGMA1_temp1),                     \\\n    SHA512_ROTR(18, (word), SIGMA1_temp2),                     \\\n    SHA512_ROTR(41, (word), SIGMA1_temp3),                     \\",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "SHA512_XOR(SIGMA1_temp2, SIGMA1_temp3, SIGMA1_temp4), \\ SHA512_XOR(SIGMA1_temp1, SIGMA1_temp4, (ret)) )",
      "zh-CHS": "SHA512_XOR（SIGMA1_temp2，SIGMA1_temp3，SIGMA1_temp4），\\SHA512_XOR（SIGMA1_temp1，SIGMA1_temp4，（ret）））"
    },
    {
      "indent": 0,
      "text": "/*\n * (SHA512_ROTR( 1,word) ^ SHA512_ROTR( 8,word) ^ SHA512_SHR( 7,word))\n */\nstatic uint32_t sigma0_temp1[2], sigma0_temp2[2],\n  sigma0_temp3[2], sigma0_temp4[2];\n#define SHA512_sigma0(word, ret) (                             \\\n    SHA512_ROTR( 1, (word), sigma0_temp1),                     \\\n    SHA512_ROTR( 8, (word), sigma0_temp2),                     \\\n    SHA512_SHR( 7, (word), sigma0_temp3),                      \\\n    SHA512_XOR(sigma0_temp2, sigma0_temp3, sigma0_temp4),      \\\n    SHA512_XOR(sigma0_temp1, sigma0_temp4, (ret)) )",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * (SHA512_ROTR(19,word) ^ SHA512_ROTR(61,word) ^ SHA512_SHR( 6,word))\n */\nstatic uint32_t sigma1_temp1[2], sigma1_temp2[2],\n  sigma1_temp3[2], sigma1_temp4[2];\n#define SHA512_sigma1(word, ret) (                             \\\n    SHA512_ROTR(19, (word), sigma1_temp1),                     \\\n    SHA512_ROTR(61, (word), sigma1_temp2),                     \\\n    SHA512_SHR( 6, (word), sigma1_temp3),                      \\\n    SHA512_XOR(sigma1_temp2, sigma1_temp3, sigma1_temp4),      \\\n    SHA512_XOR(sigma1_temp1, sigma1_temp4, (ret)) )",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "#ifndef USE_MODIFIED_MACROS\n/*\n * These definitions are the ones used in FIPS 180-3, section 4.1.3\n *  Ch(x,y,z)   ((x & y) ^ (~x & z))\n */\nstatic uint32_t Ch_temp1[2], Ch_temp2[2], Ch_temp3[2];\n#define SHA_Ch(x, y, z, ret) (                                 \\\n    SHA512_AND(x, y, Ch_temp1),                                \\\n    SHA512_TILDA(x, Ch_temp2),                                 \\\n    SHA512_AND(Ch_temp2, z, Ch_temp3),                         \\\n    SHA512_XOR(Ch_temp1, Ch_temp3, (ret)) )",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n *  Maj(x,y,z)  (((x)&(y)) ^ ((x)&(z)) ^ ((y)&(z)))\n */\nstatic uint32_t Maj_temp1[2], Maj_temp2[2],\n  Maj_temp3[2], Maj_temp4[2];\n#define SHA_Maj(x, y, z, ret) (                                \\\n    SHA512_AND(x, y, Maj_temp1),                               \\\n    SHA512_AND(x, z, Maj_temp2),                               \\\n    SHA512_AND(y, z, Maj_temp3),                               \\",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "    SHA512_XOR(Maj_temp2, Maj_temp3, Maj_temp4),               \\\n    SHA512_XOR(Maj_temp1, Maj_temp4, (ret)) )\n#else /* !USE_MODIFIED_MACROS */\n/*\n * These definitions are potentially faster equivalents for the ones\n * used in FIPS 180-3, section 4.1.3.\n *   ((x & y) ^ (~x & z)) becomes\n *   ((x & (y ^ z)) ^ z)\n */\n#define SHA_Ch(x, y, z, ret) (                                 \\\n   (ret)[0] = (((x)[0] & ((y)[0] ^ (z)[0])) ^ (z)[0]),         \\\n   (ret)[1] = (((x)[1] & ((y)[1] ^ (z)[1])) ^ (z)[1]) )",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n *   ((x & y) ^ (x & z) ^ (y & z)) becomes\n *   ((x & (y | z)) | (y & z))\n */\n#define SHA_Maj(x, y, z, ret) (                                 \\\n   ret[0] = (((x)[0] & ((y)[0] | (z)[0])) | ((y)[0] & (z)[0])), \\\n   ret[1] = (((x)[1] & ((y)[1] | (z)[1])) | ((y)[1] & (z)[1])) )\n#endif /* USE_MODIFIED_MACROS */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * Add \"length\" to the length.\n * Set Corrupted when overflow has occurred.\n */\nstatic uint32_t addTemp[4] = { 0, 0, 0, 0 };\n#define SHA384_512AddLength(context, length) (                        \\\n    addTemp[3] = (length), SHA512_ADDTO4((context)->Length, addTemp), \\\n    (context)->Corrupted = (((context)->Length[3] < (length)) &&      \\\n       ((context)->Length[2] == 0) && ((context)->Length[1] == 0) &&  \\\n       ((context)->Length[0] == 0)) ? shaInputTooLong :               \\\n                                      (context)->Corrupted )",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/* Local Function Prototypes */\nstatic int SHA384_512Reset(SHA512Context *context,\n                           uint32_t H0[SHA512HashSize/4]);\nstatic void SHA384_512ProcessMessageBlock(SHA512Context *context);\nstatic void SHA384_512Finalize(SHA512Context *context,\n  uint8_t Pad_Byte);\nstatic void SHA384_512PadMessage(SHA512Context *context,\n  uint8_t Pad_Byte);\nstatic int SHA384_512ResultN( SHA512Context *context,\n  uint8_t Message_Digest[ ], int HashSize);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/* Initial Hash Values: FIPS 180-3 sections 5.3.4 and 5.3.5 */\nstatic uint32_t SHA384_H0[SHA512HashSize/4] = {\n    0xCBBB9D5D, 0xC1059ED8, 0x629A292A, 0x367CD507, 0x9159015A,",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "    0x3070DD17, 0x152FECD8, 0xF70E5939, 0x67332667, 0xFFC00B31,\n    0x8EB44A87, 0x68581511, 0xDB0C2E0D, 0x64F98FA7, 0x47B5481D,\n    0xBEFA4FA4\n};\nstatic uint32_t SHA512_H0[SHA512HashSize/4] = {\n    0x6A09E667, 0xF3BCC908, 0xBB67AE85, 0x84CAA73B, 0x3C6EF372,\n    0xFE94F82B, 0xA54FF53A, 0x5F1D36F1, 0x510E527F, 0xADE682D1,\n    0x9B05688C, 0x2B3E6C1F, 0x1F83D9AB, 0xFB41BD6B, 0x5BE0CD19,\n    0x137E2179\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "#else /* !USE_32BIT_ONLY */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "#include \"sha-private.h\"",
      "zh-CHS": "#包括“sha private.h”"
    },
    {
      "indent": 0,
      "text": "/* Define the SHA shift, rotate left and rotate right macros */\n#define SHA512_SHR(bits,word)  (((uint64_t)(word)) >> (bits))\n#define SHA512_ROTR(bits,word) ((((uint64_t)(word)) >> (bits)) | \\\n                                (((uint64_t)(word)) << (64-(bits))))",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * Define the SHA SIGMA and sigma macros\n *\n *  SHA512_ROTR(28,word) ^ SHA512_ROTR(34,word) ^ SHA512_ROTR(39,word)\n */\n#define SHA512_SIGMA0(word)   \\\n (SHA512_ROTR(28,word) ^ SHA512_ROTR(34,word) ^ SHA512_ROTR(39,word))\n#define SHA512_SIGMA1(word)   \\\n (SHA512_ROTR(14,word) ^ SHA512_ROTR(18,word) ^ SHA512_ROTR(41,word))\n#define SHA512_sigma0(word)   \\\n (SHA512_ROTR( 1,word) ^ SHA512_ROTR( 8,word) ^ SHA512_SHR( 7,word))\n#define SHA512_sigma1(word)   \\\n (SHA512_ROTR(19,word) ^ SHA512_ROTR(61,word) ^ SHA512_SHR( 6,word))",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * Add \"length\" to the length.\n * Set Corrupted when overflow has occurred.\n */\nstatic uint64_t addTemp;\n#define SHA384_512AddLength(context, length)                   \\\n   (addTemp = context->Length_Low, context->Corrupted =        \\\n    ((context->Length_Low += length) < addTemp) &&             \\\n    (++context->Length_High == 0) ? shaInputTooLong :          \\\n                                    (context)->Corrupted)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/* Local Function Prototypes */\nstatic int SHA384_512Reset(SHA512Context *context,\n                           uint64_t H0[SHA512HashSize/8]);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "static void SHA384_512ProcessMessageBlock(SHA512Context *context);\nstatic void SHA384_512Finalize(SHA512Context *context,\n  uint8_t Pad_Byte);\nstatic void SHA384_512PadMessage(SHA512Context *context,\n  uint8_t Pad_Byte);\nstatic int SHA384_512ResultN(SHA512Context *context,\n  uint8_t Message_Digest[ ], int HashSize);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/* Initial Hash Values: FIPS 180-3 sections 5.3.4 and 5.3.5 */\nstatic uint64_t SHA384_H0[ ] = {\n    0xCBBB9D5DC1059ED8ll, 0x629A292A367CD507ll, 0x9159015A3070DD17ll,\n    0x152FECD8F70E5939ll, 0x67332667FFC00B31ll, 0x8EB44A8768581511ll,\n    0xDB0C2E0D64F98FA7ll, 0x47B5481DBEFA4FA4ll\n};\nstatic uint64_t SHA512_H0[ ] = {\n    0x6A09E667F3BCC908ll, 0xBB67AE8584CAA73Bll, 0x3C6EF372FE94F82Bll,\n    0xA54FF53A5F1D36F1ll, 0x510E527FADE682D1ll, 0x9B05688C2B3E6C1Fll,\n    0x1F83D9ABFB41BD6Bll, 0x5BE0CD19137E2179ll\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "#endif /* USE_32BIT_ONLY */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * SHA384Reset\n *\n * Description:\n *   This function will initialize the SHA384Context in preparation\n *   for computing a new SHA384 message digest.\n *\n * Parameters:\n *   context: [in/out]\n *     The context to reset.\n *\n * Returns:\n *   sha Error Code.\n *\n */\nint SHA384Reset(SHA384Context *context)\n{\n  return SHA384_512Reset(context, SHA384_H0);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * SHA384Input\n *\n * Description:\n *   This function accepts an array of octets as the next portion\n *   of the message.",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": " *\n * Parameters:\n *   context: [in/out]\n *     The SHA context to update.\n *   message_array[ ]: [in]\n *     An array of octets representing the next portion of\n *     the message.\n *   length: [in]\n *     The length of the message in message_array.\n *\n * Returns:\n *   sha Error Code.\n *\n */\nint SHA384Input(SHA384Context *context,\n    const uint8_t *message_array, unsigned int length)\n{\n  return SHA512Input(context, message_array, length);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * SHA384FinalBits\n *\n * Description:\n *   This function will add in any final bits of the message.\n *\n * Parameters:\n *   context: [in/out]\n *     The SHA context to update.\n *   message_bits: [in]\n *     The final bits of the message, in the upper portion of the\n *     byte.  (Use 0b###00000 instead of 0b00000### to input the\n *     three bits ###.)\n *   length: [in]\n *     The number of bits in message_bits, between 1 and 7.\n *\n * Returns:\n *   sha Error Code.\n *\n */\nint SHA384FinalBits(SHA384Context *context,\n                    uint8_t message_bits, unsigned int length)\n{\n  return SHA512FinalBits(context, message_bits, length);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * SHA384Result",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": " *\n * Description:\n *   This function will return the 384-bit message digest\n *   into the Message_Digest array provided by the caller.\n *   NOTE:\n *    The first octet of hash is stored in the element with index 0,\n *    the last octet of hash in the element with index 47.\n *\n * Parameters:\n *   context: [in/out]\n *     The context to use to calculate the SHA hash.\n *   Message_Digest[ ]: [out]\n *     Where the digest is returned.\n *\n * Returns:\n *   sha Error Code.\n *\n */\nint SHA384Result(SHA384Context *context,\n    uint8_t Message_Digest[SHA384HashSize])\n{\n  return SHA384_512ResultN(context, Message_Digest, SHA384HashSize);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * SHA512Reset\n *\n * Description:\n *   This function will initialize the SHA512Context in preparation\n *   for computing a new SHA512 message digest.\n *\n * Parameters:\n *   context: [in/out]\n *     The context to reset.\n *\n * Returns:\n *   sha Error Code.\n *\n */\nint SHA512Reset(SHA512Context *context)\n{\n  return SHA384_512Reset(context, SHA512_H0);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * SHA512Input\n *\n * Description:",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": " *   This function accepts an array of octets as the next portion\n *   of the message.\n *\n * Parameters:\n *   context: [in/out]\n *     The SHA context to update.\n *   message_array[ ]: [in]\n *     An array of octets representing the next portion of\n *     the message.\n *   length: [in]\n *     The length of the message in message_array.\n *\n * Returns:\n *   sha Error Code.\n *\n */\nint SHA512Input(SHA512Context *context,\n        const uint8_t *message_array,\n        unsigned int length)\n{\n  if (!context) return shaNull;\n  if (!length) return shaSuccess;\n  if (!message_array) return shaNull;\n  if (context->Computed) return context->Corrupted = shaStateError;\n  if (context->Corrupted) return context->Corrupted;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "while (length--) {\n  context->Message_Block[context->Message_Block_Index++] =\n          *message_array;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "if ((SHA384_512AddLength(context, 8) == shaSuccess) &&\n  (context->Message_Block_Index == SHA512_Message_Block_Size))\n  SHA384_512ProcessMessageBlock(context);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "  message_array++;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "  return context->Corrupted;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * SHA512FinalBits\n *\n * Description:\n *   This function will add in any final bits of the message.\n *\n * Parameters:\n *   context: [in/out]",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": " *     The SHA context to update.\n *   message_bits: [in]\n *     The final bits of the message, in the upper portion of the\n *     byte.  (Use 0b###00000 instead of 0b00000### to input the\n *     three bits ###.)\n *   length: [in]\n *     The number of bits in message_bits, between 1 and 7.\n *\n * Returns:\n *   sha Error Code.\n *\n */\nint SHA512FinalBits(SHA512Context *context,\n                    uint8_t message_bits, unsigned int length)\n{\n  static uint8_t masks[8] = {\n      /* 0 0b00000000 */ 0x00, /* 1 0b10000000 */ 0x80,\n      /* 2 0b11000000 */ 0xC0, /* 3 0b11100000 */ 0xE0,\n      /* 4 0b11110000 */ 0xF0, /* 5 0b11111000 */ 0xF8,\n      /* 6 0b11111100 */ 0xFC, /* 7 0b11111110 */ 0xFE\n  };\n  static uint8_t markbit[8] = {\n      /* 0 0b10000000 */ 0x80, /* 1 0b01000000 */ 0x40,\n      /* 2 0b00100000 */ 0x20, /* 3 0b00010000 */ 0x10,\n      /* 4 0b00001000 */ 0x08, /* 5 0b00000100 */ 0x04,\n      /* 6 0b00000010 */ 0x02, /* 7 0b00000001 */ 0x01\n  };",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "if (!context) return shaNull;\nif (!length) return shaSuccess;\nif (context->Corrupted) return context->Corrupted;\nif (context->Computed) return context->Corrupted = shaStateError;\nif (length >= 8) return context->Corrupted = shaBadParam;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "SHA384_512AddLength(context, length);\nSHA384_512Finalize(context, (uint8_t)\n  ((message_bits & masks[length]) | markbit[length]));",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "  return context->Corrupted;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * SHA512Result\n *\n * Description:\n *   This function will return the 512-bit message digest\n *   into the Message_Digest array provided by the caller.\n *   NOTE:",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": " *    The first octet of hash is stored in the element with index 0,\n *    the last octet of hash in the element with index 63.\n *\n * Parameters:\n *   context: [in/out]\n *     The context to use to calculate the SHA hash.\n *   Message_Digest[ ]: [out]\n *     Where the digest is returned.\n *\n * Returns:\n *   sha Error Code.\n *\n */\nint SHA512Result(SHA512Context *context,\n    uint8_t Message_Digest[SHA512HashSize])\n{\n  return SHA384_512ResultN(context, Message_Digest, SHA512HashSize);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * SHA384_512Reset\n *\n * Description:\n *   This helper function will initialize the SHA512Context in\n *   preparation for computing a new SHA384 or SHA512 message\n *   digest.\n *\n * Parameters:\n *   context: [in/out]\n *     The context to reset.\n *   H0[ ]: [in]\n *     The initial hash value array to use.\n *\n * Returns:\n *   sha Error Code.\n *\n */\n#ifdef USE_32BIT_ONLY\nstatic int SHA384_512Reset(SHA512Context *context,\n                           uint32_t H0[SHA512HashSize/4])\n#else /* !USE_32BIT_ONLY */\nstatic int SHA384_512Reset(SHA512Context *context,\n                           uint64_t H0[SHA512HashSize/8])\n#endif /* USE_32BIT_ONLY */\n{\n  int i;\n  if (!context) return shaNull;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "context->Message_Block_Index = 0;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "#ifdef USE_32BIT_ONLY\n  context->Length[0] = context->Length[1] =\n  context->Length[2] = context->Length[3] = 0;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "  for (i = 0; i < SHA512HashSize/4; i++)\n    context->Intermediate_Hash[i] = H0[i];\n#else /* !USE_32BIT_ONLY */\n  context->Length_High = context->Length_Low = 0;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "  for (i = 0; i < SHA512HashSize/8; i++)\n    context->Intermediate_Hash[i] = H0[i];\n#endif /* USE_32BIT_ONLY */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "context->Computed = 0;\ncontext->Corrupted = shaSuccess;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "  return shaSuccess;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * SHA384_512ProcessMessageBlock\n *\n * Description:\n *   This helper function will process the next 1024 bits of the\n *   message stored in the Message_Block array.\n *\n * Parameters:\n *   context: [in/out]\n *     The SHA context to update.\n *\n * Returns:\n *   Nothing.\n *\n * Comments:\n *   Many of the variable names in this code, especially the\n *   single character names, were used because those were the\n *   names used in the Secure Hash Standard.\n *\n *\n */\nstatic void SHA384_512ProcessMessageBlock(SHA512Context *context)\n{\n#ifdef USE_32BIT_ONLY\n  /* Constants defined in FIPS 180-3, section 4.2.3 */\n  static const uint32_t K[80*2] = {\n      0x428A2F98, 0xD728AE22, 0x71374491, 0x23EF65CD, 0xB5C0FBCF,",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "    0xEC4D3B2F, 0xE9B5DBA5, 0x8189DBBC, 0x3956C25B, 0xF348B538,\n    0x59F111F1, 0xB605D019, 0x923F82A4, 0xAF194F9B, 0xAB1C5ED5,\n    0xDA6D8118, 0xD807AA98, 0xA3030242, 0x12835B01, 0x45706FBE,\n    0x243185BE, 0x4EE4B28C, 0x550C7DC3, 0xD5FFB4E2, 0x72BE5D74,\n    0xF27B896F, 0x80DEB1FE, 0x3B1696B1, 0x9BDC06A7, 0x25C71235,\n    0xC19BF174, 0xCF692694, 0xE49B69C1, 0x9EF14AD2, 0xEFBE4786,\n    0x384F25E3, 0x0FC19DC6, 0x8B8CD5B5, 0x240CA1CC, 0x77AC9C65,\n    0x2DE92C6F, 0x592B0275, 0x4A7484AA, 0x6EA6E483, 0x5CB0A9DC,\n    0xBD41FBD4, 0x76F988DA, 0x831153B5, 0x983E5152, 0xEE66DFAB,\n    0xA831C66D, 0x2DB43210, 0xB00327C8, 0x98FB213F, 0xBF597FC7,\n    0xBEEF0EE4, 0xC6E00BF3, 0x3DA88FC2, 0xD5A79147, 0x930AA725,\n    0x06CA6351, 0xE003826F, 0x14292967, 0x0A0E6E70, 0x27B70A85,\n    0x46D22FFC, 0x2E1B2138, 0x5C26C926, 0x4D2C6DFC, 0x5AC42AED,\n    0x53380D13, 0x9D95B3DF, 0x650A7354, 0x8BAF63DE, 0x766A0ABB,\n    0x3C77B2A8, 0x81C2C92E, 0x47EDAEE6, 0x92722C85, 0x1482353B,\n    0xA2BFE8A1, 0x4CF10364, 0xA81A664B, 0xBC423001, 0xC24B8B70,\n    0xD0F89791, 0xC76C51A3, 0x0654BE30, 0xD192E819, 0xD6EF5218,\n    0xD6990624, 0x5565A910, 0xF40E3585, 0x5771202A, 0x106AA070,\n    0x32BBD1B8, 0x19A4C116, 0xB8D2D0C8, 0x1E376C08, 0x5141AB53,\n    0x2748774C, 0xDF8EEB99, 0x34B0BCB5, 0xE19B48A8, 0x391C0CB3,\n    0xC5C95A63, 0x4ED8AA4A, 0xE3418ACB, 0x5B9CCA4F, 0x7763E373,\n    0x682E6FF3, 0xD6B2B8A3, 0x748F82EE, 0x5DEFB2FC, 0x78A5636F,\n    0x43172F60, 0x84C87814, 0xA1F0AB72, 0x8CC70208, 0x1A6439EC,\n    0x90BEFFFA, 0x23631E28, 0xA4506CEB, 0xDE82BDE9, 0xBEF9A3F7,\n    0xB2C67915, 0xC67178F2, 0xE372532B, 0xCA273ECE, 0xEA26619C,\n    0xD186B8C7, 0x21C0C207, 0xEADA7DD6, 0xCDE0EB1E, 0xF57D4F7F,\n    0xEE6ED178, 0x06F067AA, 0x72176FBA, 0x0A637DC5, 0xA2C898A6,\n    0x113F9804, 0xBEF90DAE, 0x1B710B35, 0x131C471B, 0x28DB77F5,\n    0x23047D84, 0x32CAAB7B, 0x40C72493, 0x3C9EBE0A, 0x15C9BEBC,\n    0x431D67C4, 0x9C100D4C, 0x4CC5D4BE, 0xCB3E42B6, 0x597F299C,\n    0xFC657E2A, 0x5FCB6FAB, 0x3AD6FAEC, 0x6C44198C, 0x4A475817\n};\nint     t, t2, t8;                  /* Loop counter */\nuint32_t  temp1[2], temp2[2],       /* Temporary word values */\n      temp3[2], temp4[2], temp5[2];\nuint32_t  W[2*80];                  /* Word sequence */\nuint32_t  A[2], B[2], C[2], D[2],   /* Word buffers */\n      E[2], F[2], G[2], H[2];",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "/* Initialize the first 16 words in the array W */\nfor (t = t2 = t8 = 0; t < 16; t++, t8 += 8) {\n  W[t2++] = ((((uint32_t)context->Message_Block[t8    ])) << 24) |\n            ((((uint32_t)context->Message_Block[t8 + 1])) << 16) |\n            ((((uint32_t)context->Message_Block[t8 + 2])) << 8) |\n            ((((uint32_t)context->Message_Block[t8 + 3])));\n  W[t2++] = ((((uint32_t)context->Message_Block[t8 + 4])) << 24) |\n            ((((uint32_t)context->Message_Block[t8 + 5])) << 16) |\n            ((((uint32_t)context->Message_Block[t8 + 6])) << 8) |",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "            ((((uint32_t)context->Message_Block[t8 + 7])));\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "for (t = 16; t < 80; t++, t2 += 2) {\n  /* W[t] = SHA512_sigma1(W[t-2]) + W[t-7] +\n    SHA512_sigma0(W[t-15]) + W[t-16]; */\n  uint32_t *Wt2 = &W[t2-2*2];\n  uint32_t *Wt7 = &W[t2-7*2];\n  uint32_t *Wt15 = &W[t2-15*2];\n  uint32_t *Wt16 = &W[t2-16*2];\n  SHA512_sigma1(Wt2, temp1);\n  SHA512_ADD(temp1, Wt7, temp2);\n  SHA512_sigma0(Wt15, temp1);\n  SHA512_ADD(temp1, Wt16, temp3);\n  SHA512_ADD(temp2, temp3, &W[t2]);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "A[0] = context->Intermediate_Hash[0];\nA[1] = context->Intermediate_Hash[1];\nB[0] = context->Intermediate_Hash[2];\nB[1] = context->Intermediate_Hash[3];\nC[0] = context->Intermediate_Hash[4];\nC[1] = context->Intermediate_Hash[5];\nD[0] = context->Intermediate_Hash[6];\nD[1] = context->Intermediate_Hash[7];\nE[0] = context->Intermediate_Hash[8];\nE[1] = context->Intermediate_Hash[9];\nF[0] = context->Intermediate_Hash[10];\nF[1] = context->Intermediate_Hash[11];\nG[0] = context->Intermediate_Hash[12];\nG[1] = context->Intermediate_Hash[13];\nH[0] = context->Intermediate_Hash[14];\nH[1] = context->Intermediate_Hash[15];",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "for (t = t2 = 0; t < 80; t++, t2 += 2) {\n  /*\n   * temp1 = H + SHA512_SIGMA1(E) + SHA_Ch(E,F,G) + K[t] + W[t];\n   */\n  SHA512_SIGMA1(E,temp1);\n  SHA512_ADD(H, temp1, temp2);\n  SHA_Ch(E,F,G,temp3);\n  SHA512_ADD(temp2, temp3, temp4);\n  SHA512_ADD(&K[t2], &W[t2], temp5);\n  SHA512_ADD(temp4, temp5, temp1);\n  /*\n   * temp2 = SHA512_SIGMA0(A) + SHA_Maj(A,B,C);\n   */\n  SHA512_SIGMA0(A,temp3);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "  SHA_Maj(A,B,C,temp4);\n  SHA512_ADD(temp3, temp4, temp2);\n  H[0] = G[0]; H[1] = G[1];\n  G[0] = F[0]; G[1] = F[1];\n  F[0] = E[0]; F[1] = E[1];\n  SHA512_ADD(D, temp1, E);\n  D[0] = C[0]; D[1] = C[1];\n  C[0] = B[0]; C[1] = B[1];\n  B[0] = A[0]; B[1] = A[1];\n  SHA512_ADD(temp1, temp2, A);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "SHA512_ADDTO2(&context->Intermediate_Hash[0], A);\nSHA512_ADDTO2(&context->Intermediate_Hash[2], B);\nSHA512_ADDTO2(&context->Intermediate_Hash[4], C);\nSHA512_ADDTO2(&context->Intermediate_Hash[6], D);\nSHA512_ADDTO2(&context->Intermediate_Hash[8], E);\nSHA512_ADDTO2(&context->Intermediate_Hash[10], F);\nSHA512_ADDTO2(&context->Intermediate_Hash[12], G);\nSHA512_ADDTO2(&context->Intermediate_Hash[14], H);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "#else /* !USE_32BIT_ONLY */\n  /* Constants defined in FIPS 180-3, section 4.2.3 */\n  static const uint64_t K[80] = {\n      0x428A2F98D728AE22ll, 0x7137449123EF65CDll, 0xB5C0FBCFEC4D3B2Fll,\n      0xE9B5DBA58189DBBCll, 0x3956C25BF348B538ll, 0x59F111F1B605D019ll,\n      0x923F82A4AF194F9Bll, 0xAB1C5ED5DA6D8118ll, 0xD807AA98A3030242ll,\n      0x12835B0145706FBEll, 0x243185BE4EE4B28Cll, 0x550C7DC3D5FFB4E2ll,\n      0x72BE5D74F27B896Fll, 0x80DEB1FE3B1696B1ll, 0x9BDC06A725C71235ll,\n      0xC19BF174CF692694ll, 0xE49B69C19EF14AD2ll, 0xEFBE4786384F25E3ll,\n      0x0FC19DC68B8CD5B5ll, 0x240CA1CC77AC9C65ll, 0x2DE92C6F592B0275ll,\n      0x4A7484AA6EA6E483ll, 0x5CB0A9DCBD41FBD4ll, 0x76F988DA831153B5ll,\n      0x983E5152EE66DFABll, 0xA831C66D2DB43210ll, 0xB00327C898FB213Fll,\n      0xBF597FC7BEEF0EE4ll, 0xC6E00BF33DA88FC2ll, 0xD5A79147930AA725ll,\n      0x06CA6351E003826Fll, 0x142929670A0E6E70ll, 0x27B70A8546D22FFCll,\n      0x2E1B21385C26C926ll, 0x4D2C6DFC5AC42AEDll, 0x53380D139D95B3DFll,\n      0x650A73548BAF63DEll, 0x766A0ABB3C77B2A8ll, 0x81C2C92E47EDAEE6ll,\n      0x92722C851482353Bll, 0xA2BFE8A14CF10364ll, 0xA81A664BBC423001ll,\n      0xC24B8B70D0F89791ll, 0xC76C51A30654BE30ll, 0xD192E819D6EF5218ll,\n      0xD69906245565A910ll, 0xF40E35855771202All, 0x106AA07032BBD1B8ll,\n      0x19A4C116B8D2D0C8ll, 0x1E376C085141AB53ll, 0x2748774CDF8EEB99ll,\n      0x34B0BCB5E19B48A8ll, 0x391C0CB3C5C95A63ll, 0x4ED8AA4AE3418ACBll,\n      0x5B9CCA4F7763E373ll, 0x682E6FF3D6B2B8A3ll, 0x748F82EE5DEFB2FCll,\n      0x78A5636F43172F60ll, 0x84C87814A1F0AB72ll, 0x8CC702081A6439ECll,\n      0x90BEFFFA23631E28ll, 0xA4506CEBDE82BDE9ll, 0xBEF9A3F7B2C67915ll,\n      0xC67178F2E372532Bll, 0xCA273ECEEA26619Cll, 0xD186B8C721C0C207ll,\n      0xEADA7DD6CDE0EB1Ell, 0xF57D4F7FEE6ED178ll, 0x06F067AA72176FBAll,\n      0x0A637DC5A2C898A6ll, 0x113F9804BEF90DAEll, 0x1B710B35131C471Bll,",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "    0x28DB77F523047D84ll, 0x32CAAB7B40C72493ll, 0x3C9EBE0A15C9BEBCll,\n    0x431D67C49C100D4Cll, 0x4CC5D4BECB3E42B6ll, 0x597F299CFC657E2All,\n    0x5FCB6FAB3AD6FAECll, 0x6C44198C4A475817ll\n};\nint        t, t8;                   /* Loop counter */\nuint64_t   temp1, temp2;            /* Temporary word value */\nuint64_t   W[80];                   /* Word sequence */\nuint64_t   A, B, C, D, E, F, G, H;  /* Word buffers */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "/*\n * Initialize the first 16 words in the array W\n */\nfor (t = t8 = 0; t < 16; t++, t8 += 8)\n  W[t] = ((uint64_t)(context->Message_Block[t8  ]) << 56) |\n         ((uint64_t)(context->Message_Block[t8 + 1]) << 48) |\n         ((uint64_t)(context->Message_Block[t8 + 2]) << 40) |\n         ((uint64_t)(context->Message_Block[t8 + 3]) << 32) |\n         ((uint64_t)(context->Message_Block[t8 + 4]) << 24) |\n         ((uint64_t)(context->Message_Block[t8 + 5]) << 16) |\n         ((uint64_t)(context->Message_Block[t8 + 6]) << 8) |\n         ((uint64_t)(context->Message_Block[t8 + 7]));",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "for (t = 16; t < 80; t++)\n  W[t] = SHA512_sigma1(W[t-2]) + W[t-7] +\n      SHA512_sigma0(W[t-15]) + W[t-16];\nA = context->Intermediate_Hash[0];\nB = context->Intermediate_Hash[1];\nC = context->Intermediate_Hash[2];\nD = context->Intermediate_Hash[3];\nE = context->Intermediate_Hash[4];\nF = context->Intermediate_Hash[5];\nG = context->Intermediate_Hash[6];\nH = context->Intermediate_Hash[7];",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "for (t = 0; t < 80; t++) {\n  temp1 = H + SHA512_SIGMA1(E) + SHA_Ch(E,F,G) + K[t] + W[t];\n  temp2 = SHA512_SIGMA0(A) + SHA_Maj(A,B,C);\n  H = G;\n  G = F;\n  F = E;\n  E = D + temp1;\n  D = C;\n  C = B;\n  B = A;\n  A = temp1 + temp2;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "context->Intermediate_Hash[0] += A;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "  context->Intermediate_Hash[1] += B;\n  context->Intermediate_Hash[2] += C;\n  context->Intermediate_Hash[3] += D;\n  context->Intermediate_Hash[4] += E;\n  context->Intermediate_Hash[5] += F;\n  context->Intermediate_Hash[6] += G;\n  context->Intermediate_Hash[7] += H;\n#endif /* USE_32BIT_ONLY */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "  context->Message_Block_Index = 0;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * SHA384_512Finalize\n *\n * Description:\n *   This helper function finishes off the digest calculations.\n *\n * Parameters:\n *   context: [in/out]\n *     The SHA context to update.\n *   Pad_Byte: [in]\n *     The last byte to add to the message block before the 0-padding\n *     and length.  This will contain the last bits of the message\n *     followed by another single bit.  If the message was an\n *     exact multiple of 8-bits long, Pad_Byte will be 0x80.\n *\n * Returns:\n *   sha Error Code.\n *\n */\nstatic void SHA384_512Finalize(SHA512Context *context,\n    uint8_t Pad_Byte)\n{\n  int_least16_t i;\n  SHA384_512PadMessage(context, Pad_Byte);\n  /* message may be sensitive, clear it out */\n  for (i = 0; i < SHA512_Message_Block_Size; ++i)\n    context->Message_Block[i] = 0;\n#ifdef USE_32BIT_ONLY    /* and clear length */\n  context->Length[0] = context->Length[1] = 0;\n  context->Length[2] = context->Length[3] = 0;\n#else /* !USE_32BIT_ONLY */\n  context->Length_High = context->Length_Low = 0;\n#endif /* USE_32BIT_ONLY */\n  context->Computed = 1;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * SHA384_512PadMessage\n *\n * Description:\n *   According to the standard, the message must be padded to the next\n *   even multiple of 1024 bits.  The first padding bit must be a '1'.\n *   The last 128 bits represent the length of the original message.\n *   All bits in between should be 0.  This helper function will\n *   pad the message according to those rules by filling the\n *   Message_Block array accordingly.  When it returns, it can be\n *   assumed that the message digest has been computed.\n *\n * Parameters:\n *   context: [in/out]\n *     The context to pad.\n *   Pad_Byte: [in]\n *     The last byte to add to the message block before the 0-padding\n *     and length.  This will contain the last bits of the message\n *     followed by another single bit.  If the message was an\n *     exact multiple of 8-bits long, Pad_Byte will be 0x80.\n *\n * Returns:\n *   Nothing.\n *\n */\nstatic void SHA384_512PadMessage(SHA512Context *context,\n    uint8_t Pad_Byte)\n{\n  /*\n   * Check to see if the current message block is too small to hold\n   * the initial padding bits and length.  If so, we will pad the\n   * block, process it, and then continue padding into a second\n   * block.\n   */\n  if (context->Message_Block_Index >= (SHA512_Message_Block_Size-16)) {\n    context->Message_Block[context->Message_Block_Index++] = Pad_Byte;\n    while (context->Message_Block_Index < SHA512_Message_Block_Size)\n      context->Message_Block[context->Message_Block_Index++] = 0;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "  SHA384_512ProcessMessageBlock(context);\n} else\n  context->Message_Block[context->Message_Block_Index++] = Pad_Byte;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "while (context->Message_Block_Index < (SHA512_Message_Block_Size-16))\n  context->Message_Block[context->Message_Block_Index++] = 0;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "/*\n * Store the message length as the last 16 octets",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "   */\n#ifdef USE_32BIT_ONLY\n  context->Message_Block[112] = (uint8_t)(context->Length[0] >> 24);\n  context->Message_Block[113] = (uint8_t)(context->Length[0] >> 16);\n  context->Message_Block[114] = (uint8_t)(context->Length[0] >> 8);\n  context->Message_Block[115] = (uint8_t)(context->Length[0]);\n  context->Message_Block[116] = (uint8_t)(context->Length[1] >> 24);\n  context->Message_Block[117] = (uint8_t)(context->Length[1] >> 16);\n  context->Message_Block[118] = (uint8_t)(context->Length[1] >> 8);\n  context->Message_Block[119] = (uint8_t)(context->Length[1]);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "  context->Message_Block[120] = (uint8_t)(context->Length[2] >> 24);\n  context->Message_Block[121] = (uint8_t)(context->Length[2] >> 16);\n  context->Message_Block[122] = (uint8_t)(context->Length[2] >> 8);\n  context->Message_Block[123] = (uint8_t)(context->Length[2]);\n  context->Message_Block[124] = (uint8_t)(context->Length[3] >> 24);\n  context->Message_Block[125] = (uint8_t)(context->Length[3] >> 16);\n  context->Message_Block[126] = (uint8_t)(context->Length[3] >> 8);\n  context->Message_Block[127] = (uint8_t)(context->Length[3]);\n#else /* !USE_32BIT_ONLY */\n  context->Message_Block[112] = (uint8_t)(context->Length_High >> 56);\n  context->Message_Block[113] = (uint8_t)(context->Length_High >> 48);\n  context->Message_Block[114] = (uint8_t)(context->Length_High >> 40);\n  context->Message_Block[115] = (uint8_t)(context->Length_High >> 32);\n  context->Message_Block[116] = (uint8_t)(context->Length_High >> 24);\n  context->Message_Block[117] = (uint8_t)(context->Length_High >> 16);\n  context->Message_Block[118] = (uint8_t)(context->Length_High >> 8);\n  context->Message_Block[119] = (uint8_t)(context->Length_High);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "  context->Message_Block[120] = (uint8_t)(context->Length_Low >> 56);\n  context->Message_Block[121] = (uint8_t)(context->Length_Low >> 48);\n  context->Message_Block[122] = (uint8_t)(context->Length_Low >> 40);\n  context->Message_Block[123] = (uint8_t)(context->Length_Low >> 32);\n  context->Message_Block[124] = (uint8_t)(context->Length_Low >> 24);\n  context->Message_Block[125] = (uint8_t)(context->Length_Low >> 16);\n  context->Message_Block[126] = (uint8_t)(context->Length_Low >> 8);\n  context->Message_Block[127] = (uint8_t)(context->Length_Low);\n#endif /* USE_32BIT_ONLY */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "  SHA384_512ProcessMessageBlock(context);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * SHA384_512ResultN\n *\n * Description:\n *   This helper function will return the 384-bit or 512-bit message\n *   digest into the Message_Digest array provided by the caller.",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": " *   NOTE:\n *    The first octet of hash is stored in the element with index 0,\n *    the last octet of hash in the element with index 47/63.\n *\n * Parameters:\n *   context: [in/out]\n *     The context to use to calculate the SHA hash.\n *   Message_Digest[ ]: [out]\n *     Where the digest is returned.\n *   HashSize: [in]\n *     The size of the hash, either 48 or 64.\n *\n * Returns:\n *   sha Error Code.\n *\n */\nstatic int SHA384_512ResultN(SHA512Context *context,\n    uint8_t Message_Digest[ ], int HashSize)\n{\n  int i;\n#ifdef USE_32BIT_ONLY\n  int i2;\n#endif /* USE_32BIT_ONLY */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "if (!context) return shaNull;\nif (!Message_Digest) return shaNull;\nif (context->Corrupted) return context->Corrupted;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "if (!context->Computed)\n  SHA384_512Finalize(context, 0x80);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "#ifdef USE_32BIT_ONLY\n  for (i = i2 = 0; i < HashSize; ) {\n    Message_Digest[i++]=(uint8_t)(context->Intermediate_Hash[i2]>>24);\n    Message_Digest[i++]=(uint8_t)(context->Intermediate_Hash[i2]>>16);\n    Message_Digest[i++]=(uint8_t)(context->Intermediate_Hash[i2]>>8);\n    Message_Digest[i++]=(uint8_t)(context->Intermediate_Hash[i2++]);\n    Message_Digest[i++]=(uint8_t)(context->Intermediate_Hash[i2]>>24);\n    Message_Digest[i++]=(uint8_t)(context->Intermediate_Hash[i2]>>16);\n    Message_Digest[i++]=(uint8_t)(context->Intermediate_Hash[i2]>>8);\n    Message_Digest[i++]=(uint8_t)(context->Intermediate_Hash[i2++]);\n  }\n#else /* !USE_32BIT_ONLY */\n  for (i = 0; i < HashSize; ++i)\n    Message_Digest[i] = (uint8_t)\n      (context->Intermediate_Hash[i>>3] >> 8 * ( 7 - ( i % 8 ) ));\n#endif /* USE_32BIT_ONLY */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "  return shaSuccess;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "8.2.4. usha.c",
      "section_title": true,
      "zh-CHS": "8.2.4. usha.c"
    },
    {
      "indent": 0,
      "text": "/**************************** usha.c ***************************/\n/***************** See RFC 6234 for details. *******************/\n/* Copyright (c) 2011 IETF Trust and the persons identified as */\n/* authors of the code.  All rights reserved.                  */\n/* See sha.h for terms of use and redistribution.              */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n *  Description:\n *     This file implements a unified interface to the SHA algorithms.\n */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "#include \"sha.h\"",
      "zh-CHS": "#包括“sha.h”"
    },
    {
      "indent": 0,
      "text": "/*\n *  USHAReset\n *\n *  Description:\n *      This function will initialize the SHA Context in preparation\n *      for computing a new SHA message digest.\n *\n *  Parameters:\n *      context: [in/out]\n *          The context to reset.\n *      whichSha: [in]\n *          Selects which SHA reset to call\n *\n *  Returns:\n *      sha Error Code.\n *\n */\nint USHAReset(USHAContext *context, enum SHAversion whichSha)\n{\n  if (!context) return shaNull;\n  context->whichSha = whichSha;\n  switch (whichSha) {\n    case SHA1:   return SHA1Reset((SHA1Context*)&context->ctx);\n    case SHA224: return SHA224Reset((SHA224Context*)&context->ctx);\n    case SHA256: return SHA256Reset((SHA256Context*)&context->ctx);\n    case SHA384: return SHA384Reset((SHA384Context*)&context->ctx);\n    case SHA512: return SHA512Reset((SHA512Context*)&context->ctx);\n    default: return shaBadParam;\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n *  USHAInput\n *\n *  Description:\n *      This function accepts an array of octets as the next portion\n *      of the message.\n *\n *  Parameters:\n *      context: [in/out]\n *          The SHA context to update.\n *      message_array: [in]\n *          An array of octets representing the next portion of\n *          the message.\n *      length: [in]\n *          The length of the message in message_array.\n *\n *  Returns:\n *      sha Error Code.\n *\n */\nint USHAInput(USHAContext *context,\n              const uint8_t *bytes, unsigned int bytecount)\n{\n  if (!context) return shaNull;\n  switch (context->whichSha) {\n    case SHA1:\n      return SHA1Input((SHA1Context*)&context->ctx, bytes,\n                       bytecount);\n    case SHA224:\n      return SHA224Input((SHA224Context*)&context->ctx, bytes,\n          bytecount);\n    case SHA256:\n      return SHA256Input((SHA256Context*)&context->ctx, bytes,\n          bytecount);\n    case SHA384:\n      return SHA384Input((SHA384Context*)&context->ctx, bytes,\n          bytecount);\n    case SHA512:\n      return SHA512Input((SHA512Context*)&context->ctx, bytes,\n          bytecount);\n    default: return shaBadParam;\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * USHAFinalBits\n *\n * Description:\n *   This function will add in any final bits of the message.\n *\n * Parameters:\n *   context: [in/out]\n *     The SHA context to update.\n *   message_bits: [in]\n *     The final bits of the message, in the upper portion of the\n *     byte.  (Use 0b###00000 instead of 0b00000### to input the\n *     three bits ###.)\n *   length: [in]\n *     The number of bits in message_bits, between 1 and 7.\n *\n * Returns:\n *   sha Error Code.\n */\nint USHAFinalBits(USHAContext *context,\n                  uint8_t bits, unsigned int bit_count)\n{\n  if (!context) return shaNull;\n  switch (context->whichSha) {\n    case SHA1:\n      return SHA1FinalBits((SHA1Context*)&context->ctx, bits,\n                           bit_count);\n    case SHA224:\n      return SHA224FinalBits((SHA224Context*)&context->ctx, bits,\n          bit_count);\n    case SHA256:\n      return SHA256FinalBits((SHA256Context*)&context->ctx, bits,\n          bit_count);\n    case SHA384:\n      return SHA384FinalBits((SHA384Context*)&context->ctx, bits,\n          bit_count);\n    case SHA512:\n      return SHA512FinalBits((SHA512Context*)&context->ctx, bits,\n          bit_count);\n    default: return shaBadParam;\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * USHAResult\n *\n * Description:\n *   This function will return the message digest of the appropriate\n *   bit size, as returned by USHAHashSizeBits(whichSHA) for the\n *   'whichSHA' value used in the preceeding call to USHAReset,\n *   into the Message_Digest array provided by the caller.\n *\n * Parameters:\n *   context: [in/out]\n *     The context to use to calculate the SHA-1 hash.\n *   Message_Digest: [out]\n *     Where the digest is returned.\n *\n * Returns:\n *   sha Error Code.\n *\n */\nint USHAResult(USHAContext *context,\n               uint8_t Message_Digest[USHAMaxHashSize])\n{\n  if (!context) return shaNull;\n  switch (context->whichSha) {\n    case SHA1:\n      return SHA1Result((SHA1Context*)&context->ctx, Message_Digest);\n    case SHA224:\n      return SHA224Result((SHA224Context*)&context->ctx,\n                          Message_Digest);\n    case SHA256:\n      return SHA256Result((SHA256Context*)&context->ctx,\n                          Message_Digest);\n    case SHA384:\n      return SHA384Result((SHA384Context*)&context->ctx,\n                          Message_Digest);\n    case SHA512:\n      return SHA512Result((SHA512Context*)&context->ctx,\n                          Message_Digest);\n    default: return shaBadParam;\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * USHABlockSize\n *\n * Description:\n *   This function will return the blocksize for the given SHA\n *   algorithm.",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": " *\n * Parameters:\n *   whichSha:\n *     which SHA algorithm to query\n *\n * Returns:\n *   block size\n *\n */\nint USHABlockSize(enum SHAversion whichSha)\n{\n  switch (whichSha) {\n    case SHA1:   return SHA1_Message_Block_Size;\n    case SHA224: return SHA224_Message_Block_Size;\n    case SHA256: return SHA256_Message_Block_Size;\n    case SHA384: return SHA384_Message_Block_Size;\n    default:\n    case SHA512: return SHA512_Message_Block_Size;\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * USHAHashSize\n *\n * Description:\n *   This function will return the hashsize for the given SHA\n *   algorithm.\n *\n * Parameters:\n *   whichSha:\n *     which SHA algorithm to query\n *\n * Returns:\n *   hash size\n *\n */\nint USHAHashSize(enum SHAversion whichSha)\n{\n  switch (whichSha) {\n    case SHA1:   return SHA1HashSize;\n    case SHA224: return SHA224HashSize;\n    case SHA256: return SHA256HashSize;\n    case SHA384: return SHA384HashSize;\n    default:\n    case SHA512: return SHA512HashSize;\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * USHAHashSizeBits\n *\n * Description:\n *   This function will return the hashsize for the given SHA\n *   algorithm, expressed in bits.\n *\n * Parameters:\n *   whichSha:\n *     which SHA algorithm to query\n *\n * Returns:\n *   hash size in bits\n *\n */\nint USHAHashSizeBits(enum SHAversion whichSha)\n{\n  switch (whichSha) {\n    case SHA1:   return SHA1HashSizeBits;\n    case SHA224: return SHA224HashSizeBits;\n    case SHA256: return SHA256HashSizeBits;\n    case SHA384: return SHA384HashSizeBits;\n    default:\n    case SHA512: return SHA512HashSizeBits;\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * USHAHashName\n *\n * Description:\n *   This function will return the name of the given SHA algorithm\n *   as a string.\n *\n * Parameters:\n *   whichSha:\n *     which SHA algorithm to query\n *\n * Returns:\n *   character string with the name in it\n *\n */\nconst char *USHAHashName(enum SHAversion whichSha)\n{\n  switch (whichSha) {\n    case SHA1:   return \"SHA1\";\n    case SHA224: return \"SHA224\";\n    case SHA256: return \"SHA256\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "    case SHA384: return \"SHA384\";\n    default:\n    case SHA512: return \"SHA512\";\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "8.3. The HMAC Code",
      "section_title": true,
      "zh-CHS": "8.3. HMAC代码"
    },
    {
      "indent": 0,
      "text": "/**************************** hmac.c ***************************/\n/***************** See RFC 6234 for details. *******************/\n/* Copyright (c) 2011 IETF Trust and the persons identified as */\n/* authors of the code.  All rights reserved.                  */\n/* See sha.h for terms of use and redistribution.              */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n *  Description:\n *      This file implements the HMAC algorithm (Keyed-Hashing for\n *      Message Authentication, [RFC 2104]), expressed in terms of\n *      the various SHA algorithms.\n */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "#include \"sha.h\"",
      "zh-CHS": "#包括“sha.h”"
    },
    {
      "indent": 0,
      "text": "/*\n *  hmac\n *\n *  Description:\n *      This function will compute an HMAC message digest.\n *\n *  Parameters:\n *      whichSha: [in]\n *          One of SHA1, SHA224, SHA256, SHA384, SHA512\n *      message_array[ ]: [in]\n *          An array of octets representing the message.\n *          Note: in RFC 2104, this parameter is known\n *          as 'text'.\n *      length: [in]\n *          The length of the message in message_array.\n *      key[ ]: [in]\n *          The secret shared key.\n *      key_len: [in]\n *          The length of the secret shared key.\n *      digest[ ]: [out]\n *          Where the digest is to be returned.\n *          NOTE: The length of the digest is determined by\n *              the value of whichSha.\n *",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 1,
      "text": "* Returns: * sha Error Code. * */",
      "zh-CHS": "* 返回：*sha错误代码。**/"
    },
    {
      "indent": 0,
      "text": "int hmac(SHAversion whichSha,\n    const unsigned char *message_array, int length,\n    const unsigned char *key, int key_len,\n    uint8_t digest[USHAMaxHashSize])\n{\n  HMACContext context;\n  return hmacReset(&context, whichSha, key, key_len) ||\n         hmacInput(&context, message_array, length) ||\n         hmacResult(&context, digest);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n *  hmacReset\n *\n *  Description:\n *      This function will initialize the hmacContext in preparation\n *      for computing a new HMAC message digest.\n *\n *  Parameters:\n *      context: [in/out]\n *          The context to reset.\n *      whichSha: [in]\n *          One of SHA1, SHA224, SHA256, SHA384, SHA512\n *      key[ ]: [in]\n *          The secret shared key.\n *      key_len: [in]\n *          The length of the secret shared key.\n *\n *  Returns:\n *      sha Error Code.\n *\n */\nint hmacReset(HMACContext *context, enum SHAversion whichSha,\n    const unsigned char *key, int key_len)\n{\n  int i, blocksize, hashsize, ret;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "/* inner padding - key XORd with ipad */\nunsigned char k_ipad[USHA_Max_Message_Block_Size];",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "/* temporary buffer when keylen > blocksize */\nunsigned char tempkey[USHAMaxHashSize];",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "if (!context) return shaNull;\ncontext->Computed = 0;\ncontext->Corrupted = shaSuccess;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "blocksize = context->blockSize = USHABlockSize(whichSha);\nhashsize = context->hashSize = USHAHashSize(whichSha);\ncontext->whichSha = whichSha;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "/*\n * If key is longer than the hash blocksize,\n * reset it to key = HASH(key).\n */\nif (key_len > blocksize) {\n  USHAContext tcontext;\n  int err = USHAReset(&tcontext, whichSha) ||\n            USHAInput(&tcontext, key, key_len) ||\n            USHAResult(&tcontext, tempkey);\n  if (err != shaSuccess) return err;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "  key = tempkey;\n  key_len = hashsize;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "/*\n * The HMAC transform looks like:\n *\n * SHA(K XOR opad, SHA(K XOR ipad, text))\n *\n * where K is an n byte key, 0-padded to a total of blocksize bytes,\n * ipad is the byte 0x36 repeated blocksize times,\n * opad is the byte 0x5c repeated blocksize times,\n * and text is the data being protected.\n */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "/* store key into the pads, XOR'd with ipad and opad values */\nfor (i = 0; i < key_len; i++) {\n  k_ipad[i] = key[i] ^ 0x36;\n  context->k_opad[i] = key[i] ^ 0x5c;\n}\n/* remaining pad bytes are '\\0' XOR'd with ipad and opad values */\nfor ( ; i < blocksize; i++) {\n  k_ipad[i] = 0x36;\n  context->k_opad[i] = 0x5c;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "/* perform inner hash */\n/* init context for 1st pass */\nret = USHAReset(&context->shaContext, whichSha) ||",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "        /* and start with inner pad */\n        USHAInput(&context->shaContext, k_ipad, blocksize);\n  return context->Corrupted = ret;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n *  hmacInput\n *\n *  Description:\n *      This function accepts an array of octets as the next portion\n *      of the message.  It may be called multiple times.\n *\n *  Parameters:\n *      context: [in/out]\n *          The HMAC context to update.\n *      text[ ]: [in]\n *          An array of octets representing the next portion of\n *          the message.\n *      text_len: [in]\n *          The length of the message in text.\n *\n *  Returns:\n *      sha Error Code.\n *\n */\nint hmacInput(HMACContext *context, const unsigned char *text,\n    int text_len)\n{\n  if (!context) return shaNull;\n  if (context->Corrupted) return context->Corrupted;\n  if (context->Computed) return context->Corrupted = shaStateError;\n  /* then text of datagram */\n  return context->Corrupted =\n    USHAInput(&context->shaContext, text, text_len);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * hmacFinalBits\n *\n * Description:\n *   This function will add in any final bits of the message.\n *\n * Parameters:\n *   context: [in/out]\n *     The HMAC context to update.\n *   message_bits: [in]\n *     The final bits of the message, in the upper portion of the\n *     byte.  (Use 0b###00000 instead of 0b00000### to input the",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": " *     three bits ###.)\n *   length: [in]\n *     The number of bits in message_bits, between 1 and 7.\n *\n * Returns:\n *   sha Error Code.\n */\nint hmacFinalBits(HMACContext *context,\n    uint8_t bits, unsigned int bit_count)\n{\n  if (!context) return shaNull;\n  if (context->Corrupted) return context->Corrupted;\n  if (context->Computed) return context->Corrupted = shaStateError;\n  /* then final bits of datagram */\n  return context->Corrupted =\n    USHAFinalBits(&context->shaContext, bits, bit_count);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * hmacResult\n *\n * Description:\n *   This function will return the N-byte message digest into the\n *   Message_Digest array provided by the caller.\n *\n * Parameters:\n *   context: [in/out]\n *     The context to use to calculate the HMAC hash.\n *   digest[ ]: [out]\n *     Where the digest is returned.\n *     NOTE 2: The length of the hash is determined by the value of\n *      whichSha that was passed to hmacReset().\n *\n * Returns:\n *   sha Error Code.\n *\n */\nint hmacResult(HMACContext *context, uint8_t *digest)\n{\n  int ret;\n  if (!context) return shaNull;\n  if (context->Corrupted) return context->Corrupted;\n  if (context->Computed) return context->Corrupted = shaStateError;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "/* finish up 1st pass */\n/* (Use digest here as a temporary buffer.) */\nret =\n  USHAResult(&context->shaContext, digest) ||",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "/* perform outer SHA */\n/* init context for 2nd pass */\nUSHAReset(&context->shaContext, context->whichSha) ||",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "/* start with outer pad */\nUSHAInput(&context->shaContext, context->k_opad,\n          context->blockSize) ||",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "/* then results of 1st hash */\nUSHAInput(&context->shaContext, digest, context->hashSize) ||\n/* finish up 2nd pass */\nUSHAResult(&context->shaContext, digest);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "  context->Computed = 1;\n  return context->Corrupted = ret;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "8.4. The HKDF Code",
      "section_title": true,
      "zh-CHS": "8.4. 香港发展基金守则"
    },
    {
      "indent": 0,
      "text": "/**************************** hkdf.c ***************************/\n/***************** See RFC 6234 for details. *******************/\n/* Copyright (c) 2011 IETF Trust and the persons identified as */\n/* authors of the code.  All rights reserved.                  */\n/* See sha.h for terms of use and redistribution.              */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n *  Description:\n *      This file implements the HKDF algorithm (HMAC-based\n *      Extract-and-Expand Key Derivation Function, RFC 5869),\n *      expressed in terms of the various SHA algorithms.\n */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "#include \"sha.h\"\n#include <string.h>\n#include <stdlib.h>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n *  hkdf\n *\n *  Description:\n *      This function will generate keying material using HKDF.\n *\n *  Parameters:\n *      whichSha: [in]\n *          One of SHA1, SHA224, SHA256, SHA384, SHA512\n *      salt[ ]: [in]\n *          The optional salt value (a non-secret random value);\n *          if not provided (salt == NULL), it is set internally",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": " *          to a string of HashLen(whichSha) zeros.\n *      salt_len: [in]\n *          The length of the salt value.  (Ignored if salt == NULL.)\n *      ikm[ ]: [in]\n *          Input keying material.\n *      ikm_len: [in]\n *          The length of the input keying material.\n *      info[ ]: [in]\n *          The optional context and application specific information.\n *          If info == NULL or a zero-length string, it is ignored.\n *      info_len: [in]\n *          The length of the optional context and application specific\n *          information.  (Ignored if info == NULL.)\n *      okm[ ]: [out]\n *          Where the HKDF is to be stored.\n *      okm_len: [in]\n *          The length of the buffer to hold okm.\n *          okm_len must be <= 255 * USHABlockSize(whichSha)\n *\n *  Notes:\n *      Calls hkdfExtract() and hkdfExpand().\n *\n *  Returns:\n *      sha Error Code.\n *\n */\nint hkdf(SHAversion whichSha,\n    const unsigned char *salt, int salt_len,\n    const unsigned char *ikm, int ikm_len,\n    const unsigned char *info, int info_len,\n    uint8_t okm[ ], int okm_len)\n{\n  uint8_t prk[USHAMaxHashSize];\n  return hkdfExtract(whichSha, salt, salt_len, ikm, ikm_len, prk) ||\n         hkdfExpand(whichSha, prk, USHAHashSize(whichSha), info,\n                    info_len, okm, okm_len);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n *  hkdfExtract\n *\n *  Description:\n *      This function will perform HKDF extraction.\n *\n *  Parameters:\n *      whichSha: [in]\n *          One of SHA1, SHA224, SHA256, SHA384, SHA512\n *      salt[ ]: [in]",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": " *          The optional salt value (a non-secret random value);\n *          if not provided (salt == NULL), it is set internally\n *          to a string of HashLen(whichSha) zeros.\n *      salt_len: [in]\n *          The length of the salt value.  (Ignored if salt == NULL.)\n *      ikm[ ]: [in]\n *          Input keying material.\n *      ikm_len: [in]\n *          The length of the input keying material.\n *      prk[ ]: [out]\n *          Array where the HKDF extraction is to be stored.\n *          Must be larger than USHAHashSize(whichSha);\n *\n *  Returns:\n *      sha Error Code.\n *\n */\nint hkdfExtract(SHAversion whichSha,\n    const unsigned char *salt, int salt_len,\n    const unsigned char *ikm, int ikm_len,\n    uint8_t prk[USHAMaxHashSize])\n{\n  unsigned char nullSalt[USHAMaxHashSize];\n  if (salt == 0) {\n    salt = nullSalt;\n    salt_len = USHAHashSize(whichSha);\n    memset(nullSalt, '\\0', salt_len);\n  } else if (salt_len < 0) {\n    return shaBadParam;\n  }\n  return hmac(whichSha, ikm, ikm_len, salt, salt_len, prk);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n *  hkdfExpand\n *\n *  Description:\n *      This function will perform HKDF expansion.\n *\n *  Parameters:\n *      whichSha: [in]\n *          One of SHA1, SHA224, SHA256, SHA384, SHA512\n *      prk[ ]: [in]\n *          The pseudo-random key to be expanded; either obtained\n *          directly from a cryptographically strong, uniformly\n *          distributed pseudo-random number generator, or as the\n *          output from hkdfExtract().\n *      prk_len: [in]",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": " *          The length of the pseudo-random key in prk;\n *          should at least be equal to USHAHashSize(whichSHA).\n *      info[ ]: [in]\n *          The optional context and application specific information.\n *          If info == NULL or a zero-length string, it is ignored.\n *      info_len: [in]\n *          The length of the optional context and application specific\n *          information.  (Ignored if info == NULL.)\n *      okm[ ]: [out]\n *          Where the HKDF is to be stored.\n *      okm_len: [in]\n *          The length of the buffer to hold okm.\n *          okm_len must be <= 255 * USHABlockSize(whichSha)\n *\n *  Returns:\n *      sha Error Code.\n *\n */\nint hkdfExpand(SHAversion whichSha, const uint8_t prk[ ], int prk_len,\n    const unsigned char *info, int info_len,\n    uint8_t okm[ ], int okm_len)\n{\n  int hash_len, N;\n  unsigned char T[USHAMaxHashSize];\n  int Tlen, where, i;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "if (info == 0) {\n  info = (const unsigned char *)\"\";\n  info_len = 0;\n} else if (info_len < 0) {\n  return shaBadParam;\n}\nif (okm_len <= 0) return shaBadParam;\nif (!okm) return shaBadParam;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "hash_len = USHAHashSize(whichSha);\nif (prk_len < hash_len) return shaBadParam;\nN = okm_len / hash_len;\nif ((okm_len % hash_len) != 0) N++;\nif (N > 255) return shaBadParam;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "Tlen = 0;\nwhere = 0;\nfor (i = 1; i <= N; i++) {\n  HMACContext context;\n  unsigned char c = i;\n  int ret = hmacReset(&context, whichSha, prk, prk_len) ||\n            hmacInput(&context, T, Tlen) ||",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "              hmacInput(&context, info, info_len) ||\n              hmacInput(&context, &c, 1) ||\n              hmacResult(&context, T);\n    if (ret != shaSuccess) return ret;\n    memcpy(okm + where, T,\n           (i != N) ? hash_len : (okm_len - where));\n    where += hash_len;\n    Tlen = hash_len;\n  }\n  return shaSuccess;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n *  hkdfReset\n *\n *  Description:\n *      This function will initialize the hkdfContext in preparation\n *      for key derivation using the modular HKDF interface for\n *      arbitrary length inputs.\n *\n *  Parameters:\n *      context: [in/out]\n *          The context to reset.\n *      whichSha: [in]\n *          One of SHA1, SHA224, SHA256, SHA384, SHA512\n *      salt[ ]: [in]\n *          The optional salt value (a non-secret random value);\n *          if not provided (salt == NULL), it is set internally\n *          to a string of HashLen(whichSha) zeros.\n *      salt_len: [in]\n *          The length of the salt value.  (Ignored if salt == NULL.)\n *\n *  Returns:\n *      sha Error Code.\n *\n */\nint hkdfReset(HKDFContext *context, enum SHAversion whichSha,\n              const unsigned char *salt, int salt_len)\n{\n  unsigned char nullSalt[USHAMaxHashSize];\n  if (!context) return shaNull;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "context->whichSha = whichSha;\ncontext->hashSize = USHAHashSize(whichSha);\nif (salt == 0) {\n  salt = nullSalt;\n  salt_len = context->hashSize;\n  memset(nullSalt, '\\0', salt_len);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "}",
      "zh-CHS": "}"
    },
    {
      "indent": 0,
      "text": "  return hmacReset(&context->hmacContext, whichSha, salt, salt_len);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n *  hkdfInput\n *\n *  Description:\n *      This function accepts an array of octets as the next portion\n *      of the input keying material.  It may be called multiple times.\n *\n *  Parameters:\n *      context: [in/out]\n *          The HKDF context to update.\n *      ikm[ ]: [in]\n *          An array of octets representing the next portion of\n *          the input keying material.\n *      ikm_len: [in]\n *          The length of ikm.\n *\n *  Returns:\n *      sha Error Code.\n *\n */\nint hkdfInput(HKDFContext *context, const unsigned char *ikm,\n              int ikm_len)\n{\n  if (!context) return shaNull;\n  if (context->Corrupted) return context->Corrupted;\n  if (context->Computed) return context->Corrupted = shaStateError;\n  return hmacInput(&context->hmacContext, ikm, ikm_len);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * hkdfFinalBits\n *\n * Description:\n *   This function will add in any final bits of the\n *   input keying material.\n *\n * Parameters:\n *   context: [in/out]\n *     The HKDF context to update\n *   ikm_bits: [in]\n *     The final bits of the input keying material, in the upper\n *     portion of the byte.  (Use 0b###00000 instead of 0b00000###\n *     to input the three bits ###.)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": " *   ikm_bit_count: [in]\n *     The number of bits in message_bits, between 1 and 7.\n *\n * Returns:\n *   sha Error Code.\n */\nint hkdfFinalBits(HKDFContext *context, uint8_t ikm_bits,\n                  unsigned int ikm_bit_count)\n{\n  if (!context) return shaNull;\n  if (context->Corrupted) return context->Corrupted;\n  if (context->Computed) return context->Corrupted = shaStateError;\n  return hmacFinalBits(&context->hmacContext, ikm_bits, ikm_bit_count);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * hkdfResult\n *\n * Description:\n *   This function will finish the HKDF extraction and perform the\n *   final HKDF expansion.\n *\n * Parameters:\n *   context: [in/out]\n *     The HKDF context to use to calculate the HKDF hash.\n *   prk[ ]: [out]\n *     An optional location to store the HKDF extraction.\n *     Either NULL, or pointer to a buffer that must be\n *     larger than USHAHashSize(whichSha);\n *   info[ ]: [in]\n *     The optional context and application specific information.\n *     If info == NULL or a zero-length string, it is ignored.\n *   info_len: [in]\n *     The length of the optional context and application specific\n *     information.  (Ignored if info == NULL.)\n *   okm[ ]: [out]\n *     Where the HKDF is to be stored.\n *   okm_len: [in]\n *     The length of the buffer to hold okm.\n *     okm_len must be <= 255 * USHABlockSize(whichSha)\n *\n * Returns:\n *   sha Error Code.\n *\n */\nint hkdfResult(HKDFContext *context,\n               uint8_t prk[USHAMaxHashSize],\n               const unsigned char *info, int info_len,",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "               uint8_t okm[ ], int okm_len)\n{\n  uint8_t prkbuf[USHAMaxHashSize];\n  int ret;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "if (!context) return shaNull;\nif (context->Corrupted) return context->Corrupted;\nif (context->Computed) return context->Corrupted = shaStateError;\nif (!okm) return context->Corrupted = shaBadParam;\nif (!prk) prk = prkbuf;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "  ret = hmacResult(&context->hmacContext, prk) ||\n        hkdfExpand(context->whichSha, prk, context->hashSize, info,\n                   info_len, okm, okm_len);\n  context->Computed = 1;\n  return context->Corrupted = ret;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "8.5. The Test Driver",
      "section_title": true,
      "zh-CHS": "8.5. 试驾"
    },
    {
      "indent": 3,
      "text": "The following code is a main program test driver to exercise the code in sha1.c, sha224-256.c, sha384-512.c, hmac.c, and hkdf.c. The test driver can also be used as a standalone program for generating the hashes. Note that the tests assume that character values are as in [US-ASCII] and a run time check warns if the code appears to have been compiled with some other character system.",
      "zh-CHS": "下面的代码是一个主程序测试驱动程序，用于练习sha1.c、sha224-256.c、sha384-512.c、hmac.c和hkdf.c中的代码。测试驱动程序也可以用作生成哈希的独立程序。请注意，测试假定字符值与[US-ASCII]中的字符值相同，如果代码似乎是用其他字符系统编译的，则运行时检查会发出警告。"
    },
    {
      "indent": 3,
      "text": "See also [SHAVS].",
      "zh-CHS": "另见[SHAVS]。"
    },
    {
      "indent": 0,
      "text": "/************************** shatest.c **************************/\n/***************** See RFC 6234 for details. *******************/\n/* Copyright (c) 2011 IETF Trust and the persons identified as */\n/* authors of the code.  All rights reserved.                  */\n/* See sha.h for terms of use and redistribution.              */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n *  Description:\n *    This file will exercise the SHA code performing\n *      the three tests documented in FIPS PUB 180-3\n *        (http://csrc.nist.gov/publications/fips/\n *         fips180-2/fips180-2withchangenotice.pdf)\n *      one that calls SHAInput with an exact multiple of 512 bits\n *      the seven tests documented for each algorithm in\n *        \"The Secure Hash Algorithm Validation System (SHAVS)\"\n *        (http://csrc.nist.gov/cryptval/shs/SHAVS.pdf),\n *        three of which are bit-level tests\n *",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 1,
      "text": "* These tests have subsequently been moved to pages linked from * http://csrc.nist.gov/groups/ST/toolkit/examples.html * * This file will exercise the HMAC SHA1 code performing * the seven tests documented in RFCs [RFC 2202] and [RFC 4231]. * * This file will exercise the HKDF code performing * the seven tests documented in RFC 4869. * * To run the tests and just see PASSED/FAILED, use the -p option. * * Other options exercise: * hashing an arbitrary string * hashing a file's contents * a few error test checks * printing the results in raw format * * Portability Issues: * None. * */",
      "zh-CHS": "* 这些测试随后被移动到链接到*http://csrc.nist.gov/groups/ST/toolkit/examples.html **本文件将执行HMAC SHA1代码，执行RFCs[RFC 2202]和[RFC 4231]中记录的七项测试。**本文件将执行执行RFC 4869中记录的七项测试的HKDF代码。**要运行测试并查看通过/失败，请使用-p选项。**其他选项练习：*散列任意字符串*散列文件内容*一些错误测试检查*以原始格式打印结果**可移植性问题：*无。**/"
    },
    {
      "indent": 0,
      "text": "#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <unistd.h>     /* defines getopt() and optarg */\n#include \"sha.h\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "static int scasecmp(const char *s1, const char *s2);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n *  Define patterns for testing\n */\n#define TEST1    \"abc\"\n#define TEST2_1  \\\n        \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n#define TEST2_2a \\\n        \"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmn\"\n#define TEST2_2b \\\n        \"hijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\"\n#define TEST2_2  TEST2_2a TEST2_2b\n#define TEST3    \"a\"                            /* times 1000000 */\n#define TEST4a   \"01234567012345670123456701234567\"\n#define TEST4b   \"01234567012345670123456701234567\"\n    /* an exact multiple of 512 bits */\n#define TEST4   TEST4a TEST4b                   /* times 10 */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "#define TEST7_1 \\ \"\\x49\\xb2\\xae\\xc2\\x59\\x4b\\xbe\\x3a\\x3b\\x11\\x75\\x42\\xd9\\x4a\\xc8\" #define TEST8_1 \\ \"\\x9a\\x7d\\xfd\\xf1\\xec\\xea\\xd0\\x6e\\xd6\\x46\\xaa\\x55\\xfe\\x75\\x71\\x46\" #define TEST9_1 \\ \"\\x65\\xf9\\x32\\x99\\x5b\\xa4\\xce\\x2c\\xb1\\xb4\\xa2\\xe7\\x1a\\xe7\\x02\\x20\" \\ \"\\xaa\\xce\\xc8\\x96\\x2d\\xd4\\x49\\x9c\\xbd\\x7c\\x88\\x7a\\x94\\xea\\xaa\\x10\" \\ \"\\x1e\\xa5\\xaa\\xbc\\x52\\x9b\\x4e\\x7e\\x43\\x66\\x5a\\x5a\\xf2\\xcd\\x03\\xfe\" \\ \"\\x67\\x8e\\xa6\\xa5\\x00\\x5b\\xba\\x3b\\x08\\x22\\x04\\xc2\\x8b\\x91\\x09\\xf4\" \\ \"\\x69\\xda\\xc9\\x2a\\xaa\\xb3\\xaa\\x7c\\x11\\xa1\\xb3\\x2a\" #define TEST10_1 \\ \"\\xf7\\x8f\\x92\\x14\\x1b\\xcd\\x17\\x0a\\xe8\\x9b\\x4f\\xba\\x15\\xa1\\xd5\\x9f\" \\ \"\\x3f\\xd8\\x4d\\x22\\x3c\\x92\\x51\\xbd\\xac\\xbb\\xae\\x61\\xd0\\x5e\\xd1\\x15\" \\ \"\\xa0\\x6a\\x7c\\xe1\\x17\\xb7\\xbe\\xea\\xd2\\x44\\x21\\xde\\xd9\\xc3\\x25\\x92\" \\ \"\\xbd\\x57\\xed\\xea\\xe3\\x9c\\x39\\xfa\\x1f\\xe8\\x94\\x6a\\x84\\xd0\\xcf\\x1f\" \\ \"\\x7b\\xee\\xad\\x17\\x13\\xe2\\xe0\\x95\\x98\\x97\\x34\\x7f\\x67\\xc8\\x0b\\x04\" \\ \"\\x00\\xc2\\x09\\x81\\x5d\\x6b\\x10\\xa6\\x83\\x83\\x6f\\xd5\\x56\\x2a\\x56\\xca\" \\ \"\\xb1\\xa2\\x8e\\x81\\xb6\\x57\\x66\\x54\\x63\\x1c\\xf1\\x65\\x66\\xb8\\x6e\\x3b\" \\ \"\\x33\\xa1\\x08\\xb0\\x53\\x07\\xc0\\x0a\\xff\\x14\\xa7\\x68\\xed\\x73\\x50\\x60\" \\ \"\\x6a\\x0f\\x85\\xe6\\xa9\\x1d\\x39\\x6f\\x5b\\x5c\\xbe\\x57\\x7f\\x9b\\x38\\x80\" \\ \"\\x7c\\x7d\\x52\\x3d\\x6d\\x79\\x2f\\x6e\\xbc\\x24\\xa4\\xec\\xf2\\xb3\\xa4\\x27\" \\ \"\\xcd\\xbb\\xfb\" #define TEST7_224 \\ \"\\xf0\\x70\\x06\\xf2\\x5a\\x0b\\xea\\x68\\xcd\\x76\\xa2\\x95\\x87\\xc2\\x8d\" #define TEST8_224 \\ \"\\x18\\x80\\x40\\x05\\xdd\\x4f\\xbd\\x15\\x56\\x29\\x9d\\x6f\\x9d\\x93\\xdf\\x62\" #define TEST9_224 \\ \"\\xa2\\xbe\\x6e\\x46\\x32\\x81\\x09\\x02\\x94\\xd9\\xce\\x94\\x82\\x65\\x69\\x42\" \\ \"\\x3a\\x3a\\x30\\x5e\\xd5\\xe2\\x11\\x6c\\xd4\\xa4\\xc9\\x87\\xfc\\x06\\x57\\x00\" \\ \"\\x64\\x91\\xb1\\x49\\xcc\\xd4\\xb5\\x11\\x30\\xac\\x62\\xb1\\x9d\\xc2\\x48\\xc7\" \\ \"\\x44\\x54\\x3d\\x20\\xcd\\x39\\x52\\xdc\\xed\\x1f\\x06\\xcc\\x3b\\x18\\xb9\\x1f\" \\ \"\\x3f\\x55\\x63\\x3e\\xcc\\x30\\x85\\xf4\\x90\\x70\\x60\\xd2\" #define TEST10_224 \\ \"\\x55\\xb2\\x10\\x07\\x9c\\x61\\xb5\\x3a\\xdd\\x52\\x06\\x22\\xd1\\xac\\x97\\xd5\" \\ \"\\xcd\\xbe\\x8c\\xb3\\x3a\\xa0\\xae\\x34\\x45\\x17\\xbe\\xe4\\xd7\\xba\\x09\\xab\" \\ \"\\xc8\\x53\\x3c\\x52\\x50\\x88\\x7a\\x43\\xbe\\xbb\\xac\\x90\\x6c\\x2e\\x18\\x37\" \\ \"\\xf2\\x6b\\x36\\xa5\\x9a\\xe3\\xbe\\x78\\x14\\xd5\\x06\\x89\\x6b\\x71\\x8b\\x2a\" \\ \"\\x38\\x3e\\xcd\\xac\\x16\\xb9\\x61\\x25\\x55\\x3f\\x41\\x6f\\xf3\\x2c\\x66\\x74\" \\ \"\\xc7\\x45\\x99\\xa9\\x00\\x53\\x86\\xd9\\xce\\x11\\x12\\x24\\x5f\\x48\\xee\\x47\" \\ \"\\x0d\\x39\\x6c\\x1e\\xd6\\x3b\\x92\\x67\\x0c\\xa5\\x6e\\xc8\\x4d\\xee\\xa8\\x14\" \\ \"\\xb6\\x13\\x5e\\xca\\x54\\x39\\x2b\\xde\\xdb\\x94\\x89\\xbc\\x9b\\x87\\x5a\\x8b\" \\ \"\\xaf\\x0d\\xc1\\xae\\x78\\x57\\x36\\x91\\x4a\\xb7\\xda\\xa2\\x64\\xbc\\x07\\x9d\" \\ \"\\x26\\x9f\\x2c\\x0d\\x7e\\xdd\\xd8\\x10\\xa4\\x26\\x14\\x5a\\x07\\x76\\xf6\\x7c\" \\ \"\\x87\\x82\\x73\" #define TEST7_256 \\ \"\\xbe\\x27\\x46\\xc6\\xdb\\x52\\x76\\x5f\\xdb\\x2f\\x88\\x70\\x0f\\x9a\\x73\" #define TEST8_256 \\ \"\\xe3\\xd7\\x25\\x70\\xdc\\xdd\\x78\\x7c\\xe3\\x88\\x7a\\xb2\\xcd\\x68\\x46\\x52\"",
      "zh-CHS": "#定义测试7\\0 0 0 0 1 1 1 1“\\x49\\x9\\x2\\x2\\x2\\x2\\x4\\x4\\x3\\x3\\x3\\x3\\x7 7\\x42\\x4\\x4\\x4\\x4\\x4\\x4\\x7\\x7\\x7\\x7\\x7\\x7\\x7\\x4\\x7\\x7\\x7\\x3\\x7\\x3\\x3\\x3\\x3\\x3\\x3\\x7\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x7\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x7\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x7\\x3\\x3\\x3\\x3\\x3\\x\\ x96\\x2d\\xd4\\x49\\x9c\\xbd\\x7c\\x88\\x7a\\x94\\xea\\xaa\\x10“\\4\\X6\\X6 6\\X8 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10\\X10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 xba\\x15\\xa1\\xd5\\x9f“\\”\\x3f\\xd8\\x4d\\x22\\x3c\\x92\\x51\\xbd\\xac\\xbb\\xae\\x61\\xd0\\x5e\\xd1\\x15“\\”\\XX0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 x56\\x2a\\x56\\xca“\\”\\xb1\\xa2\\x8e\\x81\\xb6\\x57\\x66\\x54\\x63\\x1c\\xf1\\x65\\x66\\xb8\\x6e\\x3b“\\”\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x3\\x7\\x8\\x8\\x7\\x8\\x8\\x8\\x8\\x8\\x8\\x8\\x8\\x8\\x8\\x8\\x7\\x8\\x8\\x8\\x8\\x8\\x8\\x8\\x7\\x8\\x8\\x8\\x8\\x8\\x8\\\\x7\\x7\\x7\\x8\\x8\\x7\\x8\\x8\\\\\\x7\\x7\\\\\\x5a\\x0b\\xea\\x68\\xcd\\x76\\xa2\\x95\\x87\\xc2\\x8d“#定义测试8_224”\\10\\X8 8\\X8 8 8\\X8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\x30\\xac\\x62\\xb1\\x9d\\xc2\\x48\\xc7“\\4\\x4\\x4 4\\x4 4\\x4 4\\x4 4 4\\x4 4 4\\x4 4 4\\x4 4 4\\x4 4\\x4 4 4\\x4 4\\x4 4 4\\x4 4 4\\x4 4 4\\x4 4 4\\x4 4 4 4\\x4 4 4 4\\x4\\x4\\x4\\x4\\x4\\x4\\x4\\x4\\x4\\x4\\x4\\x4 4\\x4\\x4 4\\x4\\x4 4\\x4\\x4\\x4 4 4\\x4 4 4 4 4\\x4\\x4\\x4 4 4 4\\x4 4\\x4\\x4\\x4 4 4 4\\x4\\x4 4 4\\x4\\x4\\x4 4\\x4\\x4 4\\x4\\x4\\x4\\x4\\x4\\x4\\x4\\x4 4 4\\x4\\x4 4 4\\x4 4 7\\xba\\x09\\xab“\\”\\xc8\\x53\\x3c\\x52\\x50\\x88\\x7a\\x43\\xbe\\xbb\\xac\\x90\\x6c\\x2e\\x18\\x37“\\”\\X6\\X8 8\\X8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\\x4d\\xee\\xa8\\x14“\\”\\xb6\\x13\\x5e\\xca\\x54\\x39\\x2b\\xde\\xdb\\x94\\x89\\xbc\\x9b\\x87\\x5a\\x8b“\\”\\X7\\X7\\X7\\X8\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X8\\X8\\X7\\X7\\X7\\X7\\x10\\x10\\x10\\x10\\x10\\x10\\X1\\X1\\X8\\X8\\X7\\X7\\X7\\7\\X7\\X7\\7\\7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X8\\X7\\X7\\X7\\X8\\X8\\X8\\X7\\X8\\X7\\X7\\X7\\X7\\X8\\X8\\X7\\X7\\X7\\X7\\X7\\X7\\4\\X7\\4\\X7\\4\\X8\\4\\X7\\4\\4\\XXE3\\xd7\\x25\\x70\\xdc\\xdd\\x78\\x7c\\xe3\\x88\\x7a\\xb2\\xcd\\x68\\x46\\x52“"
    },
    {
      "indent": 0,
      "text": "#define TEST9_256 \\ \"\\x3e\\x74\\x03\\x71\\xc8\\x10\\xc2\\xb9\\x9f\\xc0\\x4e\\x80\\x49\\x07\\xef\\x7c\" \\ \"\\xf2\\x6b\\xe2\\x8b\\x57\\xcb\\x58\\xa3\\xe2\\xf3\\xc0\\x07\\x16\\x6e\\x49\\xc1\" \\ \"\\x2e\\x9b\\xa3\\x4c\\x01\\x04\\x06\\x91\\x29\\xea\\x76\\x15\\x64\\x25\\x45\\x70\" \\ \"\\x3a\\x2b\\xd9\\x01\\xe1\\x6e\\xb0\\xe0\\x5d\\xeb\\xa0\\x14\\xeb\\xff\\x64\\x06\" \\ \"\\xa0\\x7d\\x54\\x36\\x4e\\xff\\x74\\x2d\\xa7\\x79\\xb0\\xb3\" #define TEST10_256 \\ \"\\x83\\x26\\x75\\x4e\\x22\\x77\\x37\\x2f\\x4f\\xc1\\x2b\\x20\\x52\\x7a\\xfe\\xf0\" \\ \"\\x4d\\x8a\\x05\\x69\\x71\\xb1\\x1a\\xd5\\x71\\x23\\xa7\\xc1\\x37\\x76\\x00\\x00\" \\ \"\\xd7\\xbe\\xf6\\xf3\\xc1\\xf7\\xa9\\x08\\x3a\\xa3\\x9d\\x81\\x0d\\xb3\\x10\\x77\" \\ \"\\x7d\\xab\\x8b\\x1e\\x7f\\x02\\xb8\\x4a\\x26\\xc7\\x73\\x32\\x5f\\x8b\\x23\\x74\" \\ \"\\xde\\x7a\\x4b\\x5a\\x58\\xcb\\x5c\\x5c\\xf3\\x5b\\xce\\xe6\\xfb\\x94\\x6e\\x5b\" \\ \"\\xd6\\x94\\xfa\\x59\\x3a\\x8b\\xeb\\x3f\\x9d\\x65\\x92\\xec\\xed\\xaa\\x66\\xca\" \\ \"\\x82\\xa2\\x9d\\x0c\\x51\\xbc\\xf9\\x33\\x62\\x30\\xe5\\xd7\\x84\\xe4\\xc0\\xa4\" \\ \"\\x3f\\x8d\\x79\\xa3\\x0a\\x16\\x5c\\xba\\xbe\\x45\\x2b\\x77\\x4b\\x9c\\x71\\x09\" \\ \"\\xa9\\x7d\\x13\\x8f\\x12\\x92\\x28\\x96\\x6f\\x6c\\x0a\\xdc\\x10\\x6a\\xad\\x5a\" \\ \"\\x9f\\xdd\\x30\\x82\\x57\\x69\\xb2\\xc6\\x71\\xaf\\x67\\x59\\xdf\\x28\\xeb\\x39\" \\ \"\\x3d\\x54\\xd6\" #define TEST7_384 \\ \"\\x8b\\xc5\\x00\\xc7\\x7c\\xee\\xd9\\x87\\x9d\\xa9\\x89\\x10\\x7c\\xe0\\xaa\" #define TEST8_384 \\ \"\\xa4\\x1c\\x49\\x77\\x79\\xc0\\x37\\x5f\\xf1\\x0a\\x7f\\x4e\\x08\\x59\\x17\\x39\" #define TEST9_384 \\ \"\\x68\\xf5\\x01\\x79\\x2d\\xea\\x97\\x96\\x76\\x70\\x22\\xd9\\x3d\\xa7\\x16\\x79\" \\ \"\\x30\\x99\\x20\\xfa\\x10\\x12\\xae\\xa3\\x57\\xb2\\xb1\\x33\\x1d\\x40\\xa1\\xd0\" \\ \"\\x3c\\x41\\xc2\\x40\\xb3\\xc9\\xa7\\x5b\\x48\\x92\\xf4\\xc0\\x72\\x4b\\x68\\xc8\" \\ \"\\x75\\x32\\x1a\\xb8\\xcf\\xe5\\x02\\x3b\\xd3\\x75\\xbc\\x0f\\x94\\xbd\\x89\\xfe\" \\ \"\\x04\\xf2\\x97\\x10\\x5d\\x7b\\x82\\xff\\xc0\\x02\\x1a\\xeb\\x1c\\xcb\\x67\\x4f\" \\ \"\\x52\\x44\\xea\\x34\\x97\\xde\\x26\\xa4\\x19\\x1c\\x5f\\x62\\xe5\\xe9\\xa2\\xd8\" \\ \"\\x08\\x2f\\x05\\x51\\xf4\\xa5\\x30\\x68\\x26\\xe9\\x1c\\xc0\\x06\\xce\\x1b\\xf6\" \\ \"\\x0f\\xf7\\x19\\xd4\\x2f\\xa5\\x21\\xc8\\x71\\xcd\\x23\\x94\\xd9\\x6e\\xf4\\x46\" \\ \"\\x8f\\x21\\x96\\x6b\\x41\\xf2\\xba\\x80\\xc2\\x6e\\x83\\xa9\" #define TEST10_384 \\ \"\\x39\\x96\\x69\\xe2\\x8f\\x6b\\x9c\\x6d\\xbc\\xbb\\x69\\x12\\xec\\x10\\xff\\xcf\" \\ \"\\x74\\x79\\x03\\x49\\xb7\\xdc\\x8f\\xbe\\x4a\\x8e\\x7b\\x3b\\x56\\x21\\xdb\\x0f\" \\ \"\\x3e\\x7d\\xc8\\x7f\\x82\\x32\\x64\\xbb\\xe4\\x0d\\x18\\x11\\xc9\\xea\\x20\\x61\" \\ \"\\xe1\\xc8\\x4a\\xd1\\x0a\\x23\\xfa\\xc1\\x72\\x7e\\x72\\x02\\xfc\\x3f\\x50\\x42\" \\ \"\\xe6\\xbf\\x58\\xcb\\xa8\\xa2\\x74\\x6e\\x1f\\x64\\xf9\\xb9\\xea\\x35\\x2c\\x71\" \\ \"\\x15\\x07\\x05\\x3c\\xf4\\xe5\\x33\\x9d\\x52\\x86\\x5f\\x25\\xcc\\x22\\xb5\\xe8\" \\ \"\\x77\\x84\\xa1\\x2f\\xc9\\x61\\xd6\\x6c\\xb6\\xe8\\x95\\x73\\x19\\x9a\\x2c\\xe6\" \\ \"\\x56\\x5c\\xbd\\xf1\\x3d\\xca\\x40\\x38\\x32\\xcf\\xcb\\x0e\\x8b\\x72\\x11\\xe8\" \\ \"\\x3a\\xf3\\x2a\\x11\\xac\\x17\\x92\\x9f\\xf1\\xc0\\x73\\xa5\\x1c\\xc0\\x27\\xaa\" \\ \"\\xed\\xef\\xf8\\x5a\\xad\\x7c\\x2b\\x7c\\x5a\\x80\\x3e\\x24\\x04\\xd9\\x6d\\x2a\" \\ \"\\x77\\x35\\x7b\\xda\\x1a\\x6d\\xae\\xed\\x17\\x15\\x1c\\xb9\\xbc\\x51\\x25\\xa4\" \\ \"\\x22\\xe9\\x41\\xde\\x0c\\xa0\\xfc\\x50\\x11\\xc2\\x3e\\xcf\\xfe\\xfd\\xd0\\x96\" \\ \"\\x76\\x71\\x1c\\xf3\\xdb\\x0a\\x34\\x40\\x72\\x0e\\x16\\x15\\xc1\\xf2\\x2f\\xbc\" \\ \"\\x3c\\x72\\x1d\\xe5\\x21\\xe1\\xb9\\x9b\\xa1\\xbd\\x55\\x77\\x40\\x86\\x42\\x14\" \\ \"\\x7e\\xd0\\x96\"",
      "zh-CHS": "#10\\x9\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x9\\x10\\x10\\x10\\x0\\x0 0\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x0\\x0\\x0\\x0 0\\x0\\x10\\x0\\x0 0 0\\x10\\x0\\x10\\x10\\x0 0 0 0\\x10\\x10\\x10\\x0 0 0 0\\x10\\x10\\x10\\x0 0 0\\x10\\x10\\x10\\x10\\x0 0 0 0 0 0\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x0 0\\xeb\\xa0\\x14\\xeb\\xff\\x64\\x06“\\”\\xa0\\x7d\\x54\\x36\\x4e\\xff\\x74\\x2d\\xa7\\x79\\xb0\\xb3”定义定义测试10 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0定义定义测试10 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0定义定义定义定义定义测试10 10 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0定义定义定义定义定义定义定义定义定义定义测试10 10 10 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0定义定义定义定义定义定义定义定义定义定义x4a\\x26\\xc7\\x73\\x32\\x5f\\x8b\\x23\\x74“\\\\X6\\X6\\X6\\X6\\X8\\X8\\X8\\X8\\X8\\X8\\X8\\X8\\X8\\X6\\X6\\X6\\X6\\X6\\X4\\X4\\X4\\X4\\X4\\X7\\X7\\X7\\X7\\X7\\X7\\X8\\X8\\X8\\8\\X6\\X6\\X6\\X8\\X8\\X6\\X8\\X6\\X6\\X8\\X6\\X6\\X6\\X6\\X6\\X8\\X6\\X6\\X6\\X8\\X8\\X6\\X6\\X6\\X6\\X8\\X6\\X6\\X6\\X6\\X6\\X6\\X6\\X6\\X6\\X6\\X6\\X6\\X6\\X6\\X6\\X6\\X6\\X6\\X6\\X6\\X8\\X\\ x77\\x4b\\x9c\\x71\\x09“\\”\\xa9\\x7d\\x13\\x8f\\x12\\x92\\x28\\x96\\x6f\\x6c\\x0a\\xdc\\x10\\x6a\\xad\\x5a“\\”\\X7\\X7 7\\X7 7\\X7 7 7 7\\X7 7 7 7\\X7 7 7\\X7 7 7\\X9 9 9\\X7 7 7\\X7 7 7\\X7 7 7\\X7 7 7 7\\X8 8 8\\X7 7 7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7 7 7 7\\X7 7 7\\X7 7 7 7 7 7\\X9\\X9 9\\X9\\X7 7 7 7\\X9\\X7 7 7 7\\X9 9 9\\X7 7 7\\X7 7 7\\X7 7 7 7 7 7 7 7 7 7 7\\X7\\X9\\X7 7 7 7\\X9\\X7 7 7\\X7\\X7\\X9\\X9\\X9\\X9\\X9\\X9\\X9\\X9 9 9 9 9\\X9\\X9 9 9\\X8 9\\X9\\X8 8 8 8 9\\；定义TEST9\\u 384\\“\\x68\\xf5\\x01\\x79\\x2d\\xea\\x97\\x96\\x76\\x70\\x22\\xd9\\x3d\\xa7\\x16\\x79”\\x0\\x0\\x0\\x0\\x0\\x0\\x0\\x0\\x0\\x0\\x0 0\\x0 0\\x0 0\\x0 0\\x0\\x0\\x0 0\\x0\\x0 0\\x0 0\\x0\\x0\\x0\\x0\\x0\\x0\\x0\\x0\\x0\\x0\\x0\\x0\\x0\\x0\\x0\\x0\\x0\\x0\\x0\\x0\\x0\\x0\\x0\\x0\\x0\\x0 0\\x0 0\\x0 0 0 0\\x0 0\\x0 0\\x0\\x0 0 0\\x0 0 0 0 0 0\\x0 0 0 0 0\\x0\\x0 0\\x0 0 0\\x0\\x0 0 0\\x0\\x0\\x0 0 0\\x0 0 0\\x0\\x0 0 0\\x0\\x0 0 0 0 0\\x1c\\xcb\\x67\\x4f“\\”\\x52\\x44\\xea\\x34\\x97\\xde\\x26\\xa4\\x19\\x1c\\x5f\\x62\\xe5\\xe9\\xa2\\xd8“\\”\\x08\\x08\\x08\\x08\\x08\\XX08\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\\\xec\\x10\\xff\\xcf“\\”\\x74\\x79\\x03\\x49\\xb7\\xdc\\x8f\\xbe\\x4a\\x8e\\x7b\\x3b\\x56\\x21\\xdb\\x0f“\\”\\X8\\X8\\X8\\X7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 5\\xcc\\x22\\xb5\\xe8“\\”\\x77\\x84\\xa1\\x2f\\xc9\\x61\\xd6\\x6c\\xb6\\xe8\\x95\\x73\\x19\\x9a\\x2c\\xe6“\\”\\X5 6 0 0 0 0 0 0 0 0 0 0 0 0 5 5 5 5 5 5 5 6 6 6 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 X8 8 8 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 C\\x51\\x25\\xa4“\\”\\x22\\xe9\\x41\\xde\\x0c\\xa0\\xfc\\x50\\x11\\xc2\\x3e\\xcf\\xfe\\xfd\\xd0\\x96“\\”\\x76\\x71\\x1c\\xf3\\xdb\\x0a\\x34\\x40\\x72\\x0e\\x16\\x15\\xc1\\xf2\\x2f\\xbc“\\”\\x3c\\x72\\x1d\\xe5\\x21\\xe1\\xb9\\x9b\\xa1\\xbd\\x55\\x77\\x40\\x86\\x42\\x14“\\”\\x7e\\xd0\\x96”"
    },
    {
      "indent": 0,
      "text": "#define TEST7_512 \\ \"\\x08\\xec\\xb5\\x2e\\xba\\xe1\\xf7\\x42\\x2d\\xb6\\x2b\\xcd\\x54\\x26\\x70\" #define TEST8_512 \\ \"\\x8d\\x4e\\x3c\\x0e\\x38\\x89\\x19\\x14\\x91\\x81\\x6e\\x9d\\x98\\xbf\\xf0\\xa0\" #define TEST9_512 \\ \"\\x3a\\xdd\\xec\\x85\\x59\\x32\\x16\\xd1\\x61\\x9a\\xa0\\x2d\\x97\\x56\\x97\\x0b\" \\ \"\\xfc\\x70\\xac\\xe2\\x74\\x4f\\x7c\\x6b\\x27\\x88\\x15\\x10\\x28\\xf7\\xb6\\xa2\" \\ \"\\x55\\x0f\\xd7\\x4a\\x7e\\x6e\\x69\\xc2\\xc9\\xb4\\x5f\\xc4\\x54\\x96\\x6d\\xc3\" \\ \"\\x1d\\x2e\\x10\\xda\\x1f\\x95\\xce\\x02\\xbe\\xb4\\xbf\\x87\\x65\\x57\\x4c\\xbd\" \\ \"\\x6e\\x83\\x37\\xef\\x42\\x0a\\xdc\\x98\\xc1\\x5c\\xb6\\xd5\\xe4\\xa0\\x24\\x1b\" \\ \"\\xa0\\x04\\x6d\\x25\\x0e\\x51\\x02\\x31\\xca\\xc2\\x04\\x6c\\x99\\x16\\x06\\xab\" \\ \"\\x4e\\xe4\\x14\\x5b\\xee\\x2f\\xf4\\xbb\\x12\\x3a\\xab\\x49\\x8d\\x9d\\x44\\x79\" \\ \"\\x4f\\x99\\xcc\\xad\\x89\\xa9\\xa1\\x62\\x12\\x59\\xed\\xa7\\x0a\\x5b\\x6d\\xd4\" \\ \"\\xbd\\xd8\\x77\\x78\\xc9\\x04\\x3b\\x93\\x84\\xf5\\x49\\x06\" #define TEST10_512 \\ \"\\xa5\\x5f\\x20\\xc4\\x11\\xaa\\xd1\\x32\\x80\\x7a\\x50\\x2d\\x65\\x82\\x4e\\x31\" \\ \"\\xa2\\x30\\x54\\x32\\xaa\\x3d\\x06\\xd3\\xe2\\x82\\xa8\\xd8\\x4e\\x0d\\xe1\\xde\" \\ \"\\x69\\x74\\xbf\\x49\\x54\\x69\\xfc\\x7f\\x33\\x8f\\x80\\x54\\xd5\\x8c\\x26\\xc4\" \\ \"\\x93\\x60\\xc3\\xe8\\x7a\\xf5\\x65\\x23\\xac\\xf6\\xd8\\x9d\\x03\\xe5\\x6f\\xf2\" \\ \"\\xf8\\x68\\x00\\x2b\\xc3\\xe4\\x31\\xed\\xc4\\x4d\\xf2\\xf0\\x22\\x3d\\x4b\\xb3\" \\ \"\\xb2\\x43\\x58\\x6e\\x1a\\x7d\\x92\\x49\\x36\\x69\\x4f\\xcb\\xba\\xf8\\x8d\\x95\" \\ \"\\x19\\xe4\\xeb\\x50\\xa6\\x44\\xf8\\xe4\\xf9\\x5e\\xb0\\xea\\x95\\xbc\\x44\\x65\" \\ \"\\xc8\\x82\\x1a\\xac\\xd2\\xfe\\x15\\xab\\x49\\x81\\x16\\x4b\\xbb\\x6d\\xc3\\x2f\" \\ \"\\x96\\x90\\x87\\xa1\\x45\\xb0\\xd9\\xcc\\x9c\\x67\\xc2\\x2b\\x76\\x32\\x99\\x41\" \\ \"\\x9c\\xc4\\x12\\x8b\\xe9\\xa0\\x77\\xb3\\xac\\xe6\\x34\\x06\\x4e\\x6d\\x99\\x28\" \\ \"\\x35\\x13\\xdc\\x06\\xe7\\x51\\x5d\\x0d\\x73\\x13\\x2e\\x9a\\x0d\\xc6\\xd3\\xb1\" \\ \"\\xf8\\xb2\\x46\\xf1\\xa9\\x8a\\x3f\\xc7\\x29\\x41\\xb1\\xe3\\xbb\\x20\\x98\\xe8\" \\ \"\\xbf\\x16\\xf2\\x68\\xd6\\x4f\\x0b\\x0f\\x47\\x07\\xfe\\x1e\\xa1\\xa1\\x79\\x1b\" \\ \"\\xa2\\xf3\\xc0\\xc7\\x58\\xe5\\xf5\\x51\\x86\\x3a\\x96\\xc9\\x49\\xad\\x47\\xd7\" \\ \"\\xfb\\x40\\xd2\" #define SHA1_SEED \"\\xd0\\x56\\x9c\\xb3\\x66\\x5a\\x8a\\x43\\xeb\\x6e\\xa2\\x3d\" \\ \"\\x75\\xa3\\xc4\\xd2\\x05\\x4a\\x0d\\x7d\" #define SHA224_SEED \"\\xd0\\x56\\x9c\\xb3\\x66\\x5a\\x8a\\x43\\xeb\\x6e\\xa2\" \\ \"\\x3d\\x75\\xa3\\xc4\\xd2\\x05\\x4a\\x0d\\x7d\\x66\\xa9\\xca\\x99\\xc9\\xce\\xb0\" \\ \"\\x27\" #define SHA256_SEED \"\\xf4\\x1e\\xce\\x26\\x13\\xe4\\x57\\x39\\x15\\x69\\x6b\" \\ \"\\x5a\\xdc\\xd5\\x1c\\xa3\\x28\\xbe\\x3b\\xf5\\x66\\xa9\\xca\\x99\\xc9\\xce\\xb0\" \\ \"\\x27\\x9c\\x1c\\xb0\\xa7\" #define SHA384_SEED \"\\x82\\x40\\xbc\\x51\\xe4\\xec\\x7e\\xf7\\x6d\\x18\\xe3\" \\ \"\\x52\\x04\\xa1\\x9f\\x51\\xa5\\x21\\x3a\\x73\\xa8\\x1d\\x6f\\x94\\x46\\x80\\xd3\" \\ \"\\x07\\x59\\x48\\xb7\\xe4\\x63\\x80\\x4e\\xa3\\xd2\\x6e\\x13\\xea\\x82\\x0d\\x65\" \\ \"\\xa4\\x84\\xbe\\x74\\x53\" #define SHA512_SEED \"\\x47\\x3f\\xf1\\xb9\\xb3\\xff\\xdf\\xa1\\x26\\x69\\x9a\" \\ \"\\xc7\\xef\\x9e\\x8e\\x78\\x77\\x73\\x09\\x58\\x24\\xc6\\x42\\x55\\x7c\\x13\\x99\" \\ \"\\xd9\\x8e\\x42\\x20\\x44\\x8d\\xc3\\x5b\\x99\\xbf\\xdd\\x44\\x77\\x95\\x43\\x92\" \\ \"\\x4c\\x1c\\xe9\\x3b\\xc5\\x94\\x15\\x38\\x89\\x5d\\xb9\\x88\\x26\\x1b\\x00\\x77\" \\ \"\\x4b\\x12\\x27\\x20\\x39\"",
      "zh-CHS": "#10\\x08\\XX8\\XXC\\XXC\\X8\\X8\\X8\\X8\\X8\\X8\\X7\\X7 2\\X4\\X7\\X4\\X7\\X4\\X7\\X7\\X7\\X7\\X7\\X7\\X8\\X8\\X8\\X8\\X8\\X8\\X8\\X8\\X8\\X8\\X8\\X8\\X8\\X7\\X7\\X7\\2\\2\\4\\4\\4\\2\\X7\\2\\2\\2\\2\\2\\2\\X7 7 7\\2\\X7\\2\\2\\X7\\2\\2 2\\X7 7 7 7 7\\4\\2 2\\X7\\X7\\2\\4\\4\\X7\\2 2 2\\X7\\2 2\\X7\\4\\4\\4\\4\\X7\\X7\\X7\\X7\\4\\2\\4\\4\\2\\xac\\xe2\\x74\\x4f\\x7c\\x6b\\x27\\x88\\x15\\x10\\x28\\xf7\\xb6\\xa2“\\X5 5\\X5 5\\X5 5\\X5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\x6c\\x99\\x16\\x06\\xab“\\”\\x4e\\xe4\\x14\\x5b\\xee\\x2f\\xf4\\xbb\\x12\\x3a\\xab\\x49\\x8d\\x9d\\x44\\x79“\\”\\10\\X7\\X7\\X7\\X9\\X9\\X9\\X9\\X9\\X9\\X9\\X7\\X7\\X7\\X7\\X7\\X7\\X9\\X9\\X9\\X9\\X9\\X9\\X9\\X9\\X9\\X9\\X9\\X9\\X9\\X9\\X9\\X9\\X9\\X9\\X9\\X9\\X9\\X7\\X7\\X7\\X7\\X10\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\x0d\\xe1\\xde“\\”\\x69\\x74\\xbf\\x49\\x54\\x69\\xfc\\x7f\\x33\\x8f\\x80\\x54\\xd5\\x8c\\x26\\xc4“\\”\\x93\\x93\\X6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 95\\xbc\\x44\\x65“\\”\\xc8\\x82\\x1a\\xac\\xd2\\xfe\\x15\\xab\\x49\\x81\\x16\\x4b\\xbb\\x6d\\xc3\\x2f“\\”\\x96\\x96\\x96\\x90\\x90\\x90\\XX90\\X10\\X10\\X10\\X10\\X10\\x96\\x96\\x90\\x90\\x90\\x90\\X10\\x90\\X10\\X10\\X10\\X10\\X10\\X10\\X10\\X10\\X10\\X10\\X10\\X10\\X10\\X10\\X10\\X8\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\x7\\X7\\X7\\X7\\X7\\X7\\x7\\x7\\x7\\x7\\0 0 0 0 0 0 0 0 0\\xe3\\xbb\\x20\\x98\\xe8“\\”\\xbf\\x16\\xf2\\x68\\xd6\\x4f\\x0b\\x0f\\x47\\x07\\xfe\\x1e\\xa1\\x79\\x1b“\\”\\X6\\X9\\X9 9\\X9 9 9\\X9 9 9\\X9 9 9\\X9 9 9\\X9 9 9\\X10 10 10 10\\X8 8 8\\X9 9\\X9 9 9\\X7 7 7\\X7 10 10\\X3\\X3\\X3\\X3\\X3 3\\X7 3\\X7 3\\X7\\X7\\X8 3\\X7\\X8\\X7\\X8\\X8\\X9\\X9\\X9\\X9\\X9 9 9 9 9 9\\X9 9\\X9 9 9\\X9 9 9 9 9 9\\X9 9 9 9 9\\X9 9\\X9 9\\X9 9 9 9 9 9 9\\X7\\X7\\X9 9 9 9\\X7\\X7\\X7\\X9 9 9 9 9 9 9 9 9\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\Xd\\x75\\xa3\\xc4\\xd2\\x05\\x4a\\x0d\\x7d\\x66\\xa9\\xca\\x99\\xc9\\xce\\xb0“\\”\\x27在本次调查中，定义了一个沙256型种子的学校是否定义了一个256型种子的种子是否定义了沙256型种子的种子是否定义了一个256型种子的种子是否定义了一个256型种子的种子是否定义了一个256型种子的种子是否定义了一个256型种子的种子是否是否定义了一个256型种子的美国256型种子种子的学校学校学校的表面表面\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\A\\x73\\xa8\\x1d\\x6f\\x94\\x46\\x80\\xd3“\\\\x07\\x07\\x07\\x07\\x07\\x07\\x07\\X8 8\\X7 7\\X7 7\\X7 7 7\\X7 7 7\\X7 7 7\\X7 7 7\\X7 7 7\\X7 7 7\\X7 7 7\\X7 7 7 7\\X7 7\\X7 7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7\\X7 7\\X7\\X7 7\\X7 7 7 7 7\\X7\\X7\\7\\X7\\X7\\X7\\X7\\X7\\7\\7\\7 7\\X7\\X7 7\\7\\7\\7 7\\7\\7\\X7\\X7\\X7\\X7\\7\\X7\\X7\\7\\X7\\X7\\X7\\7\\7\\7\\7\\X7\\X7\\X7\\7\\7\\7\\7\\7\\7 3\\x5b\\x99\\xbf\\xdd\\x44\\x77\\x95\\x43\\x92“\\”\\x4c\\x1c\\xe9\\x3b\\xc5\\x94\\x15\\x38\\x89\\x5d\\xb9\\x88\\x26\\x1b\\x00\\x77“\\”\\x4b\\x12\\x27\\x20\\x39”"
    },
    {
      "indent": 0,
      "text": "#define TESTCOUNT 10 #define HASHCOUNT 5 #define RANDOMCOUNT 4 #define HMACTESTCOUNT 7 #define HKDFTESTCOUNT 7",
      "zh-CHS": "#定义TESTCOUNT 10#定义HASHCOUNT 5#定义RANDOMCOUNT 4#定义HMactTestCount 7#定义HKDFTESTCOUNT 7"
    },
    {
      "indent": 0,
      "text": "#define PRINTNONE 0 #define PRINTTEXT 1 #define PRINTRAW 2 #define PRINTHEX 3 #define PRINTBASE64 4",
      "zh-CHS": "#定义PRINTNONE 0#定义PRINTTEXT 1#定义PRINTRAW 2#定义PRINTHEX 3#定义PRINTBASE64 4"
    },
    {
      "indent": 0,
      "text": "#define PRINTPASSFAIL 1 #define PRINTFAIL 2",
      "zh-CHS": "#定义PRINTPASSFAIL 1#定义PRINTFAIL 2"
    },
    {
      "indent": 0,
      "text": "#define length(x) (sizeof(x)-1)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/* Test arrays for hashes. */\nstruct hash {\n    const char *name;\n    SHAversion whichSha;\n    int hashsize;\n    struct {\n        const char *testarray;\n        int length;\n        long repeatcount;\n        int extrabits;\n        int numberExtrabits;\n        const char *resultarray;\n    } tests[TESTCOUNT];\n    const char *randomtest;\n    const char *randomresults[RANDOMCOUNT];\n} hashes[HASHCOUNT] = {\n  { \"SHA1\", SHA1, SHA1HashSize,\n    {\n      /* 1 */ { TEST1, length(TEST1), 1, 0, 0,\n        \"A9993E364706816ABA3E25717850C26C9CD0D89D\" },\n      /* 2 */ { TEST2_1, length(TEST2_1), 1, 0, 0,\n        \"84983E441C3BD26EBAAE4AA1F95129E5E54670F1\" },\n      /* 3 */ { TEST3, length(TEST3), 1000000, 0, 0,\n        \"34AA973CD4C4DAA4F61EEB2BDBAD27316534016F\" },\n      /* 4 */ { TEST4, length(TEST4), 10, 0, 0,\n        \"DEA356A2CDDD90C7A7ECEDC5EBB563934F460452\" },\n      /* 5 */ { \"\", 0, 0, 0x98, 5,\n        \"29826B003B906E660EFF4027CE98AF3531AC75BA\" },\n      /* 6 */ { \"\\x5e\", 1, 1, 0, 0,\n        \"5E6F80A34A9798CAFC6A5DB96CC57BA4C4DB59C2\" },\n      /* 7 */ { TEST7_1, length(TEST7_1), 1, 0x80, 3,",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "      \"6239781E03729919C01955B3FFA8ACB60B988340\" },\n    /* 8 */ { TEST8_1, length(TEST8_1), 1, 0, 0,\n      \"82ABFF6605DBE1C17DEF12A394FA22A82B544A35\" },\n    /* 9 */ { TEST9_1, length(TEST9_1), 1, 0xE0, 3,\n      \"8C5B2A5DDAE5A97FC7F9D85661C672ADBF7933D4\" },\n    /* 10 */ { TEST10_1, length(TEST10_1), 1, 0, 0,\n      \"CB0082C8F197D260991BA6A460E76E202BAD27B3\" }\n  }, SHA1_SEED, { \"E216836819477C7F78E0D843FE4FF1B6D6C14CD4\",\n      \"A2DBC7A5B1C6C0A8BCB7AAA41252A6A7D0690DBC\",\n      \"DB1F9050BB863DFEF4CE37186044E2EEB17EE013\",\n      \"127FDEDF43D372A51D5747C48FBFFE38EF6CDF7B\"\n   } },\n{ \"SHA224\", SHA224, SHA224HashSize,\n  {\n    /* 1 */ { TEST1, length(TEST1), 1, 0, 0,\n      \"23097D223405D8228642A477BDA255B32AADBCE4BDA0B3F7E36C9DA7\" },\n    /* 2 */ { TEST2_1, length(TEST2_1), 1, 0, 0,\n      \"75388B16512776CC5DBA5DA1FD890150B0C6455CB4F58B1952522525\" },\n    /* 3 */ { TEST3, length(TEST3), 1000000, 0, 0,\n      \"20794655980C91D8BBB4C1EA97618A4BF03F42581948B2EE4EE7AD67\" },\n    /* 4 */ { TEST4, length(TEST4), 10, 0, 0,\n      \"567F69F168CD7844E65259CE658FE7AADFA25216E68ECA0EB7AB8262\" },\n    /* 5 */ { \"\", 0, 0, 0x68, 5,\n      \"E3B048552C3C387BCAB37F6EB06BB79B96A4AEE5FF27F51531A9551C\" },\n    /* 6 */ { \"\\x07\", 1, 1, 0, 0,\n      \"00ECD5F138422B8AD74C9799FD826C531BAD2FCABC7450BEE2AA8C2A\" },\n    /* 7 */ { TEST7_224, length(TEST7_224), 1, 0xA0, 3,\n      \"1B01DB6CB4A9E43DED1516BEB3DB0B87B6D1EA43187462C608137150\" },\n    /* 8 */ { TEST8_224, length(TEST8_224), 1, 0, 0,\n      \"DF90D78AA78821C99B40BA4C966921ACCD8FFB1E98AC388E56191DB1\" },\n    /* 9 */ { TEST9_224, length(TEST9_224), 1, 0xE0, 3,\n      \"54BEA6EAB8195A2EB0A7906A4B4A876666300EEFBD1F3B8474F9CD57\" },\n    /* 10 */ { TEST10_224, length(TEST10_224), 1, 0, 0,\n      \"0B31894EC8937AD9B91BDFBCBA294D9ADEFAA18E09305E9F20D5C3A4\" }\n  }, SHA224_SEED, { \"100966A5B4FDE0B42E2A6C5953D4D7F41BA7CF79FD\"\n      \"2DF431416734BE\", \"1DCA396B0C417715DEFAAE9641E10A2E99D55A\"\n      \"BCB8A00061EB3BE8BD\", \"1864E627BDB2319973CD5ED7D68DA71D8B\"\n      \"F0F983D8D9AB32C34ADB34\", \"A2406481FC1BCAF24DD08E6752E844\"\n      \"709563FB916227FED598EB621F\"\n   } },\n{ \"SHA256\", SHA256, SHA256HashSize,\n{\n    /* 1 */ { TEST1, length(TEST1), 1, 0, 0, \"BA7816BF8F01CFEA4141\"\n      \"40DE5DAE2223B00361A396177A9CB410FF61F20015AD\" },\n    /* 2 */ { TEST2_1, length(TEST2_1), 1, 0, 0, \"248D6A61D20638B8\"\n      \"E5C026930C3E6039A33CE45964FF2167F6ECEDD419DB06C1\" },\n    /* 3 */ { TEST3, length(TEST3), 1000000, 0, 0, \"CDC76E5C9914FB92\"\n      \"81A1C7E284D73E67F1809A48A497200E046D39CCC7112CD0\" },",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "    /* 4 */ { TEST4, length(TEST4), 10, 0, 0, \"594847328451BDFA\"\n      \"85056225462CC1D867D877FB388DF0CE35F25AB5562BFBB5\" },\n    /* 5 */ { \"\", 0, 0, 0x68, 5, \"D6D3E02A31A84A8CAA9718ED6C2057BE\"\n      \"09DB45E7823EB5079CE7A573A3760F95\" },\n    /* 6 */ { \"\\x19\", 1, 1, 0, 0, \"68AA2E2EE5DFF96E3355E6C7EE373E3D\"\n      \"6A4E17F75F9518D843709C0C9BC3E3D4\" },\n    /* 7 */ { TEST7_256, length(TEST7_256), 1, 0x60, 3, \"77EC1DC8\"\n      \"9C821FF2A1279089FA091B35B8CD960BCAF7DE01C6A7680756BEB972\" },\n    /* 8 */ { TEST8_256, length(TEST8_256), 1, 0, 0, \"175EE69B02BA\"\n      \"9B58E2B0A5FD13819CEA573F3940A94F825128CF4209BEABB4E8\" },\n    /* 9 */ { TEST9_256, length(TEST9_256), 1, 0xA0, 3, \"3E9AD646\"\n      \"8BBBAD2AC3C2CDC292E018BA5FD70B960CF1679777FCE708FDB066E9\" },\n    /* 10 */ { TEST10_256, length(TEST10_256), 1, 0, 0, \"97DBCA7D\"\n      \"F46D62C8A422C941DD7E835B8AD3361763F7E9B2D95F4F0DA6E1CCBC\" },\n  }, SHA256_SEED, { \"83D28614D49C3ADC1D6FC05DB5F48037C056F8D2A4CE44\"\n      \"EC6457DEA5DD797CD1\", \"99DBE3127EF2E93DD9322D6A07909EB33B6399\"\n      \"5E529B3F954B8581621BB74D39\", \"8D4BE295BB64661CA3C7EFD129A2F7\"\n      \"25B33072DBDDE32385B9A87B9AF88EA76F\", \"40AF5D3F9716B040DF9408\"\n      \"E31536B70FF906EC51B00447CA97D7DD97C12411F4\"\n  } },\n{ \"SHA384\", SHA384, SHA384HashSize,\n  {\n    /* 1 */ { TEST1, length(TEST1), 1, 0, 0,\n      \"CB00753F45A35E8BB5A03D699AC65007272C32AB0EDED163\"\n      \"1A8B605A43FF5BED8086072BA1E7CC2358BAECA134C825A7\" },\n    /* 2 */ { TEST2_2, length(TEST2_2), 1, 0, 0,\n      \"09330C33F71147E83D192FC782CD1B4753111B173B3B05D2\"\n      \"2FA08086E3B0F712FCC7C71A557E2DB966C3E9FA91746039\" },\n    /* 3 */ { TEST3, length(TEST3), 1000000, 0, 0,\n      \"9D0E1809716474CB086E834E310A4A1CED149E9C00F24852\"\n      \"7972CEC5704C2A5B07B8B3DC38ECC4EBAE97DDD87F3D8985\" },\n    /* 4 */ { TEST4, length(TEST4), 10, 0, 0,\n      \"2FC64A4F500DDB6828F6A3430B8DD72A368EB7F3A8322A70\"\n      \"BC84275B9C0B3AB00D27A5CC3C2D224AA6B61A0D79FB4596\" },\n    /* 5 */ { \"\", 0, 0, 0x10, 5,\n      \"8D17BE79E32B6718E07D8A603EB84BA0478F7FCFD1BB9399\"\n      \"5F7D1149E09143AC1FFCFC56820E469F3878D957A15A3FE4\" },\n    /* 6 */ { \"\\xb9\", 1, 1, 0, 0,\n      \"BC8089A19007C0B14195F4ECC74094FEC64F01F90929282C\"\n      \"2FB392881578208AD466828B1C6C283D2722CF0AD1AB6938\" },\n    /* 7 */ { TEST7_384, length(TEST7_384), 1, 0xA0, 3,\n      \"D8C43B38E12E7C42A7C9B810299FD6A770BEF30920F17532\"\n      \"A898DE62C7A07E4293449C0B5FA70109F0783211CFC4BCE3\" },\n    /* 8 */ { TEST8_384, length(TEST8_384), 1, 0, 0,\n      \"C9A68443A005812256B8EC76B00516F0DBB74FAB26D66591\"\n      \"3F194B6FFB0E91EA9967566B58109CBC675CC208E4C823F7\" },\n    /* 9 */ { TEST9_384, length(TEST9_384), 1, 0xE0, 3,\n      \"5860E8DE91C21578BB4174D227898A98E0B45C4C760F0095\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "      \"49495614DAEDC0775D92D11D9F8CE9B064EEAC8DAFC3A297\" },\n    /* 10 */ { TEST10_384, length(TEST10_384), 1, 0, 0,\n      \"4F440DB1E6EDD2899FA335F09515AA025EE177A79F4B4AAF\"\n      \"38E42B5C4DE660F5DE8FB2A5B2FBD2A3CBFFD20CFF1288C0\" }\n  }, SHA384_SEED, { \"CE44D7D63AE0C91482998CF662A51EC80BF6FC68661A3C\"\n      \"57F87566112BD635A743EA904DEB7D7A42AC808CABE697F38F\", \"F9C6D2\"\n      \"61881FEE41ACD39E67AA8D0BAD507C7363EB67E2B81F45759F9C0FD7B503\"\n      \"DF1A0B9E80BDE7BC333D75B804197D\", \"D96512D8C9F4A7A4967A366C01\"\n      \"C6FD97384225B58343A88264847C18E4EF8AB7AEE4765FFBC3E30BD485D3\"\n      \"638A01418F\", \"0CA76BD0813AF1509E170907A96005938BC985628290B2\"\n      \"5FEF73CF6FAD68DDBA0AC8920C94E0541607B0915A7B4457F7\"\n  } },\n{ \"SHA512\", SHA512, SHA512HashSize,\n  {\n    /* 1 */ { TEST1, length(TEST1), 1, 0, 0,\n      \"DDAF35A193617ABACC417349AE20413112E6FA4E89A97EA2\"\n      \"0A9EEEE64B55D39A2192992A274FC1A836BA3C23A3FEEBBD\"\n      \"454D4423643CE80E2A9AC94FA54CA49F\" },\n    /* 2 */ { TEST2_2, length(TEST2_2), 1, 0, 0,\n      \"8E959B75DAE313DA8CF4F72814FC143F8F7779C6EB9F7FA1\"\n      \"7299AEADB6889018501D289E4900F7E4331B99DEC4B5433A\"\n      \"C7D329EEB6DD26545E96E55B874BE909\" },\n     /* 3 */ { TEST3, length(TEST3), 1000000, 0, 0,\n      \"E718483D0CE769644E2E42C7BC15B4638E1F98B13B204428\"\n      \"5632A803AFA973EBDE0FF244877EA60A4CB0432CE577C31B\"\n      \"EB009C5C2C49AA2E4EADB217AD8CC09B\" },\n    /* 4 */ { TEST4, length(TEST4), 10, 0, 0,\n      \"89D05BA632C699C31231DED4FFC127D5A894DAD412C0E024\"\n      \"DB872D1ABD2BA8141A0F85072A9BE1E2AA04CF33C765CB51\"\n      \"0813A39CD5A84C4ACAA64D3F3FB7BAE9\" },\n    /* 5 */ { \"\", 0, 0, 0xB0, 5,\n      \"D4EE29A9E90985446B913CF1D1376C836F4BE2C1CF3CADA0\"\n      \"720A6BF4857D886A7ECB3C4E4C0FA8C7F95214E41DC1B0D2\"\n      \"1B22A84CC03BF8CE4845F34DD5BDBAD4\" },\n    /* 6 */ { \"\\xD0\", 1, 1, 0, 0,\n      \"9992202938E882E73E20F6B69E68A0A7149090423D93C81B\"\n      \"AB3F21678D4ACEEEE50E4E8CAFADA4C85A54EA8306826C4A\"\n      \"D6E74CECE9631BFA8A549B4AB3FBBA15\" },\n    /* 7 */ { TEST7_512, length(TEST7_512), 1, 0x80, 3,\n      \"ED8DC78E8B01B69750053DBB7A0A9EDA0FB9E9D292B1ED71\"\n      \"5E80A7FE290A4E16664FD913E85854400C5AF05E6DAD316B\"\n      \"7359B43E64F8BEC3C1F237119986BBB6\" },\n    /* 8 */ { TEST8_512, length(TEST8_512), 1, 0, 0,\n      \"CB0B67A4B8712CD73C9AABC0B199E9269B20844AFB75ACBD\"\n      \"D1C153C9828924C3DDEDAAFE669C5FDD0BC66F630F677398\"\n      \"8213EB1B16F517AD0DE4B2F0C95C90F8\" },\n    /* 9 */ { TEST9_512, length(TEST9_512), 1, 0x80, 3,\n      \"32BA76FC30EAA0208AEB50FFB5AF1864FDBF17902A4DC0A6\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "        \"82C61FCEA6D92B783267B21080301837F59DE79C6B337DB2\"\n        \"526F8A0A510E5E53CAFED4355FE7C2F1\" },\n      /* 10 */ { TEST10_512, length(TEST10_512), 1, 0, 0,\n        \"C665BEFB36DA189D78822D10528CBF3B12B3EEF726039909\"\n        \"C1A16A270D48719377966B957A878E720584779A62825C18\"\n        \"DA26415E49A7176A894E7510FD1451F5\" }\n    }, SHA512_SEED, { \"2FBB1E7E00F746BA514FBC8C421F36792EC0E11FF5EFC3\"\n        \"78E1AB0C079AA5F0F66A1E3EDBAEB4F9984BE14437123038A452004A5576\"\n        \"8C1FD8EED49E4A21BEDCD0\", \"25CBE5A4F2C7B1D7EF07011705D50C62C5\"\n        \"000594243EAFD1241FC9F3D22B58184AE2FEE38E171CF8129E29459C9BC2\"\n        \"EF461AF5708887315F15419D8D17FE7949\", \"5B8B1F2687555CE2D7182B\"\n        \"92E5C3F6C36547DA1C13DBB9EA4F73EA4CBBAF89411527906D35B1B06C1B\"\n        \"6A8007D05EC66DF0A406066829EAB618BDE3976515AAFC\", \"46E36B007D\"\n        \"19876CDB0B29AD074FE3C08CDD174D42169D6ABE5A1414B6E79707DF5877\"\n        \"6A98091CF431854147BB6D3C66D43BFBC108FD715BDE6AA127C2B0E79F\"\n    }\n  }\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/* Test arrays for HMAC. */\nstruct hmachash {\n    const char *keyarray[5];\n    int keylength[5];\n    const char *dataarray[5];\n    int datalength[5];\n    const char *resultarray[5];\n    int resultlength[5];\n} hmachashes[HMACTESTCOUNT] = {\n  { /* 1 */ {\n      \"\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\"\n      \"\\x0b\\x0b\\x0b\\x0b\\x0b\"\n    }, { 20 }, {\n      \"\\x48\\x69\\x20\\x54\\x68\\x65\\x72\\x65\" /* \"Hi There\" */\n    }, { 8 }, {\n      /* HMAC-SHA-1 */\n      \"B617318655057264E28BC0B6FB378C8EF146BE00\",\n      /* HMAC-SHA-224 */\n      \"896FB1128ABBDF196832107CD49DF33F47B4B1169912BA4F53684B22\",\n      /* HMAC-SHA-256 */\n      \"B0344C61D8DB38535CA8AFCEAF0BF12B881DC200C9833DA726E9376C2E32\"\n      \"CFF7\",\n      /* HMAC-SHA-384 */\n      \"AFD03944D84895626B0825F4AB46907F15F9DADBE4101EC682AA034C7CEB\"\n      \"C59CFAEA9EA9076EDE7F4AF152E8B2FA9CB6\",\n      /* HMAC-SHA-512 */\n      \"87AA7CDEA5EF619D4FF0B4241A1D6CB02379F4E2CE4EC2787AD0B30545E1\"\n      \"7CDEDAA833B7D6B8A702038B274EAEA3F4E4BE9D914EEB61F1702E696C20\"\n      \"3A126854\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "  }, { SHA1HashSize, SHA224HashSize, SHA256HashSize,\n    SHA384HashSize, SHA512HashSize }\n},\n{ /* 2 */ {\n    \"\\x4a\\x65\\x66\\x65\" /* \"Jefe\" */\n  }, { 4 }, {\n    \"\\x77\\x68\\x61\\x74\\x20\\x64\\x6f\\x20\\x79\\x61\\x20\\x77\\x61\\x6e\\x74\"\n    \"\\x20\\x66\\x6f\\x72\\x20\\x6e\\x6f\\x74\\x68\\x69\\x6e\\x67\\x3f\"\n    /* \"what do ya want for nothing?\" */\n  }, { 28 }, {\n    /* HMAC-SHA-1 */\n    \"EFFCDF6AE5EB2FA2D27416D5F184DF9C259A7C79\",\n    /* HMAC-SHA-224 */\n    \"A30E01098BC6DBBF45690F3A7E9E6D0F8BBEA2A39E6148008FD05E44\",\n    /* HMAC-SHA-256 */\n    \"5BDCC146BF60754E6A042426089575C75A003F089D2739839DEC58B964EC\"\n    \"3843\",\n    /* HMAC-SHA-384 */\n    \"AF45D2E376484031617F78D2B58A6B1B9C7EF464F5A01B47E42EC3736322\"\n    \"445E8E2240CA5E69E2C78B3239ECFAB21649\",\n    /* HMAC-SHA-512 */\n    \"164B7A7BFCF819E2E395FBE73B56E0A387BD64222E831FD610270CD7EA25\"\n    \"05549758BF75C05A994A6D034F65F8F0E6FDCAEAB1A34D4A6B4B636E070A\"\n    \"38BCE737\"\n  }, { SHA1HashSize, SHA224HashSize, SHA256HashSize,\n    SHA384HashSize, SHA512HashSize }\n},\n{ /* 3 */\n  {\n    \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n    \"\\xaa\\xaa\\xaa\\xaa\\xaa\"\n  }, { 20 }, {\n    \"\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\"\n    \"\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\"\n    \"\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\"\n    \"\\xdd\\xdd\\xdd\\xdd\\xdd\"\n  }, { 50 }, {\n    /* HMAC-SHA-1 */\n    \"125D7342B9AC11CD91A39AF48AA17B4F63F175D3\",\n    /* HMAC-SHA-224 */\n    \"7FB3CB3588C6C1F6FFA9694D7D6AD2649365B0C1F65D69D1EC8333EA\",\n    /* HMAC-SHA-256 */\n    \"773EA91E36800E46854DB8EBD09181A72959098B3EF8C122D9635514CED5\"\n    \"65FE\",\n    /* HMAC-SHA-384 */\n    \"88062608D3E6AD8A0AA2ACE014C8A86F0AA635D947AC9FEBE83EF4E55966\"\n    \"144B2A5AB39DC13814B94E3AB6E101A34F27\",\n    /* HMAC-SHA-512 */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "    \"FA73B0089D56A284EFB0F0756C890BE9B1B5DBDD8EE81A3655F83E33B227\"\n    \"9D39BF3E848279A722C806B485A47E67C807B946A337BEE8942674278859\"\n    \"E13292FB\"\n  }, { SHA1HashSize, SHA224HashSize, SHA256HashSize,\n    SHA384HashSize, SHA512HashSize }\n},\n{ /* 4 */ {\n    \"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\"\n    \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\"\n  }, { 25 }, {\n    \"\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\"\n    \"\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\"\n    \"\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\"\n    \"\\xcd\\xcd\\xcd\\xcd\\xcd\"\n  }, { 50 }, {\n    /* HMAC-SHA-1 */\n    \"4C9007F4026250C6BC8414F9BF50C86C2D7235DA\",\n    /* HMAC-SHA-224 */\n    \"6C11506874013CAC6A2ABC1BB382627CEC6A90D86EFC012DE7AFEC5A\",\n    /* HMAC-SHA-256 */\n    \"82558A389A443C0EA4CC819899F2083A85F0FAA3E578F8077A2E3FF46729\"\n    \"665B\",\n    /* HMAC-SHA-384 */\n    \"3E8A69B7783C25851933AB6290AF6CA77A9981480850009CC5577C6E1F57\"\n    \"3B4E6801DD23C4A7D679CCF8A386C674CFFB\",\n    /* HMAC-SHA-512 */\n    \"B0BA465637458C6990E5A8C5F61D4AF7E576D97FF94B872DE76F8050361E\"\n    \"E3DBA91CA5C11AA25EB4D679275CC5788063A5F19741120C4F2DE2ADEBEB\"\n    \"10A298DD\"\n  }, { SHA1HashSize, SHA224HashSize, SHA256HashSize,\n    SHA384HashSize, SHA512HashSize }\n},\n{ /* 5 */ {\n    \"\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\"\n    \"\\x0c\\x0c\\x0c\\x0c\\x0c\"\n  }, { 20 }, {\n    \"Test With Truncation\"\n  }, { 20 }, {\n    /* HMAC-SHA-1 */\n    \"4C1A03424B55E07FE7F27BE1\",\n    /* HMAC-SHA-224 */\n    \"0E2AEA68A90C8D37C988BCDB9FCA6FA8\",\n    /* HMAC-SHA-256 */\n    \"A3B6167473100EE06E0C796C2955552B\",\n    /* HMAC-SHA-384 */\n    \"3ABF34C3503B2A23A46EFC619BAEF897\",\n    /* HMAC-SHA-512 */\n    \"415FAD6271580A531D4179BC891D87A6\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "  }, { 12, 16, 16, 16, 16 }\n},\n{ /* 6 */ {\n    \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n    \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n    \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n    \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n    \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n    \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n    \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n    \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n    \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n  }, { 80, 131 }, {\n    \"Test Using Larger Than Block-Size Key - Hash Key First\"\n  }, { 54 }, {\n    /* HMAC-SHA-1 */\n    \"AA4AE5E15272D00E95705637CE8A3B55ED402112\",\n    /* HMAC-SHA-224 */\n    \"95E9A0DB962095ADAEBE9B2D6F0DBCE2D499F112F2D2B7273FA6870E\",\n    /* HMAC-SHA-256 */\n    \"60E431591EE0B67F0D8A26AACBF5B77F8E0BC6213728C5140546040F0EE3\"\n    \"7F54\",\n    /* HMAC-SHA-384 */\n    \"4ECE084485813E9088D2C63A041BC5B44F9EF1012A2B588F3CD11F05033A\"\n    \"C4C60C2EF6AB4030FE8296248DF163F44952\",\n    /* HMAC-SHA-512 */\n    \"80B24263C7C1A3EBB71493C1DD7BE8B49B46D1F41B4AEEC1121B013783F8\"\n    \"F3526B56D037E05F2598BD0FD2215D6A1E5295E64F73F63F0AEC8B915A98\"\n    \"5D786598\"\n  }, { SHA1HashSize, SHA224HashSize, SHA256HashSize,\n    SHA384HashSize, SHA512HashSize }\n},\n{ /* 7 */ {\n    \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n    \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n    \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n    \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n    \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n    \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n    \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n    \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n    \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n  }, { 80, 131 }, {\n    \"Test Using Larger Than Block-Size Key and \"\n    \"Larger Than One Block-Size Data\",\n    \"\\x54\\x68\\x69\\x73\\x20\\x69\\x73\\x20\\x61\\x20\\x74\\x65\\x73\\x74\\x20\"\n    \"\\x75\\x73\\x69\\x6e\\x67\\x20\\x61\\x20\\x6c\\x61\\x72\\x67\\x65\\x72\\x20\"\n    \"\\x74\\x68\\x61\\x6e\\x20\\x62\\x6c\\x6f\\x63\\x6b\\x2d\\x73\\x69\\x7a\\x65\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "      \"\\x20\\x6b\\x65\\x79\\x20\\x61\\x6e\\x64\\x20\\x61\\x20\\x6c\\x61\\x72\\x67\"\n      \"\\x65\\x72\\x20\\x74\\x68\\x61\\x6e\\x20\\x62\\x6c\\x6f\\x63\\x6b\\x2d\\x73\"\n      \"\\x69\\x7a\\x65\\x20\\x64\\x61\\x74\\x61\\x2e\\x20\\x54\\x68\\x65\\x20\\x6b\"\n      \"\\x65\\x79\\x20\\x6e\\x65\\x65\\x64\\x73\\x20\\x74\\x6f\\x20\\x62\\x65\\x20\"\n      \"\\x68\\x61\\x73\\x68\\x65\\x64\\x20\\x62\\x65\\x66\\x6f\\x72\\x65\\x20\\x62\"\n      \"\\x65\\x69\\x6e\\x67\\x20\\x75\\x73\\x65\\x64\\x20\\x62\\x79\\x20\\x74\\x68\"\n      \"\\x65\\x20\\x48\\x4d\\x41\\x43\\x20\\x61\\x6c\\x67\\x6f\\x72\\x69\\x74\\x68\"\n      \"\\x6d\\x2e\"\n      /* \"This is a test using a larger than block-size key and a \"\n          \"larger than block-size data.  The key needs to be hashed \"\n          \"before being used by the HMAC algorithm.\" */\n    }, { 73, 152 }, {\n      /* HMAC-SHA-1 */\n      \"E8E99D0F45237D786D6BBAA7965C7808BBFF1A91\",\n      /* HMAC-SHA-224 */\n      \"3A854166AC5D9F023F54D517D0B39DBD946770DB9C2B95C9F6F565D1\",\n      /* HMAC-SHA-256 */\n      \"9B09FFA71B942FCB27635FBCD5B0E944BFDC63644F0713938A7F51535C3A\"\n      \"35E2\",\n      /* HMAC-SHA-384 */\n      \"6617178E941F020D351E2F254E8FD32C602420FEB0B8FB9ADCCEBB82461E\"\n      \"99C5A678CC31E799176D3860E6110C46523E\",\n      /* HMAC-SHA-512 */\n      \"E37B6A775DC87DBAA4DFA9F96E5E3FFDDEBD71F8867289865DF5A32D20CD\"\n      \"C944B6022CAC3C4982B10D5EEB55C3E4DE15134676FB6DE0446065C97440\"\n      \"FA8C6A58\"\n    }, { SHA1HashSize, SHA224HashSize, SHA256HashSize,\n      SHA384HashSize, SHA512HashSize }\n  }\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/* Test arrays for HKDF. */\nstruct hkdfhash {\n    SHAversion whichSha;\n    int ikmlength;\n    const char *ikmarray;\n    int saltlength;\n    const char *saltarray;\n    int infolength;\n    const char *infoarray;\n    int prklength;\n    const char *prkarray;\n    int okmlength;\n    const char *okmarray;\n} hkdfhashes[HKDFTESTCOUNT] = {\n    {   /* RFC 5869 A.1. Test Case 1 */\n        SHA256,\n        22, \"\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "        \"\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\",\n    13, \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\",\n    10, \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\",\n    32, \"077709362C2E32DF0DDC3F0DC47BBA6390B6C73BB50F9C3122EC844A\"\n        \"D7C2B3E5\",\n    42, \"3CB25F25FAACD57A90434F64D0362F2A2D2D0A90CF1A5A4C5DB02D56\"\n        \"ECC4C5BF34007208D5B887185865\"\n},\n{   /* RFC 5869 A.2. Test Case 2 */\n    SHA256,\n    80, \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\"\n        \"\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\"\n        \"\\x1c\\x1d\\x1e\\x1f\\x20\\x21\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\"\n        \"\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f\\x30\\x31\\x32\\x33\\x34\\x35\\x36\\x37\"\n        \"\\x38\\x39\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f\\x40\\x41\\x42\\x43\\x44\\x45\"\n        \"\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\\x4d\\x4e\\x4f\",\n    80, \"\\x60\\x61\\x62\\x63\\x64\\x65\\x66\\x67\\x68\\x69\\x6a\\x6b\\x6c\\x6d\"\n        \"\\x6e\\x6f\\x70\\x71\\x72\\x73\\x74\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\"\n        \"\\x7c\\x7d\\x7e\\x7f\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\"\n        \"\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\"\n        \"\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\\xa1\\xa2\\xa3\\xa4\\xa5\"\n        \"\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\",\n    80, \"\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\"\n        \"\\xbe\\xbf\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\"\n        \"\\xcc\\xcd\\xce\\xcf\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\"\n        \"\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\"\n        \"\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\"\n        \"\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\",\n    32, \"06A6B88C5853361A06104C9CEB35B45C\"\n        \"EF760014904671014A193F40C15FC244\",\n    82, \"B11E398DC80327A1C8E7F78C596A4934\"\n        \"4F012EDA2D4EFAD8A050CC4C19AFA97C\"\n        \"59045A99CAC7827271CB41C65E590E09\"\n        \"DA3275600C2F09B8367793A9ACA3DB71\"\n        \"CC30C58179EC3E87C14C01D5C1F3434F\"\n        \"1D87\"\n},\n{   /* RFC 5869 A.3. Test Case 3 */\n    SHA256,\n    22, \"\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\"\n        \"\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\",\n    0, \"\",\n    0, \"\",\n    32, \"19EF24A32C717B167F33A91D6F648BDF\"\n        \"96596776AFDB6377AC434C1C293CCB04\",\n    42, \"8DA4E775A563C18F715F802A063C5A31\"\n        \"B8A11F5C5EE1879EC3454E5F3C738D2D\"\n        \"9D201395FAA4B61A96C8\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "},\n{   /* RFC 5869 A.4. Test Case 4 */\n    SHA1,\n    11, \"\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\",\n    13, \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\",\n    10, \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\",\n    20, \"9B6C18C432A7BF8F0E71C8EB88F4B30BAA2BA243\",\n    42, \"085A01EA1B10F36933068B56EFA5AD81\"\n        \"A4F14B822F5B091568A9CDD4F155FDA2\"\n        \"C22E422478D305F3F896\"\n},\n{   /* RFC 5869 A.5. Test Case 5 */\n    SHA1,\n    80, \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\"\n        \"\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\"\n        \"\\x1c\\x1d\\x1e\\x1f\\x20\\x21\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\"\n        \"\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f\\x30\\x31\\x32\\x33\\x34\\x35\\x36\\x37\"\n        \"\\x38\\x39\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f\\x40\\x41\\x42\\x43\\x44\\x45\"\n        \"\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\\x4d\\x4e\\x4f\",\n    80, \"\\x60\\x61\\x62\\x63\\x64\\x65\\x66\\x67\\x68\\x69\\x6A\\x6B\\x6C\\x6D\"\n        \"\\x6E\\x6F\\x70\\x71\\x72\\x73\\x74\\x75\\x76\\x77\\x78\\x79\\x7A\\x7B\"\n        \"\\x7C\\x7D\\x7E\\x7F\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\"\n        \"\\x8A\\x8B\\x8C\\x8D\\x8E\\x8F\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\"\n        \"\\x98\\x99\\x9A\\x9B\\x9C\\x9D\\x9E\\x9F\\xA0\\xA1\\xA2\\xA3\\xA4\\xA5\"\n        \"\\xA6\\xA7\\xA8\\xA9\\xAA\\xAB\\xAC\\xAD\\xAE\\xAF\",\n    80, \"\\xB0\\xB1\\xB2\\xB3\\xB4\\xB5\\xB6\\xB7\\xB8\\xB9\\xBA\\xBB\\xBC\\xBD\"\n        \"\\xBE\\xBF\\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\"\n        \"\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD7\\xD8\\xD9\"\n        \"\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\"\n        \"\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\"\n        \"\\xF6\\xF7\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xFF\",\n    20, \"8ADAE09A2A307059478D309B26C4115A224CFAF6\",\n    82, \"0BD770A74D1160F7C9F12CD5912A06EB\"\n        \"FF6ADCAE899D92191FE4305673BA2FFE\"\n        \"8FA3F1A4E5AD79F3F334B3B202B2173C\"\n        \"486EA37CE3D397ED034C7F9DFEB15C5E\"\n        \"927336D0441F4C4300E2CFF0D0900B52\"\n        \"D3B4\"\n},\n{   /* RFC 5869 A.6. Test Case 6 */\n    SHA1,\n    22, \"\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\"\n        \"\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\",\n    0, \"\",\n    0, \"\",\n    20, \"DA8C8A73C7FA77288EC6F5E7C297786AA0D32D01\",\n    42, \"0AC1AF7002B3D761D1E55298DA9D0506\"\n        \"B9AE52057220A306E07B6B87E8DF21D0\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "            \"EA00033DE03984D34918\"\n    },\n    {   /* RFC 5869 A.7. Test Case 7. */\n        SHA1,\n        22, \"\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\"\n            \"\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\",\n        0, 0,\n        0, \"\",\n        20, \"2ADCCADA18779E7C2077AD2EB19D3F3E731385DD\",\n        42, \"2C91117204D745F3500D636A62F64F0A\"\n            \"B3BAE548AA53D423B0D1F27EBBA6F5E5\"\n            \"673A081D70CCE7ACFC48\"\n    }\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * Check the hash value against the expected string, expressed in hex\n */\nstatic const char hexdigits[ ] = \"0123456789ABCDEF\";\nint checkmatch(const unsigned char *hashvalue,\n  const char *hexstr, int hashsize)\n{\n  int i;\n  for (i = 0; i < hashsize; ++i) {\n    if (*hexstr++ != hexdigits[(hashvalue[i] >> 4) & 0xF])\n      return 0;\n    if (*hexstr++ != hexdigits[hashvalue[i] & 0xF]) return 0;\n  }\n  return 1;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * Print the string, converting non-printable characters to \".\"\n */\nvoid printstr(const char *str, int len)\n{\n  for ( ; len-- > 0; str++)\n    putchar(isprint((unsigned char)*str) ? *str : '.');\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * Print the string, converting all characters to hex \"## \".\n */\nvoid printxstr(const char *str, int len)\n{\n  char *sep = \"\";\n  for ( ; len-- > 0; str++) {\n    printf(\"%s%c%c\", sep, hexdigits[(*str >> 4) & 0xF],",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "      hexdigits[*str & 0xF]);\n    sep = \" \";\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * Print a usage message.\n */\nvoid usage(const char *argv0)\n{\n  fprintf(stderr,\n    \"Usage:\\n\"\n    \"Common options: [-h hash] [-w|-x|-6] [-H]\\n\"\n    \"Hash a string:\\n\"\n      \"\\t%s [-S expectedresult] -s hashstr [-k key] \"\n           \"[-i info -L okm-len]\\n\"\n    \"Hash a file:\\n\"\n      \"\\t%s [-S expectedresult] -f file [-k key] \"\n           \"[-i info -L okm-len]\\n\"\n    \"Hash a file, ignoring whitespace:\\n\"\n      \"\\t%s [-S expectedresult] -F file [-k key] \"\n           \"[-i info -L okm-len]\\n\"\n    \"Additional bits to add in: [-B bitcount -b bits]\\n\"\n    \"(If -k,-i&-L are used, run HKDF-SHA###.\\n\"\n    \" If -k is used, but not -i&-L, run HMAC-SHA###.\\n\"\n    \" Otherwise, run SHA###.)\\n\"\n    \"Standard tests:\\n\"\n      \"\\t%s [-m | -d] [-l loopcount] [-t test#] [-e]\\n\"\n      \"\\t\\t[-r randomseed] [-R randomloop-count] \"\n        \"[-p] [-P|-X]\\n\"\n    \"-h\\thash to test: \"\n      \"0|SHA1, 1|SHA224, 2|SHA256, 3|SHA384, 4|SHA512\\n\"\n    \"-m\\tperform hmac standard tests\\n\"\n    \"-k\\tkey for hmac test\\n\"\n    \"-d\\tperform hkdf standard tests\\n\"\n    \"-t\\ttest case to run, 1-10\\n\"\n    \"-l\\thow many times to run the test\\n\"\n    \"-e\\ttest error returns\\n\"\n    \"-p\\tdo not print results\\n\"\n    \"-P\\tdo not print PASSED/FAILED\\n\"\n    \"-X\\tprint FAILED, but not PASSED\\n\"\n    \"-r\\tseed for random test\\n\"\n    \"-R\\thow many times to run random test\\n\"\n    \"-s\\tstring to hash\\n\"\n    \"-S\\texpected result of hashed string, in hex\\n\"\n    \"-w\\toutput hash in raw format\\n\"\n    \"-x\\toutput hash in hex format\\n\"\n    \"-6\\toutput hash in base64 format\\n\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "    \"-B\\t# extra bits to add in after string or file input\\n\"\n    \"-b\\textra bits to add (high order bits of #, 0# or 0x#)\\n\"\n    \"-H\\tinput hashstr or randomseed is in hex\\n\"\n    , argv0, argv0, argv0, argv0);\n  exit(1);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * Print the results and PASS/FAIL.\n */\nvoid printResult(uint8_t *Message_Digest, int hashsize,\n    const char *hashname, const char *testtype, const char *testname,\n    const char *resultarray, int printResults, int printPassFail)\n{\n  int i, k;\n  if (printResults == PRINTTEXT) {\n    printf(\"\\nhashsize=%d\\n\", hashsize);\n    putchar('\\t');\n    for (i = 0; i < hashsize; ++i) {\n      putchar(hexdigits[(Message_Digest[i] >> 4) & 0xF]);\n      putchar(hexdigits[Message_Digest[i] & 0xF]);\n      putchar(' ');\n    }\n    putchar('\\n');\n  } else if (printResults == PRINTRAW) {\n    fwrite(Message_Digest, 1, hashsize, stdout);\n  } else if (printResults == PRINTHEX) {\n    for (i = 0; i < hashsize; ++i) {\n      putchar(hexdigits[(Message_Digest[i] >> 4) & 0xF]);\n      putchar(hexdigits[Message_Digest[i] & 0xF]);\n    }\n    putchar('\\n');\n  } else if (printResults == PRINTBASE64) {\n    unsigned char b;\n    char *sm = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n               \"0123456789+/\";\n    for (i = 0; i < hashsize; i += 3) {\n      putchar(sm[Message_Digest[i] >> 2]);\n      b = (Message_Digest[i] & 0x03) << 4;\n      if (i+1 < hashsize) b |= Message_Digest[i+1] >> 4;\n      putchar(sm[b]);\n      if (i+1 < hashsize) {\n        b = (Message_Digest[i+1] & 0x0f) << 2;\n        if (i+2 < hashsize) b |= Message_Digest[i+2] >> 6;\n        putchar(sm[b]);\n      } else putchar('=');\n      if (i+2 < hashsize) putchar(sm[Message_Digest[i+2] & 0x3f]);\n      else putchar('=');",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "  }\n  putchar('\\n');\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "if (printResults && resultarray) {\n  printf(\"    Should match:\\n\\t\");\n  for (i = 0, k = 0; i < hashsize; i++, k += 2) {\n    putchar(resultarray[k]);\n    putchar(resultarray[k+1]);\n    putchar(' ');\n  }\n  putchar('\\n');\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "  if (printPassFail && resultarray) {\n    int ret = checkmatch(Message_Digest, resultarray, hashsize);\n    if ((printPassFail == PRINTPASSFAIL) || !ret)\n      printf(\"%s %s %s: %s\\n\", hashname, testtype, testname,\n        ret ? \"PASSED\" : \"FAILED\");\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * Exercise a hash series of functions.  The input is the testarray,\n * repeated repeatcount times, followed by the extrabits.  If the\n * result is known, it is in resultarray in uppercase hex.\n */\nint hash(int testno, int loopno, int hashno,\n  const char *testarray, int length, long repeatcount,\n  int numberExtrabits, int extrabits, const unsigned char *keyarray,\n  int keylen, const unsigned char *info, int infolen, int okmlen,\n  const char *resultarray, int hashsize, int printResults,\n  int printPassFail)\n{\n  USHAContext sha;\n  HMACContext hmac;\n  HKDFContext hkdf;\n  int err, i;\n  uint8_t Message_Digest_Buf[USHAMaxHashSize];\n  uint8_t *Message_Digest = Message_Digest_Buf;\n  char buf[20];",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "if (printResults == PRINTTEXT) {\n  printf(\"\\nTest %d: Iteration %d, Repeat %ld\\n\\t'\", testno+1,\n    loopno, repeatcount);\n  printstr(testarray, length);\n  printf(\"'\\n\\t'\");\n  printxstr(testarray, length);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "  printf(\"'\\n\");\n  printf(\"    Length=%d bytes (%d bits), \", length, length * 8);\n  printf(\"ExtraBits %d: %2.2x\\n\", numberExtrabits, extrabits);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "if (info) Message_Digest = malloc(okmlen);\nmemset(&sha, '\\343', sizeof(sha)); /* force bad data into struct */\nmemset(&hmac, '\\343', sizeof(hmac));\nmemset(&hkdf, '\\343', sizeof(hkdf));",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "err = info ? hkdfReset(&hkdf, hashes[hashno].whichSha,\n                           keyarray, keylen) :\n      keyarray ? hmacReset(&hmac, hashes[hashno].whichSha,\n                           keyarray, keylen) :\n                 USHAReset(&sha, hashes[hashno].whichSha);\nif (err != shaSuccess) {\n  fprintf(stderr, \"hash(): %sReset Error %d.\\n\",\n          info ? \"hkdf\" : keyarray ? \"hmac\" : \"sha\", err);\n  return err;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "for (i = 0; i < repeatcount; ++i) {\n  err = info ? hkdfInput(&hkdf, (const uint8_t *)testarray, length) :\n        keyarray ? hmacInput(&hmac, (const uint8_t *) testarray,\n                             length) :\n                   USHAInput(&sha, (const uint8_t *) testarray,\n                             length);\n  if (err != shaSuccess) {\n    fprintf(stderr, \"hash(): %sInput Error %d.\\n\",\n            info ? \"hkdf\" : keyarray ? \"hmac\" : \"sha\", err);\n    return err;\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "if (numberExtrabits > 0) {\n  err = info ? hkdfFinalBits(&hkdf, extrabits, numberExtrabits) :\n        keyarray ? hmacFinalBits(&hmac, (uint8_t) extrabits,\n                                 numberExtrabits) :\n                   USHAFinalBits(&sha, (uint8_t) extrabits,\n                                 numberExtrabits);\n  if (err != shaSuccess) {\n    fprintf(stderr, \"hash(): %sFinalBits Error %d.\\n\",\n            info ? \"hkdf\" : keyarray ? \"hmac\" : \"sha\", err);\n    return err;\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "err = info ? hkdfResult(&hkdf, 0, info, infolen,",
      "zh-CHS": "错误=信息？hkdfResult&hkdf，0，info，infolen，"
    },
    {
      "indent": 2,
      "text": "                        Message_Digest, okmlen) :\n      keyarray ? hmacResult(&hmac, Message_Digest) :\n                 USHAResult(&sha, Message_Digest);\nif (err != shaSuccess) {\n  fprintf(stderr, \"hash(): %s Result Error %d, could not compute \"\n    \"message digest.\\n\",\n    info ? \"hkdf\" : keyarray ? \"hmac\" : \"sha\", err);\n  return err;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "sprintf(buf, \"%d\", testno+1);\nprintResult(Message_Digest, info ? okmlen : hashsize,\n  hashes[hashno].name, info ? \"hkdf standard test\" :\n  keyarray ? \"hmac standard test\" : \"sha standard test\", buf,\n  resultarray, printResults, printPassFail);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "  return err;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * Exercise an HKDF series.  The input is the testarray,\n * repeated repeatcount times, followed by the extrabits.  If the\n * result is known, it is in resultarray in uppercase hex.\n */\nint hashHkdf(int testno, int loopno, int hashno,\n  int printResults, int printPassFail)\n{\n  int err;\n  unsigned char prk[USHAMaxHashSize+1];\n  uint8_t okm[255 * USHAMaxHashSize+1];\n  char buf[20];",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "if (printResults == PRINTTEXT) {\n  printf(\"\\nTest %d: Iteration %d\\n\\tSALT\\t'\", testno+1, loopno);\n  printxstr(hkdfhashes[testno].saltarray,\n    hkdfhashes[testno].saltlength);\n  printf(\"'\\n\\tIKM\\t'\");\n  printxstr(hkdfhashes[testno].ikmarray,\n    hkdfhashes[testno].ikmlength);\n  printf(\"'\\n\\tINFO\\t'\");\n  printxstr(hkdfhashes[testno].infoarray,\n    hkdfhashes[testno].infolength);\n  printf(\"'\\n\");\n  printf(\"    L=%d bytes\\n\", hkdfhashes[testno].okmlength);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "/* Run hkdf() against the test vectors */\nerr = hkdf(hkdfhashes[testno].whichSha,",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "           (const uint8_t *) hkdfhashes[testno].saltarray,\n           hkdfhashes[testno].saltlength,\n           (const uint8_t *) hkdfhashes[testno].ikmarray,\n           hkdfhashes[testno].ikmlength,\n           (const uint8_t *) hkdfhashes[testno].infoarray,\n           hkdfhashes[testno].infolength, okm,\n           hkdfhashes[testno].okmlength);\nif (err != shaSuccess) {\n  fprintf(stderr, \"hashHkdf(): hkdf Error %d.\\n\", err);\n  return err;\n}\nsprintf(buf, \"hkdf %d\", testno+1);\nprintResult(okm, hkdfhashes[testno].okmlength,\n  USHAHashName(hkdfhashes[testno].whichSha), \"hkdf standard test\",\n  buf, hkdfhashes[testno].okmarray, printResults, printPassFail);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "/* Now run hkdfExtract() by itself against the test vectors */\n/* to verify the intermediate results. */\nerr = hkdfExtract(hkdfhashes[testno].whichSha,\n                  (const uint8_t *) hkdfhashes[testno].saltarray,\n                  hkdfhashes[testno].saltlength,\n                  (const uint8_t *) hkdfhashes[testno].ikmarray,\n                  hkdfhashes[testno].ikmlength, prk);\nif (err != shaSuccess) {\n  fprintf(stderr, \"hashHkdf(): hkdfExtract Error %d.\\n\", err);\n  return err;\n}\nsprintf(buf, \"hkdfExtract %d\", testno+1);\nprintResult(prk, USHAHashSize(hkdfhashes[testno].whichSha),\n  USHAHashName(hkdfhashes[testno].whichSha), \"hkdf standard test\",\n  buf, hkdfhashes[testno].prkarray, printResults, printPassFail);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "/* Now run hkdfExpand() by itself against the test vectors */\n/* using the intermediate results from hkdfExtract. */\nerr = hkdfExpand(hkdfhashes[testno].whichSha, prk,\n  USHAHashSize(hkdfhashes[testno].whichSha),\n  (const uint8_t *)hkdfhashes[testno].infoarray,\n  hkdfhashes[testno].infolength, okm, hkdfhashes[testno].okmlength);\nif (err != shaSuccess) {\n  fprintf(stderr, \"hashHkdf(): hkdfExpand Error %d.\\n\", err);\n  return err;\n}\nsprintf(buf, \"hkdfExpand %d\", testno+1);\nprintResult(okm, hkdfhashes[testno].okmlength,\n  USHAHashName(hkdfhashes[testno].whichSha), \"hkdf standard test\",\n  buf, hkdfhashes[testno].okmarray, printResults, printPassFail);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "return err;",
      "zh-CHS": "返回错误；"
    },
    {
      "indent": 0,
      "text": "}",
      "zh-CHS": "}"
    },
    {
      "indent": 0,
      "text": "/*\n * Exercise a hash series of functions.  The input is a filename.\n * If the result is known, it is in resultarray in uppercase hex.\n */\nint hashfile(int hashno, const char *hashfilename, int bits,\n  int bitcount, int skipSpaces, const unsigned char *keyarray,\n  int keylen, const unsigned char *info, int infolen, int okmlen,\n  const char *resultarray, int hashsize,\n  int printResults, int printPassFail)\n{\n  USHAContext sha;\n  HMACContext hmac;\n  HKDFContext hkdf;\n  int err, nread, c;\n  unsigned char buf[4096];\n  uint8_t Message_Digest_Buf[USHAMaxHashSize];\n  uint8_t *Message_Digest = Message_Digest_Buf;\n  unsigned char cc;\n  FILE *hashfp = (strcmp(hashfilename, \"-\") == 0) ? stdin :\n    fopen(hashfilename, \"r\");",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "if (!hashfp) {\n  fprintf(stderr, \"cannot open file '%s'\\n\", hashfilename);\n  return shaStateError;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "if (info) Message_Digest = malloc(okmlen);\nmemset(&sha, '\\343', sizeof(sha)); /* force bad data into struct */\nmemset(&hmac, '\\343', sizeof(hmac));\nmemset(&hkdf, '\\343', sizeof(hkdf));\nerr = info ? hkdfReset(&hkdf, hashes[hashno].whichSha,\n                           keyarray, keylen) :\n      keyarray ? hmacReset(&hmac, hashes[hashno].whichSha,\n                           keyarray, keylen) :\n                 USHAReset(&sha, hashes[hashno].whichSha);\nif (err != shaSuccess) {\n  fprintf(stderr, \"hashfile(): %sReset Error %d.\\n\",\n          info ? \"hkdf\" : keyarray ? \"hmac\" : \"sha\", err);\n  return err;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "if (skipSpaces)\n  while ((c = getc(hashfp)) != EOF) {\n    if (!isspace(c)) {\n      cc = (unsigned char)c;\n      err = info ? hkdfInput(&hkdf, &cc, 1) :",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "            keyarray ? hmacInput(&hmac, &cc, 1) :\n                       USHAInput(&sha, &cc, 1);\n      if (err != shaSuccess) {\n        fprintf(stderr, \"hashfile(): %sInput Error %d.\\n\",\n                info ? \"hkdf\" : keyarray ? \"hmac\" : \"sha\", err);\n        if (hashfp != stdin) fclose(hashfp);\n        return err;\n      }\n    }\n  }\nelse\n  while ((nread = fread(buf, 1, sizeof(buf), hashfp)) > 0) {\n    err = info ? hkdfInput(&hkdf, buf, nread) :\n          keyarray ? hmacInput(&hmac, buf, nread) :\n                     USHAInput(&sha, buf, nread);\n    if (err != shaSuccess) {\n      fprintf(stderr, \"hashfile(): %s Error %d.\\n\",\n              info ? \"hkdf\" : keyarray ? \"hmacInput\" :\n              \"shaInput\", err);\n      if (hashfp != stdin) fclose(hashfp);\n      return err;\n    }\n  }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "if (bitcount > 0)\n  err = info ? hkdfFinalBits(&hkdf, bits, bitcount) :\n        keyarray ? hmacFinalBits(&hmac, bits, bitcount) :\n                 USHAFinalBits(&sha, bits, bitcount);\nif (err != shaSuccess) {\n  fprintf(stderr, \"hashfile(): %s Error %d.\\n\",\n          info ? \"hkdf\" : keyarray ? \"hmacFinalBits\" :\n          \"shaFinalBits\", err);\n  if (hashfp != stdin) fclose(hashfp);\n  return err;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "err = info ? hkdfResult(&hkdf, 0, info, infolen,\n                        Message_Digest, okmlen) :\n      keyarray ? hmacResult(&hmac, Message_Digest) :\n                 USHAResult(&sha, Message_Digest);\nif (err != shaSuccess) {\n  fprintf(stderr, \"hashfile(): %s Error %d.\\n\",\n          info ? \"hkdf\" : keyarray ? \"hmacResult\" :\n          \"shaResult\", err);\n  if (hashfp != stdin) fclose(hashfp);\n  return err;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "printResult(Message_Digest, info ? okmlen : hashsize, hashes[hashno].name, \"file\", hashfilename, resultarray, printResults, printPassFail);",
      "zh-CHS": "printResult（消息摘要，信息？okmlen:hashsize，哈希[hashno]。名称，“文件”，hashfilename，resultarray，printResults，printPassFail）；"
    },
    {
      "indent": 0,
      "text": "  if (hashfp != stdin) fclose(hashfp);\n  if (info) free(Message_Digest);\n  return err;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * Exercise a hash series of functions through multiple permutations.\n * The input is an initial seed.  That seed is replicated 3 times.\n * For 1000 rounds, the previous three results are used as the input.\n * This result is then checked, and used to seed the next cycle.\n * If the result is known, it is in resultarrays in uppercase hex.\n */\nvoid randomtest(int hashno, const char *seed, int hashsize,\n    const char **resultarrays, int randomcount,\n    int printResults, int printPassFail)\n{\n  int i, j; char buf[20];\n  unsigned char SEED[USHAMaxHashSize], MD[1003][USHAMaxHashSize];",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "/* INPUT: Seed - A random seed n bits long */\nmemcpy(SEED, seed, hashsize);\nif (printResults == PRINTTEXT) {\n  printf(\"%s random test seed= '\", hashes[hashno].name);\n  printxstr(seed, hashsize);\n  printf(\"'\\n\");\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "for (j = 0; j < randomcount; j++) {\n  /* MD0 = MD1 = MD2 = Seed; */\n  memcpy(MD[0], SEED, hashsize);\n  memcpy(MD[1], SEED, hashsize);\n  memcpy(MD[2], SEED, hashsize);\n  for (i=3; i<1003; i++) {\n    /* Mi = MDi-3 || MDi-2 || MDi-1; */\n    USHAContext Mi;\n    memset(&Mi, '\\343', sizeof(Mi)); /* force bad data into struct */\n    USHAReset(&Mi, hashes[hashno].whichSha);\n    USHAInput(&Mi, MD[i-3], hashsize);\n    USHAInput(&Mi, MD[i-2], hashsize);\n    USHAInput(&Mi, MD[i-1], hashsize);\n    /* MDi = SHA(Mi); */\n    USHAResult(&Mi, MD[i]);\n  }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "/* MDj = Seed = MDi; */\nmemcpy(SEED, MD[i-1], hashsize);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "    /* OUTPUT: MDj */\n    sprintf(buf, \"%d\", j);\n    printResult(SEED, hashsize, hashes[hashno].name, \"random test\",\n      buf, resultarrays ? resultarrays[j] : 0, printResults,\n      (j < RANDOMCOUNT) ? printPassFail : 0);\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * Look up a hash name.\n */\nint findhash(const char *argv0, const char *opt)\n{\n  int i;\n  const char *names[HASHCOUNT][2] = {\n    { \"0\", \"sha1\" }, { \"1\", \"sha224\" }, { \"2\", \"sha256\" },\n    { \"3\", \"sha384\" }, { \"4\", \"sha512\" }\n  };\n  for (i = 0; i < HASHCOUNT; i++)\n    if ((strcmp(opt, names[i][0]) == 0) ||\n        (scasecmp(opt, names[i][1]) == 0))\n      return i;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "  fprintf(stderr, \"%s: Unknown hash name: '%s'\\n\", argv0, opt);\n  usage(argv0);\n  return 0;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * Run some tests that should invoke errors.\n */\nvoid testErrors(int hashnolow, int hashnohigh, int printResults,\n    int printPassFail)\n{\n  USHAContext usha;\n  uint8_t Message_Digest[USHAMaxHashSize];\n  int hashno, err;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "for (hashno = hashnolow; hashno <= hashnohigh; hashno++) {\n  memset(&usha, '\\343', sizeof(usha)); /* force bad data */\n  USHAReset(&usha, hashno);\n  USHAResult(&usha, Message_Digest);\n  err = USHAInput(&usha, (const unsigned char *)\"foo\", 3);\n  if (printResults == PRINTTEXT)\n    printf (\"\\nError %d. Should be %d.\\n\", err, shaStateError);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "if ((printPassFail == PRINTPASSFAIL) ||\n    ((printPassFail == PRINTFAIL) && (err != shaStateError)))\n  printf(\"%s se: %s\\n\", hashes[hashno].name,\n    (err == shaStateError) ? \"PASSED\" : \"FAILED\");",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "err = USHAFinalBits(&usha, 0x80, 3);\nif (printResults == PRINTTEXT)\n  printf (\"\\nError %d. Should be %d.\\n\", err, shaStateError);\nif ((printPassFail == PRINTPASSFAIL) ||\n    ((printPassFail == PRINTFAIL) && (err != shaStateError)))\n  printf(\"%s se: %s\\n\", hashes[hashno].name,\n    (err == shaStateError) ? \"PASSED\" : \"FAILED\");",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "err = USHAReset(0, hashes[hashno].whichSha);\nif (printResults == PRINTTEXT)\n   printf(\"\\nError %d. Should be %d.\\n\", err, shaNull);\nif ((printPassFail == PRINTPASSFAIL) ||\n    ((printPassFail == PRINTFAIL) && (err != shaNull)))\n   printf(\"%s usha null: %s\\n\", hashes[hashno].name,\n    (err == shaNull) ? \"PASSED\" : \"FAILED\");",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "    switch (hashno) {\n      case SHA1: err = SHA1Reset(0); break;\n      case SHA224: err = SHA224Reset(0); break;\n      case SHA256: err = SHA256Reset(0); break;\n      case SHA384: err = SHA384Reset(0); break;\n      case SHA512: err = SHA512Reset(0); break;\n    }\n    if (printResults == PRINTTEXT)\n       printf(\"\\nError %d. Should be %d.\\n\", err, shaNull);\n    if ((printPassFail == PRINTPASSFAIL) ||\n        ((printPassFail == PRINTFAIL) && (err != shaNull)))\n       printf(\"%s sha null: %s\\n\", hashes[hashno].name,\n        (err == shaNull) ? \"PASSED\" : \"FAILED\");\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/* replace a hex string in place with its value */\nint unhexStr(char *hexstr)\n{\n  char *o = hexstr;\n  int len = 0, nibble1 = 0, nibble2 = 0;\n  if (!hexstr) return 0;\n  for ( ; *hexstr; hexstr++) {\n    if (isalpha((int)(unsigned char)(*hexstr))) {\n      nibble1 = tolower((int)(unsigned char)(*hexstr)) - 'a' + 10;\n    } else if (isdigit((int)(unsigned char)(*hexstr))) {\n      nibble1 = *hexstr - '0';",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "    } else {\n      printf(\"\\nError: bad hex character '%c'\\n\", *hexstr);\n    }\n    if (!*++hexstr) break;\n    if (isalpha((int)(unsigned char)(*hexstr))) {\n      nibble2 = tolower((int)(unsigned char)(*hexstr)) - 'a' + 10;\n    } else if (isdigit((int)(unsigned char)(*hexstr))) {\n      nibble2 = *hexstr - '0';\n    } else {\n      printf(\"\\nError: bad hex character '%c'\\n\", *hexstr);\n    }\n    *o++ = (char)((nibble1 << 4) | nibble2);\n    len++;\n  }\n  return len;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "int main(int argc, char **argv)\n{\n  int i, err;\n  int loopno, loopnohigh = 1;\n  int hashno, hashnolow = 0, hashnohigh = HASHCOUNT - 1;\n  int testno, testnolow = 0, testnohigh;\n  int ntestnohigh = 0;\n  int printResults = PRINTTEXT;\n  int printPassFail = 1;\n  int checkErrors = 0;\n  char *hashstr = 0;\n  int hashlen = 0;\n  const char *resultstr = 0;\n  char *randomseedstr = 0;\n  int runHmacTests = 0;\n  int runHkdfTests = 0;\n  char *hmacKey = 0;\n  int hmaclen = 0;\n  char *info = 0;\n  int infolen = 0, okmlen = 0;\n  int randomcount = RANDOMCOUNT;\n  const char *hashfilename = 0;\n  const char *hashFilename = 0;\n  int extrabits = 0, numberExtrabits = 0;\n  int strIsHex = 0;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "if ('A' != 0x41) {\n  fprintf(stderr, \"%s: these tests require ASCII\\n\", argv[0]);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "while ((i = getopt(argc, argv,",
      "zh-CHS": "而（（i=getopt）（argc，argv，"
    },
    {
      "indent": 4,
      "text": "                  \"6b:B:def:F:h:i:Hk:l:L:mpPr:R:s:S:t:wxX\")) != -1)\nswitch (i) {\n  case 'b': extrabits = strtol(optarg, 0, 0); break;\n  case 'B': numberExtrabits = atoi(optarg); break;\n  case 'd': runHkdfTests = 1; break;\n  case 'e': checkErrors = 1; break;\n  case 'f': hashfilename = optarg; break;\n  case 'F': hashFilename = optarg; break;\n  case 'h': hashnolow = hashnohigh = findhash(argv[0], optarg);\n    break;\n  case 'H': strIsHex = 1; break;\n  case 'i': info = optarg; infolen = strlen(optarg); break;\n  case 'k': hmacKey = optarg; hmaclen = strlen(optarg); break;\n  case 'l': loopnohigh = atoi(optarg); break;\n  case 'L': okmlen = strtol(optarg, 0, 0); break;\n  case 'm': runHmacTests = 1; break;\n  case 'P': printPassFail = 0; break;\n  case 'p': printResults = PRINTNONE; break;\n  case 'R': randomcount = atoi(optarg); break;\n  case 'r': randomseedstr = optarg; break;\n  case 's': hashstr = optarg; hashlen = strlen(hashstr); break;\n  case 'S': resultstr = optarg; break;\n  case 't': testnolow = ntestnohigh = atoi(optarg) - 1; break;\n  case 'w': printResults = PRINTRAW; break;\n  case 'x': printResults = PRINTHEX; break;\n  case 'X': printPassFail = 2; break;\n  case '6': printResults = PRINTBASE64; break;\n  default: usage(argv[0]);\n  }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "if (strIsHex) {\n  hashlen = unhexStr(hashstr);\n  unhexStr(randomseedstr);\n  hmaclen = unhexStr(hmacKey);\n  infolen = unhexStr(info);\n}\ntestnohigh = (ntestnohigh != 0) ? ntestnohigh:\n             runHmacTests ? (HMACTESTCOUNT-1) :\n             runHkdfTests ? (HKDFTESTCOUNT-1) :\n             (TESTCOUNT-1);\nif ((testnolow < 0) ||\n    (testnohigh >= (runHmacTests ? HMACTESTCOUNT : TESTCOUNT)) ||\n    (hashnolow < 0) || (hashnohigh >= HASHCOUNT) ||\n    (hashstr && (testnolow == testnohigh)) ||\n    (randomcount < 0) ||\n    (resultstr && (!hashstr && !hashfilename && !hashFilename)) ||\n    ((runHmacTests || hmacKey) && randomseedstr) ||\n    (hashfilename && hashFilename) ||",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "  (info && ((infolen <= 0) || (okmlen <= 0))) ||\n  (info && !hmacKey))\nusage(argv[0]);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "/*\n *  Perform SHA/HMAC tests\n */\nfor (hashno = hashnolow; hashno <= hashnohigh; ++hashno) {\n  if (printResults == PRINTTEXT)\n    printf(\"Hash %s\\n\", hashes[hashno].name);\n  err = shaSuccess;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "for (loopno = 1; (loopno <= loopnohigh) && (err == shaSuccess);\n     ++loopno) {\n  if (hashstr)\n    err = hash(0, loopno, hashno, hashstr, hashlen, 1,\n      numberExtrabits, extrabits, (const unsigned char *)hmacKey,\n      hmaclen, (const uint8_t *) info, infolen, okmlen, resultstr,\n      hashes[hashno].hashsize, printResults, printPassFail);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "else if (randomseedstr) randomtest(hashno, randomseedstr, hashes[hashno].hashsize, 0, randomcount, printResults, printPassFail);",
      "zh-CHS": "else if（randomsedstr）randomtest（hashno，randomsedstr，hashs[hashno].hashsize，0，randomcount，printfresults，printPassFail）；"
    },
    {
      "indent": 6,
      "text": "else if (hashfilename) err = hashfile(hashno, hashfilename, extrabits, numberExtrabits, 0, (const unsigned char *)hmacKey, hmaclen, (const uint8_t *) info, infolen, okmlen, resultstr, hashes[hashno].hashsize, printResults, printPassFail);",
      "zh-CHS": "else if（hashfilename）err=hashfile（hashno，hashfilename，extrabits，numberxtrabits，0，（const unsigned char*）hmacKey，hmaclen，（const uint8_t*）info，infolen，okmlen，resultstr，hashs[hashno]。hashsize，printfresults，printPassFail）；"
    },
    {
      "indent": 6,
      "text": "else if (hashFilename) err = hashfile(hashno, hashFilename, extrabits, numberExtrabits, 1, (const unsigned char *)hmacKey, hmaclen, (const uint8_t *) info, infolen, okmlen, resultstr, hashes[hashno].hashsize, printResults, printPassFail);",
      "zh-CHS": "else if（hashFilename）err=hashfile（hashno，hashFilename，extrabits，numberxtrabits，1，（const unsigned char*）hmacKey，hmaclen，（const uint8_t*）info，infolen，okmlen，resultstr，hashs[hashno]。hashsize，printfresults，printPassFail）；"
    },
    {
      "indent": 6,
      "text": "else /* standard tests */ {\n  for (testno = testnolow;\n       (testno <= testnohigh) && (err == shaSuccess); ++testno) {\n    if (runHmacTests) {\n      err = hash(testno, loopno, hashno,\n                 hmachashes[testno].dataarray[hashno] ?\n                 hmachashes[testno].dataarray[hashno] :\n                 hmachashes[testno].dataarray[1] ?",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "                     hmachashes[testno].dataarray[1] :\n                     hmachashes[testno].dataarray[0],\n                     hmachashes[testno].datalength[hashno] ?\n                     hmachashes[testno].datalength[hashno] :\n                     hmachashes[testno].datalength[1] ?\n                     hmachashes[testno].datalength[1] :\n                     hmachashes[testno].datalength[0],\n                     1, 0, 0,\n                     (const unsigned char *)(\n                      hmachashes[testno].keyarray[hashno] ?\n                      hmachashes[testno].keyarray[hashno] :\n                      hmachashes[testno].keyarray[1] ?\n                      hmachashes[testno].keyarray[1] :\n                      hmachashes[testno].keyarray[0]),\n                     hmachashes[testno].keylength[hashno] ?\n                     hmachashes[testno].keylength[hashno] :\n                     hmachashes[testno].keylength[1] ?\n                     hmachashes[testno].keylength[1] :\n                     hmachashes[testno].keylength[0],\n                     0, 0, 0,\n                     hmachashes[testno].resultarray[hashno],\n                     hmachashes[testno].resultlength[hashno],\n                     printResults, printPassFail);\n        } else if (runHkdfTests) {\n          err = hashHkdf(testno, loopno, hashno,\n                     printResults, printPassFail);\n        } else { /* sha tests */\n          err = hash(testno, loopno, hashno,\n                     hashes[hashno].tests[testno].testarray,\n                     hashes[hashno].tests[testno].length,\n                     hashes[hashno].tests[testno].repeatcount,\n                     hashes[hashno].tests[testno].numberExtrabits,\n                     hashes[hashno].tests[testno].extrabits,\n                     0, 0, 0, 0, 0,\n                     hashes[hashno].tests[testno].resultarray,\n                     hashes[hashno].hashsize,\n                     printResults, printPassFail);\n        }\n      }\n      if (!runHmacTests && !runHkdfTests) {\n        randomtest(hashno, hashes[hashno].randomtest,\n          hashes[hashno].hashsize, hashes[hashno].randomresults,\n          RANDOMCOUNT, printResults, printPassFail);\n      }\n    }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "/* Test some error returns */\nif (checkErrors) {\n  testErrors(hashnolow, hashnohigh, printResults, printPassFail);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "  return 0;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "/*\n * Compare two strings, case independently.\n * Equivalent to strcasecmp() found on some systems.\n */\nint scasecmp(const char *s1, const char *s2)\n{\n  for (;;) {\n    char u1 = tolower((int)(unsigned char)(*s1++));\n    char u2 = tolower((int)(unsigned char)(*s2++));\n    if (u1 != u2)\n      return u1 - u2;\n    if (u1 == '\\0')\n      return 0;\n   }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "9. Security Considerations",
      "section_title": true,
      "zh-CHS": "9. 安全考虑"
    },
    {
      "indent": 3,
      "text": "This document is intended to provide convenient open source access by the Internet community to the United States of America Federal Information Processing Standard Secure Hash Algorithms (SHAs) [FIPS 180-2], HMACs based thereon, and HKDF. No independent assertion of the security of these functions by the authors for any particular use is intended.",
      "zh-CHS": "本文件旨在为互联网社区提供方便的开源访问，以访问美国联邦信息处理标准安全哈希算法（SHAs）[FIPS 180-2]，基于此的HMAC和HKDF。作者无意为任何特定用途独立断言这些函数的安全性。"
    },
    {
      "indent": 3,
      "text": "See [RFC6194] for a discussion of SHA-1 Security Considerations.",
      "zh-CHS": "有关SHA-1安全注意事项的讨论，请参见[RFC6194]。"
    },
    {
      "indent": 0,
      "text": "10. Acknowledgements",
      "section_title": true,
      "zh-CHS": "10. 致谢"
    },
    {
      "indent": 3,
      "text": "Thanks for the corrections to [RFC4634] that were provided by Alfred Hoenes and Jan Andres and to Alfred's comments on the document hereof.",
      "zh-CHS": "感谢Alfred Hoenes和Jan Andres对[RFC4634]的更正以及Alfred对本文件的评论。"
    },
    {
      "indent": 3,
      "text": "Also to the following in alphabetic order, whose comments lead to improvements in the document: James Carlson, Russ Housley, Tero Kivinen, Juergen Quittek, and Sean Turner.",
      "zh-CHS": "以下是按字母顺序排列的，他们的评论导致了文件的改进：詹姆斯·卡尔森、罗斯·霍斯利、泰罗·基维宁、尤尔根·奎特克和肖恩·特纳。"
    },
    {
      "indent": 0,
      "text": "11. References",
      "section_title": true,
      "zh-CHS": "11. 工具书类"
    },
    {
      "indent": 0,
      "text": "11.1. Normative References",
      "section_title": true,
      "zh-CHS": "11.1. 规范性引用文件"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "zh-CHS": "[RFC2104]Krawczyk，H.，Bellare，M.，和R.Canetti，“HMAC：用于消息认证的键控哈希”，RFC 2104，1997年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC5869] Krawczyk, H. and P. Eronen, \"HMAC-based Extract-and-Expand Key Derivation Function (HKDF)\", RFC 5869, May 2010.",
      "zh-CHS": "[RFC5869]Krawczyk，H.和P.Eronen，“基于HMAC的提取和扩展密钥派生函数（HKDF）”，RFC 5869，2010年5月。"
    },
    {
      "indent": 3,
      "text": "[SHS] \"Secure Hash Standard\", United States of American, National Institute of Science and Technology, Federal Information Processing Standard (FIPS) 180-3, http://csrc.nist.gov/publications/fips/fips180-3/ fips180-3_final.pdf.",
      "zh-CHS": "[SHS]“安全哈希标准”，美利坚合众国，国家科学技术研究所，联邦信息处理标准（FIPS）180-3，http://csrc.nist.gov/publications/fips/fips180-3/ fips180-3_final.pdf。"
    },
    {
      "indent": 3,
      "text": "[US-ASCII] ANSI, \"USA Standard Code for Information Interchange\", X3.4, American National Standards Institute: New York, 1968.",
      "zh-CHS": "[US-ASCII]ANSI，“美国信息交换标准代码”，X3.4，美国国家标准协会：纽约，1968年。"
    },
    {
      "indent": 0,
      "text": "11.2. Informative References",
      "section_title": true,
      "zh-CHS": "11.2. 资料性引用"
    },
    {
      "indent": 3,
      "text": "[RFC3174] Eastlake 3rd, D. and P. Jones, \"US Secure Hash Algorithm 1 (SHA1)\", RFC 3174, September 2001.",
      "zh-CHS": "[RFC3174]Eastlake 3rd，D.和P.Jones，“美国安全哈希算法1（SHA1）”，RFC 3174，2001年9月。"
    },
    {
      "indent": 14,
      "text": "[RFC3874] Housley, R., \"A 224-bit One-way Hash Function: SHA-224\", RFC 3874, September 2004.",
      "zh-CHS": "[RFC3874]Housley，R.，“224位单向散列函数：SHA-224”，RFC 3874，2004年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC4055] Schaad, J., Kaliski, B., and R. Housley, \"Additional Algorithms and Identifiers for RSA Cryptography for use in the Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 4055, June 2005.",
      "zh-CHS": "[RFC4055]Schaad，J.，Kaliski，B.，和R.Housley，“Internet X.509公钥基础设施证书和证书撤销列表（CRL）配置文件中使用的RSA加密的其他算法和标识符”，RFC 4055，2005年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake 3rd, D., Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, June 2005.",
      "zh-CHS": "[RFC4086]Eastlake 3rd，D.，Schiller，J.，和S.Crocker，“安全的随机性要求”，BCP 106，RFC 4086，2005年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC4634] Eastlake 3rd, D. and T. Hansen, \"US Secure Hash Algorithms (SHA and HMAC-SHA)\", RFC 4634, July 2006.",
      "zh-CHS": "[RFC4634]Eastlake 3rd，D.和T.Hansen，“美国安全哈希算法（SHA和HMAC-SHA）”，RFC 46342006年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC6194] Polk, T., Chen, L., Turner, S., and P. Hoffman, \"Security Considerations for the SHA-0 and SHA-1 Message-Digest Algorithms\", RFC 6194, March 2011.",
      "zh-CHS": "[RFC6194]Polk，T.，Chen，L.，Turner，S.，和P.Hoffman，“SHA-0和SHA-1消息摘要算法的安全考虑”，RFC 61942011年3月。"
    },
    {
      "indent": 3,
      "text": "[SHAVS] \"The Secure Hash Algorithm Validation System (SHAVS)\", http://csrc.nist.gov/groups/STM/cavp/documents/shs/ SHAVS.pdf, July 2004.",
      "zh-CHS": "[SHAVS]“安全哈希算法验证系统（SHAVS）”，http://csrc.nist.gov/groups/STM/cavp/documents/shs/ SHAVS.pdf，2004年7月。"
    },
    {
      "indent": 0,
      "text": "Appendix: Changes from RFC 4634",
      "zh-CHS": "附录：RFC 4634的变更"
    },
    {
      "indent": 3,
      "text": "The following changes were made to RFC 4634 to produce this document:",
      "zh-CHS": "为编制本文件，对RFC 4634进行了以下更改："
    },
    {
      "indent": 3,
      "text": "1. Add code for HKDF and brief text about HKDF with pointer to [RFC5869].",
      "zh-CHS": "1. 添加HKDF代码和有关HKDF的简短文本，指针指向[RFC5869]。"
    },
    {
      "indent": 3,
      "text": "2. Fix numerous errata filed against [RFC4634] as included below. Note that in no case did the old code return an incorrect hash value.",
      "zh-CHS": "2. 修复针对[RFC4634]提交的大量勘误表，如下所示。请注意，旧代码在任何情况下都不会返回错误的哈希值。"
    },
    {
      "indent": 6,
      "text": "2.a. Correct some of the error return values which has erroneously been \"shaNull\" to the correct \"shaInputTooLong\" error.",
      "zh-CHS": "2.a。将一些错误返回值“shaNull”更正为正确的“shainputtolong”错误。"
    },
    {
      "indent": 6,
      "text": "2.b. Update comments and variable names within the code for consistency and clarity and other editorial changes.",
      "zh-CHS": "2.b。更新代码中的注释和变量名称，以保持一致性和清晰性，并进行其他编辑性更改。"
    },
    {
      "indent": 6,
      "text": "2.c. The previous code for SHA-384 and SHA-512 would stop after 2^93 bytes (2^96 bits). The fixed code handles up to 2^125 bytes (2^128 bits).",
      "zh-CHS": "2.c。SHA-384和SHA-512的先前代码将在2^93字节（2^96位）后停止。固定代码最多可处理2^125字节（2^128位）。"
    },
    {
      "indent": 6,
      "text": "2.d. Add additional error checking including a run time check in the test driver to detect attempts to run the test driver after compilation using some other character set instead of [US-ASCII].",
      "zh-CHS": "2.d。添加额外的错误检查，包括测试驱动程序中的运行时检查，以检测编译后使用其他字符集而不是[US-ASCII]运行测试驱动程序的尝试。"
    },
    {
      "indent": 3,
      "text": "3. Update boilerplate, remove special license in [RFC4634] as new boilerplate mandates simplified BSD license.",
      "zh-CHS": "3. 更新样板文件，删除[RFC4634]中的特殊许可证，因为新样板文件要求简化BSD许可证。"
    },
    {
      "indent": 3,
      "text": "4. Replace MIT version of getopt with new code to satisfy IETF incoming and outgoing license restrictions.",
      "zh-CHS": "4. 用新代码替换MIT版本的getopt，以满足IETF传入和传出许可证限制。"
    },
    {
      "indent": 3,
      "text": "5. Add references to [RFC6194].",
      "zh-CHS": "5. 添加对[RFC6194]的引用。"
    },
    {
      "indent": 3,
      "text": "6. Other assorted editorial improvements.",
      "zh-CHS": "6. 其他各种各样的编辑改进。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "zh-CHS": "作者地址"
    },
    {
      "indent": 3,
      "text": "Donald Eastlake Huawei 155 Beaver Street Milford, MA 01757 USA",
      "zh-CHS": "美国马萨诸塞州米尔福德海狸街155号唐纳德东湖华为01757"
    },
    {
      "indent": 3,
      "text": "Telephone:   +1-508-333-2270\nEMail:       d3e3e3@gmail.com",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Tony Hansen AT&T Laboratories 200 Laurel Ave. Middletown, NJ 07748 USA",
      "zh-CHS": "美国新泽西州米德尔顿劳雷尔大道200号托尼·汉森AT&T实验室，邮编：07748"
    },
    {
      "indent": 3,
      "text": "Telephone:   +1-732-420-8934\nEMail:       tony+shs@maillennium.att.com",
      "raw": true,
      "zh-CHS": " "
    }
  ]
}