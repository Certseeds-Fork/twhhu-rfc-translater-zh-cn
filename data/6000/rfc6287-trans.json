{
  "title": {
    "text": "RFC 6287: OCRA: OATH Challenge-Response Algorithm",
    "zh-CHS": "RFC 6287"
  },
  "number": 6287,
  "created_at": "2021-11-05 22:10:43.436657+08:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                        D. M'Raihi\nRequest for Comments: 6287                                Verisign, Inc.\nCategory: Informational                                        J. Rydell\nISSN: 2070-1721                                           Portwise, Inc.\n                                                                S. Bajaj\n                                                          Symantec Corp.\n                                                              S. Machani\n                                                        Diversinet Corp.\n                                                             D. Naccache\n                                                Ecole Normale Superieure\n                                                               June 2011",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 16,
      "text": "OCRA: OATH Challenge-Response Algorithm",
      "zh-CHS": "OCRA：誓言挑战响应算法"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "zh-CHS": "摘要"
    },
    {
      "indent": 3,
      "text": "This document describes an algorithm for challenge-response authentication developed by the Initiative for Open Authentication (OATH). The specified mechanisms leverage the HMAC-based One-Time Password (HOTP) algorithm and offer one-way and mutual authentication, and electronic signature capabilities.",
      "zh-CHS": "本文档描述了由开放式身份验证计划（SWORD）开发的质询-响应身份验证算法。指定的机制利用基于HMAC的一次性密码（HOTP）算法，并提供单向和相互身份验证以及电子签名功能。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "zh-CHS": "关于下段备忘"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "zh-CHS": "本文件不是互联网标准跟踪规范；它是为了提供信息而发布的。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "zh-CHS": "本文件是互联网工程任务组（IETF）的产品。它代表了IETF社区的共识。它已经接受了公众审查，并已被互联网工程指导小组（IESG）批准出版。并非IESG批准的所有文件都适用于任何级别的互联网标准；见RFC 5741第2节。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6287.",
      "zh-CHS": "有关本文件当前状态、任何勘误表以及如何提供反馈的信息，请访问http://www.rfc-editor.org/info/rfc6287."
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "zh-CHS": "版权公告"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2011 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "zh-CHS": "版权所有（c）2011 IETF信托基金和确定为文件作者的人员。版权所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents",
      "zh-CHS": "本文件受BCP 78和IETF信托有关IETF文件的法律规定的约束(http://trustee.ietf.org/license-info)自本文件出版之日起生效。请审阅这些文件"
    },
    {
      "indent": 3,
      "text": "carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "zh-CHS": "请仔细阅读，因为他们描述了您对本文件的权利和限制。从本文件中提取的代码组件必须包括信托法律条款第4.e节中所述的简化BSD许可证文本，并提供简化BSD许可证中所述的无担保。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "zh-CHS": "目录"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n2. Notation and Terminology ........................................3\n3. Algorithm Requirements ..........................................3\n4. OCRA Background .................................................4\n   4.1. HOTP Algorithm .............................................4\n5. Definition of OCRA ..............................................5\n   5.1. DataInput Parameters .......................................5\n   5.2. CryptoFunction .............................................7\n6. The OCRASuite ...................................................8\n   6.1. Algorithm ..................................................9\n   6.2. CryptoFunction .............................................9\n   6.3. DataInput ..................................................9\n   6.4. OCRASuite Examples ........................................10\n7. Algorithm Modes for Authentication .............................10\n   7.1. One-Way Challenge-Response ................................11\n   7.2. Mutual Challenge-Response .................................12\n   7.3. Algorithm Modes for Signature .............................13\n        7.3.1. Plain Signature ....................................13\n        7.3.2. Signature with Server Authentication ...............14\n8. Security Considerations ........................................16\n   8.1. Security Analysis of OCRA .................................16\n   8.2. Implementation Considerations .............................17\n9. Conclusion .....................................................18\n10. Acknowledgements ..............................................18\n11. References ....................................................19\n   11.1. Normative References .....................................19\n   11.2. Informative References ...................................19\nAppendix A. Reference Implementation ..............................20\nAppendix B. Test Vectors Generation ...............................26\nAppendix C. Test Vectors ..........................................33\n  C.1. One-Way Challenge Response .................................34\n  C.2. Mutual Challenge-Response ..................................35\n  C.3. Plain Signature ............................................37",
      "raw": true,
      "toc": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "zh-CHS": "1. 介绍"
    },
    {
      "indent": 3,
      "text": "The Initiative for Open Authentication (OATH) [OATH] has identified several use cases and scenarios that require an asynchronous variant to accommodate users who do not want to maintain a synchronized authentication system. A commonly accepted method for this is to use a challenge-response scheme.",
      "zh-CHS": "开放身份验证计划（OREAN）[OREAN]已经确定了几个用例和场景，这些用例和场景需要一个异步变体来适应不希望维护同步身份验证系统的用户。对此，一种普遍接受的方法是使用质询-响应方案。"
    },
    {
      "indent": 3,
      "text": "Such a challenge-response mode of authentication is widely adopted in the industry. Several vendors already offer software applications and hardware devices implementing challenge-response -- but each of those uses vendor-specific proprietary algorithms. For the benefits of users there is a need for a standardized challenge-response algorithm that allows multi-sourcing of token purchases and validation systems to facilitate the democratization of strong authentication.",
      "zh-CHS": "这种认证的质询-响应模式在业界被广泛采用。一些供应商已经提供了实现质询响应的软件应用程序和硬件设备，但它们都使用特定于供应商的专有算法。为了用户的利益，需要一种标准化的质询-响应算法，该算法允许代币购买和验证系统的多来源，以促进强身份验证的民主化。"
    },
    {
      "indent": 3,
      "text": "Additionally, this specification describes the means to create symmetric key-based short 'electronic signatures'. Such signatures are variants of challenge-response mode where the data to be signed becomes the challenge or is used to derive the challenge. Note that the term 'electronic signature' and 'signature' are used interchangeably in this document.",
      "zh-CHS": "此外，本规范描述了创建基于对称密钥的短“电子签名”的方法。此类签名是质询响应模式的变体，其中待签名的数据成为质询或用于导出质询。请注意，“电子签名”和“签名”在本文件中互换使用。"
    },
    {
      "indent": 0,
      "text": "2. Notation and Terminology",
      "section_title": true,
      "zh-CHS": "2. 符号和术语"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "zh-CHS": "本文件中的关键词“必须”、“不得”、“必需”、“应”、“不应”、“应”、“不应”、“建议”、“可”和“可选”应按照[RFC2119]中所述进行解释。"
    },
    {
      "indent": 0,
      "text": "3. Algorithm Requirements",
      "section_title": true,
      "zh-CHS": "3. 算法要求"
    },
    {
      "indent": 3,
      "text": "This section presents the main requirements that drove this algorithm design. A lot of emphasis was placed on flexibility and usability, under the constraints and specificity of the HMAC-based One-Time Password (HOTP) algorithm [RFC4226] and hardware token capabilities.",
      "zh-CHS": "本节介绍了驱动该算法设计的主要需求。在基于HMAC的一次性密码（HOTP）算法[RFC4226]和硬件令牌功能的约束和特殊性下，人们非常重视灵活性和可用性。"
    },
    {
      "indent": 3,
      "text": "R1 - The algorithm MUST support challenge-response-based authentication.",
      "zh-CHS": "R1-算法必须支持基于质询-响应的身份验证。"
    },
    {
      "indent": 3,
      "text": "R2 - The algorithm MUST be capable of supporting symmetric key-based short electronic signatures. Essentially, this is a variation of challenge-response where the challenge is derived from the data that needs to be signed.",
      "zh-CHS": "R2-算法必须能够支持基于对称密钥的短电子签名。本质上，这是质询响应的一种变体，质询来自需要签名的数据。"
    },
    {
      "indent": 3,
      "text": "R3 - The algorithm MUST be capable of supporting server authentication, whereby the user can verify that he/she is talking to a trusted server.",
      "zh-CHS": "R3-该算法必须能够支持服务器身份验证，用户可以通过该算法验证他/她是否正在与受信任的服务器通信。"
    },
    {
      "indent": 3,
      "text": "R4 - The algorithm SHOULD use HOTP [RFC4226] as a key building block.",
      "zh-CHS": "R4-算法应使用HOTP[RFC4226]作为关键构建块。"
    },
    {
      "indent": 3,
      "text": "R5 - The length and format of the input challenge SHOULD be configurable.",
      "zh-CHS": "R5-输入质询的长度和格式应该是可配置的。"
    },
    {
      "indent": 3,
      "text": "R6 - The output length and format of the generated response SHOULD be configurable.",
      "zh-CHS": "R6-生成响应的输出长度和格式应该是可配置的。"
    },
    {
      "indent": 3,
      "text": "R7 - The challenge MAY be generated with integrity checking (e.g., parity bits). This will allow tokens with pin pads to perform simple error checking when the user enters the challenge value into a token.",
      "zh-CHS": "R7-质询可通过完整性检查（例如奇偶校验位）生成。这将允许带有pin焊盘的令牌在用户将质询值输入令牌时执行简单的错误检查。"
    },
    {
      "indent": 3,
      "text": "R8 - There MUST be a unique secret (key) for each token/soft token that is shared between the token and the authentication server. The keys MUST be randomly generated or derived using a key derivation algorithm.",
      "zh-CHS": "R8-令牌和身份验证服务器之间共享的每个令牌/软令牌必须具有唯一的密钥。必须使用密钥派生算法随机生成或派生密钥。"
    },
    {
      "indent": 3,
      "text": "R9 - The algorithm MAY enable additional data attributes such as a timestamp or session information to be included in the computation. These data inputs MAY be used individually or all together.",
      "zh-CHS": "R9-该算法可使额外的数据属性（如时间戳或会话信息）包括在计算中。这些数据输入可以单独使用，也可以一起使用。"
    },
    {
      "indent": 0,
      "text": "4. OCRA Background",
      "section_title": true,
      "zh-CHS": "4. OCRA背景"
    },
    {
      "indent": 3,
      "text": "OATH introduced the HOTP algorithm as a first open, freely available building block towards strengthening authentication for end-users in a variety of applications. One-time passwords are very efficient at solving specific security issues thanks to the dynamic nature of OTP computations.",
      "zh-CHS": "誓言将HOTP算法作为第一个开放的、免费可用的构建块引入，以加强各种应用中最终用户的身份验证。由于OTP计算的动态特性，一次性密码在解决特定安全问题时非常有效。"
    },
    {
      "indent": 3,
      "text": "After carefully analyzing different use cases, OATH came to the conclusion that providing for extensions to the HOTP algorithms was important. A very natural extension is to introduce a challenge mode for computing HOTP values based on random questions. Equally beneficial is being able to perform mutual authentication between two parties, or short-signature computation for authenticating transaction to improve the security of e-commerce applications.",
      "zh-CHS": "在仔细分析了不同的用例之后，誓言得出结论，为HOTP算法提供扩展非常重要。一个非常自然的扩展是引入一种基于随机问题计算HOTP值的挑战模式。同样有益的是，能够在双方之间执行相互认证，或短签名计算来认证交易，以提高电子商务应用程序的安全性。"
    },
    {
      "indent": 0,
      "text": "4.1. HOTP Algorithm",
      "section_title": true,
      "zh-CHS": "4.1. HOTP算法"
    },
    {
      "indent": 3,
      "text": "The HOTP algorithm, as defined in [RFC4226], is based on an increasing counter value and a static symmetric key known only to the prover and verifier parties.",
      "zh-CHS": "[RFC4226]中定义的HOTP算法基于递增的计数器值和仅验证方和验证方已知的静态对称密钥。"
    },
    {
      "indent": 3,
      "text": "As a reminder:\n                  HOTP(K,C) = Truncate(HMAC-SHA1(K,C))",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "where Truncate represents the function that converts an HMAC-SHA-1 value into an HOTP value.",
      "zh-CHS": "其中Truncate表示将HMAC-SHA-1值转换为HOTP值的函数。"
    },
    {
      "indent": 3,
      "text": "We refer the reader to [RFC4226] for the full description and further details on the rationale and security analysis of HOTP.",
      "zh-CHS": "我们请读者参考[RFC4226]以获取有关HOTP的基本原理和安全性分析的完整描述和进一步详细信息。"
    },
    {
      "indent": 3,
      "text": "The present document describes the different variants based on similar constructions as HOTP.",
      "zh-CHS": "本文件描述了基于与HOTP类似结构的不同变体。"
    },
    {
      "indent": 0,
      "text": "5. Definition of OCRA",
      "section_title": true,
      "zh-CHS": "5. OCRA的定义"
    },
    {
      "indent": 3,
      "text": "The OATH Challenge-Response Algorithm (OCRA) is a generalization of HOTP with variable data inputs not solely based on an incremented counter and secret key values.",
      "zh-CHS": "誓言挑战响应算法（OCRA）是HOTP的推广，具有可变数据输入，而不仅仅基于递增计数器和密钥值。"
    },
    {
      "indent": 3,
      "text": "The definition of OCRA requires a cryptographic function, a key K and a set of DataInput parameters. This section first formally introduces OCRA and then introduces the definitions and default values recommended for all parameters.",
      "zh-CHS": "OCRA的定义需要加密函数、密钥K和一组数据输入参数。本节首先正式介绍OCRA，然后介绍为所有参数推荐的定义和默认值。"
    },
    {
      "indent": 3,
      "text": "In a nutshell, OCRA = CryptoFunction(K, DataInput)",
      "zh-CHS": "简而言之，OCRA=加密函数（K，数据输入）"
    },
    {
      "indent": 3,
      "text": "where:",
      "zh-CHS": "哪里："
    },
    {
      "indent": 3,
      "text": "o K: a shared secret key known to both parties",
      "zh-CHS": "o K：双方都知道的共享密钥"
    },
    {
      "indent": 3,
      "text": "o DataInput: a structure that contains the concatenation of the various input data values defined in details in section 5.1",
      "zh-CHS": "o DataInput：包含第5.1节中详细定义的各种输入数据值的串联的结构"
    },
    {
      "indent": 3,
      "text": "o CryptoFunction: this is the function performing the OCRA computation from the secret key K and the DataInput material;",
      "zh-CHS": "o CryptoFunction：这是从密钥K和数据输入材料执行OCRA计算的函数；"
    },
    {
      "indent": 3,
      "text": "CryptoFunction is described in details in Section 5.2",
      "zh-CHS": "第5.2节详细描述了加密函数"
    },
    {
      "indent": 0,
      "text": "5.1. DataInput Parameters",
      "section_title": true,
      "zh-CHS": "5.1. 数据输入参数"
    },
    {
      "indent": 3,
      "text": "This structure is the concatenation over byte array of the OCRASuite value as defined in section 6 with the different parameters used in the computation, save for the secret key K.",
      "zh-CHS": "该结构是第6节中定义的OCRASuite值的字节数组与计算中使用的不同参数的串联，除了密钥K。"
    },
    {
      "indent": 3,
      "text": "DataInput = {OCRASuite | 00 | C | Q | P | S | T} where:",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "o OCRASuite is a value representing the suite of operations to compute an OCRA response",
      "zh-CHS": "o OCRASuite是一个值，表示计算OCRA响应的一系列操作"
    },
    {
      "indent": 3,
      "text": "o 00 is a byte value used as a separator",
      "zh-CHS": "o 00是用作分隔符的字节值"
    },
    {
      "indent": 3,
      "text": "o C is an unsigned 8-byte counter value processed high-order bit first, and MUST be synchronized between all parties; It loops around from \"{Hex}0\" to \"{Hex}FFFFFFFFFFFFFFFF\" and then starts over at \"{Hex}0\". Note that 'C' is optional for all OCRA modes described in this document.",
      "zh-CHS": "o C是一个无符号8字节计数器值，首先处理高阶位，并且必须在各方之间同步；它从“{Hex}0”循环到“{Hex}ffffffffffff”，然后从“{Hex}0”开始。请注意，对于本文档中描述的所有OCRA模式，“C”是可选的。"
    },
    {
      "indent": 3,
      "text": "o Q, mandatory, is a 128-byte list of (concatenated) challenge question(s) generated by the parties; if Q is less than 128 bytes, then it should be padded with zeroes to the right",
      "zh-CHS": "o Q、 必填项，是由双方生成的（串联）质询问题的128字节列表；如果Q小于128字节，则应在右侧用零填充"
    },
    {
      "indent": 3,
      "text": "o P is a hash (SHA-1 [RFC3174], SHA-256 and SHA-512 [SHA2] are supported) value of PIN/password that is known to all parties during the execution of the algorithm; the length of P will depend on the hash function that is used",
      "zh-CHS": "o P是算法执行期间各方已知的PIN/密码的散列值（支持SHA-1[RFC3174]、SHA-256和SHA-512[SHA2]）；P的长度取决于所使用的哈希函数"
    },
    {
      "indent": 3,
      "text": "o S is a UTF-8 [RFC3629] encoded string of length up to 512 bytes that contains information about the current session; the length of S is defined in the OCRASuite string",
      "zh-CHS": "o S是一个UTF-8[RFC3629]编码字符串，长度为512字节，包含有关当前会话的信息；S的长度在OCRASuite字符串中定义"
    },
    {
      "indent": 3,
      "text": "o T is an 8-byte unsigned integer in big-endian order (i.e., network byte order) representing the number of time-steps (seconds, minutes, hours, or days depending on the specified granularity) since midnight UTC of January 1, 1970 [UT]. More specifically, if the OCRA computation includes a timestamp T, you should first convert your current local time to UTC time; you can then derive the UTC time in the proper format (i.e., seconds, minutes, hours, or days elapsed from epoch time); the size of the time-step is specified in the OCRASuite string as described in Section 6.3",
      "zh-CHS": "o T是一个8字节的无符号整数，以大端顺序（即网络字节顺序）表示自1970年1月1日[UT]UTC午夜以来的时间步数（秒、分钟、小时或天，具体取决于指定的粒度）。更具体地说，如果OCRA计算包括时间戳T，则应首先将当前本地时间转换为UTC时间；然后，您可以以适当的格式导出UTC时间（即从历元时间起经过的秒、分钟、小时或天）；时间步长的大小在OCRASuite字符串中指定，如第6.3节所述"
    },
    {
      "indent": 3,
      "text": "When computing a response, the concatenation order is always the following:",
      "zh-CHS": "计算响应时，连接顺序始终如下所示："
    },
    {
      "indent": 36,
      "text": "C |",
      "zh-CHS": "C|"
    },
    {
      "indent": 16,
      "text": "OTHER-PARTY-GENERATED-CHALLENGE-QUESTION |",
      "zh-CHS": "对方提出的挑战问题|"
    },
    {
      "indent": 20,
      "text": "YOUR-GENERATED-CHALLENGE-QUESTION |",
      "zh-CHS": "你的问题|"
    },
    {
      "indent": 33,
      "text": "P| S | T",
      "zh-CHS": "P | S | T"
    },
    {
      "indent": 3,
      "text": "If a value is empty (i.e., a certain input is not used in the computation) then the value is simply not represented in the string.",
      "zh-CHS": "如果某个值为空（即，计算中未使用某个输入），则该值不在字符串中表示。"
    },
    {
      "indent": 3,
      "text": "The counter on the token or client MUST be incremented every time a new computation is requested by the user. The server's counter value MUST only be incremented after a successful OCRA authentication.",
      "zh-CHS": "每次用户请求新计算时，令牌或客户端上的计数器都必须递增。只有在成功进行OCRA身份验证后，服务器的计数器值才能增加。"
    },
    {
      "indent": 0,
      "text": "5.2. CryptoFunction",
      "section_title": true,
      "zh-CHS": "5.2. 加密函数"
    },
    {
      "indent": 3,
      "text": "The default CryptoFunction is HOTP-SHA1-6, i.e., the default mode of computation for OCRA is HOTP with the default 6-digit dynamic truncation and a combination of DataInput values as the message to compute the HMAC-SHA1 digest.",
      "zh-CHS": "默认的加密函数是HOTP-SHA1-6，即OCRA的默认计算模式是HOTP，默认的6位动态截断和数据输入值的组合作为计算HMAC-SHA1摘要的消息。"
    },
    {
      "indent": 3,
      "text": "We denote t as the length in decimal digits of the truncation output. For instance, if t = 6, then the output of the truncation is a 6-digit (decimal) value.",
      "zh-CHS": "我们将t表示为截断输出的十进制数长度。例如，如果t=6，则截断的输出为6位（十进制）值。"
    },
    {
      "indent": 3,
      "text": "We define the HOTP family of functions as an extension to HOTP:",
      "zh-CHS": "我们将HOTP函数族定义为HOTP的扩展："
    },
    {
      "indent": 3,
      "text": "1. HOTP-H-t: these are the different possible truncated versions of HOTP, using the dynamic truncation method for extracting an HOTP value from the HMAC output",
      "zh-CHS": "1. HOTP-H-t：这些是HOTP的不同可能的截断版本，使用动态截断方法从HMAC输出中提取HOTP值"
    },
    {
      "indent": 3,
      "text": "2. We will denote HOTP-H-t as the realization of an HOTP function that uses an HMAC function with the hash function H, and the dynamic truncation as described in [RFC4226] to extract a t-digit value",
      "zh-CHS": "2. 我们将HOTP-H-t表示为HOTP函数的实现，该函数使用HMAC函数和散列函数H，以及[RFC4226]中所述的动态截断来提取t位值"
    },
    {
      "indent": 3,
      "text": "3. t=0 means that no truncation is performed and the full HMAC value is used for authentication purposes",
      "zh-CHS": "3. t=0表示不执行截断，完整的HMAC值用于身份验证"
    },
    {
      "indent": 3,
      "text": "We list the following preferred modes of computation, where * denotes the default CryptoFunction:",
      "zh-CHS": "我们列出了以下首选计算模式，其中*表示默认加密函数："
    },
    {
      "indent": 3,
      "text": "o HOTP-SHA1-4: HOTP with SHA-1 as the hash function for HMAC and a dynamic truncation to a 4-digit value; this mode is not recommended in the general case, but it can be useful when a very short authentication code is needed by an application",
      "zh-CHS": "o HOTP-SHA1-4:HOTP使用SHA-1作为HMAC的哈希函数，并动态截断为4位值；一般情况下不建议使用此模式，但当应用程序需要非常短的身份验证代码时，此模式非常有用"
    },
    {
      "indent": 3,
      "text": "o HOTP-SHA1-6: HOTP with SHA-1 as the hash function for HMAC and a dynamic truncation to a 6-digit value",
      "zh-CHS": "o HOTP-SHA1-6:HOTP使用SHA-1作为HMAC的哈希函数，并动态截断为6位值"
    },
    {
      "indent": 3,
      "text": "o HOTP-SHA1-8: HOTP with SHA-1 as the hash function for HMAC and a dynamic truncation to an 8-digit value",
      "zh-CHS": "o HOTP-SHA1-8:HOTP使用SHA-1作为HMAC的哈希函数，并动态截断为8位值"
    },
    {
      "indent": 3,
      "text": "o HOTP-SHA256-6: HOTP with SHA-256 as the hash function for HMAC and a dynamic truncation to a 6-digit value",
      "zh-CHS": "o HOTP-SHA256-6:HOTP使用SHA-256作为HMAC的哈希函数，并动态截断为6位值"
    },
    {
      "indent": 3,
      "text": "o HOTP-SHA512-6: HOTP with SHA-512 as the hash function for HMAC and a dynamic truncation to a 6-digit value",
      "zh-CHS": "o HOTP-SHA512-6:HOTP使用SHA-512作为HMAC的哈希函数，并动态截断为6位值"
    },
    {
      "indent": 3,
      "text": "This table summarizes all possible values for the CryptoFunction:",
      "zh-CHS": "此表总结了CryptoFunction的所有可能值："
    },
    {
      "indent": 5,
      "text": "+---------------+--------------------+-------------------------+\n|      Name     | HMAC Function Used |  Size of Truncation (t) |\n+---------------+--------------------+-------------------------+\n|  HOTP-SHA1-t  |      HMAC-SHA1     | 0 (no truncation), 4-10 |\n| HOTP-SHA256-t |     HMAC-SHA256    | 0 (no truncation), 4-10 |\n| HOTP-SHA512-t |     HMAC-SHA512    | 0 (no truncation), 4-10 |\n+---------------+--------------------+-------------------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 23,
      "text": "Table 1: CryptoFunction Table",
      "zh-CHS": "表1：加密函数表"
    },
    {
      "indent": 0,
      "text": "6. The OCRASuite",
      "section_title": true,
      "zh-CHS": "6. 奥克拉苏岩"
    },
    {
      "indent": 3,
      "text": "An OCRASuite value is a text string that captures one mode of operation for OCRA, completely specifying the various options for that computation. An OCRASuite value is represented as follows:",
      "zh-CHS": "OCRASuite值是一个文本字符串，用于捕获OCRA的一种操作模式，完全指定该计算的各种选项。OCRASuite值表示如下："
    },
    {
      "indent": 18,
      "text": "<Algorithm>:<CryptoFunction>:<DataInput>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The OCRASuite value is the concatenation of three sub-components that are described below. Some example OCRASuite strings are described in Section 6.4.",
      "zh-CHS": "OCRASuite值是下面描述的三个子组件的串联。第6.4节介绍了一些OCRASuite字符串示例。"
    },
    {
      "indent": 3,
      "text": "The client and server need to agree on one or two values of OCRASuite. These values may be agreed upon at the time of token provisioning or, for more sophisticated client-server interactions, these values may be negotiated for every transaction.",
      "zh-CHS": "客户端和服务器需要就OCRASuite的一个或两个值达成一致。这些值可以在令牌供应时商定，或者，对于更复杂的客户机-服务器交互，可以为每个事务协商这些值。"
    },
    {
      "indent": 3,
      "text": "The provisioning of OCRA keys and related metadata such as OCRASuite is out of scope for this document. [RFC6030] specifies one key container specification that facilitates provisioning of such data between the client and the server.",
      "zh-CHS": "OCRA密钥和相关元数据（如OCRASuite）的提供超出了本文档的范围。[RFC6030]指定一个密钥容器规范，该规范有助于在客户端和服务器之间提供此类数据。"
    },
    {
      "indent": 3,
      "text": "Note that for Mutual Challenge-Response or Signature with Server Authentication modes, the client and server will need to agree on two values of OCRASuite -- one for server computation and another for client computation.",
      "zh-CHS": "请注意，对于具有服务器身份验证模式的相互质询响应或签名，客户端和服务器需要在OCRASuite的两个值上达成一致——一个用于服务器计算，另一个用于客户端计算。"
    },
    {
      "indent": 0,
      "text": "6.1. Algorithm",
      "section_title": true,
      "zh-CHS": "6.1. 算法"
    },
    {
      "indent": 3,
      "text": "Description: Indicates the version of OCRA.",
      "zh-CHS": "描述：表示OCRA的版本。"
    },
    {
      "indent": 3,
      "text": "Values: OCRA-v where v represents the version number (e.g., 1, 2). This document specifies version 1 of OCRA.",
      "zh-CHS": "值：OCRA-v，其中v表示版本号（例如，1、2）。本文件规定了OCRA的第1版。"
    },
    {
      "indent": 0,
      "text": "6.2. CryptoFunction",
      "section_title": true,
      "zh-CHS": "6.2. 加密函数"
    },
    {
      "indent": 3,
      "text": "Description: Indicates the function used to compute OCRA values",
      "zh-CHS": "描述：表示用于计算OCRA值的函数"
    },
    {
      "indent": 3,
      "text": "Values: Permitted values are described in Section 5.2.",
      "zh-CHS": "值：第5.2节描述了允许值。"
    },
    {
      "indent": 0,
      "text": "6.3. DataInput",
      "section_title": true,
      "zh-CHS": "6.3. 数据输入"
    },
    {
      "indent": 3,
      "text": "Description: This component of the OCRASuite string captures the list of valid inputs for that computation; [] indicates a value is optional:",
      "zh-CHS": "描述：OCRASuite字符串的此组件捕获该计算的有效输入列表；[]表示值是可选的："
    },
    {
      "indent": 3,
      "text": "[C] | QFxx | [PH | Snnn | TG] : Challenge-Response computation",
      "zh-CHS": "[C] | QFxx |[PH | Snnn | TG]：挑战响应计算"
    },
    {
      "indent": 3,
      "text": "[C] | QFxx | [PH | TG] : Plain Signature computation",
      "zh-CHS": "[C] | QFxx |[PH | TG]：普通签名计算"
    },
    {
      "indent": 3,
      "text": "Each input that is used for the computation is represented by a single letter (except Q), and they are separated by a hyphen.",
      "zh-CHS": "用于计算的每个输入都用一个字母表示（Q除外），并用连字符分隔。"
    },
    {
      "indent": 3,
      "text": "The input for challenge is further qualified by the formats supported by the client for challenge question(s). Supported values can be:",
      "zh-CHS": "质询输入由客户机支持的质询问题格式进一步限定。支持的值可以是："
    },
    {
      "indent": 17,
      "text": "+------------------+-------------------+\n|    Format (F)    | Up to Length (xx) |\n+------------------+-------------------+\n| A (alphanumeric) |       04-64       |\n|    N (numeric)   |       04-64       |\n|  H (hexadecimal) |       04-64       |\n+------------------+-------------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 22,
      "text": "Table 2: Challenge Format Table",
      "zh-CHS": "表2：挑战格式表"
    },
    {
      "indent": 3,
      "text": "The default challenge format is N08, numeric and up to 8 digits.",
      "zh-CHS": "默认质询格式为N08，数字，最多8位。"
    },
    {
      "indent": 3,
      "text": "The input for P is further qualified by the hash function used for the PIN/password. Supported values for hash function can be:",
      "zh-CHS": "P的输入由用于PIN/密码的哈希函数进一步限定。哈希函数支持的值可以是："
    },
    {
      "indent": 3,
      "text": "Hash function (H) - SHA1, SHA256, SHA512.",
      "zh-CHS": "散列函数（H）-SHA1、SHA256、SH512。"
    },
    {
      "indent": 3,
      "text": "The default hash function for P is SHA1.",
      "zh-CHS": "P的默认哈希函数是SHA1。"
    },
    {
      "indent": 3,
      "text": "The input for S is further qualified by the length of the session data in bytes. The client and server could agree to any length but the typical values are:",
      "zh-CHS": "会话数据的长度（以字节为单位）进一步限定S的输入。客户机和服务器可以同意任何长度，但典型值为："
    },
    {
      "indent": 3,
      "text": "Length (nnn) - 064, 128, 256, and 512.",
      "zh-CHS": "长度（nnn）-064、128、256和512。"
    },
    {
      "indent": 3,
      "text": "The default length is 064 bytes.",
      "zh-CHS": "默认长度为064字节。"
    },
    {
      "indent": 3,
      "text": "The input for timestamps is further qualified by G, size of the time-step. G can be specified in number of seconds, minutes, or hours:",
      "zh-CHS": "时间戳的输入进一步由时间步长的大小G限定。G可以以秒、分钟或小时为单位指定："
    },
    {
      "indent": 11,
      "text": "+--------------------+------------------------------+\n| Time-Step Size (G) |           Examples           |\n+--------------------+------------------------------+\n|       [1-59]S      | number of seconds, e.g., 20S |\n|       [1-59]M      |  number of minutes, e.g., 5M |\n|       [0-48]H      |  number of hours, e.g., 24H  |\n+--------------------+------------------------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 23,
      "text": "Table 3: Time-step Size Table",
      "zh-CHS": "表3：时间步长表"
    },
    {
      "indent": 3,
      "text": "Default value for G is 1M, i.e., time-step size is one minute and the T represents the number of minutes since epoch time [UT].",
      "zh-CHS": "G的默认值为1M，即时间步长为1分钟，T表示自历元时间[UT]以来的分钟数。"
    },
    {
      "indent": 0,
      "text": "6.4. OCRASuite Examples",
      "section_title": true,
      "zh-CHS": "6.4. 奥克拉苏岩实例"
    },
    {
      "indent": 3,
      "text": "Here are some examples of OCRASuite strings:",
      "zh-CHS": "以下是OCRASuite字符串的一些示例："
    },
    {
      "indent": 3,
      "text": "o \"OCRA-1:HOTP-SHA512-8:C-QN08-PSHA1\" means version 1 of OCRA with HMAC-SHA512 function, truncated to an 8-digit value, using the counter, a random challenge, and a SHA1 digest of the PIN/password as parameters. It also indicates that the client supports only numeric challenge up to 8 digits in length",
      "zh-CHS": "o “OCRA-1:HOTP-SHA512-8:C-QN08-PSHA1”指具有HMAC-SHA512功能的OCRA版本1，使用计数器、随机质询和PIN/密码的SHA1摘要作为参数，将其截断为8位数值。它还表示客户端仅支持长度不超过8位的数字质询"
    },
    {
      "indent": 3,
      "text": "o \"OCRA-1:HOTP-SHA256-6:QA10-T1M\" means version 1 of OCRA with HMAC-SHA256 function, truncated to a 6-digit value, using a random alphanumeric challenge up to 10 characters in length and a timestamp in number of minutes since epoch time",
      "zh-CHS": "o “OCRA-1:HOTP-SHA256-6:QA10-T1M”是指具有HMAC-SHA256功能的OCRA第1版，使用随机字母数字挑战，长度不超过10个字符，时间戳自历元时间起以分钟为单位，截断为6位数值"
    },
    {
      "indent": 3,
      "text": "o \"OCRA-1:HOTP-SHA1-4:QH8-S512\" means version 1 of OCRA with HMAC-SHA1 function, truncated to a 4-digit value, using a random hexadecimal challenge up to 8 nibbles and a session value of 512 bytes",
      "zh-CHS": "o “OCRA-1:HOTP-SHA1-4:QH8-S512”指带有HMAC-SHA1函数的OCRA版本1，使用随机十六进制质询（最多8个半字节）和512字节的会话值，将其截断为4位值"
    },
    {
      "indent": 0,
      "text": "7. Algorithm Modes for Authentication",
      "section_title": true,
      "zh-CHS": "7. 身份验证的算法模式"
    },
    {
      "indent": 3,
      "text": "This section describes the typical modes in which the above defined computation can be used for authentication.",
      "zh-CHS": "本节描述了使用上述定义的计算进行身份验证的典型模式。"
    },
    {
      "indent": 0,
      "text": "7.1. One-Way Challenge-Response",
      "section_title": true,
      "zh-CHS": "7.1. 单向挑战响应"
    },
    {
      "indent": 3,
      "text": "A challenge-response is a security mechanism in which the verifier presents a question (challenge) to the prover, who must provide a valid answer (response) to be authenticated.",
      "zh-CHS": "质询-响应是一种安全机制，其中验证者向验证者提出问题（质询），验证者必须提供有效答案（响应）以进行身份验证。"
    },
    {
      "indent": 3,
      "text": "To use this algorithm for a one-way challenge-response, the verifier will communicate a challenge value (typically randomly generated) to the prover. The prover will use the challenge in the computation as described above. The prover then communicates the response to the verifier to authenticate.",
      "zh-CHS": "为了将该算法用于单向质询响应，验证者将向验证者传达质询值（通常随机生成）。验证人将在上述计算中使用质询。验证方随后将响应传递给验证方进行验证。"
    },
    {
      "indent": 3,
      "text": "Therefore in this mode, the typical data inputs will be:",
      "zh-CHS": "因此，在此模式下，典型的数据输入为："
    },
    {
      "indent": 6,
      "text": "C - Counter, optional.",
      "zh-CHS": "C-计数器，可选。"
    },
    {
      "indent": 6,
      "text": "Q - Challenge question, mandatory, supplied by the verifier.",
      "zh-CHS": "Q-质询问题，强制性，由验证者提供。"
    },
    {
      "indent": 6,
      "text": "P - Hashed version of PIN/password, optional.",
      "zh-CHS": "P-PIN/密码的哈希版本，可选。"
    },
    {
      "indent": 6,
      "text": "S - Session information, optional.",
      "zh-CHS": "S-会话信息，可选。"
    },
    {
      "indent": 6,
      "text": "T - Timestamp, optional.",
      "zh-CHS": "T-时间戳，可选。"
    },
    {
      "indent": 3,
      "text": "The diagram below shows the message exchange between the client (prover) and the server (verifier) to complete a one-way challenge-response authentication.",
      "zh-CHS": "下图显示了客户端（验证程序）和服务器（验证程序）之间的消息交换，以完成单向质询-响应身份验证。"
    },
    {
      "indent": 3,
      "text": "It is assumed that the client and server have a pre-shared key K that is used for the computation.",
      "zh-CHS": "假定客户端和服务器具有用于计算的预共享密钥K。"
    },
    {
      "indent": 13,
      "text": " CLIENT                                   SERVER\n(PROVER)                                 VERIFIER)\n   |                                        |\n   |   Verifier sends challenge to prover   |\n   |   Challenge = Q                        |\n   |<---------------------------------------|\n   |                                        |\n   |   Prover Computes Response             |\n   |   R = OCRA(K, {[C] | Q | [P | S | T]}) |\n   |   Prover sends Response = R            |\n   |--------------------------------------->|\n   |                                        |\n   |  Verifier Validates Response           |\n   |  If Response is valid, Server sends OK |\n   |  If Response is not,  Server sends NOK |\n   |<---------------------------------------|\n   |                                        |",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.2. Mutual Challenge-Response",
      "section_title": true,
      "zh-CHS": "7.2. 相互挑战响应"
    },
    {
      "indent": 3,
      "text": "Mutual challenge-response is a variation of one-way challenge-response where both the client and server mutually authenticate each other.",
      "zh-CHS": "相互质询响应是单向质询响应的一种变体，其中客户端和服务器相互验证。"
    },
    {
      "indent": 3,
      "text": "To use this algorithm, the client will first send a random client-challenge to the server. The server computes the server-response and sends it to the client along with a server-challenge.",
      "zh-CHS": "要使用此算法，客户端将首先向服务器发送随机客户端质询。服务器计算服务器响应并将其与服务器质询一起发送给客户端。"
    },
    {
      "indent": 3,
      "text": "The client will first verify the server-response to be assured that it is talking to a valid server. It will then compute the client-response and send it to the server to authenticate. The server verifies the client-response to complete the two-way authentication process.",
      "zh-CHS": "客户机将首先验证服务器响应，以确保它正在与有效的服务器通信。然后，它将计算客户端响应并将其发送到服务器进行身份验证。服务器验证客户端响应以完成双向身份验证过程。"
    },
    {
      "indent": 3,
      "text": "In this mode there are two computations: client-response and server-response. There are two separate challenge questions, generated by both parties. We denote these challenge questions Q1 and Q2.",
      "zh-CHS": "在这种模式下，有两种计算：客户端响应和服务器响应。双方提出了两个独立的质疑问题。我们表示这些挑战问题Q1和Q2。"
    },
    {
      "indent": 3,
      "text": "Typical data inputs for server-response computation will be:",
      "zh-CHS": "服务器响应计算的典型数据输入为："
    },
    {
      "indent": 6,
      "text": "C - Counter, optional.",
      "zh-CHS": "C-计数器，可选。"
    },
    {
      "indent": 6,
      "text": "QC - Challenge question, mandatory, supplied by the client.",
      "zh-CHS": "QC-质询问题，强制性，由客户提供。"
    },
    {
      "indent": 6,
      "text": "QS - Challenge question, mandatory, supplied by the server.",
      "zh-CHS": "QS-质询问题，必填，由服务器提供。"
    },
    {
      "indent": 6,
      "text": "S - Session information, optional.",
      "zh-CHS": "S-会话信息，可选。"
    },
    {
      "indent": 6,
      "text": "T - Timestamp, optional.",
      "zh-CHS": "T-时间戳，可选。"
    },
    {
      "indent": 3,
      "text": "Typical data inputs for client-response computation will be:",
      "zh-CHS": "客户响应计算的典型数据输入为："
    },
    {
      "indent": 6,
      "text": "C - Counter, optional.",
      "zh-CHS": "C - Counter, optional.translate error, please retry"
    },
    {
      "indent": 6,
      "text": "QS - Challenge question, mandatory, supplied by the server.",
      "zh-CHS": "QS-质询问题，必填，由服务器提供。"
    },
    {
      "indent": 6,
      "text": "QC - Challenge question, mandatory, supplied by the client.",
      "zh-CHS": "QC-质询问题，强制性，由客户提供。"
    },
    {
      "indent": 6,
      "text": "P - Hashed version of PIN/password, optional.",
      "zh-CHS": "P-PIN/密码的哈希版本，可选。"
    },
    {
      "indent": 6,
      "text": "S - Session information, optional.",
      "zh-CHS": "S-会话信息，可选。"
    },
    {
      "indent": 6,
      "text": "T - Timestamp, optional.",
      "zh-CHS": "T-时间戳，可选。"
    },
    {
      "indent": 3,
      "text": "The following diagram shows the messages that are exchanged between the client and the server to complete a two-way mutual challenge-response authentication.",
      "zh-CHS": "下图显示了客户端和服务器之间为完成双向相互质询-响应身份验证而交换的消息。"
    },
    {
      "indent": 3,
      "text": "It is assumed that the client and server have a pre-shared key K (or pair of keys if using dual-key mode of computation) that is used for the computation.",
      "zh-CHS": "假定客户端和服务器具有用于计算的预共享密钥K（如果使用双密钥计算模式，则为一对密钥）。"
    },
    {
      "indent": 8,
      "text": " CLIENT                                             SERVER\n(PROVER)                                          (VERIFIER)\n   |                                                  |\n   |   1. Client sends client-challenge               |\n   |   QC = Client-challenge                          |\n   |------------------------------------------------->|\n   |                                                  |\n   |   2. Server computes server-response             |\n   |      and sends server-challenge                  |\n   |   RS = OCRA(K, [C] | QC | QS | [S | T])          |\n   |   QS = Server-challenge                          |\n   |   Response = RS, QS                              |\n   |<-------------------------------------------------|\n   |                                                  |\n   |   3. Client verifies server-response             |\n   |      and computes client-response                |\n   |   OCRA(K, [C] | QC | QS | [S | T]) != RS -> STOP |\n   |   RC = OCRA(K, [C] | QS | QC | [P | S | T])      |\n   |   Response = RC                                  |\n   |------------------------------------------------->|\n   |                                                  |\n   |   4. Server verifies client-response             |\n   |   OCRA(K, [C] | QS | QC | [P|S|T]) != RC -> STOP |\n   |   Response = OK                                  |\n   |<-------------------------------------------------|\n   |                                                  |",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.3. Algorithm Modes for Signature",
      "section_title": true,
      "zh-CHS": "7.3. 签名的算法模式"
    },
    {
      "indent": 3,
      "text": "In this section we describe the typical modes in which the above defined computation can be used for electronic signatures.",
      "zh-CHS": "在本节中，我们将描述上述定义的计算可用于电子签名的典型模式。"
    },
    {
      "indent": 0,
      "text": "7.3.1. Plain Signature",
      "section_title": true,
      "zh-CHS": "7.3.1. 普通签名"
    },
    {
      "indent": 3,
      "text": "To use this algorithm in plain signature mode, the server will communicate a signature-challenge value to the client (signer). The signature-challenge is either the data to be signed or derived from the data to be signed using a hash function, for example.",
      "zh-CHS": "要在普通签名模式下使用此算法，服务器将向客户端（签名者）传递签名质询值。例如，签名质询是要签名的数据或使用哈希函数从要签名的数据派生的数据。"
    },
    {
      "indent": 3,
      "text": "The client will use the signature-challenge in the computation as described above. The client then communicates the signature value (response) to the server to authenticate.",
      "zh-CHS": "客户端将在上述计算中使用签名质询。然后，客户端将签名值（响应）传递给服务器进行身份验证。"
    },
    {
      "indent": 3,
      "text": "Therefore in this mode, the data inputs will be:",
      "zh-CHS": "因此，在此模式下，数据输入将为："
    },
    {
      "indent": 6,
      "text": "C - Counter, optional.",
      "zh-CHS": "C-计数器，可选。"
    },
    {
      "indent": 6,
      "text": "QS - Signature-challenge, mandatory, supplied by the server.",
      "zh-CHS": "QS-签名质询，必填，由服务器提供。"
    },
    {
      "indent": 6,
      "text": "P - Hashed version of PIN/password, optional.",
      "zh-CHS": "P-PIN/密码的哈希版本，可选。"
    },
    {
      "indent": 6,
      "text": "T - Timestamp, optional.",
      "zh-CHS": "T-时间戳，可选。"
    },
    {
      "indent": 3,
      "text": "The picture below shows the messages that are exchanged between the client (prover) and the server (verifier) to complete a plain signature operation.",
      "zh-CHS": "下图显示了客户端（验证程序）和服务器（验证程序）之间交换的消息，以完成普通签名操作。"
    },
    {
      "indent": 3,
      "text": "It is assumed that the client and server have a pre-shared key K that is used for the computation.",
      "zh-CHS": "假定客户端和服务器具有用于计算的预共享密钥K。"
    },
    {
      "indent": 12,
      "text": " CLIENT                                     SERVER\n(PROVER)                                  (VERIFIER)\n   |                                           |\n   |    Verifier sends signature-challenge     |\n   |    Challenge = QS                         |\n   |<------------------------------------------|\n   |                                           |\n   |    Client Computes Response               |\n   |    SIGN = OCRA(K, [C] | QS | [P | T])     |\n   |    Response = SIGN                        |\n   |------------------------------------------>|\n   |                                           |\n   |    Verifier Validates Response            |\n   |    Response = OK                          |\n   |<------------------------------------------|\n   |                                           |",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.3.2. Signature with Server Authentication",
      "section_title": true,
      "zh-CHS": "7.3.2. 具有服务器身份验证的签名"
    },
    {
      "indent": 3,
      "text": "This mode is a variation of the plain signature mode where the client can first authenticate the server before generating a electronic signature.",
      "zh-CHS": "此模式是普通签名模式的一种变体，其中客户端可以在生成电子签名之前首先对服务器进行身份验证。"
    },
    {
      "indent": 3,
      "text": "To use this algorithm, the client will first send a random client-challenge to the server. The server computes the server-response and sends it to the client along with a signature-challenge.",
      "zh-CHS": "要使用此算法，客户端将首先向服务器发送随机客户端质询。服务器计算服务器响应并将其与签名质询一起发送给客户端。"
    },
    {
      "indent": 3,
      "text": "The client will first verify the server-response to authenticate that it is talking to a valid server. It will then compute the signature and send it to the server.",
      "zh-CHS": "客户端将首先验证服务器响应，以验证它是否正在与有效的服务器通信。然后，它将计算签名并将其发送到服务器。"
    },
    {
      "indent": 3,
      "text": "In this mode there are two computations: client-signature and server-response.",
      "zh-CHS": "In this mode there are two computations: client-signature and server-response.translate error, please retry"
    },
    {
      "indent": 3,
      "text": "Typical data inputs for server-response computation will be:",
      "zh-CHS": "服务器响应计算的典型数据输入为："
    },
    {
      "indent": 6,
      "text": "C - Counter, optional.",
      "zh-CHS": "C-计数器，可选。"
    },
    {
      "indent": 6,
      "text": "QC - Challenge question, mandatory, supplied by the client.",
      "zh-CHS": "QC-质询问题，强制性，由客户提供。"
    },
    {
      "indent": 6,
      "text": "QS - Signature-challenge, mandatory, supplied by the server.",
      "zh-CHS": "QS-签名质询，必填，由服务器提供。"
    },
    {
      "indent": 6,
      "text": "T - Timestamp, optional.",
      "zh-CHS": "T-时间戳，可选。"
    },
    {
      "indent": 3,
      "text": "Typical data inputs for client-signature computation will be:",
      "zh-CHS": "客户签名计算的典型数据输入为："
    },
    {
      "indent": 6,
      "text": "C - Counter, optional.",
      "zh-CHS": "C-计数器，可选。"
    },
    {
      "indent": 6,
      "text": "QC - Challenge question, mandatory, supplied by the client.",
      "zh-CHS": "QC-质询问题，强制性，由客户提供。"
    },
    {
      "indent": 6,
      "text": "QS - Signature-challenge, mandatory, supplied by the server.",
      "zh-CHS": "QS-签名质询，必填，由服务器提供。"
    },
    {
      "indent": 6,
      "text": "P - Hashed version of PIN/password, optional.",
      "zh-CHS": "P-PIN/密码的哈希版本，可选。"
    },
    {
      "indent": 6,
      "text": "T - Timestamp, optional.",
      "zh-CHS": "T-时间戳，可选。"
    },
    {
      "indent": 3,
      "text": "The diagram below shows the messages that are exchanged between the client and the server to complete a signature with server authentication transaction.",
      "zh-CHS": "下图显示了客户端和服务器之间交换的消息，以完成带有服务器身份验证的签名事务。"
    },
    {
      "indent": 3,
      "text": "It is assumed that the client and server have a pre-shared key K (or pair of keys if using dual-key mode of computation) that is used for the computation.",
      "zh-CHS": "假定客户端和服务器具有用于计算的预共享密钥K（如果使用双密钥计算模式，则为一对密钥）。"
    },
    {
      "indent": 7,
      "text": " CLIENT                                              SERVER\n(PROVER)                                            VERIFIER)\n   |                                                   |\n   |    1. Client sends client-challenge               |\n   |    QC = Client-challenge                          |\n   |-------------------------------------------------->|\n   |                                                   |\n   |    2. Server computes server-response             |\n   |       and sends signature-challenge               |\n   |    RS = OCRA(K, [C] | QC | QS | [T])              |\n   |    QS = signature-challenge                       |\n   |    Response = RS, QS                              |\n   |<--------------------------------------------------|\n   |                                                   |\n   |    3. Client verifies server-response             |\n   |       and computes signature                      |\n   |    OCRA(K, [C] | QC | QS | [T]) != RS -> STOP     |\n   |    SIGN = OCRA( K, [C] | QS | QC | [P | T])       |\n   |    Response = SIGN                                |\n   |-------------------------------------------------->|\n   |                                                   |\n   |    4. Server verifies Signature                   |\n   |    OCRA(K, [C] | QS | QC | [P|T]) != SIGN -> STOP |\n   |    Response = OK                                  |\n   |<--------------------------------------------------|\n   |                                                   |",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "zh-CHS": "8. 安全考虑"
    },
    {
      "indent": 3,
      "text": "Any algorithm is only as secure as the application and the authentication protocols that implement it. Therefore, this section discusses the critical security requirements that our choice of algorithm imposes on the authentication protocol and validation software.",
      "zh-CHS": "任何算法的安全性都取决于应用程序和实现它的身份验证协议。因此，本节讨论了我们选择的算法对身份验证协议和验证软件提出的关键安全要求。"
    },
    {
      "indent": 0,
      "text": "8.1. Security Analysis of OCRA",
      "section_title": true,
      "zh-CHS": "8.1. OCRA的安全性分析"
    },
    {
      "indent": 3,
      "text": "The security and strength of this algorithm depend on the properties of the underlying building block HOTP, which is a construction based on HMAC [RFC2104] using SHA-1 [RFC3174] (or SHA-256 or SHA-512 [SHA2]) as the hash function.",
      "zh-CHS": "该算法的安全性和强度取决于底层构建块HOTP的属性，它是基于HMAC[RFC2104]的构造，使用SHA-1[RFC3174]（或SHA-256或SHA-512[SHA2]）作为哈希函数。"
    },
    {
      "indent": 3,
      "text": "The conclusion of the security analysis detailed in [RFC4226] is that, for all practical purposes, the outputs of the dynamic truncation on distinct counter inputs are uniformly and independently distributed strings.",
      "zh-CHS": "[RFC4226]中详述的安全性分析的结论是，出于所有实际目的，不同计数器输入上的动态截断输出是均匀和独立分布的字符串。"
    },
    {
      "indent": 3,
      "text": "The analysis demonstrates that the best possible attack against the HOTP function is the brute force attack.",
      "zh-CHS": "分析表明，针对HOTP函数的最佳可能攻击是蛮力攻击。"
    },
    {
      "indent": 0,
      "text": "8.2. Implementation Considerations",
      "section_title": true,
      "zh-CHS": "8.2. 实施考虑"
    },
    {
      "indent": 3,
      "text": "IC1 - In the authentication mode, the client MUST support two-factor authentication, i.e., the communication and verification of something you know (secret code such as a password, pass phrase, PIN code, etc.) and something you have (token). The secret code is known only to the user and usually entered with the Response value for authentication purpose (two-factor authentication). Alternatively, instead of sending something you know to the server, the client may use a hash of the password or PIN code in the computation itself, thus implicitly enabling two-factor authentication.",
      "zh-CHS": "IC1-在身份验证模式中，客户端必须支持双因素身份验证，即对您知道的内容（密码、密码短语、PIN码等）和您拥有的内容（令牌）进行通信和验证。密码仅为用户所知，通常与响应值一起输入以用于身份验证（双因素身份验证）。或者，客户端可以在计算本身中使用密码或PIN码的散列，从而隐式地启用双因素身份验证，而不是向服务器发送您知道的内容。"
    },
    {
      "indent": 3,
      "text": "IC2 - Keys SHOULD be of the length of the CryptoFunction output to facilitate interoperability.",
      "zh-CHS": "IC2-密钥的长度应与CryptoFunction输出相同，以促进互操作性。"
    },
    {
      "indent": 3,
      "text": "IC3 - Keys SHOULD be chosen at random or using a cryptographically strong pseudo-random generator properly seeded with a random value. We RECOMMEND following the recommendations in [RFC4086] for all pseudo-random and random generations. The pseudo-random numbers used for generating the keys SHOULD successfully pass the randomness test specified in [CN].",
      "zh-CHS": "IC3-密钥应随机选择，或使用加密强伪随机生成器（使用随机值正确播种）。对于所有伪随机和随机生成，我们建议遵循[RFC4086]中的建议。用于生成密钥的伪随机数应成功通过[CN]中规定的随机性测试。"
    },
    {
      "indent": 3,
      "text": "IC4 - Challenge questions SHOULD be 20-byte values and MUST be at least t-byte values where t stands for the digit-length of the OCRA truncation output.",
      "zh-CHS": "IC4-挑战问题应为20字节值，且必须至少为t字节值，其中t代表OCRA截断输出的数字长度。"
    },
    {
      "indent": 3,
      "text": "IC5 - On the client side, the keys SHOULD be embedded in a tamper-resistant device or securely implemented in a software application. Additionally, by embedding the keys in a hardware device, you also have the advantage of improving the flexibility (mobility) of the authentication system.",
      "zh-CHS": "IC5-在客户端，密钥应嵌入防篡改设备或在软件应用程序中安全实现。此外，通过将密钥嵌入硬件设备，还可以提高身份验证系统的灵活性（移动性）。"
    },
    {
      "indent": 3,
      "text": "IC6 - All the communications SHOULD take place over a secure channel, e.g., SSL/TLS [RFC5246], IPsec connections.",
      "zh-CHS": "IC6-所有通信应通过安全通道进行，例如SSL/TLS[RFC5246]，IPsec连接。"
    },
    {
      "indent": 3,
      "text": "IC7 - OCRA, when used in mutual authentication mode or in signature with server authentication mode, MAY use dual-key mode -- i.e., there are two keys that are shared between the client and the server. One shared key is used to generate the server response on the server side and to verify it on the client side. The other key is used to create the response or signature on the client side and to verify it on the server side.",
      "zh-CHS": "IC7-OCRA在相互身份验证模式或服务器签名身份验证模式下使用时，可以使用双密钥模式——即，客户端和服务器之间共享两个密钥。一个共享密钥用于在服务器端生成服务器响应，并在客户端验证它。另一个密钥用于在客户端创建响应或签名，并在服务器端验证它。"
    },
    {
      "indent": 3,
      "text": "IC8 - We recommend that implementations MAY use the session information, S, as an additional input in the computation. For example, S could be the session identifier from the TLS session.",
      "zh-CHS": "IC8-我们建议实现可以使用会话信息S作为计算中的额外输入。例如，S可以是TLS会话中的会话标识符。"
    },
    {
      "indent": 3,
      "text": "This will mitigate against certain types of man-in-the-middle attacks. However, this will introduce the additional dependency that first of all the prover needs to have access to the session identifier to compute the response and the verifier will need access to the session identifier to verify the response. [RFC5056] contains a relevant discussion of using Channel Bindings to Secure Channels.",
      "zh-CHS": "这将缓解某些类型的中间人攻击。然而，这将引入额外的依赖性，首先验证者需要访问会话标识符来计算响应，而验证者需要访问会话标识符来验证响应。[RFC5056]包含使用通道绑定保护通道的相关讨论。"
    },
    {
      "indent": 3,
      "text": "IC9 - In the signature mode, whenever the counter or time (defined as optional elements) are not used in the computation, there might be a risk of replay attack and the implementers should carefully consider this issue in the light of their specific application requirements and security guidelines. The server SHOULD also provide whenever possible a mean for the client (if able) to verify the validity of the signature challenge.",
      "zh-CHS": "IC9-在签名模式中，每当计数器或时间（定义为可选元素）在计算中不使用时，可能存在重放攻击的风险，并且实施者应根据其特定的应用要求和安全准则仔细考虑此问题。服务器还应尽可能为客户端（如果能够）提供验证签名质询有效性的方法。"
    },
    {
      "indent": 3,
      "text": "IC10 - We also RECOMMEND storing the keys securely in the validation system, and more specifically, encrypting them using tamper-resistant hardware encryption and exposing them only when required: for example, the key is decrypted when needed to verify an OCRA response, and re-encrypted immediately to limit exposure in the RAM for a short period of time. The key store MUST be in a secure area, to avoid as much as possible direct attack on the validation system and secrets database. Particularly, access to the key material should be limited to programs and processes required by the validation system only.",
      "zh-CHS": "IC10-我们还建议将密钥安全地存储在验证系统中，更具体地说，使用防篡改硬件加密进行加密，并仅在需要时公开密钥：例如，在需要验证OCRA响应时解密密钥，并立即重新加密，以限制在RAM中的短时间暴露。密钥存储必须位于安全区域，以尽可能避免对验证系统和机密数据库的直接攻击。特别是，对关键材料的访问应仅限于验证系统所需的程序和过程。"
    },
    {
      "indent": 0,
      "text": "9. Conclusion",
      "section_title": true,
      "zh-CHS": "9. 结论"
    },
    {
      "indent": 3,
      "text": "This document introduced several variants of HOTP for challenge-response-based authentication and short signature-like computations.",
      "zh-CHS": "本文档介绍了几种用于基于质询-响应的身份验证和类似于短签名的计算的HOTP变体。"
    },
    {
      "indent": 3,
      "text": "The OCRASuite provides for an easy integration and support of different flavors within an authentication and validation system.",
      "zh-CHS": "OCRASuite在身份验证和验证系统中提供了对不同口味的轻松集成和支持。"
    },
    {
      "indent": 3,
      "text": "Finally, OCRA should enable mutual authentication both in connected and off-line modes, with the support of different response sizes and mode of operations.",
      "zh-CHS": "最后，OCRA应在连接和离线模式下支持相互认证，并支持不同的响应大小和操作模式。"
    },
    {
      "indent": 0,
      "text": "10. Acknowledgements",
      "section_title": true,
      "zh-CHS": "10. 致谢"
    },
    {
      "indent": 3,
      "text": "We would like to thank Jeff Burstein, Shuh Chang, Oanh Hoang, Philip Hoyer, Jon Martinsson, Frederik Mennes, Mingliang Pei, Jonathan Tuliani, Stu Vaeth, Enrique Rodriguez, and Robert Zuccherato for their comments and suggestions to improve this document.",
      "zh-CHS": "我们要感谢Jeff Burstein、Shuh Chang、Oanh Hoang、Philip Hoyer、Jon Martinsson、Frederik Mennes、Pei Mingliang、Jonathan Tuliani、Stu Vaeth、Enrique Rodriguez和Robert Zuccherato为改进本文件提出的意见和建议。"
    },
    {
      "indent": 0,
      "text": "11. References",
      "section_title": true,
      "zh-CHS": "11. 工具书类"
    },
    {
      "indent": 0,
      "text": "11.1. Normative References",
      "section_title": true,
      "zh-CHS": "11.1. 规范性引用文件"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "zh-CHS": "[RFC2104]Krawczyk，H.，Bellare，M.，和R.Canetti，“HMAC：用于消息认证的键控哈希”，RFC 2104，1997年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "zh-CHS": "[RFC2119]Bradner，S.，“RFC中用于表示需求水平的关键词”，BCP 14，RFC 2119，1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3174] Eastlake, D. and P. Jones, \"US Secure Hash Algorithm 1 (SHA1)\", RFC 3174, September 2001.",
      "zh-CHS": "[RFC3174]Eastlake，D.和P.Jones，“美国安全哈希算法1（SHA1）”，RFC 3174，2001年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, November 2003.",
      "zh-CHS": "[RFC3629]Yergeau，F.，“UTF-8，ISO 10646的转换格式”，STD 63，RFC 3629，2003年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake, D., Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, June 2005.",
      "zh-CHS": "[RFC4086]Eastlake，D.，Schiller，J.，和S.Crocker，“安全的随机性要求”，BCP 106，RFC 4086，2005年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC4226] M'Raihi, D., Bellare, M., Hoornaert, F., Naccache, D., and O. Ranen, \"HOTP: An HMAC-Based One-Time Password Algorithm\", RFC 4226, December 2005.",
      "zh-CHS": "[RFC4226]M'Raihi，D.，Bellare，M.，Hoornaert，F.，Naccache，D.，和O.Ranen，“HOTP：基于HMAC的一次性密码算法”，RFC 42262005年12月。"
    },
    {
      "indent": 3,
      "text": "[SHA2] NIST, \"FIPS PUB 180-3: Secure Hash Standard (SHS)\", October 2008, <http://csrc.nist.gov/publications/fips/ fips180-3/fips180-3_final.pdf>.",
      "zh-CHS": "[SHA2]NIST，“FIPS发布180-3：安全哈希标准（SHS）”，2008年10月<http://csrc.nist.gov/publications/fips/ fips180-3/fips180-3_final.pdf>。"
    },
    {
      "indent": 0,
      "text": "11.2. Informative References",
      "section_title": true,
      "zh-CHS": "11.2. 资料性引用"
    },
    {
      "indent": 3,
      "text": "[CN] Coron, J. and D. Naccache, \"An accurate evaluation of Maurer's universal test\", LNCS 1556, February 1999, <http: //www.gemplus.com/smart/rd/publications/pdf/CN99maur.pdf>.",
      "zh-CHS": "[CN]Coron，J.和D.Naccache，“Maurer万能试验的准确评估”，LNCS 15561999年2月，<http://www.gemplus.com/smart/rd/publications/pdf/CN99maur.pdf>。"
    },
    {
      "indent": 3,
      "text": "[OATH] Initiative for Open Authentication, \"OATH Vision\", <http://www.openauthentication.org/about>.",
      "zh-CHS": "[誓言]开放认证倡议，“誓言愿景”<http://www.openauthentication.org/about>."
    },
    {
      "indent": 3,
      "text": "[RFC5056] Williams, N., \"On the Use of Channel Bindings to Secure Channels\", RFC 5056, November 2007.",
      "zh-CHS": "[RFC5056]Williams，N.，“关于使用通道绑定保护通道”，RFC 5056，2007年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, August 2008.",
      "zh-CHS": "[RFC5246]Dierks，T.和E.Rescorla，“传输层安全（TLS）协议版本1.2”，RFC 5246，2008年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC6030] Hoyer, P., Pei, M., and S. Machani, \"Portable Symmetric Key Container (PSKC)\", RFC 6030, October 2010.",
      "zh-CHS": "[RFC6030]Hoyer，P.，Pei，M.和S.Machani，“便携式对称密钥容器（PSKC）”，RFC 603012010年10月。"
    },
    {
      "indent": 3,
      "text": "[UT] Wikipedia, \"Unix time\", <http://en.wikipedia.org/wiki/Unix_time>.",
      "zh-CHS": "[UT]维基百科，“Unix时代”<http://en.wikipedia.org/wiki/Unix_time>."
    },
    {
      "indent": 0,
      "text": "Appendix A. Reference Implementation",
      "section_title": true,
      "zh-CHS": "附录A.参考实施"
    },
    {
      "indent": 2,
      "text": "<CODE BEGINS>",
      "zh-CHS": "<代码开始>"
    },
    {
      "indent": 2,
      "text": "/**\n   Copyright (c) 2011 IETF Trust and the persons identified as\n   authors of the code. All rights reserved.",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": " Redistribution and use in source and binary forms, with or without modification, is permitted pursuant to, and subject to the license terms contained in, the Simplified BSD License set forth in Section 4.c of the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info). */",
      "zh-CHS": "根据IETF信托有关IETF文件的法律规定第4.c节规定的简化BSD许可证中包含的许可条款，允许以源代码和二进制格式重新分发和使用，无论是否修改(http://trustee.ietf.org/license-info). */"
    },
    {
      "indent": 2,
      "text": "import javax.crypto.Mac;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.math.BigInteger;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "/**\n * This an example implementation of OCRA.\n * Visit www.openauthentication.org for more information.\n *\n * @author Johan Rydell, PortWise\n */\npublic class OCRA {",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "private OCRA() {}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "/**\n * This method uses the JCE to provide the crypto\n * algorithm.\n * HMAC computes a Hashed Message Authentication Code with the\n * crypto hash algorithm as a parameter.\n *\n * @param crypto     the crypto algorithm (HmacSHA1, HmacSHA256,\n *                                   HmacSHA512)\n * @param keyBytes   the bytes to use for the HMAC key\n * @param text       the message or text to be authenticated.\n */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "private static byte[] hmac_sha1(String crypto,\n                 byte[] keyBytes, byte[] text){\n    Mac hmac = null;\n    try {\n        hmac = Mac.getInstance(crypto);\n        SecretKeySpec macKey =\n            new SecretKeySpec(keyBytes, \"RAW\");",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "        hmac.init(macKey);\n        return hmac.doFinal(text);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return null;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "private static final int[] DIGITS_POWER\n// 0 1  2   3    4     5      6       7        8\n= {1,10,100,1000,10000,100000,1000000,10000000,100000000 };",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "/**\n * This method converts HEX string to Byte[]\n *\n * @param hex   the HEX string\n *\n * @return      A byte array\n */\nprivate static byte[] hexStr2Bytes(String hex){\n    // Adding one byte to get the right conversion\n    // values starting with \"0\" can be converted\n    byte[] bArray = new BigInteger(\"10\" + hex,16).toByteArray();",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "    // Copy all the REAL bytes, not the \"first\"\n    byte[] ret = new byte[bArray.length - 1];\n    System.arraycopy(bArray, 1, ret, 0, ret.length);\n    return ret;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "/**\n * This method generates an OCRA HOTP value for the given\n * set of parameters.\n *\n * @param ocraSuite    the OCRA Suite\n * @param key          the shared secret, HEX encoded\n * @param counter      the counter that changes on a per use\n *                     basis, HEX encoded\n * @param question     the challenge question, HEX encoded\n * @param password     a password that can be used, HEX encoded\n * @param sessionInformation Static information that identifies\n *                     the current session, Hex encoded\n * @param timeStamp    a value that reflects a time\n *\n * @return A numeric String in base 10 that includes\n * {@link truncationDigits} digits",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": " */ static public String generateOCRA(String ocraSuite, String key, String counter, String question, String password, String sessionInformation, String timeStamp){",
      "zh-CHS": "*/静态公共字符串生成器CRA（字符串ocraSuite、字符串键、字符串计数器、字符串问题、字符串密码、字符串会话信息、字符串时间戳）{"
    },
    {
      "indent": 10,
      "text": "int codeDigits = 0;\nString crypto = \"\";\nString result = null;\nint ocraSuiteLength = (ocraSuite.getBytes()).length;\nint counterLength = 0;\nint questionLength = 0;\nint passwordLength = 0;\nint sessionInformationLength = 0;\nint timeStampLength = 0;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "// The OCRASuites components\nString CryptoFunction = ocraSuite.split(\":\")[1];\nString DataInput = ocraSuite.split(\":\")[2];",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "if(CryptoFunction.toLowerCase().indexOf(\"sha1\") > 1)\n    crypto = \"HmacSHA1\";\nif(CryptoFunction.toLowerCase().indexOf(\"sha256\") > 1)\n    crypto = \"HmacSHA256\";\nif(CryptoFunction.toLowerCase().indexOf(\"sha512\") > 1)\n    crypto = \"HmacSHA512\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "// How many digits should we return\ncodeDigits = Integer.decode(CryptoFunction.substring(\n        CryptoFunction.lastIndexOf(\"-\")+1));",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "// The size of the byte array message to be encrypted\n// Counter\nif(DataInput.toLowerCase().startsWith(\"c\")) {\n    // Fix the length of the HEX string\n    while(counter.length() < 16)\n        counter = \"0\" + counter;\n    counterLength=8;\n}\n// Question - always 128 bytes\nif(DataInput.toLowerCase().startsWith(\"q\") ||\n        (DataInput.toLowerCase().indexOf(\"-q\") >= 0)) {\n    while(question.length() < 256)\n        question = question + \"0\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "    questionLength=128;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "// Password - sha1\nif(DataInput.toLowerCase().indexOf(\"psha1\") > 1){\n    while(password.length() < 40)\n        password = \"0\" + password;\n    passwordLength=20;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "// Password - sha256\nif(DataInput.toLowerCase().indexOf(\"psha256\") > 1){\n    while(password.length() < 64)\n        password = \"0\" + password;\n    passwordLength=32;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "// Password - sha512\nif(DataInput.toLowerCase().indexOf(\"psha512\") > 1){\n    while(password.length() < 128)\n        password = \"0\" + password;\n    passwordLength=64;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "// sessionInformation - s064\nif(DataInput.toLowerCase().indexOf(\"s064\") > 1){\n    while(sessionInformation.length() < 128)\n        sessionInformation = \"0\" + sessionInformation;\n    sessionInformationLength=64;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "// sessionInformation - s128\nif(DataInput.toLowerCase().indexOf(\"s128\") > 1){\n    while(sessionInformation.length() < 256)\n        sessionInformation = \"0\" + sessionInformation;\n    sessionInformationLength=128;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "// sessionInformation - s256\nif(DataInput.toLowerCase().indexOf(\"s256\") > 1){\n    while(sessionInformation.length() < 512)\n        sessionInformation = \"0\" + sessionInformation;\n    sessionInformationLength=256;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "// sessionInformation - s512\nif(DataInput.toLowerCase().indexOf(\"s512\") > 1){\n    while(sessionInformation.length() < 1024)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "        sessionInformation = \"0\" + sessionInformation;\n    sessionInformationLength=512;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "// TimeStamp\nif(DataInput.toLowerCase().startsWith(\"t\") ||\n        (DataInput.toLowerCase().indexOf(\"-t\") > 1)){\n    while(timeStamp.length() < 16)\n        timeStamp = \"0\" + timeStamp;\n    timeStampLength=8;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "// Remember to add \"1\" for the \"00\" byte delimiter\nbyte[] msg = new byte[ocraSuiteLength +\n              counterLength +\n              questionLength +\n              passwordLength +\n              sessionInformationLength +\n              timeStampLength +\n              1];",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "// Put the bytes of \"ocraSuite\" parameters into the message\nbyte[] bArray = ocraSuite.getBytes();\nSystem.arraycopy(bArray, 0, msg, 0, bArray.length);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "// Delimiter\nmsg[bArray.length] = 0x00;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "// Put the bytes of \"Counter\" to the message\n// Input is HEX encoded\nif(counterLength > 0 ){\n    bArray = hexStr2Bytes(counter);\n    System.arraycopy(bArray, 0, msg, ocraSuiteLength + 1,\n            bArray.length);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "// Put the bytes of \"question\" to the message\n// Input is text encoded\nif(questionLength > 0 ){\n    bArray = hexStr2Bytes(question);\n    System.arraycopy(bArray, 0, msg, ocraSuiteLength + 1 +\n            counterLength, bArray.length);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "// Put the bytes of \"password\" to the message\n// Input is HEX encoded",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "if(passwordLength > 0){\n    bArray = hexStr2Bytes(password);\n    System.arraycopy(bArray, 0, msg, ocraSuiteLength + 1 +\n            counterLength +    questionLength, bArray.length);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "}",
      "zh-CHS": "}"
    },
    {
      "indent": 10,
      "text": "// Put the bytes of \"sessionInformation\" to the message\n// Input is text encoded\nif(sessionInformationLength > 0 ){\n    bArray = hexStr2Bytes(sessionInformation);\n    System.arraycopy(bArray, 0, msg, ocraSuiteLength + 1 +\n            counterLength +     questionLength +\n            passwordLength, bArray.length);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "// Put the bytes of \"time\" to the message\n// Input is text value of minutes\nif(timeStampLength > 0){\n    bArray = hexStr2Bytes(timeStamp);\n    System.arraycopy(bArray, 0, msg, ocraSuiteLength + 1 +\n            counterLength + questionLength +\n            passwordLength + sessionInformationLength,\n            bArray.length);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "bArray = hexStr2Bytes(key);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "byte[] hash = hmac_sha1(crypto, bArray, msg);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "// put selected bytes into result int\nint offset = hash[hash.length - 1] & 0xf;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "int binary =\n    ((hash[offset] & 0x7f) << 24) |\n    ((hash[offset + 1] & 0xff) << 16) |\n    ((hash[offset + 2] & 0xff) << 8) |\n    (hash[offset + 3] & 0xff);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "int otp = binary % DIGITS_POWER[codeDigits];",
      "zh-CHS": "int otp=二进制%DIGITS_幂[码位]；"
    },
    {
      "indent": 2,
      "text": "        result = Integer.toString(otp);\n        while (result.length() < codeDigits) {\n            result = \"0\" + result;\n        }\n        return result;\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "<CODE ENDS>",
      "zh-CHS": "<代码结束>"
    },
    {
      "indent": 0,
      "text": "Appendix B. Test Vectors Generation",
      "section_title": true,
      "zh-CHS": "附录B.测试向量生成"
    },
    {
      "indent": 2,
      "text": "<CODE BEGINS>",
      "zh-CHS": "<代码开始>"
    },
    {
      "indent": 2,
      "text": "/**\n   Copyright (c) 2011 IETF Trust and the persons identified as\n   authors of the code. All rights reserved.",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": " Redistribution and use in source and binary forms, with or without modification, is permitted pursuant to, and subject to the license terms contained in, the Simplified BSD License set forth in Section 4.c of the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info). */",
      "zh-CHS": "根据IETF信托有关IETF文件的法律规定第4.c节规定的简化BSD许可证中包含的许可条款，允许以源代码和二进制格式重新分发和使用，无论是否修改(http://trustee.ietf.org/license-info). */"
    },
    {
      "indent": 2,
      "text": "import java.math.BigInteger;\nimport java.util.*;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "public class TestOCRA {",
      "zh-CHS": "公共类TestOCRA{"
    },
    {
      "indent": 2,
      "text": "public static String asHex (byte buf[]) {\n    StringBuffer strbuf = new StringBuffer(buf.length * 2);\n    int i;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "    for (i = 0; i < buf.length; i++) {\n        if (((int) buf[i] & 0xff) < 0x10)\n            strbuf.append(\"0\");\n        strbuf.append(Long.toString((int) buf[i] & 0xff, 16));\n    }\n    return strbuf.toString();\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "/**\n * @param args\n */\npublic static void main(String[] args) {",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "String ocra = \"\";\nString seed = \"\";\nString ocraSuite = \"\";\nString counter = \"\";\nString password = \"\";\nString sessionInformation = \"\";\nString question = \"\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "String qHex = \"\";\nString timeStamp = \"\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "// PASS1234 is SHA1 hash of \"1234\"\nString PASS1234 = \"7110eda4d09e062aa5e4a390b0a572ac0d2c0220\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "String SEED = \"3132333435363738393031323334353637383930\";\nString SEED32 = \"31323334353637383930313233343536373839\" +\n    \"30313233343536373839303132\";\nString SEED64 = \"31323334353637383930313233343536373839\" +\n    \"3031323334353637383930313233343536373839\" +\n    \"3031323334353637383930313233343536373839\" +\n    \"3031323334\";\nint STOP = 5;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "Date myDate = Calendar.getInstance().getTime();\nBigInteger b = new BigInteger(\"0\");\nString sDate = \"Mar 25 2008, 12:06:30 GMT\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "try{\n    DateFormat df =\n        new SimpleDateFormat(\"MMM dd yyyy, HH:mm:ss zzz\");\n    myDate = df.parse(sDate);\n    b = new BigInteger(\"0\" + myDate.getTime());\n    b = b.divide(new BigInteger(\"60000\"));",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "System.out.println(\"Time of \\\"\" + sDate + \"\\\" is in\");\nSystem.out.println(\"milli sec: \" + myDate.getTime());\nSystem.out.println(\"minutes: \" + b.toString());\nSystem.out.println(\"minutes (HEX encoded): \"\n    + b.toString(16).toUpperCase());\nSystem.out.println(\"Time of \\\"\" + sDate\n    + \"\\\" is the same as this localized\");\nSystem.out.println(\"time, \\\"\"\n    + new Date(myDate.getTime()) + \"\\\"\");",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "System.out.println();\nSystem.out.println(\"Standard 20Byte key: \" +\n    \"3132333435363738393031323334353637383930\");\nSystem.out.println(\"Standard 32Byte key: \" +\n    \"3132333435363738393031323334353637383930\");\nSystem.out.println(\"                     \" +\n    \"313233343536373839303132\");\nSystem.out.println(\"Standard 64Byte key: 313233343536373839\"\n    + \"3031323334353637383930\");\nSystem.out.println(\"                     313233343536373839\"\n    + \"3031323334353637383930\");",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "System.out.println(\"                     313233343536373839\"\n    + \"3031323334353637383930\");\nSystem.out.println(\"                     31323334\");",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "System.out.println();\nSystem.out.println(\"Plain challenge response\");\nSystem.out.println(\"========================\");\nSystem.out.println();",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "ocraSuite = \"OCRA-1:HOTP-SHA1-6:QN08\";\nSystem.out.println(ocraSuite);\nSystem.out.println(\"=======================\");\nseed = SEED;\ncounter = \"\";\nquestion = \"\";\npassword = \"\";\nsessionInformation = \"\";\ntimeStamp = \"\";\nfor(int i=0; i < 10; i++){\n    question = \"\" + i + i + i + i + i + i + i + i;\n    qHex = new String((new BigInteger(question,10))\n               .toString(16)).toUpperCase();\n    ocra = OCRA.generateOCRA(ocraSuite,seed,counter,\n                   qHex,password,\n                   sessionInformation,timeStamp);\n     System.out.println(\"Key: Standard 20Byte  Q: \"\n            + question + \"  OCRA: \" + ocra);\n}\nSystem.out.println();",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "ocraSuite = \"OCRA-1:HOTP-SHA256-8:C-QN08-PSHA1\";\nSystem.out.println(ocraSuite);\nSystem.out.println(\"=================================\");\nseed = SEED32;\ncounter = \"\";\nquestion = \"12345678\";\npassword = PASS1234;\nsessionInformation = \"\";\ntimeStamp = \"\";\nfor(int i=0; i < 10; i++){\n    counter = \"\" + i;\n    qHex = new String((new BigInteger(question,10))\n               .toString(16)).toUpperCase();\n    ocra = OCRA.generateOCRA(ocraSuite,seed,counter,\n               qHex,password,sessionInformation,timeStamp);\n    System.out.println(\"Key: Standard 32Byte  C: \"\n                 + counter + \"  Q: \"\n                 + question + \"  PIN(1234): \");",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "    System.out.println(password + \"  OCRA: \" + ocra);\n}\nSystem.out.println();",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "ocraSuite = \"OCRA-1:HOTP-SHA256-8:QN08-PSHA1\";\nSystem.out.println(ocraSuite);\nSystem.out.println(\"===============================\");\nseed = SEED32;\ncounter = \"\";\nquestion = \"\";\npassword = PASS1234;\nsessionInformation = \"\";\ntimeStamp = \"\";\nfor(int i=0; i < STOP; i++){\n    question = \"\" + i + i + i + i + i + i + i + i;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "    qHex = new String((new BigInteger(question,10))\n                .toString(16)).toUpperCase();\n    ocra = OCRA.generateOCRA(ocraSuite,seed,counter,\n             qHex,password,sessionInformation,timeStamp);\n    System.out.println(\"Key: Standard 32Byte  Q: \"\n                + question + \"  PIN(1234): \");\n    System.out.println(password + \"  OCRA: \" + ocra);\n}\nSystem.out.println();",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "ocraSuite = \"OCRA-1:HOTP-SHA512-8:C-QN08\";\nSystem.out.println(ocraSuite);\nSystem.out.println(\"===========================\");\nseed = SEED64;\ncounter = \"\";\nquestion = \"\";\npassword = \"\";\nsessionInformation = \"\";\ntimeStamp = \"\";\nfor(int i=0; i < 10; i++){\n    question = \"\" + i + i + i + i + i + i + i + i;\n    qHex = new String((new BigInteger(question,10))\n                .toString(16)).toUpperCase();\n    counter = \"0000\" + i;\n    ocra = OCRA.generateOCRA(ocraSuite,seed,counter,\n             qHex,password,sessionInformation,timeStamp);\n    System.out.println(\"Key: Standard 64Byte  C: \"\n             + counter + \"  Q: \"\n             + question + \"  OCRA: \" + ocra);\n}\nSystem.out.println();",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "ocraSuite = \"OCRA-1:HOTP-SHA512-8:QN08-T1M\";\nSystem.out.println(ocraSuite);\nSystem.out.println(\"=============================\");\nseed = SEED64;\ncounter = \"\";\nquestion = \"\";\npassword = \"\";\nsessionInformation = \"\";\ntimeStamp = b.toString(16);\nfor(int i=0; i < STOP; i++){\n    question = \"\" + i + i + i + i + i + i + i + i;\n    counter = \"\";\n    qHex = new String((new BigInteger(question,10))\n                .toString(16)).toUpperCase();\n    ocra = OCRA.generateOCRA(ocraSuite,seed,counter,\n             qHex,password,sessionInformation,timeStamp);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "    System.out.println(\"Key: Standard 64Byte  Q: \"\n                + question +\"  T: \"\n                  + timeStamp.toUpperCase()\n                + \"  OCRA: \" + ocra);\n}\nSystem.out.println();",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "System.out.println();\nSystem.out.println(\"Mutual Challenge Response\");\nSystem.out.println(\"=========================\");\nSystem.out.println();",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "ocraSuite = \"OCRA-1:HOTP-SHA256-8:QA08\";\nSystem.out.println(\"OCRASuite (server computation) = \"\n                   + ocraSuite);\nSystem.out.println(\"OCRASuite (client computation) = \"\n                   + ocraSuite);\nSystem.out.println(\"===============================\" +\n    \"===========================\");\nseed = SEED32;\ncounter = \"\";\nquestion = \"\";\npassword = \"\";\nsessionInformation = \"\";\ntimeStamp = \"\";\nfor(int i=0; i < STOP; i++){\n    question = \"CLI2222\" + i + \"SRV1111\" + i;\n    qHex = asHex(question.getBytes());\n    ocra = OCRA.generateOCRA(ocraSuite,seed,counter,qHex,\n                 password,sessionInformation,timeStamp);\n    System.out.println(",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "             \"(server)Key: Standard 32Byte  Q: \"\n             + question + \"  OCRA: \"\n             + ocra);\n    question = \"SRV1111\" + i + \"CLI2222\" + i;\n    qHex = asHex(question.getBytes());\n    ocra = OCRA.generateOCRA(ocraSuite,seed,counter,qHex,\n                 password,sessionInformation,timeStamp);\n    System.out.println(\n             \"(client)Key: Standard 32Byte  Q: \"\n             + question + \"  OCRA: \"\n             + ocra);\n}\nSystem.out.println();",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "String ocraSuite1 = \"OCRA-1:HOTP-SHA512-8:QA08\";\nString ocraSuite2 = \"OCRA-1:HOTP-SHA512-8:QA08-PSHA1\";\nSystem.out.println(\"OCRASuite (server computation) = \"\n                   + ocraSuite1);\nSystem.out.println(\"OCRASuite (client computation) = \"\n                   + ocraSuite2);\nSystem.out.println(\"===============================\" +\n    \"=================================\");\nocraSuite = \"\";\nseed = SEED64;\ncounter = \"\";\nquestion = \"\";\npassword = \"\";\nsessionInformation = \"\";\ntimeStamp = \"\";\nfor(int i=0; i < STOP; i++){\n    ocraSuite = ocraSuite1;\n    question = \"CLI2222\" + i + \"SRV1111\" + i;\n    qHex = asHex(question.getBytes());\n    password = \"\";\n    ocra = OCRA.generateOCRA(ocraSuite,seed,counter,qHex,\n                 password,sessionInformation,timeStamp);\n    System.out.println(\n                \"(server)Key: Standard 64Byte  Q: \"\n                + question + \"  OCRA: \"\n                + ocra);\n    ocraSuite = ocraSuite2;\n    question = \"SRV1111\" + i + \"CLI2222\" + i;\n    qHex = asHex(question.getBytes());\n    password = PASS1234;\n    ocra = OCRA.generateOCRA(ocraSuite,seed,counter,qHex,\n                 password,sessionInformation,timeStamp);\n    System.out.println(\"(client)Key: Standard 64Byte  Q: \"\n                 + question);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "    System.out.println(\"P: \" + password.toUpperCase()\n                 + \"  OCRA: \" + ocra);\n}\nSystem.out.println();",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "System.out.println();\nSystem.out.println(\"Plain Signature\");\nSystem.out.println(\"===============\");\nSystem.out.println();\nocraSuite = \"OCRA-1:HOTP-SHA256-8:QA08\";\nSystem.out.println(ocraSuite);\nSystem.out.println(\"=========================\");\nseed = SEED32;\ncounter = \"\";\nquestion = \"\";\npassword = \"\";\nsessionInformation = \"\";\ntimeStamp = \"\";\nfor(int i=0; i < STOP; i++){\n    question = \"SIG1\" + i + \"000\";\n    qHex = asHex(question.getBytes());\n    ocra = OCRA.generateOCRA(ocraSuite,seed,counter,qHex,\n                 password,sessionInformation,timeStamp);\n    System.out.println(\n            \"Key: Standard 32Byte  Q(Signature challenge): \"\n            + question);\n    System.out.println(\"   OCRA: \" + ocra);\n}\nSystem.out.println();",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "ocraSuite = \"OCRA-1:HOTP-SHA512-8:QA10-T1M\";\nSystem.out.println(ocraSuite);\nSystem.out.println(\"=============================\");\nseed = SEED64;\ncounter = \"\";\nquestion = \"\";\npassword = \"\";\nsessionInformation = \"\";\ntimeStamp = b.toString(16);\nfor(int i=0; i < STOP; i++){\n    question = \"SIG1\" + i + \"00000\";\n    qHex = asHex(question.getBytes());\n    ocra = OCRA.generateOCRA(ocraSuite,seed,counter,\n                 qHex,password,sessionInformation,timeStamp);\n    System.out.println(\n            \"Key: Standard 64Byte  Q(Signature challenge): \"\n            + question);\n    System.out.println(\"   T: \"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "            + timeStamp.toUpperCase() + \"  OCRA: \"\n            + ocra);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "    }catch (Exception e){\n              System.out.println(\"Error : \" + e);\n    }\n}\n}\n<CODE ENDS>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "Appendix C. Test Vectors",
      "section_title": true,
      "zh-CHS": "附录C.测试向量"
    },
    {
      "indent": 3,
      "text": "This section provides test values that can be used for the OCRA interoperability test.",
      "zh-CHS": "本节提供可用于OCRA互操作性测试的测试值。"
    },
    {
      "indent": 3,
      "text": "Standard 20Byte key:",
      "zh-CHS": "标准20字节密钥："
    },
    {
      "indent": 3,
      "text": "3132333435363738393031323334353637383930",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Standard 32Byte key:",
      "zh-CHS": "标准32字节密钥："
    },
    {
      "indent": 3,
      "text": "3132333435363738393031323334353637383930313233343536373839303132",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Standard 64Byte key:",
      "zh-CHS": "标准64字节密钥："
    },
    {
      "indent": 3,
      "text": "313233343536373839303132333435363738393031323334353637383930313233343\n53637383930313233343536373839303132333435363738393031323334",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "PIN (1234) SHA1 hash value:",
      "zh-CHS": "PIN（1234）SHA1哈希值："
    },
    {
      "indent": 3,
      "text": "7110eda4d09e062aa5e4a390b0a572ac0d2c0220",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "C.1. One-Way Challenge Response",
      "section_title": true,
      "zh-CHS": "C.1. 单向挑战响应"
    },
    {
      "indent": 16,
      "text": "+-----------------+----------+------------+\n|       Key       |     Q    | OCRA Value |\n+-----------------+----------+------------+\n| Standard 20Byte | 00000000 |   237653   |\n| Standard 20Byte | 11111111 |   243178   |\n| Standard 20Byte | 22222222 |   653583   |\n| Standard 20Byte | 33333333 |   740991   |\n| Standard 20Byte | 44444444 |   608993   |\n| Standard 20Byte | 55555555 |   388898   |\n| Standard 20Byte | 66666666 |   816933   |\n| Standard 20Byte | 77777777 |   224598   |\n| Standard 20Byte | 88888888 |   750600   |\n| Standard 20Byte | 99999999 |   294470   |\n+-----------------+----------+------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 26,
      "text": "OCRA-1:HOTP-SHA1-6:QN08",
      "zh-CHS": "OCRA-1:HOTP-SHA1-6:QN08"
    },
    {
      "indent": 14,
      "text": "+-----------------+---+----------+------------+\n|       Key       | C |     Q    | OCRA Value |\n+-----------------+---+----------+------------+\n| Standard 32Byte | 0 | 12345678 |  65347737  |\n| Standard 32Byte | 1 | 12345678 |  86775851  |\n| Standard 32Byte | 2 | 12345678 |  78192410  |\n| Standard 32Byte | 3 | 12345678 |  71565254  |\n| Standard 32Byte | 4 | 12345678 |  10104329  |\n| Standard 32Byte | 5 | 12345678 |  65983500  |\n| Standard 32Byte | 6 | 12345678 |  70069104  |\n| Standard 32Byte | 7 | 12345678 |  91771096  |\n| Standard 32Byte | 8 | 12345678 |  75011558  |\n| Standard 32Byte | 9 | 12345678 |  08522129  |\n+-----------------+---+----------+------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 21,
      "text": "OCRA-1:HOTP-SHA256-8:C-QN08-PSHA1",
      "zh-CHS": "OCRA-1:HOTP-SHA256-8:C-QN08-PSHA1"
    },
    {
      "indent": 16,
      "text": "+-----------------+----------+------------+\n|       Key       |     Q    | OCRA Value |\n+-----------------+----------+------------+\n| Standard 32Byte | 00000000 |  83238735  |\n| Standard 32Byte | 11111111 |  01501458  |\n| Standard 32Byte | 22222222 |  17957585  |\n| Standard 32Byte | 33333333 |  86776967  |\n| Standard 32Byte | 44444444 |  86807031  |\n+-----------------+----------+------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 22,
      "text": "OCRA-1:HOTP-SHA256-8:QN08-PSHA1",
      "zh-CHS": "OCRA-1:HOTP-SHA256-8:QN08-PSHA1"
    },
    {
      "indent": 12,
      "text": "+-----------------+-------+----------+------------+\n|       Key       |   C   |     Q    | OCRA Value |\n+-----------------+-------+----------+------------+\n| Standard 64Byte | 00000 | 00000000 |  07016083  |\n| Standard 64Byte | 00001 | 11111111 |  63947962  |\n| Standard 64Byte | 00002 | 22222222 |  70123924  |\n| Standard 64Byte | 00003 | 33333333 |  25341727  |\n| Standard 64Byte | 00004 | 44444444 |  33203315  |\n| Standard 64Byte | 00005 | 55555555 |  34205738  |\n| Standard 64Byte | 00006 | 66666666 |  44343969  |\n| Standard 64Byte | 00007 | 77777777 |  51946085  |\n| Standard 64Byte | 00008 | 88888888 |  20403879  |\n| Standard 64Byte | 00009 | 99999999 |  31409299  |\n+-----------------+-------+----------+------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 24,
      "text": "OCRA-1:HOTP-SHA512-8:C-QN08",
      "zh-CHS": "OCRA-1:HOTP-SHA512-8:C-QN08"
    },
    {
      "indent": 11,
      "text": "+-----------------+----------+---------+------------+\n|       Key       |     Q    |    T    | OCRA Value |\n+-----------------+----------+---------+------------+\n| Standard 64Byte | 00000000 | 132d0b6 |  95209754  |\n| Standard 64Byte | 11111111 | 132d0b6 |  55907591  |\n| Standard 64Byte | 22222222 | 132d0b6 |  22048402  |\n| Standard 64Byte | 33333333 | 132d0b6 |  24218844  |\n| Standard 64Byte | 44444444 | 132d0b6 |  36209546  |\n+-----------------+----------+---------+------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 23,
      "text": "OCRA-1:HOTP-SHA512-8:QN08-T1M",
      "zh-CHS": "OCRA-1:HOTP-SHA512-8:QN08-T1M"
    },
    {
      "indent": 0,
      "text": "C.2. Mutual Challenge-Response",
      "section_title": true,
      "zh-CHS": "C.2. 相互挑战响应"
    },
    {
      "indent": 3,
      "text": "OCRASuite (server computation) = OCRA-1:HOTP-SHA256-8:QA08",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "OCRASuite (client computation) = OCRA-1:HOTP-SHA256-8:QA08",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 12,
      "text": "+-----------------+------------------+------------+\n|       Key       |         Q        | OCRA Value |\n+-----------------+------------------+------------+\n| Standard 32Byte | CLI22220SRV11110 |  28247970  |\n| Standard 32Byte | CLI22221SRV11111 |  01984843  |\n| Standard 32Byte | CLI22222SRV11112 |  65387857  |\n| Standard 32Byte | CLI22223SRV11113 |  03351211  |\n| Standard 32Byte | CLI22224SRV11114 |  83412541  |\n+-----------------+------------------+------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 20,
      "text": "Server -- OCRA-1:HOTP-SHA256-8:QA08",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 12,
      "text": "+-----------------+------------------+------------+\n|       Key       |         Q        | OCRA Value |\n+-----------------+------------------+------------+\n| Standard 32Byte | SRV11110CLI22220 |  15510767  |\n| Standard 32Byte | SRV11111CLI22221 |  90175646  |\n| Standard 32Byte | SRV11112CLI22222 |  33777207  |\n| Standard 32Byte | SRV11113CLI22223 |  95285278  |\n| Standard 32Byte | SRV11114CLI22224 |  28934924  |\n+-----------------+------------------+------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 20,
      "text": "Client -- OCRA-1:HOTP-SHA256-8:QA08",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "OCRASuite (server computation) = OCRA-1:HOTP-SHA512-8:QA08",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "OCRASuite (client computation) = OCRA-1:HOTP-SHA512-8:QA08-PSHA1",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 12,
      "text": "+-----------------+------------------+------------+\n|       Key       |         Q        | OCRA Value |\n+-----------------+------------------+------------+\n| Standard 64Byte | CLI22220SRV11110 |  79496648  |\n| Standard 64Byte | CLI22221SRV11111 |  76831980  |\n| Standard 64Byte | CLI22222SRV11112 |  12250499  |\n| Standard 64Byte | CLI22223SRV11113 |  90856481  |\n| Standard 64Byte | CLI22224SRV11114 |  12761449  |\n+-----------------+------------------+------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 20,
      "text": "Server -- OCRA-1:HOTP-SHA512-8:QA08",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 12,
      "text": "+-----------------+------------------+------------+\n|       Key       |         Q        | OCRA Value |\n+-----------------+------------------+------------+\n| Standard 64Byte | SRV11110CLI22220 |  18806276  |\n| Standard 64Byte | SRV11111CLI22221 |  70020315  |\n| Standard 64Byte | SRV11112CLI22222 |  01600026  |\n| Standard 64Byte | SRV11113CLI22223 |  18951020  |\n| Standard 64Byte | SRV11114CLI22224 |  32528969  |\n+-----------------+------------------+------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 17,
      "text": "Client -- OCRA-1:HOTP-SHA512-8:QA08-PSHA1",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "C.3. Plain Signature",
      "section_title": true,
      "zh-CHS": "C.3. 普通签名"
    },
    {
      "indent": 3,
      "text": "In this mode of operation, Q represents the signature challenge.",
      "zh-CHS": "在此操作模式中，Q表示签名质询。"
    },
    {
      "indent": 16,
      "text": "+-----------------+----------+------------+\n|       Key       |     Q    | OCRA Value |\n+-----------------+----------+------------+\n| Standard 32Byte | SIG10000 |  53095496  |\n| Standard 32Byte | SIG11000 |  04110475  |\n| Standard 32Byte | SIG12000 |  31331128  |\n| Standard 32Byte | SIG13000 |  76028668  |\n| Standard 32Byte | SIG14000 |  46554205  |\n+-----------------+----------+------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 25,
      "text": "OCRA-1:HOTP-SHA256-8:QA08",
      "zh-CHS": "OCRA-1:HOTP-SHA256-8:QA08"
    },
    {
      "indent": 10,
      "text": "+-----------------+------------+---------+------------+\n|       Key       |      Q     |    T    | OCRA Value |\n+-----------------+------------+---------+------------+\n| Standard 64Byte | SIG1000000 | 132d0b6 |  77537423  |\n| Standard 64Byte | SIG1100000 | 132d0b6 |  31970405  |\n| Standard 64Byte | SIG1200000 | 132d0b6 |  10235557  |\n| Standard 64Byte | SIG1300000 | 132d0b6 |  95213541  |\n| Standard 64Byte | SIG1400000 | 132d0b6 |  65360607  |\n+-----------------+------------+---------+------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 23,
      "text": "OCRA-1:HOTP-SHA512-8:QA10-T1M",
      "zh-CHS": "OCRA-1:HOTP-SHA512-8:QA10-T1M"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "zh-CHS": "作者地址"
    },
    {
      "indent": 3,
      "text": "David M'Raihi Verisign, Inc. 487 E. Middlefield Road Mountain View, CA 94043 USA",
      "zh-CHS": "David M'Raihi Verisign，Inc.美国加利福尼亚州米德尔菲尔德路山景大道东487号，邮编94043"
    },
    {
      "indent": 3,
      "text": "EMail: davidietf@gmail.com",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Johan Rydell Portwise, Inc. 275 Hawthorne Ave, Suite 119 Palo Alto, CA 94301 USA",
      "zh-CHS": "Johan Rydell Portwise，Inc.美国加利福尼亚州帕洛阿尔托市霍桑大道275号119室，邮编94301"
    },
    {
      "indent": 3,
      "text": "EMail: johanietf@gmail.com",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Siddharth Bajaj Symantec Corp. 350 Ellis Street Mountain View, CA 94043 USA",
      "zh-CHS": "Siddharth Bajaj Symantec Corp.美国加利福尼亚州埃利斯街山景城350号，邮编94043"
    },
    {
      "indent": 3,
      "text": "EMail: siddharthietf@gmail.com",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Salah Machani Diversinet Corp. 2225 Sheppard Avenue East, Suite 1801 Toronto, Ontario M2J 5C2 Canada",
      "zh-CHS": "Salah Machani Diversinet Corp.加拿大安大略省多伦多Sheppard大道东2225号1801室M2J 5C2"
    },
    {
      "indent": 3,
      "text": "EMail: smachani@diversinet.com",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "David Naccache Ecole Normale Superieure ENS DI, 45 rue d'Ulm Paris, 75005 France",
      "zh-CHS": "David Naccache法国巴黎乌尔姆街45号高等师范学院，75005"
    },
    {
      "indent": 3,
      "text": "EMail: david.naccache@ens.fr",
      "raw": true,
      "zh-CHS": " "
    }
  ]
}