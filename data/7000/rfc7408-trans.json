{
  "title": {
    "text": "RFC 7408: Forwarding and Control Element Separation (ForCES) Model Extension",
    "zh-CHS": "RFC 7408"
  },
  "number": 7408,
  "created_at": "2021-11-02 21:30:45.597910+08:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                     E. Haleplidis\nRequest for Comments: 7408                          University of Patras\nUpdates: 5812                                              November 2014\nCategory: Standards Track\nISSN: 2070-1721",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Forwarding and Control Element Separation (ForCES) Model Extension",
      "zh-CHS": "转发和控制元素分离（ForCES）模型扩展"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "zh-CHS": "摘要"
    },
    {
      "indent": 3,
      "text": "This memo extends the Forwarding and Control Element Separation (ForCES) model defined in RFC 5812 and updates that RFC to allow complex data types for metadata, optional default values for data types, and optional access types for structures. It also fixes an issue with Logical Functional Block (LFB) inheritance and introduces two new features: a new event condition called eventBecomesEqualTo and LFB properties. The changes introduced in this memo do not alter the protocol and retain backward compatibility with older LFB models.",
      "zh-CHS": "此备忘录扩展了RFC 5812中定义的转发和控制元素分离（ForCES）模型，并更新该RFC，以允许元数据的复杂数据类型、数据类型的可选默认值以及结构的可选访问类型。它还修复了逻辑功能块（LFB）继承的问题，并引入了两个新特性：一个名为eventBecomesEqualTo的新事件条件和LFB属性。本备忘录中引入的更改不会改变协议，并保留与旧LFB模型的向后兼容性。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "zh-CHS": "关于下段备忘"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "zh-CHS": "这是一份互联网标准跟踪文件。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "zh-CHS": "本文件是互联网工程任务组（IETF）的产品。它代表了IETF社区的共识。它已经接受了公众审查，并已被互联网工程指导小组（IESG）批准出版。有关互联网标准的更多信息，请参见RFC 5741第2节。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7408.",
      "zh-CHS": "有关本文件当前状态、任何勘误表以及如何提供反馈的信息，请访问http://www.rfc-editor.org/info/rfc7408."
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "zh-CHS": "版权公告"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2014 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "zh-CHS": "版权所有（c）2014 IETF信托基金和确定为文件作者的人员。版权所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "zh-CHS": "本文件受BCP 78和IETF信托有关IETF文件的法律规定的约束(http://trustee.ietf.org/license-info)自本文件出版之日起生效。请仔细阅读这些文件，因为它们描述了您对本文件的权利和限制。从本文件中提取的代码组件必须包括信托法律条款第4.e节中所述的简化BSD许可证文本，并提供简化BSD许可证中所述的无担保。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "zh-CHS": "目录"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................2\n   1.1. Requirements Language ......................................3\n   1.2. Terminology ................................................3\n2. ForCES Model Extensions .........................................3\n   2.1. Complex Data Types for Metadata ............................3\n   2.2. Optional Default Values for Data Types .....................5\n   2.3. Optional Access Types for Structs ..........................8\n   2.4. New Event Condition: eventBecomesEqualTo ..................11\n   2.5. LFB Properties ............................................12\n   2.6. LFB Class Inheritance .....................................14\n   2.7. Enhancing XML Validation ..................................15\n3. XML Extension Schema for LFB Class Library Documents ...........15\n4. IANA Considerations ............................................29\n5. Security Considerations ........................................29\n6. References .....................................................30\n   6.1. Normative References ......................................30\n   6.2. Informative References ....................................30\nAcknowledgements ..................................................31\nAuthor's Address ..................................................31",
      "raw": true,
      "toc": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "zh-CHS": "1. 介绍"
    },
    {
      "indent": 3,
      "text": "The ForCES model [RFC5812] presents a formal way to define Forwarding Element (FE) Logical Functional Blocks (LFBs) using the eXtensible Markup Language (XML). [RFC5812] was published several years before this document, and experience with its use has demonstrated the need to add new modeling concepts and change existing ones.",
      "zh-CHS": "ForCES模型[RFC5812]提供了一种使用可扩展标记语言（XML）定义转发元素（FE）逻辑功能块（LFB）的正式方法。[RFC5812]在本文档发布前几年发布，其使用经验表明需要添加新的建模概念并更改现有概念。"
    },
    {
      "indent": 3,
      "text": "Specifically, this document updates the ForCES model [RFC5812] to allow complex data types for metadata (Section 2.1), optional default values for data types (Section 2.2), and optional access types for structures (Section 2.3). It also fixes an issue with LFB class inheritance (Section 2.6). Additionally, the document introduces two new features: a new event condition named eventBecomesEqualTo (Section 2.4) and LFB properties (Section 2.5).",
      "zh-CHS": "具体而言，本文档更新了ForCES模型[RFC5812]，以允许元数据的复杂数据类型（第2.1节）、数据类型的可选默认值（第2.2节）和结构的可选访问类型（第2.3节）。它还修复了LFB类继承的问题（第2.6节）。此外，本文档还引入了两个新特性：名为eventBecomesEqualTo的新事件条件（第2.4节）和LFB属性（第2.5节）。"
    },
    {
      "indent": 3,
      "text": "These extensions are an update to the ForCES model [RFC5812] and do not require any changes to the ForCES protocol [RFC5810] as they are simply changes to the schema definition. Additionally, backward compatibility is ensured as XML libraries produced with the earlier schema are still valid with the new one. In order for XML libraries produced by the new schema to be compatible with existing ForCES implementations, the XML libraries MUST NOT include any of the features described in this document.",
      "zh-CHS": "这些扩展是对ForCES模型[RFC5812]的更新，不需要对ForCES协议[RFC5810]进行任何更改，因为它们只是对模式定义的更改。此外，由于使用早期模式生成的XML库对于新模式仍然有效，因此可以确保向后兼容性。为了使新模式生成的XML库与现有的ForCES实现兼容，XML库不得包含本文档中描述的任何功能。"
    },
    {
      "indent": 3,
      "text": "Extensions to the schema and excerpts of the schema include the tags <!-- Extension RFC 7408 --> and <!-- /Extension RFC 7408 -->, which designate the beginning and ending of extension text specified by this document in respect to the schema in the original ForCES model [RFC5812].",
      "zh-CHS": "模式的扩展和模式的摘录包括标记<！--扩展RFC 7408-->和<！--/扩展名RFC 7408-->，用于指定本文档针对原始ForCES模型[RFC5812]中的模式指定的扩展名文本的开头和结尾。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Language",
      "section_title": true,
      "zh-CHS": "1.1. 需求语言"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "zh-CHS": "本文件中的关键词“必须”、“不得”、“必需”、“应”、“不应”、“应”、“不应”、“建议”、“可”和“可选”应按照[RFC2119]中所述进行解释。"
    },
    {
      "indent": 0,
      "text": "1.2. Terminology",
      "section_title": true,
      "zh-CHS": "1.2. 术语"
    },
    {
      "indent": 3,
      "text": "This document uses the terminology defined in the ForCES model [RFC5812]. In particular, the reader is expected to be familiar with the following terms:",
      "zh-CHS": "本文件使用部队模型[RFC5812]中定义的术语。读者应特别熟悉以下术语："
    },
    {
      "indent": 6,
      "text": "FE Model",
      "zh-CHS": "有限元模型"
    },
    {
      "indent": 6,
      "text": "LFB (Logical Functional Block) Class (or type)",
      "zh-CHS": "LFB（逻辑功能块）类（或类型）"
    },
    {
      "indent": 6,
      "text": "LFB Instance",
      "zh-CHS": "LFB实例"
    },
    {
      "indent": 6,
      "text": "LFB Model",
      "zh-CHS": "LFB模型"
    },
    {
      "indent": 6,
      "text": "Element",
      "zh-CHS": "要素"
    },
    {
      "indent": 6,
      "text": "Attribute",
      "zh-CHS": "属性"
    },
    {
      "indent": 6,
      "text": "LFB Metadata",
      "zh-CHS": "LFB元数据"
    },
    {
      "indent": 6,
      "text": "ForCES Component",
      "zh-CHS": "力分量"
    },
    {
      "indent": 6,
      "text": "LFB Class Library",
      "zh-CHS": "LFB类库"
    },
    {
      "indent": 0,
      "text": "2. ForCES Model Extensions",
      "section_title": true,
      "zh-CHS": "2. 强制模型扩展"
    },
    {
      "indent": 0,
      "text": "2.1. Complex Data Types for Metadata",
      "section_title": true,
      "zh-CHS": "2.1. 元数据的复杂数据类型"
    },
    {
      "indent": 3,
      "text": "Section 4.6 (\"<metadataDefs> Element for Metadata Definitions\") of the ForCES model [RFC5812] limits the data type use in metadata to only atomic types. Figure 1 shows the XML schema excerpt where only typeRef and atomic are allowed for a metadata definition.",
      "zh-CHS": "ForCES模型[RFC5812]的第4.6节（“元数据定义元素”）将元数据中使用的数据类型限制为仅原子类型。图1显示了XML模式摘录，其中元数据定义只允许typeRef和atomic。"
    },
    {
      "indent": 5,
      "text": "<xsd:complexType name=\"metadataDefsType\">\n  <xsd:sequence>\n    <xsd:element name=\"metadataDef\" maxOccurs=\"unbounded\">\n      <xsd:complexType>\n        <xsd:sequence>\n          <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/>\n          <xsd:element ref=\"synopsis\"/>\n          <xsd:element name=\"metadataID\" type=\"xsd:integer\"/>\n          <xsd:element ref=\"description\" minOccurs=\"0\"/>\n          <xsd:choice>\n            <xsd:element name=\"typeRef\" type=\"typeRefNMTOKEN\"/>\n            <xsd:element name=\"atomic\" type=\"atomicType\"/>\n          </xsd:choice>\n        </xsd:sequence>\n      </xsd:complexType>\n    </xsd:element>\n  </xsd:sequence>\n</xsd:complexType>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 8,
      "text": "Figure 1: Initial metadataDefsType Definition in the Schema",
      "zh-CHS": "图1：模式中的初始metadataDefsType定义"
    },
    {
      "indent": 3,
      "text": "However, there are cases where complex metadata are used in the datapath: for example, two simple use cases are described in version 1.1.0 (and subsequent versions) of the OpenFlow Switch Specification [OpenFlowSpec1.1]:",
      "zh-CHS": "但是，也有在数据路径中使用复杂元数据的情况：例如，OpenFlow Switch规范[OpenFlowSpec1.1]的版本1.1.0（及后续版本）中描述了两个简单的用例："
    },
    {
      "indent": 3,
      "text": "1. The Action Set metadata is an array of actions descriptors, which traverses the processing pipeline along with the packet data.",
      "zh-CHS": "1. 动作集元数据是一组动作描述符，它与数据包一起穿过处理管道。"
    },
    {
      "indent": 3,
      "text": "2. When a packet is received from a controller, it may be accompanied by a list of actions, as metadata, to be performed on it prior to being sent on the processing pipeline. This list of actions is also an array.",
      "zh-CHS": "2. 当从控制器接收到一个数据包时，它可能伴随着一个动作列表，作为元数据，在发送到处理管道之前对其执行。此操作列表也是一个数组。"
    },
    {
      "indent": 3,
      "text": "With the extension shown in Figure 2, complex data types are also allowed, specifically structs and arrays as metadata. The key declarations are required to check for validity of content keys in arrays and componentIDs in structs.",
      "zh-CHS": "通过图2所示的扩展，还可以使用复杂的数据类型，特别是作为元数据的结构和数组。需要密钥声明来检查数组中的内容密钥和结构中的组件的有效性。"
    },
    {
      "indent": 5,
      "text": "<xsd:complexType name=\"metadataDefsType\">\n  <xsd:sequence>\n    <xsd:element name=\"metadataDef\" maxOccurs=\"unbounded\">\n      <xsd:complexType>\n        <xsd:sequence>\n          <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/>\n          <xsd:element ref=\"synopsis\"/>\n          <xsd:element name=\"metadataID\" type=\"xsd:integer\"/>\n          <xsd:element ref=\"description\" minOccurs=\"0\"/>\n          <xsd:choice>\n            <xsd:element name=\"typeRef\" type=\"typeRefNMTOKEN\"/>\n            <xsd:element name=\"atomic\" type=\"atomicType\"/>\n            <!-- Extension RFC 7408 -->\n            <xsd:element name=\"array\" type=\"arrayType\">\n              <xsd:key name=\"contentKeyID1\">\n                <xsd:selector xpath=\"lfb:contentKey\"/>\n                <xsd:field xpath=\"@contentKeyID\"/>\n              </xsd:key>\n            </xsd:element>\n            <xsd:element name=\"struct\" type=\"structType\">\n              <xsd:key name=\"structComponentID1\">\n                <xsd:selector xpath=\"lfb:component\"/>\n                <xsd:field xpath=\"@componentID\"/>\n              </xsd:key>\n            </xsd:element>\n            <!-- /Extension RFC 7408 -->\n          </xsd:choice>\n        </xsd:sequence>\n      </xsd:complexType>\n    </xsd:element>\n  </xsd:sequence>\n</xsd:complexType>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": "Figure 2: New metadataDefsType Definition in the Schema",
      "zh-CHS": "图2：模式中新的metadataDefsType定义"
    },
    {
      "indent": 0,
      "text": "2.2. Optional Default Values for Data Types",
      "section_title": true,
      "zh-CHS": "2.2. 数据类型的可选默认值"
    },
    {
      "indent": 3,
      "text": "In the original schema, default values can only be defined for data types defined inside LFB components and not inside structures or arrays. Therefore, default values for data types that are constantly being reused, e.g., counters with default value of 0, have to be constantly respecified. Additionally, data types inside complex data types cannot be defined with a default value, e.g., a counter inside a struct that has a default value of 0.",
      "zh-CHS": "在原始模式中，只能为LFB组件内部定义的数据类型定义默认值，而不能为结构或数组内部定义的数据类型定义默认值。因此，必须不断重新指定不断重复使用的数据类型的默认值，例如默认值为0的计数器。此外，复杂数据类型中的数据类型不能用默认值定义，例如，结构中的计数器的默认值为0。"
    },
    {
      "indent": 3,
      "text": "This extension allows the option to add default values to data types. These data types can then be referenced as simple components or within complex data types such as structs. A simple use case would",
      "zh-CHS": "此扩展允许选项向数据类型添加默认值。然后，这些数据类型可以作为简单组件或在复杂数据类型（如结构）中引用。一个简单的用例"
    },
    {
      "indent": 3,
      "text": "be to have a struct component where one of the components is a counter with a default value of zero. To achieve that, the counter must first be defined as a data type with the required default value and then referenced in the struct. Default values MUST adhere the following formal restrictions:",
      "zh-CHS": "将有一个结构组件，其中一个组件是默认值为零的计数器。为此，必须首先将计数器定义为具有所需默认值的数据类型，然后在结构中引用。默认值必须遵守以下正式限制："
    },
    {
      "indent": 3,
      "text": "1. Default values MUST be ignored if the data type is not an atomic or a base data type.",
      "zh-CHS": "1. 如果数据类型不是原子或基本数据类型，则必须忽略默认值。"
    },
    {
      "indent": 3,
      "text": "2. When a data type X with default value A is referenced from a data type Y with a default value B, the default value of the data type that references overrides the referenced default value, e.g., in this case, Y's default value will be B.",
      "zh-CHS": "2. 当从具有默认值B的数据类型Y引用具有默认值a的数据类型X时，引用的数据类型的默认值将覆盖引用的默认值，例如，在这种情况下，Y的默认值将为B。"
    },
    {
      "indent": 3,
      "text": "3. Default values of LFB components override any default value specified from the dataTypeDef definition.",
      "zh-CHS": "3. LFB组件的默认值覆盖从dataTypeDef定义中指定的任何默认值。"
    },
    {
      "indent": 3,
      "text": "4. Default values of data types referenced in capabilities or metadata MUST be ignored.",
      "zh-CHS": "4. 必须忽略功能或元数据中引用的数据类型的默认值。"
    },
    {
      "indent": 3,
      "text": "This extension simply adds to the definition of dataTypeDefsType in the XML schema shown in Figure 3 to allow default values for dataTypeDefsType. The new definition is shown in Figure 4.",
      "zh-CHS": "此扩展只是在图3所示的XML模式中添加了dataTypeDefsType的定义，以允许dataTypeDefsType的默认值。新定义如图4所示。"
    },
    {
      "indent": 5,
      "text": "<xsd:complexType name=\"dataTypeDefsType\">\n  <xsd:sequence>\n    <xsd:element name=\"dataTypeDef\" maxOccurs=\"unbounded\">\n      <xsd:complexType>\n        <xsd:sequence>\n          <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/>\n          <xsd:element name=\"derivedFrom\" type=\"xsd:NMTOKEN\"\n             minOccurs=\"0\"/>\n          <xsd:element ref=\"synopsis\"/>\n          <xsd:element ref=\"description\" minOccurs=\"0\"/>\n          <xsd:group ref=\"typeDeclarationGroup\"/>\n        </xsd:sequence>\n      </xsd:complexType>\n    </xsd:element>\n  </xsd:sequence>\n</xsd:complexType>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "Figure 3: Initial Excerpt of dataTypeDefsType Definition in the Schema",
      "zh-CHS": "图3：模式中dataTypeDefsType定义的初始摘录"
    },
    {
      "indent": 5,
      "text": "<xsd:complexType name=\"dataTypeDefsType\">\n  <xsd:sequence>\n    <xsd:element name=\"dataTypeDef\" maxOccurs=\"unbounded\">\n      <xsd:complexType>\n        <xsd:sequence>\n          <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/>\n          <xsd:element name=\"derivedFrom\" type=\"xsd:NMTOKEN\"\n             minOccurs=\"0\"/>\n          <xsd:element ref=\"synopsis\"/>\n          <xsd:element ref=\"description\" minOccurs=\"0\"/>\n          <xsd:group ref=\"typeDeclarationGroup\"/>\n          <!-- Extension RFC 7408 -->\n          <xsd:element name=\"defaultValue\" type=\"xsd:token\"\n             minOccurs=\"0\"/>\n          <!-- /Extension RFC 7408 -->\n        </xsd:sequence>\n      </xsd:complexType>\n    </xsd:element>\n  </xsd:sequence>\n</xsd:complexType>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "Figure 4: New Excerpt of dataTypeDefsType Definition in the Schema",
      "zh-CHS": "图4：模式中dataTypeDefsType定义的新摘录"
    },
    {
      "indent": 3,
      "text": "Examples of using default values is depicted in Figure 5.",
      "zh-CHS": "使用默认值的示例如图5所示。"
    },
    {
      "indent": 5,
      "text": "<dataTypeDef>\n  <name>ZeroCounter</name>\n  <synopsis>A counter with default 0</synopsis>\n  <typeRef>uint32</typeRef>\n  <defaultValue>0</defaultValue>\n</dataTypeDef>\n<dataTypeDef>\n  <name>CounterValues</name>\n  <synopsis>Example default values in struct</synopsis>\n  <struct>\n    <component componentID=\"1\">\n      <name>GoodPacketCounter</name>\n      <synopsis>A counter for good packets</synopsis>\n      <typeRef>ZeroCounter</typeRef>\n    </component>\n    <component componentID=\"2\">\n      <name>BadPacketCounter</name>\n      <synopsis>A counter for bad packets</synopsis>\n      <typeRef>ZeroCounter</typeRef>\n    </component>\n  </struct>\n</dataTypeDef>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 15,
      "text": "Figure 5: Example of Optional Default Values",
      "zh-CHS": "图5：可选默认值的示例"
    },
    {
      "indent": 0,
      "text": "2.3. Optional Access Types for Structs",
      "section_title": true,
      "zh-CHS": "2.3. 结构的可选访问类型"
    },
    {
      "indent": 3,
      "text": "In the original schema, the access type can only be defined on components of an LFB and not on components within structs or arrays. That means that when it is a struct data type, it is not possible to fine-tune access type per component within the struct. A simple use case would be to have a read-write struct component where one of the components is a counter with an access type that could be read-reset or read-only, e.g., a read-reset or a read-only counter inside a struct.",
      "zh-CHS": "在原始模式中，只能在LFB的组件上定义访问类型，而不能在结构或数组中的组件上定义。这意味着，当它是结构数据类型时，不可能微调结构中每个组件的访问类型。一个简单的用例是拥有一个读写结构组件，其中一个组件是一个访问类型为读重置或只读的计数器，例如，结构中的读重置或只读计数器。"
    },
    {
      "indent": 3,
      "text": "This extension allows the definition of the access type for a struct component either in the data type definitions or in the LFB component definitions.",
      "zh-CHS": "此扩展允许在数据类型定义或LFB组件定义中定义结构组件的访问类型。"
    },
    {
      "indent": 3,
      "text": "When optional access types for components within a struct are defined, the access types for these components MUST override the access type of the struct. For example, if a struct has an access type of read-write but has a component that is a read-only counter, the counter's access type MUST be read-only.",
      "zh-CHS": "定义结构中组件的可选访问类型时，这些组件的访问类型必须覆盖结构的访问类型。例如，如果结构的访问类型为读写，但组件为只读计数器，则计数器的访问类型必须为只读。"
    },
    {
      "indent": 3,
      "text": "Per [RFC5812], the access type for a component in a capability is always read-only. If an access type is provided for a component in a capability, the access type MUST be ignored. Similarly, if an access type is provided for a struct in a metadata, the access type MUST be ignored.",
      "zh-CHS": "根据[RFC5812]，功能中组件的访问类型始终为只读。如果为功能中的组件提供了访问类型，则必须忽略该访问类型。类似地，如果为元数据中的结构提供了访问类型，则必须忽略该访问类型。"
    },
    {
      "indent": 3,
      "text": "This extension alters the definition of the struct in the XML schema from the initial definition shown in Figure 6 to the new shown in Figure 7.",
      "zh-CHS": "此扩展将XML模式中结构的定义从图6所示的初始定义更改为图7所示的新定义。"
    },
    {
      "indent": 5,
      "text": "<xsd:complexType name=\"structType\">\n  <xsd:sequence>\n    <xsd:element name=\"derivedFrom\" type=\"typeRefNMTOKEN\"\n      minOccurs=\"0\"/>\n    <xsd:element name=\"component\" maxOccurs=\"unbounded\">\n      <xsd:complexType>\n        <xsd:sequence>\n          <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/>\n          <xsd:element ref=\"synopsis\"/>\n          <xsd:element ref=\"description\" minOccurs=\"0\"/>\n          <xsd:element name=\"optional\" minOccurs=\"0\"/>\n          <xsd:group ref=\"typeDeclarationGroup\"/>\n        </xsd:sequence>\n        <xsd:attribute name=\"componentID\" type=\"xsd:unsignedInt\"\n         use=\"required\"/>\n      </xsd:complexType>\n    </xsd:element>\n  </xsd:sequence>\n</xsd:complexType>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "Figure 6: Initial XML for the Struct Definition in the Schema",
      "zh-CHS": "图6：模式中结构定义的初始XML"
    },
    {
      "indent": 5,
      "text": "<xsd:complexType name=\"structType\">\n  <xsd:sequence>\n    <xsd:element name=\"derivedFrom\" type=\"typeRefNMTOKEN\"\n      minOccurs=\"0\"/>\n    <xsd:element name=\"component\" maxOccurs=\"unbounded\">\n      <xsd:complexType>\n        <xsd:sequence>\n          <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/>\n          <xsd:element ref=\"synopsis\"/>\n          <xsd:element ref=\"description\" minOccurs=\"0\"/>\n          <xsd:element name=\"optional\" minOccurs=\"0\"/>\n          <xsd:group ref=\"typeDeclarationGroup\"/>\n        </xsd:sequence>\n        <!-- Extension RFC 7408 -->\n        <xsd:attribute name=\"access\" use=\"optional\"\n          default=\"read-write\">\n          <xsd:simpleType>\n            <xsd:list itemType=\"accessModeType\"/>\n          </xsd:simpleType>\n        </xsd:attribute>\n        <!-- /Extension RFC 7408 -->\n        <xsd:attribute name=\"componentID\" type=\"xsd:unsignedInt\"\n          use=\"required\"/>\n      </xsd:complexType>\n    </xsd:element>\n  </xsd:sequence>\n</xsd:complexType>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "Figure 7: New XML for the Struct Definition in the Schema",
      "zh-CHS": "图7：模式中结构定义的新XML"
    },
    {
      "indent": 3,
      "text": "An example of using optional access types for structs is depicted in Figure 8.",
      "zh-CHS": "图8描述了为结构使用可选访问类型的示例。"
    },
    {
      "indent": 6,
      "text": "<component componentID=\"1\" access=\"read-write\">\n   <name>PacketFlows</name>\n   <synopsis>Packet Flows, match and counter</synopsis>\n   <struct>\n    <component componentID=\"1\">\n      <name>FlowMatch</name>\n      <synopsis>Flow Match</synopsis>\n      <typeRef>MatchType</typeRef>\n    </component>\n    <component componentID=\"2\" access=\"read-only\">\n      <name>MatchCounter</name>\n      <synopsis>Packets matching the flow match</synopsis>\n      <typeRef>ZeroCounter</typeRef>\n    </component>\n  </struct>\n</component>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 11,
      "text": "Figure 8: Example of Optional Access Types for Struct",
      "zh-CHS": "图8:Struct的可选访问类型示例"
    },
    {
      "indent": 0,
      "text": "2.4. New Event Condition: eventBecomesEqualTo",
      "section_title": true,
      "zh-CHS": "2.4. 新事件条件：eventBecomesEqualTo"
    },
    {
      "indent": 3,
      "text": "This extension adds one more event condition in the model schema, eventBecomesEqualTo. eventBecomesEqualTo is different from eventGreaterThan and eventLessThan because the event is triggered when the value is exactly that of the eventBecomesEqualTo threshold. This event condition is particularly useful when there is a need to monitor one or more states of an LFB or the FE. For example, in the Control Element High Availability (CEHA) document [RFC7121], it may be useful for the master CE to know which backup CEs have just become associated in order to connect to them and begin synchronizing the state of the FE. The master CE could always poll for such information, but getting such an event will speed up the process, and the event may be useful in other cases as well for monitoring state.",
      "zh-CHS": "此扩展在模型模式中添加了一个以上的事件条件eventBecomesEqualTo。eventBecomesEqualTo与eventGreaterThan和EventLessTo不同，因为当值正好是eventBecomesEqualTo阈值时会触发事件。当需要监控LFB或FE的一个或多个状态时，此事件条件特别有用。例如，在控制元件高可用性（CEHA）文档[RFC7121]中，主CE可能需要知道哪些备份CE刚刚关联，以便连接到它们并开始同步FE的状态。主CE始终可以轮询此类信息，但获取此类事件将加快处理速度，并且该事件在其他情况下也可用于监视状态。"
    },
    {
      "indent": 3,
      "text": "The event MUST be triggered only when the value of the targeted component becomes equal to the event condition value. Implementations MUST NOT generate subsequent events while the targeted component's value remains equal to the event condition's value.",
      "zh-CHS": "只有当目标组件的值等于事件条件值时，才能触发事件。当目标组件的值保持等于事件条件的值时，实现不得生成后续事件。"
    },
    {
      "indent": 3,
      "text": "eventBecomesEqualTo is appended to the schema as shown in Figure 9.",
      "zh-CHS": "eventBecomesEqualTo被追加到模式中，如图9所示。"
    },
    {
      "indent": 5,
      "text": "<xsd:element name=\"eventBecomesEqualTo\"\n  substitutionGroup=\"eventCondition\"/>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "Figure 9: New Excerpt of eventBecomesEqualTo Event Condition Definition in the Schema",
      "zh-CHS": "图9:eventBecomesEqualTo模式中事件条件定义的新摘录"
    },
    {
      "indent": 3,
      "text": "It can become useful for the CE to be notified when the state has changed once the eventBecomesEqualTo event has been triggered, e.g., the CE may need to know when a backup CE has lost association. Such an event can be generated either by defining a second event on the same component (namely, an eventChanged) or by simply reusing eventBecomesEqualTo and using event properties (in particular, eventHysteresis). We append the following definition to the eventHysteresis defined in Section 4.8.5.2 of [RFC5812], with V being the hysteresis value:",
      "zh-CHS": "触发eventBecomesEqualTo事件后，当状态发生变化时通知CE可能会很有用，例如，CE可能需要知道备份CE何时失去关联。可以通过在同一组件上定义第二个事件（即eventChanged）或简单地重用eventBecomesEqualTo并使用事件属性（特别是EventHi滞）来生成此类事件。我们将以下定义附加到[RFC5812]第4.8.5.2节中定义的事件滞后，V为滞后值："
    },
    {
      "indent": 3,
      "text": "o For an eventBecomesEqualTo condition, after the last notification, a new eventBecomesEqualTo notification MUST be generated only one time once the value has changed by +/- V.",
      "zh-CHS": "o 对于eventBecomesEqualTo条件，在上次通知后，值更改+/-V后，只能生成一次新的eventBecomesEqualTo通知。"
    },
    {
      "indent": 3,
      "text": "For example, using the value of 1 for V will, in effect, create a singular event that will notify the CE that the value has changed by at least 1.",
      "zh-CHS": "例如，使用V的值1实际上将创建一个单一事件，该事件将通知CE该值已更改至少1。"
    },
    {
      "indent": 3,
      "text": "A developer of a CE should consider using count or time filtering to avoid being overrun by messages, e.g., in the case of rapid state changes.",
      "zh-CHS": "CE的开发人员应该考虑使用计数或时间过滤来避免消息的溢出，例如，在快速状态改变的情况下。"
    },
    {
      "indent": 0,
      "text": "2.5. LFB Properties",
      "section_title": true,
      "zh-CHS": "2.5. LFB特性"
    },
    {
      "indent": 3,
      "text": "The previous model definition specifies properties for components of LFBs. Experience has shown that, at least for debug reasons, it would be useful to have statistics per LFB instance to monitor sent and received messages and errors in communication between a CE and FE. These properties are read-only.",
      "zh-CHS": "前面的模型定义指定LFB组件的特性。经验表明，至少出于调试原因，为每个LFB实例提供统计信息以监控CE和FE之间通信中发送和接收的消息以及错误是有用的。这些属性是只读的。"
    },
    {
      "indent": 3,
      "text": "In order to avoid ambiguity on protocol path semantics, this document specifies that the LFB componentID 0 specifically MUST refer to LFB properties and ID 0 MUST NOT be used for any component definition. This disallowance is backward compatible as no known LFB definition uses an LFB componentID 0. Any command with a path starting from LFB componentID 0 refers to LFB properties. Figures 10 and 11 illustrate the change in the XML schema that disallows usage of LFB componentID 0:",
      "zh-CHS": "为了避免协议路径语义上的歧义，本文档规定LFB组件ID 0必须特别引用LFB属性，ID 0不得用于任何组件定义。此禁止是向后兼容的，因为没有已知的LFB定义使用LFB组件ID 0。路径从LFB组件ID 0开始的任何命令都引用LFB属性。图10和图11说明了XML模式中不允许使用LFB ComponentD 0的更改："
    },
    {
      "indent": 6,
      "text": "<xsd:attribute name=\"componentID\" type=\"xsd:unsignedInt\"\n use=\"required\">",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 16,
      "text": "Figure 10: Initial XML for LFB componentIDs",
      "zh-CHS": "图10:LFB组件的初始XML"
    },
    {
      "indent": 6,
      "text": "<!-- Extension added restriction to componentID -->\n<xsd:attribute name=\"componentID\" use=\"required\">\n  <xsd:simpleType>\n    <xsd:restriction base=\"xsd:unsignedInt\">\n      <xsd:minExclusive value=\"0\"/>\n    </xsd:restriction>\n  </xsd:simpleType>\n</xsd:attribute>\n<!-- End of extension -->",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "Figure 11: New XML to Disallow Usage of LFB componentID 0",
      "zh-CHS": "图11：不允许使用LFB组件ID 0的新XML"
    },
    {
      "indent": 3,
      "text": "The following data type definitions are to be used as properties for LFB instances.",
      "zh-CHS": "以下数据类型定义将用作LFB实例的属性。"
    },
    {
      "indent": 6,
      "text": "<dataTypeDef>\n   <name>LFBProperties</name>\n   <synopsis>LFB Properties definition</synopsis>\n   <struct>\n      <component componentID=\"1\">\n         <name>PacketsSentToCE</name>\n         <synopsis>Packets sent to CE</synopsis>\n         <typeRef>uint32</typeRef>\n      </component>\n      <component componentID=\"2\">\n         <name>SentErrorPacketsToCE</name>\n         <synopsis>Error Packets sent to CE</synopsis>\n         <typeRef>uint32</typeRef>\n      </component>\n      <component componentID=\"3\">\n         <name>BytesSentToCE</name>\n         <synopsis>Bytes sent to CE</synopsis>\n         <typeRef>uint32</typeRef>\n      </component>\n      <component componentID=\"4\">\n         <name>SentErrorBytesToCE</name>\n         <synopsis>Error Bytes sent to CE</synopsis>\n         <typeRef>uint32</typeRef>\n      </component>\n      <component componentID=\"5\">\n         <name>PacketsReceivedFromCE</name>\n         <synopsis>Packets received from CE</synopsis>\n         <typeRef>uint32</typeRef>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "      </component>\n      <component componentID=\"6\">\n         <name>ReceivedErrorPacketsFromCE</name>\n         <synopsis>Error Packets received from CE</synopsis>\n         <typeRef>uint32</typeRef>\n      </component>\n      <component componentID=\"7\">\n         <name>BytesReceivedFromCE</name>\n         <synopsis>Bytes received from CE</synopsis>\n         <typeRef>uint32</typeRef>\n      </component>\n      <component componentID=\"8\">\n         <name>ReceivedErrorBytesFromCE</name>\n         <synopsis>Error Bytes received from CE</synopsis>\n         <typeRef>uint32</typeRef>\n      </component>\n   </struct>\n</dataTypeDef>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 18,
      "text": "Figure 12: Properties for LFB Instances",
      "zh-CHS": "图12:LFB实例的属性"
    },
    {
      "indent": 0,
      "text": "2.6. LFB Class Inheritance",
      "section_title": true,
      "zh-CHS": "2.6. LFB类继承"
    },
    {
      "indent": 3,
      "text": "The ForCES model [RFC5812] allows inheritance for LFB classes. However, the XML schema defines only the LFB class from which an LFB class inherits. Recent implementations have identified an issue where ambiguity rises when different versions of the parent LFB class exist. This document augments the derivedFrom part of the LFB class definition with an optional version attribute when the derivedFrom field is used.",
      "zh-CHS": "ForCES模型[RFC5812]允许LFB类的继承。但是，XML模式仅定义LFB类从中继承的LFB类。最近的实现发现了一个问题，即当父LFB类的不同版本存在时，歧义会增加。当使用derivedFrom字段时，本文档使用可选的version属性扩充LFB类定义的DeriveFrom部分。"
    },
    {
      "indent": 3,
      "text": "Having the version attribute as optional was a decision based on the need to maintain backward compatibility with the XML schema defined in [RFC5812]. However, if the version is omitted, then derivedFrom will always specify the first version of the parent LFB class, which usually is version 1.0.",
      "zh-CHS": "将version属性作为可选属性是基于需要与[RFC5812]中定义的XML模式保持向后兼容性的决定。但是，如果省略了版本，那么derivedFrom将始终指定父LFB类的第一个版本，通常是版本1.0。"
    },
    {
      "indent": 3,
      "text": "This extension alters the definition of derivedFrom in the XML schema from the initial definition shown in Figure 13 to the new shown in Figure 14.",
      "zh-CHS": "这个扩展将XML模式中derivedFrom的定义从图13所示的初始定义更改为图14所示的新定义。"
    },
    {
      "indent": 6,
      "text": "<xsd:element name=\"derivedFrom\" minOccurs=\"0\"/>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 13,
      "text": "Figure 13: Initial XML for LFB Class Inheritance",
      "zh-CHS": "图13:LFB类继承的初始XML"
    },
    {
      "indent": 6,
      "text": "<xsd:element name=\"derivedFrom\" minOccurs=\"0\">\n  <xsd:complexType>\n    <xsd:simpleContent>\n      <xsd:extension base=\"xsd:NMTOKEN\">\n        <xsd:attribute name=\"version\"\n          type=\"versionType\" use=\"optional\"/>\n      </xsd:extension>\n    </xsd:simpleContent>\n  </xsd:complexType>\n</xsd:element>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 15,
      "text": "Figure 14: New XML for LFB Class Inheritance",
      "zh-CHS": "图14：LFB类继承的新XML"
    },
    {
      "indent": 3,
      "text": "An example of the use of the version attribute is given in Figure 15.",
      "zh-CHS": "图15给出了version属性的使用示例。"
    },
    {
      "indent": 6,
      "text": "<derivedFrom version=\"1.0\">EtherPHYCop</derivedFrom>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "Figure 15: Example of Use of New XML for LFB Class Inheritance",
      "zh-CHS": "图15：将新XML用于LFB类继承的示例"
    },
    {
      "indent": 0,
      "text": "2.7. Enhancing XML Validation",
      "section_title": true,
      "zh-CHS": "2.7. 增强XML验证"
    },
    {
      "indent": 3,
      "text": "As specified earlier, this is not an extension but an enhancement of the schema to provide additional validation rules. This includes adding new key declarations to provide uniqueness as defined by the ForCES model [RFC5812]. Such validations work only within the same XML file.",
      "zh-CHS": "如前所述，这不是对模式的扩展，而是对模式的增强，以提供额外的验证规则。这包括添加新的键声明，以提供ForCES模型[RFC5812]定义的唯一性。这种验证只在同一个XML文件中工作。"
    },
    {
      "indent": 3,
      "text": "This document introduces the following validation rules that did not exist in the original schema in [RFC5812]:",
      "zh-CHS": "本文档介绍了[RFC5812]中原始架构中不存在的以下验证规则："
    },
    {
      "indent": 3,
      "text": "1. Each metadataID must be unique.",
      "zh-CHS": "1. 每个元数据ID必须是唯一的。"
    },
    {
      "indent": 3,
      "text": "2. LFBClassIDs must be unique.",
      "zh-CHS": "2. LFBClassIDs必须是唯一的。"
    },
    {
      "indent": 3,
      "text": "3. componentID, capabilityID, and Event baseID must be unique per LFB.",
      "zh-CHS": "3. 每个LFB的componentID、capabilityID和Event baseID必须是唯一的。"
    },
    {
      "indent": 3,
      "text": "4. eventIDs must be unique per LFB.",
      "zh-CHS": "4. 每个LFB的EventID必须是唯一的。"
    },
    {
      "indent": 3,
      "text": "5. Special values in atomic data types must be unique per atomic data type.",
      "zh-CHS": "5. 每个原子数据类型中的特殊值必须是唯一的。"
    },
    {
      "indent": 0,
      "text": "3. XML Extension Schema for LFB Class Library Documents",
      "section_title": true,
      "zh-CHS": "3. LFB类库文档的XML扩展模式"
    },
    {
      "indent": 3,
      "text": "This section includes the new XML schema. Note that the namespace number has been updated from 1.0 to 1.1.",
      "zh-CHS": "本节包括新的XML模式。请注意，名称空间编号已从1.0更新为1.1。"
    },
    {
      "indent": 3,
      "text": "The extensions described in this document are backwards compatible in terms of the operation of the ForCES protocol. In terms of the XML, any definitions that were valid under the old namespace are valid under the new namespace. It is to be noted that any auxiliary tools that are processing XML definitions written under both namespaces will need to be able to understand both.",
      "zh-CHS": "本文件中描述的扩展在ForCES协议的操作方面是向后兼容的。就XML而言，在旧名称空间下有效的任何定义在新名称空间下都是有效的。需要注意的是，处理在这两个名称空间下编写的XML定义的任何辅助工具都需要能够理解这两个名称空间。"
    },
    {
      "indent": 0,
      "text": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\n   xmlns=\"urn:ietf:params:xml:ns:forces:lfbmodel:1.1\"\n   xmlns:lfb=\"urn:ietf:params:xml:ns:forces:lfbmodel:1.1\"\n   targetNamespace=\"urn:ietf:params:xml:ns:forces:lfbmodel:1.1\"\n   elementFormDefault=\"qualified\" attributeFormDefault=\"unqualified\">\n   <xsd:annotation>\n      <xsd:documentation xml:lang=\"en\">\n         Schema for Defining LFB Classes and associated types\n         (frames, data types for LFB attributes, and metadata).\n      </xsd:documentation>\n   </xsd:annotation>\n   <xsd:element name=\"description\" type=\"xsd:string\"/>\n   <xsd:element name=\"synopsis\" type=\"xsd:string\"/>\n   <!-- Document root element: LFBLibrary -->\n   <xsd:element name=\"LFBLibrary\">\n      <xsd:complexType>\n         <xsd:sequence>\n            <xsd:element ref=\"description\" minOccurs=\"0\"/>\n            <xsd:element name=\"load\" type=\"loadType\"\n               minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n            <xsd:element name=\"frameDefs\" type=\"frameDefsType\"\n               minOccurs=\"0\"/>\n            <xsd:element name=\"dataTypeDefs\" type=\"dataTypeDefsType\"\n               minOccurs=\"0\"/>\n            <xsd:element name=\"metadataDefs\" type=\"metadataDefsType\"\n               minOccurs=\"0\"/>\n            <xsd:element name=\"LFBClassDefs\" type=\"LFBClassDefsType\"\n               minOccurs=\"0\"/>\n         </xsd:sequence>\n         <xsd:attribute name=\"provides\" type=\"xsd:Name\"\n            use=\"required\"/>\n      </xsd:complexType>\n      <!-- Uniqueness constraints -->\n      <xsd:key name=\"frame\">\n         <xsd:selector xpath=\"lfb:frameDefs/lfb:frameDef\"/>\n         <xsd:field xpath=\"lfb:name\"/>\n      </xsd:key>\n      <xsd:key name=\"dataType\">\n         <xsd:selector xpath=\"lfb:dataTypeDefs/lfb:dataTypeDef\"/>\n         <xsd:field xpath=\"lfb:name\"/>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "   </xsd:key>\n   <xsd:key name=\"metadataDef\">\n      <xsd:selector xpath=\"lfb:metadataDefs/lfb:metadataDef\"/>\n      <xsd:field xpath=\"lfb:name\"/>\n   </xsd:key>\n   <xsd:key name=\"metadataDefID\">\n      <xsd:selector xpath=\"lfb:metadataDefs/lfb:metadataDef\"/>\n      <xsd:field xpath=\"lfb:metadataID\"/>\n   </xsd:key>\n   <xsd:key name=\"LFBClassDef\">\n      <xsd:selector xpath=\"lfb:LFBClassDefs/lfb:LFBClassDef\"/>\n      <xsd:field xpath=\"lfb:name\"/>\n   </xsd:key>\n   <xsd:key name=\"LFBClassDefID\">\n      <xsd:selector xpath=\"lfb:LFBClassDefs/lfb:LFBClassDef\"/>\n      <xsd:field xpath=\"@LFBClassID\"/>\n   </xsd:key>\n</xsd:element>\n<xsd:complexType name=\"loadType\">\n   <xsd:attribute name=\"library\" type=\"xsd:Name\" use=\"required\"/>\n   <xsd:attribute name=\"location\" type=\"xsd:anyURI\"\n      use=\"optional\"/>\n</xsd:complexType>\n<xsd:complexType name=\"frameDefsType\">\n   <xsd:sequence>\n      <xsd:element name=\"frameDef\" maxOccurs=\"unbounded\">\n         <xsd:complexType>\n            <xsd:sequence>\n               <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/>\n               <xsd:element ref=\"synopsis\"/>\n               <xsd:element ref=\"description\"\n                  minOccurs=\"0\"/>\n            </xsd:sequence>\n         </xsd:complexType>\n      </xsd:element>\n   </xsd:sequence>\n</xsd:complexType>\n<xsd:complexType name=\"dataTypeDefsType\">\n   <xsd:sequence>\n      <xsd:element name=\"dataTypeDef\" maxOccurs=\"unbounded\">\n         <xsd:complexType>\n            <xsd:sequence>\n               <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/>\n               <xsd:element name=\"derivedFrom\" type=\"xsd:NMTOKEN\"\n                  minOccurs=\"0\"/>\n               <xsd:element ref=\"synopsis\"/>\n               <xsd:element ref=\"description\"\n                  minOccurs=\"0\"/>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "               <xsd:group ref=\"typeDeclarationGroup\"/>\n               <!-- Extension RFC 7408 -->\n               <xsd:element name=\"defaultValue\" type=\"xsd:token\"\n                  minOccurs=\"0\"/>\n               <!-- /Extension RFC 7408 -->\n            </xsd:sequence>\n         </xsd:complexType>\n      </xsd:element>\n   </xsd:sequence>\n</xsd:complexType>\n<!-- Predefined (built-in) atomic data-types are: char, uchar,\nint16, uint16, int32, uint32, int64, uint64, string[N], string,\nbyte[N], boolean, octetstring[N], float32, float64 -->\n<xsd:group name=\"typeDeclarationGroup\">\n   <xsd:choice>\n      <xsd:element name=\"typeRef\" type=\"typeRefNMTOKEN\"/>\n      <xsd:element name=\"atomic\" type=\"atomicType\"/>\n      <xsd:element name=\"array\" type=\"arrayType\">\n         <!-- Extension RFC 7408 -->\n         <!-- declare keys to have unique IDs -->\n         <xsd:key name=\"contentKeyID\">\n            <xsd:selector xpath=\"lfb:contentKey\"/>\n            <xsd:field xpath=\"@contentKeyID\"/>\n         </xsd:key>\n         <!-- /Extension RFC 7408 -->\n      </xsd:element>\n      <xsd:element name=\"struct\" type=\"structType\">\n         <!-- Extension RFC 7408 -->\n         <!-- key declaration to make componentIDs\n           unique in a struct -->\n         <xsd:key name=\"structComponentID\">\n            <xsd:selector xpath=\"lfb:component\"/>\n            <xsd:field xpath=\"@componentID\"/>\n         </xsd:key>\n         <!-- /Extension RFC 7408 -->\n      </xsd:element>\n      <xsd:element name=\"union\" type=\"structType\"/>\n      <xsd:element name=\"alias\" type=\"typeRefNMTOKEN\"/>\n   </xsd:choice>\n</xsd:group>\n<xsd:simpleType name=\"typeRefNMTOKEN\">\n   <xsd:restriction base=\"xsd:token\">\n      <xsd:pattern value=\"\\c+\"/>\n      <xsd:pattern value=\"string\\[\\d+\\]\"/>\n      <xsd:pattern value=\"byte\\[\\d+\\]\"/>\n      <xsd:pattern value=\"octetstring\\[\\d+\\]\"/>\n   </xsd:restriction>\n</xsd:simpleType>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "<xsd:complexType name=\"atomicType\">\n   <xsd:sequence>\n      <xsd:element name=\"baseType\" type=\"typeRefNMTOKEN\"/>\n      <xsd:element name=\"rangeRestriction\"\n        type=\"rangeRestrictionType\" minOccurs=\"0\"/>\n      <xsd:element name=\"specialValues\" type=\"specialValuesType\"\n         minOccurs=\"0\">\n         <!-- Extension RFC 7408 -->\n         <xsd:key name=\"SpecialValue\">\n            <xsd:selector xpath=\"specialValue\"/>\n            <xsd:field xpath=\"@value\"/>\n         </xsd:key>\n         <!-- /Extension RFC 7408 -->\n      </xsd:element>\n   </xsd:sequence>\n</xsd:complexType>\n<xsd:complexType name=\"rangeRestrictionType\">\n   <xsd:sequence>\n      <xsd:element name=\"allowedRange\" maxOccurs=\"unbounded\">\n         <xsd:complexType>\n            <xsd:attribute name=\"min\" type=\"xsd:integer\"\n               use=\"required\"/>\n            <xsd:attribute name=\"max\" type=\"xsd:integer\"\n               use=\"required\"/>\n         </xsd:complexType>\n      </xsd:element>\n   </xsd:sequence>\n</xsd:complexType>\n<xsd:complexType name=\"specialValuesType\">\n   <xsd:sequence>\n      <xsd:element name=\"specialValue\" maxOccurs=\"unbounded\">\n         <xsd:complexType>\n            <xsd:sequence>\n               <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/>\n               <xsd:element ref=\"synopsis\"/>\n            </xsd:sequence>\n            <xsd:attribute name=\"value\" type=\"xsd:token\"/>\n         </xsd:complexType>\n      </xsd:element>\n   </xsd:sequence>\n</xsd:complexType>\n<xsd:complexType name=\"arrayType\">\n   <xsd:sequence>\n      <xsd:group ref=\"typeDeclarationGroup\"/>\n      <xsd:element name=\"contentKey\" minOccurs=\"0\"\n         maxOccurs=\"unbounded\">\n         <xsd:complexType>\n            <xsd:sequence>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "               <xsd:element name=\"contentKeyField\"\n                  type=\"xsd:string\" maxOccurs=\"unbounded\"/>\n            </xsd:sequence>\n            <xsd:attribute name=\"contentKeyID\" type=\"xsd:integer\"\n               use=\"required\"/>\n         </xsd:complexType>\n      </xsd:element>\n   </xsd:sequence>\n   <xsd:attribute name=\"type\" use=\"optional\" default=\"variable-size\">\n      <xsd:simpleType>\n         <xsd:restriction base=\"xsd:string\">\n            <xsd:enumeration value=\"fixed-size\"/>\n            <xsd:enumeration value=\"variable-size\"/>\n         </xsd:restriction>\n      </xsd:simpleType>\n   </xsd:attribute>\n   <xsd:attribute name=\"length\" type=\"xsd:integer\"\n      use=\"optional\"/>\n   <xsd:attribute name=\"maxLength\" type=\"xsd:integer\"\n      use=\"optional\"/>\n</xsd:complexType>\n<xsd:complexType name=\"structType\">\n   <xsd:sequence>\n      <xsd:element name=\"derivedFrom\" type=\"typeRefNMTOKEN\"\n         minOccurs=\"0\"/>\n      <xsd:element name=\"component\" maxOccurs=\"unbounded\">\n         <xsd:complexType>\n            <xsd:sequence>\n               <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/>\n               <xsd:element ref=\"synopsis\"/>\n               <xsd:element ref=\"description\"\n                  minOccurs=\"0\"/>\n               <xsd:element name=\"optional\" minOccurs=\"0\"/>\n               <xsd:group ref=\"typeDeclarationGroup\"/>\n            </xsd:sequence>\n            <!-- Extension RFC 7408 -->\n            <xsd:attribute name=\"access\" use=\"optional\"\n               default=\"read-write\">\n               <xsd:simpleType>\n                  <xsd:list itemType=\"accessModeType\"/>\n               </xsd:simpleType>\n            </xsd:attribute>\n            <!-- Extension RFC 7408 -->\n            <xsd:attribute name=\"componentID\" type=\"xsd:unsignedInt\"\n               use=\"required\"/>\n         </xsd:complexType>\n      </xsd:element>\n   </xsd:sequence>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "</xsd:complexType>\n<xsd:complexType name=\"metadataDefsType\">\n   <xsd:sequence>\n      <xsd:element name=\"metadataDef\" maxOccurs=\"unbounded\">\n         <xsd:complexType>\n            <xsd:sequence>\n               <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/>\n               <xsd:element ref=\"synopsis\"/>\n               <xsd:element name=\"metadataID\" type=\"xsd:integer\"/>\n               <xsd:element ref=\"description\"\n                  minOccurs=\"0\"/>\n               <xsd:choice>\n                  <xsd:element name=\"typeRef\" type=\"typeRefNMTOKEN\"/>\n                  <xsd:element name=\"atomic\" type=\"atomicType\"/>\n                  <!-- Extension RFC 7408 -->\n                  <xsd:element name=\"array\" type=\"arrayType\">\n                     <!--declare keys to have unique IDs -->\n                     <xsd:key name=\"contentKeyID1\">\n                        <xsd:selector xpath=\"lfb:contentKey\"/>\n                        <xsd:field xpath=\"@contentKeyID\"/>\n                     </xsd:key>\n                     <!-- /Extension RFC 7408 -->\n                  </xsd:element>\n                  <xsd:element name=\"struct\" type=\"structType\">\n                     <!-- Extension RFC 7408 -->\n                     <!-- key declaration to make componentIDs\n                        unique in a struct -->\n                     <xsd:key name=\"structComponentID1\">\n                        <xsd:selector xpath=\"lfb:component\"/>\n                        <xsd:field xpath=\"@componentID\"/>\n                     </xsd:key>\n                     <!-- /Extension RFC 7408 -->\n                  </xsd:element>\n               </xsd:choice>\n            </xsd:sequence>\n         </xsd:complexType>\n      </xsd:element>\n   </xsd:sequence>\n</xsd:complexType>\n<xsd:complexType name=\"LFBClassDefsType\">\n   <xsd:sequence>\n      <xsd:element name=\"LFBClassDef\" maxOccurs=\"unbounded\">\n         <xsd:complexType>\n            <xsd:sequence>\n               <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/>\n               <xsd:element ref=\"synopsis\"/>\n               <xsd:element name=\"version\" type=\"versionType\"/>\n               <xsd:element name=\"derivedFrom\" minOccurs=\"0\">",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 12,
      "text": "        <xsd:complexType>\n          <xsd:simpleContent>\n            <xsd:extension base=\"xsd:NMTOKEN\">\n              <xsd:attribute name=\"version\"\n                type=\"versionType\" use=\"optional\"/>\n            </xsd:extension>\n          </xsd:simpleContent>\n        </xsd:complexType>\n      </xsd:element>\n      <xsd:element name=\"inputPorts\"\n       type=\"inputPortsType\" minOccurs=\"0\"/>\n      <xsd:element name=\"outputPorts\"\n       type=\"outputPortsType\" minOccurs=\"0\"/>\n      <xsd:element name=\"components\"\n       type=\"LFBComponentsType\" minOccurs=\"0\"/>\n      <xsd:element name=\"capabilities\"\n       type=\"LFBCapabilitiesType\" minOccurs=\"0\"/>\n      <xsd:element name=\"events\" type=\"eventsType\"\n         minOccurs=\"0\"/>\n      <xsd:element ref=\"description\"\n         minOccurs=\"0\"/>\n   </xsd:sequence>\n   <xsd:attribute name=\"LFBClassID\" type=\"xsd:unsignedInt\"\n      use=\"required\"/>\n</xsd:complexType>\n<!-- Key constraint to ensure unique attribute names\nwithin a class: -->\n<xsd:key name=\"components\">\n   <xsd:selector xpath=\"lfb:components/lfb:component\"/>\n   <xsd:field xpath=\"lfb:name\"/>\n</xsd:key>\n<xsd:key name=\"capabilities\">\n   <xsd:selector xpath=\"lfb:capabilities/lfb:capability\"/>\n   <xsd:field xpath=\"lfb:name\"/>\n</xsd:key>\n<xsd:key name=\"events\">\n   <xsd:selector xpath=\"lfb:events/lfb:event\"/>\n   <xsd:field xpath=\"lfb:name\"/>\n</xsd:key>\n<xsd:key name=\"eventsIDs\">\n   <xsd:selector xpath=\"lfb:events/lfb:event\"/>\n   <xsd:field xpath=\"@eventID\"/>\n</xsd:key>\n<xsd:key name=\"componentIDs\">\n   <xsd:selector xpath=\"lfb:components/lfb:component\"/>\n   <xsd:field xpath=\"@componentID\"/>\n</xsd:key>\n<xsd:key name=\"capabilityIDs\">",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "            <xsd:selector xpath=\"lfb:capabilities/lfb:capability\"/>\n            <xsd:field xpath=\"@componentID\"/>\n         </xsd:key>\n         <xsd:key name=\"ComponentCapabilityComponentIDUniqueness\">\n            <xsd:selector\n               xpath=\"lfb:components/lfb:component|\n               lfb:capabilities/lfb:capability|lfb:events\"/>\n            <xsd:field xpath=\"@componentID|@baseID\"/>\n         </xsd:key>\n      </xsd:element>\n   </xsd:sequence>\n</xsd:complexType>\n<xsd:simpleType name=\"versionType\">\n   <xsd:restriction base=\"xsd:NMTOKEN\">\n      <xsd:pattern value=\"[1-9][0-9]*\\.([1-9][0-9]*|0)\"/>\n   </xsd:restriction>\n</xsd:simpleType>\n<xsd:complexType name=\"inputPortsType\">\n   <xsd:sequence>\n      <xsd:element name=\"inputPort\" type=\"inputPortType\"\n         maxOccurs=\"unbounded\"/>\n   </xsd:sequence>\n</xsd:complexType>\n<xsd:complexType name=\"inputPortType\">\n   <xsd:sequence>\n      <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/>\n      <xsd:element ref=\"synopsis\"/>\n      <xsd:element name=\"expectation\" type=\"portExpectationType\"/>\n      <xsd:element ref=\"description\" minOccurs=\"0\"/>\n   </xsd:sequence>\n   <xsd:attribute name=\"group\" type=\"xsd:boolean\"\n      use=\"optional\" default=\"0\"/>\n</xsd:complexType>\n<xsd:complexType name=\"portExpectationType\">\n   <xsd:sequence>\n      <xsd:element name=\"frameExpected\" minOccurs=\"0\">\n         <xsd:complexType>\n            <xsd:sequence>\n               <!-- ref must refer to a name of a defined\n                 frame type -->\n               <xsd:element name=\"ref\" type=\"xsd:string\"\n                  maxOccurs=\"unbounded\"/>\n            </xsd:sequence>\n         </xsd:complexType>\n      </xsd:element>\n      <xsd:element name=\"metadataExpected\" minOccurs=\"0\">\n         <xsd:complexType>\n            <xsd:choice maxOccurs=\"unbounded\">",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "               <!--ref must refer to a name of a defined metadata-->\n               <xsd:element name=\"ref\" type=\"metadataInputRefType\"/>\n               <xsd:element name=\"one-of\"\n                  type=\"metadataInputChoiceType\"/>\n            </xsd:choice>\n         </xsd:complexType>\n      </xsd:element>\n   </xsd:sequence>\n</xsd:complexType>\n<xsd:complexType name=\"metadataInputChoiceType\">\n   <xsd:choice minOccurs=\"2\" maxOccurs=\"unbounded\">\n      <!-- ref must refer to a name of a defined metadata -->\n      <xsd:element name=\"ref\" type=\"xsd:NMTOKEN\"/>\n      <xsd:element name=\"one-of\" type=\"metadataInputChoiceType\"/>\n      <xsd:element name=\"metadataSet\" type=\"metadataInputSetType\"/>\n   </xsd:choice>\n</xsd:complexType>\n<xsd:complexType name=\"metadataInputSetType\">\n   <xsd:choice minOccurs=\"2\" maxOccurs=\"unbounded\">\n      <!-- ref must refer to a name of a defined metadata -->\n      <xsd:element name=\"ref\" type=\"metadataInputRefType\"/>\n      <xsd:element name=\"one-of\" type=\"metadataInputChoiceType\"/>\n   </xsd:choice>\n</xsd:complexType>\n<xsd:complexType name=\"metadataInputRefType\">\n   <xsd:simpleContent>\n      <xsd:extension base=\"xsd:NMTOKEN\">\n         <xsd:attribute name=\"dependency\" use=\"optional\"\n            default=\"required\">\n            <xsd:simpleType>\n               <xsd:restriction base=\"xsd:string\">\n                  <xsd:enumeration value=\"required\"/>\n                  <xsd:enumeration value=\"optional\"/>\n               </xsd:restriction>\n            </xsd:simpleType>\n         </xsd:attribute>\n         <xsd:attribute name=\"defaultValue\" type=\"xsd:token\"\n            use=\"optional\"/>\n      </xsd:extension>\n   </xsd:simpleContent>\n</xsd:complexType>\n<xsd:complexType name=\"outputPortsType\">\n   <xsd:sequence>\n      <xsd:element name=\"outputPort\" type=\"outputPortType\"\n         maxOccurs=\"unbounded\"/>\n   </xsd:sequence>\n</xsd:complexType>\n<xsd:complexType name=\"outputPortType\">",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "   <xsd:sequence>\n      <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/>\n      <xsd:element ref=\"synopsis\"/>\n      <xsd:element name=\"product\" type=\"portProductType\"/>\n      <xsd:element ref=\"description\" minOccurs=\"0\"/>\n   </xsd:sequence>\n   <xsd:attribute name=\"group\" type=\"xsd:boolean\"\n      use=\"optional\" default=\"0\"/>\n</xsd:complexType>\n<xsd:complexType name=\"portProductType\">\n   <xsd:sequence>\n      <xsd:element name=\"frameProduced\" minOccurs=\"0\">\n         <xsd:complexType>\n            <xsd:sequence>\n               <!-- ref must refer to a name of a defined\n                  frame type -->\n               <xsd:element name=\"ref\" type=\"xsd:NMTOKEN\"\n                  maxOccurs=\"unbounded\"/>\n            </xsd:sequence>\n         </xsd:complexType>\n      </xsd:element>\n      <xsd:element name=\"metadataProduced\" minOccurs=\"0\">\n         <xsd:complexType>\n            <xsd:choice maxOccurs=\"unbounded\">\n               <!-- ref must refer to a name of a\n                  defined metadata -->\n               <xsd:element name=\"ref\"\n                  type=\"metadataOutputRefType\"/>\n               <xsd:element name=\"one-of\"\n                  type=\"metadataOutputChoiceType\"/>\n            </xsd:choice>\n         </xsd:complexType>\n      </xsd:element>\n   </xsd:sequence>\n</xsd:complexType>\n<xsd:complexType name=\"metadataOutputChoiceType\">\n   <xsd:choice minOccurs=\"2\" maxOccurs=\"unbounded\">\n      <!-- ref must refer to a name of a defined metadata -->\n      <xsd:element name=\"ref\" type=\"xsd:NMTOKEN\"/>\n      <xsd:element name=\"one-of\" type=\"metadataOutputChoiceType\"/>\n      <xsd:element name=\"metadataSet\" type=\"metadataOutputSetType\"/>\n   </xsd:choice>\n</xsd:complexType>\n<xsd:complexType name=\"metadataOutputSetType\">\n   <xsd:choice minOccurs=\"2\" maxOccurs=\"unbounded\">\n      <!-- ref must refer to a name of a defined metadata -->\n      <xsd:element name=\"ref\" type=\"metadataOutputRefType\"/>\n      <xsd:element name=\"one-of\" type=\"metadataOutputChoiceType\"/>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "   </xsd:choice>\n</xsd:complexType>\n<xsd:complexType name=\"metadataOutputRefType\">\n   <xsd:simpleContent>\n      <xsd:extension base=\"xsd:NMTOKEN\">\n         <xsd:attribute name=\"availability\" use=\"optional\"\n            default=\"unconditional\">\n            <xsd:simpleType>\n               <xsd:restriction base=\"xsd:string\">\n                  <xsd:enumeration value=\"unconditional\"/>\n                  <xsd:enumeration value=\"conditional\"/>\n               </xsd:restriction>\n            </xsd:simpleType>\n         </xsd:attribute>\n      </xsd:extension>\n   </xsd:simpleContent>\n</xsd:complexType>\n<xsd:complexType name=\"LFBComponentsType\">\n   <xsd:sequence>\n      <xsd:element name=\"component\" maxOccurs=\"unbounded\">\n         <xsd:complexType>\n            <xsd:sequence>\n               <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/>\n               <xsd:element ref=\"synopsis\"/>\n               <xsd:element ref=\"description\"\n                  minOccurs=\"0\"/>\n               <xsd:element name=\"optional\" minOccurs=\"0\"/>\n               <xsd:group ref=\"typeDeclarationGroup\"/>\n               <xsd:element name=\"defaultValue\" type=\"xsd:token\"\n                  minOccurs=\"0\"/>\n            </xsd:sequence>\n            <xsd:attribute name=\"access\" use=\"optional\"\n               default=\"read-write\">\n               <xsd:simpleType>\n                  <xsd:list itemType=\"accessModeType\"/>\n               </xsd:simpleType>\n            </xsd:attribute>\n            <!-- Extension added restriction to componentID -->\n            <xsd:attribute name=\"componentID\" use=\"required\">\n               <xsd:simpleType>\n                  <xsd:restriction base=\"xsd:unsignedInt\">\n                     <xsd:minExclusive value=\"0\"/>\n                  </xsd:restriction>\n               </xsd:simpleType>\n            </xsd:attribute>\n            <!-- End of extension -->\n         </xsd:complexType>\n      </xsd:element>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "   </xsd:sequence>\n</xsd:complexType>\n<xsd:simpleType name=\"accessModeType\">\n   <xsd:restriction base=\"xsd:NMTOKEN\">\n      <xsd:enumeration value=\"read-only\"/>\n      <xsd:enumeration value=\"read-write\"/>\n      <xsd:enumeration value=\"write-only\"/>\n      <xsd:enumeration value=\"read-reset\"/>\n      <xsd:enumeration value=\"trigger-only\"/>\n   </xsd:restriction>\n</xsd:simpleType>\n<xsd:complexType name=\"LFBCapabilitiesType\">\n   <xsd:sequence>\n      <xsd:element name=\"capability\" maxOccurs=\"unbounded\">\n         <xsd:complexType>\n            <xsd:sequence>\n               <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/>\n               <xsd:element ref=\"synopsis\"/>\n               <xsd:element ref=\"description\"\n                  minOccurs=\"0\"/>\n               <xsd:element name=\"optional\" minOccurs=\"0\"/>\n               <xsd:group ref=\"typeDeclarationGroup\"/>\n            </xsd:sequence>\n            <xsd:attribute name=\"componentID\" type=\"xsd:integer\"\n               use=\"required\"/>\n         </xsd:complexType>\n      </xsd:element>\n   </xsd:sequence>\n</xsd:complexType>\n<xsd:complexType name=\"eventsType\">\n   <xsd:sequence>\n      <xsd:element name=\"event\" maxOccurs=\"unbounded\">\n         <xsd:complexType>\n            <xsd:sequence>\n               <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/>\n               <xsd:element ref=\"synopsis\"/>\n               <xsd:element name=\"eventTarget\"\n                 type=\"eventPathType\"/>\n               <xsd:element ref=\"eventCondition\"/>\n               <xsd:element name=\"eventReports\"\n                type=\"eventReportsType\" minOccurs=\"0\"/>\n               <xsd:element ref=\"description\"\n                  minOccurs=\"0\"/>\n            </xsd:sequence>\n            <xsd:attribute name=\"eventID\" type=\"xsd:integer\"\n               use=\"required\"/>\n         </xsd:complexType>\n      </xsd:element>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "      </xsd:sequence>\n      <xsd:attribute name=\"baseID\" type=\"xsd:integer\"\n         use=\"optional\"/>\n   </xsd:complexType>\n   <!-- the substitution group for the event conditions -->\n   <xsd:element name=\"eventCondition\" abstract=\"true\"/>\n   <xsd:element name=\"eventCreated\"\n    substitutionGroup=\"eventCondition\"/>\n   <xsd:element name=\"eventDeleted\"\n    substitutionGroup=\"eventCondition\"/>\n   <xsd:element name=\"eventChanged\"\n    substitutionGroup=\"eventCondition\"/>\n   <xsd:element name=\"eventGreaterThan\"\n    substitutionGroup=\"eventCondition\"/>\n   <xsd:element name=\"eventLessThan\"\n    substitutionGroup=\"eventCondition\"/>\n   <!-- Extension RFC 7408 -->\n   <xsd:element name=\"eventBecomesEqualTo\"\n      substitutionGroup=\"eventCondition\"/>\n   <!-- /Extension RFC 7408 -->\n   <xsd:complexType name=\"eventPathType\">\n      <xsd:sequence>\n         <xsd:element ref=\"eventPathPart\" maxOccurs=\"unbounded\"/>\n      </xsd:sequence>\n   </xsd:complexType>\n   <!-- the substitution group for the event path parts -->\n   <xsd:element name=\"eventPathPart\" type=\"xsd:string\"\n      abstract=\"true\"/>\n   <xsd:element name=\"eventField\" type=\"xsd:string\"\n      substitutionGroup=\"eventPathPart\"/>\n   <xsd:element name=\"eventSubscript\" type=\"xsd:string\"\n      substitutionGroup=\"eventPathPart\"/>\n   <xsd:complexType name=\"eventReportsType\">\n      <xsd:sequence>\n         <xsd:element name=\"eventReport\" type=\"eventPathType\"\n            maxOccurs=\"unbounded\"/>\n      </xsd:sequence>\n   </xsd:complexType>\n   <xsd:simpleType name=\"booleanType\">\n      <xsd:restriction base=\"xsd:string\">\n         <xsd:enumeration value=\"0\"/>\n         <xsd:enumeration value=\"1\"/>\n      </xsd:restriction>\n   </xsd:simpleType>\n</xsd:schema>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 27,
      "text": "ForCES LFB XML Schema",
      "zh-CHS": "强制LFB XML模式"
    },
    {
      "indent": 0,
      "text": "4. IANA Considerations",
      "section_title": true,
      "zh-CHS": "4. IANA考虑"
    },
    {
      "indent": 3,
      "text": "IANA has registered a new XML namespace, as per the guidelines in RFC 3688 [RFC3688].",
      "zh-CHS": "IANA已根据RFC 3688[RFC3688]中的指南注册了一个新的XML名称空间。"
    },
    {
      "indent": 3,
      "text": "URI: The URI for this namespace is:",
      "zh-CHS": "URI:此命名空间的URI为："
    },
    {
      "indent": 6,
      "text": "urn:ietf:params:xml:ns:forces:lfbmodel:1.1",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Registrant Contact: IESG",
      "zh-CHS": "注册联系人：IESG"
    },
    {
      "indent": 3,
      "text": "XML: none, this is an XML namespace",
      "zh-CHS": "XML：无，这是一个XML名称空间"
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "zh-CHS": "5. 安全考虑"
    },
    {
      "indent": 3,
      "text": "This specification adds only a few constructs to the initial model defined in [RFC5812], namely, a new event, some new properties, and a way to define optional access types and complex metadata. In addition, this document addresses and clarifies an issue with the inheritance model by introducing the version of the derivedFrom LFB class. These constructs and the update to the inheritance model do not change the nature of the initial model.",
      "zh-CHS": "本规范仅向[RFC5812]中定义的初始模型添加了几个构造，即新事件、一些新属性以及定义可选访问类型和复杂元数据的方法。此外，本文档通过介绍derivedFrom LFB类的版本，解决并澄清了继承模型的一个问题。这些构造和对继承模型的更新不会改变初始模型的性质。"
    },
    {
      "indent": 3,
      "text": "Thus, the security considerations defined in [RFC5812] apply to this specification as well, as the changes proposed here are simply constructs to write XML library definitions, as [RFC5812] does. These changes, as well as the clarification of the inheritance issue of the initial model, have no effect on the security semantics of the protocol.",
      "zh-CHS": "因此，[RFC5812]中定义的安全注意事项也适用于本规范，因为这里提出的更改只是编写XML库定义的构造，正如[RFC5812]所做的那样。这些更改，以及对初始模型继承问题的澄清，对协议的安全语义没有影响。"
    },
    {
      "indent": 3,
      "text": "In regard to pervasive monitoring (PM), as discussed in [RFC7258], this specification defines ways to expose more complex information (namely, metadata) exchanged between LFBs and between CEs and FEs and a new event. These changes have very little or no effect in terms of making PM simpler or more effective to an attacker who controls the LFBs. The new metadata might make for slightly more elegant PM, but does not enable any new ways to (ab)use LFBs for PM. The same applies for the new event.",
      "zh-CHS": "关于普适监控（PM），如[RFC7258]中所述，本规范定义了公开LFB之间、CEs和FEs之间以及新事件之间交换的更复杂信息（即元数据）的方法。对于控制LFB的攻击者来说，这些更改对于使PM更简单或更有效而言几乎没有影响。新的元数据可能会使PM更优雅一些，但不会启用（ab）将LFB用于PM的任何新方法。这同样适用于新事件。"
    },
    {
      "indent": 3,
      "text": "Finally, this document does not provide any protocol specification and, as such, does not specify how information will be transmitted between respective entities. Thus, PM mitigation for a passive attacker that simply wants to eavesdrop on the information exchanged is out of the scope of this document.",
      "zh-CHS": "最后，本文件未提供任何协议规范，因此也未规定各实体之间如何传输信息。因此，对于只想窃听交换信息的被动攻击者，PM缓解措施不在本文档的范围之内。"
    },
    {
      "indent": 0,
      "text": "6. References",
      "section_title": true,
      "zh-CHS": "6. 工具书类"
    },
    {
      "indent": 0,
      "text": "6.1. Normative References",
      "section_title": true,
      "zh-CHS": "6.1. 规范性引用文件"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "zh-CHS": "[RFC2119]Bradner，S.，“RFC中用于表示需求水平的关键词”，BCP 14，RFC 2119，1997年3月<http://www.rfc-editor.org/info/rfc2119>."
    },
    {
      "indent": 3,
      "text": "[RFC3688] Mealling, M., \"The IETF XML Registry\", BCP 81, RFC 3688, January 2004, <http://www.rfc-editor.org/info/rfc3688>.",
      "zh-CHS": "[RFC3688]Mealling，M.“IETF XML注册表”，BCP 81，RFC 3688，2004年1月<http://www.rfc-editor.org/info/rfc3688>."
    },
    {
      "indent": 3,
      "text": "[RFC5810] Doria, A., Hadi Salim, J., Haas, R., Khosravi, H., Wang, W., Dong, L., Gopal, R., and J. Halpern, \"Forwarding and Control Element Separation (ForCES) Protocol Specification\", RFC 5810, March 2010, <http://www.rfc-editor.org/info/rfc5810>.",
      "zh-CHS": "[RFC5810]Doria，A.，Hadi Salim，J.，Haas，R.，Khosravi，H.，Wang，W.，Dong，L.，Gopal，R.，和J.Halpern，“转发和控制元件分离（部队）协议规范”，RFC 58102010年3月<http://www.rfc-editor.org/info/rfc5810>."
    },
    {
      "indent": 3,
      "text": "[RFC5812] Halpern, J. and J. Hadi Salim, \"Forwarding and Control Element Separation (ForCES) Forwarding Element Model\", RFC 5812, March 2010, <http://www.rfc-editor.org/info/rfc5812>.",
      "zh-CHS": "[RFC5812]Halpern，J.和J.Hadi Salim，“转发和控制单元分离（部队）转发单元模型”，RFC 5812，2010年3月<http://www.rfc-editor.org/info/rfc5812>."
    },
    {
      "indent": 3,
      "text": "[RFC7121] Ogawa, K., Wang, W., Haleplidis, E., and J. Hadi Salim, \"High Availability within a Forwarding and Control Element Separation (ForCES) Network Element\", RFC 7121, February 2014, <http://www.rfc-editor.org/info/rfc7121>.",
      "zh-CHS": "[RFC7121]Ogawa，K.，Wang，W.，Haleplidis，E.，和J.Hadi Salim，“转发和控制单元分离（部队）网元内的高可用性”，RFC 71212014年2月<http://www.rfc-editor.org/info/rfc7121>."
    },
    {
      "indent": 3,
      "text": "[RFC7258] Farrell, S. and H. Tschofenig, \"Pervasive Monitoring Is an Attack\", BCP 188, RFC 7258, May 2014, <http://www.rfc-editor.org/info/rfc7258>.",
      "zh-CHS": "[RFC7258]Farrell，S.和H.Tschofenig，“普遍监控是一种攻击”，BCP 188，RFC 7258，2014年5月<http://www.rfc-editor.org/info/rfc7258>."
    },
    {
      "indent": 0,
      "text": "6.2. Informative References",
      "section_title": true,
      "zh-CHS": "6.2. 资料性引用"
    },
    {
      "indent": 3,
      "text": "[OpenFlowSpec1.1] ONF, \"OpenFlow Switch Specification\", February 2011, <https://www.opennetworking.org/images/stories/downloads/ sdn-resources/onf-specifications/openflow/ openflow-spec-v1.1.0.pdf>.",
      "zh-CHS": "[OpenFlowSpec1.1]ONF，“OpenFlow开关规范”，2011年2月<https://www.opennetworking.org/images/stories/downloads/ sdn资源/onf规范/openflow/openflow-spec-v1.1.0.pdf>。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "zh-CHS": "致谢"
    },
    {
      "indent": 3,
      "text": "The author would like to acknowledge Joel Halpern, Jamal Hadi Salim, and Dave Hood for their comments and discussion that helped shape this document for the better. Special acknowledgements to Joel Halpern for resolving the issue with the default values, Adrian Farrel for his AD review, Ben Campbell for his Gen-ART review, and Tom Yu for his security review, all of which improved the quality of this document. Additionally, reviews and comments by the following members of the IESG shaped the final version of this document: Stephen Farrel, Barry Leiba, and Ted Lemon. Finally, the author would like to acknowledge Julian Reschke for input regarding the namespace change issue and Joel Halpern for helping to resolve it.",
      "zh-CHS": "作者要感谢Joel Halpern、Jamal Hadi Salim和Dave Hood的评论和讨论，他们的评论和讨论帮助本文件变得更好。特别感谢Joel Halpern使用默认值解决问题，Adrian Farrel进行广告审查，Ben Campbell进行Gen ART审查，Tom Yu进行安全审查，所有这些都提高了本文档的质量。此外，IESG以下成员的审查和评论形成了本文件的最终版本：Stephen Farrel、Barry Leiba和Ted Lemon。最后，作者要感谢Julian Reschke对名称空间更改问题的意见，以及Joel Halpern对解决该问题的帮助。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "zh-CHS": "作者地址"
    },
    {
      "indent": 3,
      "text": "Evangelos Haleplidis University of Patras Department of Electrical and Computer Engineering Patras 26500 Greece",
      "zh-CHS": "佩特雷大学电气与计算机工程系帕特雷26500希腊分校"
    },
    {
      "indent": 3,
      "text": "EMail: ehalep@ece.upatras.gr",
      "raw": true,
      "zh-CHS": " "
    }
  ]
}