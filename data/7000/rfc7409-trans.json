{
  "title": {
    "text": "RFC 7409: Forwarding and Control Element Separation (ForCES) Packet Parallelization",
    "zh-CHS": "RFC 7409"
  },
  "number": 7409,
  "created_at": "2021-11-02 21:33:39.258273+08:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                     E. Haleplidis\nRequest for Comments: 7409                          University of Patras\nCategory: Experimental                                        J. Halpern\nISSN: 2070-1721                                                 Ericsson\n                                                           November 2014",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 11,
      "text": "Forwarding and Control Element Separation (ForCES) Packet Parallelization",
      "zh-CHS": "转发和控制元素分离（ForCES）数据包并行化"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "zh-CHS": "摘要"
    },
    {
      "indent": 3,
      "text": "Many network devices support parallel packet processing. This document describes how Forwarding and Control Element Separation (ForCES) can model a network device's parallelization datapath using constructs defined by the ForCES model (RFC 5812) and controlled via the ForCES protocol (RFC 5810).",
      "zh-CHS": "许多网络设备支持并行数据包处理。本文档描述了转发和控制元素分离（ForCES）如何使用ForCES模型（RFC 5812）定义并通过ForCES协议（RFC 5810）控制的结构对网络设备的并行化数据路径进行建模。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "zh-CHS": "关于下段备忘"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.",
      "zh-CHS": "本文件不是互联网标准跟踪规范；它是为检查、实验实施和评估而发布的。"
    },
    {
      "indent": 3,
      "text": "This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "zh-CHS": "本文档为互联网社区定义了一个实验协议。本文件是互联网工程任务组（IETF）的产品。它代表了IETF社区的共识。它已经接受了公众审查，并已被互联网工程指导小组（IESG）批准出版。并非IESG批准的所有文件都适用于任何级别的互联网标准；见RFC 5741第2节。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7409.",
      "zh-CHS": "有关本文件当前状态、任何勘误表以及如何提供反馈的信息，请访问http://www.rfc-editor.org/info/rfc7409."
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "zh-CHS": "版权公告"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2014 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "zh-CHS": "版权所有（c）2014 IETF信托基金和确定为文件作者的人员。版权所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "zh-CHS": "本文件受BCP 78和IETF信托有关IETF文件的法律规定的约束(http://trustee.ietf.org/license-info)自本文件出版之日起生效。请仔细阅读这些文件，因为它们描述了您对本文件的权利和限制。从本文件中提取的代码组件必须包括信托法律条款第4.e节中所述的简化BSD许可证文本，并提供简化BSD许可证中所述的无担保。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "zh-CHS": "目录"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4\n  1.1.  Requirements Language . . . . . . . . . . . . . . . . . .   4\n  1.2.  Definitions . . . . . . . . . . . . . . . . . . . . . . .   4\n2.  Packet Parallelization  . . . . . . . . . . . . . . . . . . .   5\n  2.1.  CoreParallelization LFB . . . . . . . . . . . . . . . . .   7\n  2.2.  Parallelization Metadata  . . . . . . . . . . . . . . . .  10\n3.  Parallel Base Types . . . . . . . . . . . . . . . . . . . . .  11\n  3.1.  Frame Types . . . . . . . . . . . . . . . . . . . . . . .  11\n  3.2.  Data Types  . . . . . . . . . . . . . . . . . . . . . . .  11\n  3.3.  Metadata Types  . . . . . . . . . . . . . . . . . . . . .  12\n4.  Parallel LFBs . . . . . . . . . . . . . . . . . . . . . . . .  12\n  4.1.  Splitter  . . . . . . . . . . . . . . . . . . . . . . . .  12\n    4.1.1.  Data Handling . . . . . . . . . . . . . . . . . . . .  13\n    4.1.2.  Components  . . . . . . . . . . . . . . . . . . . . .  13\n    4.1.3.  Capabilities  . . . . . . . . . . . . . . . . . . . .  13\n    4.1.4.  Events  . . . . . . . . . . . . . . . . . . . . . . .  13\n  4.2.  Merger  . . . . . . . . . . . . . . . . . . . . . . . . .  14\n    4.2.1.  Data Handling . . . . . . . . . . . . . . . . . . . .  14\n    4.2.2.  Components  . . . . . . . . . . . . . . . . . . . . .  15\n    4.2.3.  Capabilities  . . . . . . . . . . . . . . . . . . . .  15\n    4.2.4.  Events  . . . . . . . . . . . . . . . . . . . . . . .  16\n  4.3.  CoreParallelization . . . . . . . . . . . . . . . . . . .  16\n    4.3.1.  Data Handling . . . . . . . . . . . . . . . . . . . .  16\n    4.3.2.  Components  . . . . . . . . . . . . . . . . . . . . .  16\n    4.3.3.  Capabilities  . . . . . . . . . . . . . . . . . . . .  16\n    4.3.4.  Events  . . . . . . . . . . . . . . . . . . . . . . .  17\n5.  XML for Parallel LFB Library  . . . . . . . . . . . . . . . .  17\n6.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  25\n  6.1.  LFB Class Names and LFB Class Identifiers . . . . . . . .  25\n  6.2.  Metadata ID . . . . . . . . . . . . . . . . . . . . . . .  26\n7.  Security Considerations . . . . . . . . . . . . . . . . . . .  26\n8.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  26\n  8.1.  Normative References  . . . . . . . . . . . . . . . . . .  26\n  8.2.  Informative References  . . . . . . . . . . . . . . . . .  27\nAcknowledgments   . . . . . . . . . . . . . . . . . . . . . . . .  27\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  27",
      "raw": true,
      "toc": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "zh-CHS": "1. 介绍"
    },
    {
      "indent": 3,
      "text": "A lot of network devices can process packets in a parallel manner. The Forwarding and Control Element Separation (ForCES) model [RFC5812] presents a formal way to describe the Forwarding Plane's datapath with Logical Function Blocks (LFBs) using XML. This document describes how packet parallelization can be described with the ForCES model.",
      "zh-CHS": "许多网络设备可以以并行方式处理数据包。转发和控制元素分离（ForCES）模型[RFC5812]提供了一种形式化方法，使用XML描述带有逻辑功能块（LFB）的转发平面的数据路径。本文档描述如何使用ForCES模型描述数据包并行化。"
    },
    {
      "indent": 3,
      "text": "The modeling concept has been influenced by Cilk [Cilk]. Cilk is a programming language that has been in development since 1994 at the Massachusetts Institute of Technology (MIT) Laboratory. Cilk allows programmers to identify elements that can be executed in parallel. The two Cilk concepts used in this document are \"spawn\" and \"sync\": spawn being the place where parallel tasks can start and sync being the place where the parallel task finishes and must collect all parallel output (see Section 1.2 for the definitions of both \"task\" and \"task correclator\").",
      "zh-CHS": "建模概念受到Cilk[Cilk]的影响。Cilk是一种编程语言，自1994年以来一直在麻省理工学院（MIT）实验室开发。Cilk允许程序员识别可以并行执行的元素。本文档中使用的两个Cilk概念是“spawn”和“sync”：spawn是并行任务可以启动的地方，sync是并行任务完成的地方，必须收集所有并行输出（有关“任务”和“任务协调器”的定义，请参见第1.2节）。"
    },
    {
      "indent": 3,
      "text": "This document is Experimental; thus, the LFB Class IDs will not be included in the Standard Action's values. Therefore, the LFB Class IDs must have a value larger than 65535, and the LFB names must begin with the prefix 'Ext-'. However, for brevity, when we refer to the LFB Class names in the text of this document (not the formal definitions), the 'Ext-' prefix will be omitted.",
      "zh-CHS": "本文件是实验性的；因此，LFB类ID将不包括在标准操作的值中。因此，LFB类ID的值必须大于65535，并且LFB名称必须以前缀“Ext-”开头。然而，为了简洁起见，当我们在本文档的文本中引用LFB类名时（不是正式定义），将省略“Ext-”前缀。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Language",
      "section_title": true,
      "zh-CHS": "1.1. 需求语言"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "zh-CHS": "本文件中的关键词“必须”、“不得”、“必需”、“应”、“不应”、“应”、“不应”、“建议”、“可”和“可选”应按照[RFC2119]中所述进行解释。"
    },
    {
      "indent": 0,
      "text": "1.2. Definitions",
      "section_title": true,
      "zh-CHS": "1.2. 定义"
    },
    {
      "indent": 3,
      "text": "This document follows the terminology defined by the ForCES model in [RFC5812]. In particular, the reader is expected to be familiar with the following terms:",
      "zh-CHS": "本文件遵循[RFC5812]中力模型定义的术语。读者应特别熟悉以下术语："
    },
    {
      "indent": 6,
      "text": "FE",
      "zh-CHS": "铁"
    },
    {
      "indent": 6,
      "text": "CE",
      "zh-CHS": "总工程师"
    },
    {
      "indent": 6,
      "text": "FE Model",
      "zh-CHS": "有限元模型"
    },
    {
      "indent": 6,
      "text": "LFB Class (or type)",
      "zh-CHS": "LFB类（或类型）"
    },
    {
      "indent": 6,
      "text": "LFB Instance",
      "zh-CHS": "LFB实例"
    },
    {
      "indent": 6,
      "text": "LFB Model",
      "zh-CHS": "LFB模型"
    },
    {
      "indent": 6,
      "text": "Element",
      "zh-CHS": "要素"
    },
    {
      "indent": 6,
      "text": "Attribute",
      "zh-CHS": "属性"
    },
    {
      "indent": 6,
      "text": "LFB Metadata",
      "zh-CHS": "LFB元数据"
    },
    {
      "indent": 6,
      "text": "ForCES Component",
      "zh-CHS": "力分量"
    },
    {
      "indent": 6,
      "text": "LFB Class Library",
      "zh-CHS": "LFB类库"
    },
    {
      "indent": 3,
      "text": "This document also introduces the following terms:",
      "zh-CHS": "本文件还介绍了以下术语："
    },
    {
      "indent": 3,
      "text": "Chunk: Pieces of a packet.",
      "zh-CHS": "块：一个包的碎片。"
    },
    {
      "indent": 3,
      "text": "Task: Grouping of packets or chunks belonging to the same packet that are processed in parallel.",
      "zh-CHS": "任务：分组属于并行处理的相同数据包的数据包或数据块。"
    },
    {
      "indent": 3,
      "text": "Task Correlator: A 32-bit identifier that uniquely distinguishes tasks.",
      "zh-CHS": "任务相关器：唯一区分任务的32位标识符。"
    },
    {
      "indent": 3,
      "text": "Split Type: A parallel type where the packets are split into chunks to be processed in parallel. Each task in a split type is composed only of chunks.",
      "zh-CHS": "拆分类型：一种并行类型，其中数据包被拆分为块以进行并行处理。拆分类型中的每个任务仅由块组成。"
    },
    {
      "indent": 3,
      "text": "Flood Type: A parallel type where the packets are copied as-is to downstream LFBs to be processed in parallel. Each task in a flood type is composed only of packets.",
      "zh-CHS": "泛洪类型：一种并行类型，其中数据包按原样复制到要并行处理的下游LFB。洪水类型中的每个任务仅由数据包组成。"
    },
    {
      "indent": 0,
      "text": "2. Packet Parallelization",
      "section_title": true,
      "zh-CHS": "2. 分组并行化"
    },
    {
      "indent": 3,
      "text": "This document addresses the following two types of packet parallelization:",
      "zh-CHS": "本文档介绍了以下两种类型的数据包并行化："
    },
    {
      "indent": 3,
      "text": "1. Flood: Where a copy of a packet is sent to multiple LFBs to be processed in parallel.",
      "zh-CHS": "1. 泛洪：一个数据包的副本被发送到多个LFB进行并行处理。"
    },
    {
      "indent": 3,
      "text": "2. Split: Where the packet will be split into chunks of equal size specified by the CE and sent to multiple LFB instances, probably of the same LFB class, to be processed in parallel.",
      "zh-CHS": "2. 拆分：将数据包拆分为CE指定的大小相等的块，并发送到多个LFB实例（可能是同一LFB类的实例），以并行处理。"
    },
    {
      "indent": 3,
      "text": "It must be noted that the process of copying the packet in the flood parallel type is implementation dependent and is loosely defined here. An implementer may either decide to physically copy the packet and send all packets on the parallel paths or decide to logically copy the packet by simply sending, for example, pointers to the same",
      "zh-CHS": "必须注意，以泛洪并行类型复制数据包的过程依赖于实现，并且在这里定义得很松散。实现者可以决定物理地复制该分组并在并行路径上发送所有分组，或者决定通过简单地发送（例如）指向该分组的指针来逻辑地复制该分组"
    },
    {
      "indent": 3,
      "text": "packet provided that the necessary interlocks are taken into account. The implementer has to take into account the device's characteristics to decide which approach fits best to the device.",
      "zh-CHS": "如果考虑了必要的联锁，则数据包。实现者必须考虑设备的特性，以决定哪种方法最适合设备。"
    },
    {
      "indent": 3,
      "text": "In the split parallel type, while harder, the implementer may also decide to logically split the packet and send, for example, pointers to parts of the packet, provided that the necessary interlocks are managed. In addition, how chunks are distributed to the LFBs (e.g., which chunk to which LFB) is implementation dependent. For example, while usually chunks are sent to the same LFB class, the number of LFB instances may not be equal to the number of chunks. It is up to the implementer to decide how these chunks will be sent, for example, in a round-robin fashion.",
      "zh-CHS": "在拆分并行类型中，虽然更难，但实现者也可以决定在逻辑上拆分数据包并发送（例如）指向数据包部分的指针，前提是管理必要的联锁。此外，区块如何分布到LFB（例如，LFB所属的区块）取决于实现。例如，虽然通常将块发送到同一LFB类，但LFB实例的数量可能不等于块的数量。由实现者决定如何发送这些块，例如，以循环方式发送。"
    },
    {
      "indent": 3,
      "text": "This document introduces two LFBs that are used before and after the parallelization occurs:",
      "zh-CHS": "本文档介绍了并行化前后使用的两个LFB："
    },
    {
      "indent": 3,
      "text": "1. Splitter: Similar to Cilk's spawn, a splitter is an LFB that will split the path of a packet that will be sent to multiple downstream LFBs to be processed in parallel.",
      "zh-CHS": "1. 拆分器：与Cilk的spawn类似，拆分器是一个LFB，它将拆分数据包的路径，该数据包将被发送到多个下游LFB进行并行处理。"
    },
    {
      "indent": 3,
      "text": "2. Merger: Similar to Cilk's sync, a merger is an LFB that will receive packets or chunks of the same initial packet and merge them and the results into one packet.",
      "zh-CHS": "2. 合并：与Cilk的sync类似，合并是一个LFB，它将接收相同初始数据包的数据包或数据块，并将它们和结果合并到一个数据包中。"
    },
    {
      "indent": 3,
      "text": "Both parallel packet distribution types can currently be achieved with the ForCES model. The Splitter LFB has one group output that produces either chunks or packets to be sent to LFBs for processing, and the Merger LFB has one group input that expects either packets or chunks to aggregate all the parallel packets or chunks and produce a single packet.",
      "zh-CHS": "这两种并行数据包分布类型目前都可以通过ForCES模型实现。拆分器LFB具有一个组输出，该组输出产生要发送到LFB进行处理的块或包，合并LFB具有一个组输入，该组输入期望包或块聚合所有并行包或块并产生单个包。"
    },
    {
      "indent": 3,
      "text": "Figure 1 shows a simple example of a split parallel datapath along with the Splitter and Merger LFB. The example in Figure 1 depicts multiple regular expression (regex) match LFBs that perform match operations on parts of the original packet. Figure 2 shows an example of a flood parallel datapath along with the Splitter and Merger LFB. The example in Figure 2 depicts a path that will classify an IPv4 packet while also performing metering; on the other path, the IPv4 Time to Live (TTL) field will be decremented.",
      "zh-CHS": "图1显示了拆分并行数据路径以及拆分器和合并LFB的简单示例。图1中的示例描述了对原始数据包的部分执行匹配操作的多个正则表达式（regex）匹配LFB。图2显示了一个泛洪并行数据路径以及拆分器和合并LFB的示例。图2中的示例描述了一条路径，该路径将对IPv4数据包进行分类，同时还执行计量；在另一条路径上，IPv4生存时间（TTL）字段将递减。"
    },
    {
      "indent": 4,
      "text": "                  C1+M   +------------+  C1+M\n                   +---->| Regex LFB  |----+\n    +----------+   |     +------------+    |       +----------+\n    |          |---+                       +------>|          |\n P  |          |  C2+M   +------------+  C2+M      |          | P\n--->| Splitter |-------->| Regex LFB  |----------->|  Merger  |--->\n    |   LFB    |  CN+M   +------------+  CN+M      |   LFB    |\n    |          |---+                       +------>|          |\n    +----------+   |     +------------+    |       +----------+\n                   +---->| Regex LFB  |----+\n                         +------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 16,
      "text": "Figure 1: Simple Split Parallel Processing",
      "zh-CHS": "图1：简单拆分并行处理"
    },
    {
      "indent": 4,
      "text": "    +----------+    +------------+    +-------+    +----------+\n    |          |P+M | Classifier |P+M | Meter |P+M |          |\n P  |          |--->|     LFB    |--->|  LFB  |--->|          | P\n--->| Splitter |    +------------+    +-------+    |  Merger  |--->\n    |   LFB    |                                   |   LFB    |\n    |          |P+M       +------------+       P+M |          |\n    |          |--------->|  IPv4 TTL  |---------->|          |\n    +----------+          |  Decrement |           +----------+\n                          |    LFB     |\n                          +------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 16,
      "text": "Figure 2: Simple Flood Parallel Processing",
      "zh-CHS": "图2：简单的泛洪并行处理"
    },
    {
      "indent": 3,
      "text": "This version of the modeling framework does not allow for nested parallel datapath topologies. This decision was reached by the authors and the ForCES working group, as there was no strong use case or need at decision time. This led to a simpler metadata definition, which is required to be transported between the splitter and the corresponding merger. If there is a need for nested parallel datapaths, a new version of a splitter and merger will need to be defined, as well as an augmentation to the defined metadata.",
      "zh-CHS": "此版本的建模框架不允许嵌套的并行数据路径拓扑。这个决定是由作者和ForCES工作组达成的，因为在决定时没有强烈的用例或需求。这导致了更简单的元数据定义，需要在拆分器和相应合并之间传输。如果需要嵌套的并行数据路径，则需要定义拆分器和合并的新版本，以及对已定义元数据的扩充。"
    },
    {
      "indent": 0,
      "text": "2.1. CoreParallelization LFB",
      "section_title": true,
      "zh-CHS": "2.1. 共并行LFB"
    },
    {
      "indent": 3,
      "text": "One important element to a developer is the ability to define which LFBs can be used in a parallel mode, which LFBs can be parallelized with which, as well as the order in which parallel LFBs can be assembled.",
      "zh-CHS": "对于开发人员来说，一个重要的元素是能够定义哪些LFB可以在并行模式下使用，哪些LFB可以与哪些LFB并行，以及并行LFB可以组装的顺序。"
    },
    {
      "indent": 3,
      "text": "To access the parallelization details, we opted for defining a new LFB class: the CoreParallelization LFB. This choice was an alternative to making another change to the core FEObject LFB. The CoreParallelization exists merely to define the capabilities for an FE's LFB parallelization. A CE using the ForCES protocol [RFC5810]",
      "zh-CHS": "为了访问并行化细节，我们选择定义一个新的LFB类：CoreParallelization LFB。这个选择是对核心FEB对象LFB进行另一次更改的替代方案。CoreParallelization的存在仅仅是为了定义FE的LFB并行化的能力。使用ForCES协议的CE[RFC5810]"
    },
    {
      "indent": 3,
      "text": "can check the existence of this LFB class in the FEObject's SupportedLFBs component. The existence of the CoreParallelization LFB will indicate to the CE that the specific FE supports parallelization. There MUST be only one instance of the CoreParallelization LFB per FE.",
      "zh-CHS": "可以检查FEObject的SupportedLFBs组件中是否存在此LFB类。共并行LFB的存在将向CE表明特定FE支持并行化。每个FE只能有一个CoreParallelization LFB实例。"
    },
    {
      "indent": 3,
      "text": "The topology of the parallel datapath can be deferred and manipulated from the FEObject LFB's LFBTopology.",
      "zh-CHS": "并行数据路径的拓扑可以从FEObject LFB的LFB拓扑中进行延迟和操作。"
    },
    {
      "indent": 3,
      "text": "The CoreParallelization requires only one capability in order to specify each LFB that can be used in a parallel mode:",
      "zh-CHS": "CoreParallelization只需要一个功能，即可指定可在并行模式下使用的每个LFB："
    },
    {
      "indent": 3,
      "text": "o The Name of the LFB.",
      "zh-CHS": "o LFB的名称。"
    },
    {
      "indent": 3,
      "text": "o The Class ID of the LFB.",
      "zh-CHS": "o LFB的类ID。"
    },
    {
      "indent": 3,
      "text": "o The Version of the LFB.",
      "zh-CHS": "o LFB的版本。"
    },
    {
      "indent": 3,
      "text": "o The number of instances that class can support in parallel.",
      "zh-CHS": "o 类可以并行支持的实例数。"
    },
    {
      "indent": 3,
      "text": "o A list of LFB classes that can follow this LFB class in a pipeline for a parallel path.",
      "zh-CHS": "o 在并行路径的管道中可以跟随此LFB类的LFB类的列表。"
    },
    {
      "indent": 3,
      "text": "o A list of LFB classes that can exist before this LFB class in a pipeline for a parallel path.",
      "zh-CHS": "o 在并行路径的管道中，可以在此LFB类之前存在的LFB类的列表。"
    },
    {
      "indent": 3,
      "text": "o A list of LFB classes that can process packets or chunks in parallel with this LFB class.",
      "zh-CHS": "o 可以与此LFB类并行处理数据包或数据块的LFB类列表。"
    },
    {
      "indent": 6,
      "text": "<!-- Datatype -->\n<dataTypeDef>\n   <name>ParallelLFBType</name>\n   <synopsis>Table entry for parallel LFBs</synopsis>\n   <struct>\n      <component componentID=\"1\">\n         <name>LFBName</name>\n         <synopsis>The name of an LFB Class</synopsis>\n         <typeRef>string</typeRef>\n      </component>\n      <component componentID=\"2\">\n         <name>LFBClassID</name>\n         <synopsis>The id of the LFB Class</synopsis>\n         <typeRef>uint32</typeRef>\n      </component>\n      <component componentID=\"3\">\n         <name>LFBVersion</name>\n         <synopsis>The version of the LFB Class used by this FE\n         </synopsis>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "         <typeRef>string</typeRef>\n      </component>\n      <component componentID=\"4\">\n         <name>LFBParallelOccurrenceLimit</name>\n         <synopsis>The upper limit of instances of the same\n            parallel LFBs of this class</synopsis>\n         <optional />\n         <typeRef>uint32</typeRef>\n      </component>\n      <component componentID=\"5\">\n         <name>AllowedParallelAfters</name>\n         <synopsis>List of LFB Classes that can follow this LFB\n            in a parallel pipeline</synopsis>\n         <optional />\n         <array>\n            <typeRef>uint32</typeRef>\n         </array>\n      </component>\n      <component componentID=\"6\">\n         <name>AllowedParallelBefores</name>\n         <synopsis>List of LFB Classes that this LFB class can\n            follow in a parallel pipeline</synopsis>\n         <optional />\n         <array>\n            <typeRef>uint32</typeRef>\n         </array>\n      </component>\n      <component componentID=\"7\">\n         <name>AllowedParallel</name>\n         <synopsis>List of LFB Classes that this LFB class can run\n            in parallel with</synopsis>\n         <array>\n            <typeRef>uint32</typeRef>\n         </array>\n      </component>\n   </struct>\n</dataTypeDef>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "<!-- Capability -->\n      <capability componentID=\"32\">\n         <name>ParallelLFBs</name>\n         <synopsis>List of all supported parallel LFBs</synopsis>\n         <array type=\"Variable-size\">\n            <typeRef>ParallelLFBType</typeRef>\n         </array>\n      </capability>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 11,
      "text": "Figure 3: XML Definitions for CoreParallelization LFB",
      "zh-CHS": "图3:CoreParallelization LFB的XML定义"
    },
    {
      "indent": 0,
      "text": "2.2. Parallelization Metadata",
      "section_title": true,
      "zh-CHS": "2.2. 并行化元数据"
    },
    {
      "indent": 3,
      "text": "It is expected that the splitting and merging mechanisms are an implementation issue. This document plays the role of defining the operational parameters for the splitting and merging: namely, the size of the chunks, what happens if a packet or chunk has been marked as invalid, and whether the merge LFB should wait for all packets or chunks to arrive. The following metadata set is defined as a struct:",
      "zh-CHS": "预计拆分和合并机制是一个实现问题。本文档的作用是定义拆分和合并的操作参数：即块的大小，如果一个数据包或数据块被标记为无效会发生什么，以及合并LFB是否应该等待所有数据包或数据块到达。以下元数据集定义为结构："
    },
    {
      "indent": 3,
      "text": "1. ParallelType - Flood or split",
      "zh-CHS": "1. 并行类型-泛洪或分裂"
    },
    {
      "indent": 3,
      "text": "2. TaskCorrelator - Identify packets or chunks that belonged to the initial packet that entered the Splitter LFB",
      "zh-CHS": "2. TaskCorrelator-识别属于进入拆分器LFB的初始数据包的数据包或数据块"
    },
    {
      "indent": 3,
      "text": "3. ParallelNum - Sequence number of the packet or the chunk for a specific task",
      "zh-CHS": "3. ParallelNum—特定任务的数据包或数据块的序列号"
    },
    {
      "indent": 3,
      "text": "4. ParallelPartsCount - Total number of packets or chunks for a specific task",
      "zh-CHS": "4. ParallelPartsCount—特定任务的数据包或数据块总数"
    },
    {
      "indent": 3,
      "text": "This metadata is produced from the Splitter LFB, is opaque to LFBs in parallel paths, and is passed along to the Merger LFB without being consumed.",
      "zh-CHS": "此元数据由拆分器LFB生成，对并行路径中的LFB是不透明的，并传递给合并LFB而不被消耗。"
    },
    {
      "indent": 3,
      "text": "In the case in which an LFB decides that a packet/chunk has to be dropped, the LFB MAY drop the packet/chunk, but the metadata MUST be sent to the Merger LFB's InvalidIn input port for merging purposes.",
      "zh-CHS": "在LFB决定必须丢弃数据包/数据块的情况下，LFB可以丢弃数据包/数据块，但元数据必须发送到合并LFB的InvalidIn输入端口，以便进行合并。"
    },
    {
      "indent": 3,
      "text": "Additional metadata produced by LFBs inside a datapath MAY be aggregated within the Merger LFB and sent on after the merging process. In case of receiving the same metadata definition with multiple values, the Merger LFB MUST keep the first received from a valid packet or chunk.",
      "zh-CHS": "数据路径内LFB产生的附加元数据可在合并LFB内聚合，并在合并过程后发送。在接收到具有多个值的相同元数据定义的情况下，合并LFB必须保留从有效数据包或数据块接收到的第一个元数据定义。"
    },
    {
      "indent": 0,
      "text": "3. Parallel Base Types",
      "section_title": true,
      "zh-CHS": "3. 平行基类型"
    },
    {
      "indent": 0,
      "text": "3.1. Frame Types",
      "section_title": true,
      "zh-CHS": "3.1. 框架类型"
    },
    {
      "indent": 3,
      "text": "One frame type has been defined in this library.",
      "zh-CHS": "此库中定义了一种帧类型。"
    },
    {
      "indent": 3,
      "text": "+-----------+-------------------------------------------------------+\n| Frame     | Synopsis                                              |\n| Name      |                                                       |\n+-----------+-------------------------------------------------------+\n| Chunk     | A chunk is a frame that is part of an original larger |\n|           | frame.                                                |\n+-----------+-------------------------------------------------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 27,
      "text": "Parallel Frame Types",
      "zh-CHS": "平行框架类型"
    },
    {
      "indent": 0,
      "text": "3.2. Data Types",
      "section_title": true,
      "zh-CHS": "3.2. 数据类型"
    },
    {
      "indent": 3,
      "text": "One data type has been defined in this library.",
      "zh-CHS": "此库中定义了一种数据类型。"
    },
    {
      "indent": 3,
      "text": "+---------------+------------------------+--------------------------+\n| DataType Name | Type                   | Synopsis                 |\n+---------------+------------------------+--------------------------+\n| ParallelTypes | Atomic uchar.  Special | The type of              |\n|               | Values Flood (0),      | parallelization this     |\n|               | Split (1).             | packet will go through.  |\n+---------------+------------------------+--------------------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 28,
      "text": "Parallel Data Types",
      "zh-CHS": "并行数据类型"
    },
    {
      "indent": 0,
      "text": "3.3. Metadata Types",
      "section_title": true,
      "zh-CHS": "3.3. 元数据类型"
    },
    {
      "indent": 3,
      "text": "The following metadata structure with ID 16, using the ForCES model extension [RFC7408], is defined for the parallelization library:",
      "zh-CHS": "使用ForCES模型扩展[RFC7408]为并行化库定义了以下ID为16的元数据结构："
    },
    {
      "indent": 3,
      "text": "+--------------------+--------+----+--------------------------------+\n|   Metadata Name    |  Type  | ID |            Synopsis            |\n+--------------------+--------+----+--------------------------------+\n|    ParallelType    | uchar  | 1  |  The type of parallelization   |\n|                    |        |    | this packet will go through. 0 |\n|                    |        |    |    for flood, 1 for split.     |\n|                    |        |    |                                |\n|   TaskCorrelator   | uint32 | 2  |  An identification number to   |\n|                    |        |    |   specify that a packet or a   |\n|                    |        |    |   chunk belongs to the same    |\n|                    |        |    |         parallel task.         |\n|                    |        |    |                                |\n|    ParallelNum     | uint32 | 3  |    Defines the number of a     |\n|                    |        |    | specific packet or chunk of a  |\n|                    |        |    |         specific task.         |\n|                    |        |    |                                |\n| ParallelPartsCount | uint32 | 4  |  Defines the total number of   |\n|                    |        |    |    packets or chunks for a     |\n|                    |        |    |         specific task.         |\n+--------------------+--------+----+--------------------------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 22,
      "text": "Metadata Structure for Merging",
      "zh-CHS": "用于合并的元数据结构"
    },
    {
      "indent": 0,
      "text": "4. Parallel LFBs",
      "section_title": true,
      "zh-CHS": "4. 并行LFB"
    },
    {
      "indent": 0,
      "text": "4.1. Splitter",
      "section_title": true,
      "zh-CHS": "4.1. 分离器"
    },
    {
      "indent": 3,
      "text": "The Splitter LFB takes part in parallelizing the processing datapath by sending either the same packet (Figure 2) or chunks (Figure 1) of the same packet to multiple LFBs.",
      "zh-CHS": "拆分器LFB通过向多个LFB发送相同数据包（图2）或相同数据包的块（图1），参与并行处理数据路径。"
    },
    {
      "indent": 18,
      "text": "           +---------------+\nSplitterIn |               | SplitterOut\n---------->| Splitter LFB  |------------->\n           |               |\n           +---------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 26,
      "text": "Figure 4: Splitter LFB",
      "zh-CHS": "图4：分离器LFB"
    },
    {
      "indent": 0,
      "text": "4.1.1. Data Handling",
      "section_title": true,
      "zh-CHS": "4.1.1. 数据处理"
    },
    {
      "indent": 3,
      "text": "The Splitter LFB receives any kind of packet via the singleton input, Input. Depending upon the CE's configuration of the ParallelType component, if the parallel type is of type flood (0), the same packet MUST be sent through all instances of the group output \"SplitterOut\". If the parallel type is of type split (1), then the packet will be split into same size chunks except for the last, which MAY be smaller, with the max size being defined by the ChunkSize component. Chunks MAY be sent out in a round-robin fashion through instances of the group output \"ParallelOut\" or in any other way defined by the implementer. Each packet or chunk will be accompanied by the following metadata set as a struct:",
      "zh-CHS": "拆分器LFB通过单例输入input接收任何类型的分组。根据并行类型组件的CE配置，如果并行类型为flood（0）类型，则必须通过组输出“SplitterOut”的所有实例发送相同的数据包。如果并行类型为split（1）类型，则数据包将被拆分为相同大小的块，但最后一个块可能更小，最大大小由ChunkSize组件定义。块可以通过组输出“ParallelOut”的实例以循环方式发送，或者以实现者定义的任何其他方式发送。每个数据包或数据块将附带以下元数据集作为结构："
    },
    {
      "indent": 3,
      "text": "o ParallelType - The parallel type: split or flood.",
      "zh-CHS": "o ParallelType-并行类型：拆分或整体应用。"
    },
    {
      "indent": 3,
      "text": "o ParallelID - Generated by the Splitter LFB to identify which chunks or packets belong to the same parallel task.",
      "zh-CHS": "o ParallelID—由拆分器LFB生成，用于标识属于同一并行任务的块或数据包。"
    },
    {
      "indent": 3,
      "text": "o ParallelNum - Each chunk or packet of a parallel ID will be assigned a number in order for the Merger LFB to know when it has gathered them all along with the ParallelPartsCount metadata.",
      "zh-CHS": "o ParallelNum—将为并行ID的每个块或数据包分配一个编号，以便合并LFB知道何时已将它们与ParallelPartsCount元数据一起收集。"
    },
    {
      "indent": 3,
      "text": "o ParallelPartsCount - The number of chunks or packets for the specific task.",
      "zh-CHS": "o ParallelPartsCount—特定任务的数据块或数据包数。"
    },
    {
      "indent": 0,
      "text": "4.1.2. Components",
      "section_title": true,
      "zh-CHS": "4.1.2. 组件"
    },
    {
      "indent": 3,
      "text": "The Splitter LFB has only two components. The first is the ParallelType, a uint32 that defines how the packet will be processed by the Splitter LFB. The second is the ChunkSize, a uint32 that specifies the size of each chunk when a packet is split into multiple same-size chunks. The last chunk MAY be smaller than the value of the ChunkSize.",
      "zh-CHS": "分离器LFB只有两个组件。第一个是ParallelType，它是一个uint32，定义了拆分器LFB将如何处理数据包。第二个是ChunkSize，一个uint32，当一个数据包被分割成多个相同大小的数据块时，它指定每个数据块的大小。最后一个区块可能小于ChunkSize的值。"
    },
    {
      "indent": 0,
      "text": "4.1.3. Capabilities",
      "section_title": true,
      "zh-CHS": "4.1.3. 能力"
    },
    {
      "indent": 3,
      "text": "This LFB has only one capability specified; the MinMaxChunkSize is a struct of two uint32s to specify the minimum and maximum chunk size.",
      "zh-CHS": "This LFB has only one capability specified; the MinMaxChunkSize is a struct of two uint32s to specify the minimum and maximum chunk size.translate error, please retry"
    },
    {
      "indent": 0,
      "text": "4.1.4. Events",
      "section_title": true,
      "zh-CHS": "4.1.4. 事件"
    },
    {
      "indent": 3,
      "text": "This LFB has no events specified.",
      "zh-CHS": "此LFB未指定任何事件。"
    },
    {
      "indent": 0,
      "text": "4.2. Merger",
      "section_title": true,
      "zh-CHS": "4.2. 合并"
    },
    {
      "indent": 3,
      "text": "The Merger LFB is the synchronization point for multiple packets or packet chunks of the same task emanating out of the parallel path, as illustrated in Figure 1 and Figure 2.",
      "zh-CHS": "合并LFB是来自并行路径的同一任务的多个数据包或数据包块的同步点，如图1和图2所示。"
    },
    {
      "indent": 21,
      "text": "          +-------------+\n MergerIn |             |\n--------->|             | MergerOut\n          | Merger LFB  |----------->\nInvalidIn |             |\n--------->|             |\n          +-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 27,
      "text": "Figure 5: Merger LFB",
      "zh-CHS": "图5：合并LFB"
    },
    {
      "indent": 0,
      "text": "4.2.1. Data Handling",
      "section_title": true,
      "zh-CHS": "4.2.1. 数据处理"
    },
    {
      "indent": 3,
      "text": "The Merger LFB receives either a packet or a chunk via the group input ParallelIn, along with the ParallelType metadata, the TaskCorrelator, the ParallelNum, and the ParallelPartsCount.",
      "zh-CHS": "合并LFB通过组输入ParallelIn接收数据包或数据块，以及ParallelType元数据、TaskCorrelator、ParallelNum和ParallelPartsCount。"
    },
    {
      "indent": 3,
      "text": "In the case in which an upstream LFB has dropped a packet or a chunk, the Merger LFB MAY receive only the metadata, both the metadata and the packet, or the chunk through the InvalidIn group input port. It SHOULD receive a metadata specifying the error code. Currently defined metadata in the Base LFB Library [RFC6956] are the ExceptionID and the ValidateErrorID.",
      "zh-CHS": "在上游LFB已经丢弃分组或区块的情况下，合并LFB可以仅接收元数据、元数据和分组，或者通过InvalidIn组输入端口接收区块。它应该接收指定错误代码的元数据。基本LFB库[RFC6956]中当前定义的元数据是ExceptionID和ValidateErrorID。"
    },
    {
      "indent": 3,
      "text": "If the MergeWaitType is set to false, the Merger LFB will initiate the merge process upon receiving the first packet. If false, for each task identified by the task correlator, it will wait for all packets/chunks to arrive unless the MergeWaitTimeoutTimer timer expires. If the MergeWaitTimeoutTimer has expired, the Merger MUST consider the rest of the packets/chunks that have not been received as invalid, and it MUST handle the packets according to the InvalidAction value.",
      "zh-CHS": "如果MergeWaitType设置为false，则合并LFB将在接收到第一个数据包时启动合并过程。如果为false，则对于任务相关器标识的每个任务，它将等待所有数据包/数据块到达，除非MergeWaitTimeoutTimer计时器过期。如果MelGeAuthTimeOutTimeExcel已经过期，合并必须考虑其余未被接收的包/块无效，并且它必须根据无效动作值来处理包。"
    },
    {
      "indent": 3,
      "text": "If one packet or chunk has been received through the InvalidIn port, then the merging procedure will handle the packets/chunks according to the InvalidAction value. If the InvalidAction component has been set to 0, then if one packet or chunk is not valid, all will be dropped or else the process will initiate. Once the merging process has been completed, the resulting packet will be sent via the singleton output port MergerOut.",
      "zh-CHS": "如果通过InvalidIn端口接收到一个数据包或数据块，则合并过程将根据InvalidAction值处理数据包/数据块。如果InvalidAction组件已设置为0，则如果一个数据包或数据块无效，则将丢弃所有数据包或数据块，否则进程将启动。合并过程完成后，生成的数据包将通过单例输出端口MergerOut发送。"
    },
    {
      "indent": 3,
      "text": "If the Merger LFB receives different values for the same metadata from different packets or chunks that have the same task correlator, then the Merger LFB will use the first metadata from a packet or chunk that entered the LFB through the MergerIn input port.",
      "zh-CHS": "如果合并LFB从具有相同任务相关器的不同数据包或数据块接收到相同元数据的不同值，则合并LFB将使用来自通过MergerIn输入端口输入LFB的数据包或数据块的第一个元数据。"
    },
    {
      "indent": 0,
      "text": "4.2.2. Components",
      "section_title": true,
      "zh-CHS": "4.2.2. 组件"
    },
    {
      "indent": 3,
      "text": "This LFB has the following components specified:",
      "zh-CHS": "该LFB指定了以下组件："
    },
    {
      "indent": 3,
      "text": "1. InvalidAction: A uchar defining what the Merge LFB will do if an invalid chunk or packet is received. If set to 0 (DropAll), the merge will be considered invalid and all chunks or packets will be dropped. If set to 1 (Continue), the merge will continue.",
      "zh-CHS": "1. InvalidAction：一个uchar，定义在接收到无效块或数据包时合并LFB将执行的操作。如果设置为0（DropAll），则合并将被视为无效，所有块或数据包都将被丢弃。如果设置为1（继续），合并将继续。"
    },
    {
      "indent": 3,
      "text": "2. MergeWaitTimeoutTimer: A uint32 defining the amount of time, in milliseconds, that the Merger will wait for all packets or chunks within the same task to arrive before considering them invalid. The MergeWaitTimeoutTimer starts as soon as the first chunk or packet of a parallel task arrives.",
      "zh-CHS": "2. MergeWaitTimeoutTimer：一个uint32，定义合并在认为同一任务中的所有数据包或数据块无效之前等待它们到达的时间量（以毫秒为单位）。MergeWaitTimeoutTimer在并行任务的第一个块或数据包到达时立即启动。"
    },
    {
      "indent": 3,
      "text": "3. MergeWaitType: A boolean. If true, the Merger LFB will wait for all packets or chunks to be received prior to performing the merge. If false, when one packet or a chunk with a response is received by the merge LFB, it will start with the merge process.",
      "zh-CHS": "3. MergeWaitType：布尔值。如果为true，则合并LFB将在执行合并之前等待接收所有数据包或数据块。如果为false，则当合并LFB接收到带有响应的一个数据包或数据块时，它将从合并进程开始。"
    },
    {
      "indent": 3,
      "text": "4. InvalidMergesCounter: A uint32 that counts the number of merges where there is at least one packet or chunk that entered the Merger LFB through the InvalidIn input port.",
      "zh-CHS": "4. InvalidMergeSconter：一个uint32，统计至少有一个数据包或数据块通过InvalidIn输入端口进入合并LFB的合并次数。"
    },
    {
      "indent": 3,
      "text": "5. InvalidTotalCounter: A uint32 that counts the number of merges where all packets/chunks entered the Merger LFB through the InvalidIn input port.",
      "zh-CHS": "5. InvalidTotalCounter：统计所有数据包/数据块通过InvalidIn输入端口进入合并LFB的合并次数的uint32。"
    },
    {
      "indent": 3,
      "text": "6. InvalidIDCounters: A struct of two arrays. Each array has a uint32 per row. Each array counts the number of invalid merges where at least one packet or chunk entered through InvalidID per error ID. The first array is the InvalidExceptionID and the second is the InvalidValidateErrorID.",
      "zh-CHS": "6. InvalidCounters：由两个数组组成的结构。每个阵列每行有一个uint32。每个数组统计无效合并的数量，其中每个错误ID至少有一个通过InvalidID输入的数据包或数据块。第一个数组是InvalidExceptionID，第二个数组是InvalidValidateErrorID。"
    },
    {
      "indent": 0,
      "text": "4.2.3. Capabilities",
      "section_title": true,
      "zh-CHS": "4.2.3. 能力"
    },
    {
      "indent": 3,
      "text": "This LFB has no capabilities specified.",
      "zh-CHS": "此LFB没有指定的功能。"
    },
    {
      "indent": 0,
      "text": "4.2.4. Events",
      "section_title": true,
      "zh-CHS": "4.2.4. 事件"
    },
    {
      "indent": 3,
      "text": "This LFB specifies only two events. The first detects whether the InvalidMergesCounter has exceeded a specific value, and the second detects whether the InvalidAllCounter has exceeded a specific value. Both error reports will send the respective counter value. Event Filters can be used to limit the number of messages",
      "zh-CHS": "此LFB仅指定两个事件。第一个检测InvalidMergesCenter是否超过特定值，第二个检测InvalidAllCounter是否超过特定值。两个错误报告将发送各自的计数器值。事件筛选器可用于限制消息的数量"
    },
    {
      "indent": 0,
      "text": "4.3. CoreParallelization",
      "section_title": true,
      "zh-CHS": "4.3. 共并行"
    },
    {
      "indent": 3,
      "text": "A core LFB that specifies that the FE supports parallelization instead of updating the FEObject LFB",
      "zh-CHS": "一种核心LFB，指定FE支持并行化，而不是更新FEB对象LFB"
    },
    {
      "indent": 0,
      "text": "4.3.1. Data Handling",
      "section_title": true,
      "zh-CHS": "4.3.1. 数据处理"
    },
    {
      "indent": 3,
      "text": "The CoreParallelization does not handle data.",
      "zh-CHS": "CoreParallelization不处理数据。"
    },
    {
      "indent": 0,
      "text": "4.3.2. Components",
      "section_title": true,
      "zh-CHS": "4.3.2. 组件"
    },
    {
      "indent": 3,
      "text": "This LFB has no components specified.",
      "zh-CHS": "此LFB未指定任何组件。"
    },
    {
      "indent": 0,
      "text": "4.3.3. Capabilities",
      "section_title": true,
      "zh-CHS": "4.3.3. 能力"
    },
    {
      "indent": 3,
      "text": "This LFB has only one capability specified. The ParallelLFBs is a table which lists all the LFBs that can be parallelized. Each row of the table contains:",
      "zh-CHS": "此LFB只有一个指定的功能。ParallelFBS是一个表，其中列出了所有可以并行化的LFB。表的每一行包含："
    },
    {
      "indent": 3,
      "text": "1. LFBName: A string. The Name of the parallel LFB.",
      "zh-CHS": "1. LFBName：一个字符串。并行LFB的名称。"
    },
    {
      "indent": 3,
      "text": "2. LFBClassID: A uint32. The Class ID of the parallel LFB.",
      "zh-CHS": "2. LFBClassID:A uint32。并行LFB的类ID。"
    },
    {
      "indent": 3,
      "text": "3. LFBVersion: A string. The Version of the parallel LFB.",
      "zh-CHS": "3. LFBVersion：一个字符串。并行LFB的版本。"
    },
    {
      "indent": 3,
      "text": "4. LFBParallelOccurrenceLimit: A uint32. The upper limit of instances of the same parallel LFBs of this class.",
      "zh-CHS": "4. LFB平行电流限值：A uint32。此类相同并行LFB实例的上限。"
    },
    {
      "indent": 3,
      "text": "5. AllowedParallelAfters: A table of uint32s (LFB Class IDs). A list of LFB classes that can follow this LFB class in a pipeline for a parallel path.",
      "zh-CHS": "5. AllowedParallelAfter：一个UINT32表（LFB类ID）。在并行路径的管道中可以跟随此LFB类的LFB类的列表。"
    },
    {
      "indent": 3,
      "text": "6. AllowedParallelBefores: A table of uint32s (LFB Class IDs). A list of LFB classes that can exist before this LFB class in a pipeline for a parallel path.",
      "zh-CHS": "6. AllowedParallelBefores：一个UINT32表（LFB类ID）。在并行路径的管道中，可以在此LFB类之前存在的LFB类的列表。"
    },
    {
      "indent": 3,
      "text": "7. AllowedParallel: A table of uint32s (LFB Class IDs). A list of LFB classes that can process packets or chunks in parallel with this LFB class.",
      "zh-CHS": "7. AllowedParallel：一个UINT32表（LFB类ID）。可以与此LFB类并行处理数据包或数据块的LFB类列表。"
    },
    {
      "indent": 0,
      "text": "4.3.4. Events",
      "section_title": true,
      "zh-CHS": "4.3.4. 事件"
    },
    {
      "indent": 3,
      "text": "This LFB specifies no events.",
      "zh-CHS": "此LFB不指定任何事件。"
    },
    {
      "indent": 0,
      "text": "5. XML for Parallel LFB Library",
      "section_title": true,
      "zh-CHS": "5. 用于并行LFB库的XML"
    },
    {
      "indent": 2,
      "text": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<LFBLibrary xmlns=\"urn:ietf:params:xml:ns:forces:lfbmodel:1.1\"\n   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n   xsi:schemaLocation=\"urn:ietf:params:xml:ns:forces:lfbmodel:1.1\"\n   provides=\"Parallel\">\n  <load library=\"BaseTypeLibrary\" location=\"BaseTypeLibrary.LFB\"/>\n  <frameDefs>\n    <frameDef>\n      <name>Chunk</name>\n      <synopsis>A chunk is a frame that is part of an original\n            larger frame</synopsis>\n    </frameDef>\n  </frameDefs>\n  <dataTypeDefs>\n    <dataTypeDef>\n      <name>ParallelTypes</name>\n      <synopsis>The type of parallelization this packet will go\n            through</synopsis>\n      <atomic>\n        <baseType>uchar</baseType>\n        <specialValues>\n          <specialValue value=\"0\">\n            <name>Flood</name>\n            <synopsis>The packet/chunk has been sent as a whole\n                     to multiple recipients</synopsis>\n          </specialValue>\n          <specialValue value=\"1\">\n            <name>Split</name>\n            <synopsis>The packet/chunk has been split into\n                     multiple chunks and sent to recipients</synopsis>\n          </specialValue>\n        </specialValues>\n      </atomic>\n    </dataTypeDef>\n    <dataTypeDef>\n      <name>ParallelLFBType</name>\n      <synopsis>Table entry for parallel LFBs</synopsis>\n      <struct>\n        <component componentID=\"1\">\n          <name>LFBName</name>\n          <synopsis>The name of an LFB Class</synopsis>\n          <typeRef>string</typeRef>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "      </component>\n      <component componentID=\"2\">\n        <name>LFBClassID</name>\n        <synopsis>The ID of the LFB Class</synopsis>\n        <typeRef>uint32</typeRef>\n      </component>\n      <component componentID=\"3\">\n        <name>LFBVersion</name>\n        <synopsis>The version of the LFB Class used by this FE\n           </synopsis>\n        <typeRef>string</typeRef>\n      </component>\n      <component componentID=\"4\">\n        <name>LFBParallelOccurrenceLimit</name>\n        <synopsis>The upper limit of instances of the same\n              parallel LFBs of this class</synopsis>\n        <optional/>\n        <typeRef>uint32</typeRef>\n      </component>\n      <component componentID=\"5\">\n        <name>AllowedParallelAfters</name>\n        <synopsis>List of LFB Classes that can follow this LFB\n              in a parallel pipeline</synopsis>\n        <optional/>\n        <array>\n          <typeRef>uint32</typeRef>\n        </array>\n      </component>\n      <component componentID=\"6\">\n        <name>AllowedParallelBefores</name>\n        <synopsis>List of LFB Classes that this LFB Class can\n              follow in a parallel pipeline</synopsis>\n        <optional/>\n        <array>\n          <typeRef>uint32</typeRef>\n        </array>\n      </component>\n      <component componentID=\"7\">\n        <name>AllowedParallel</name>\n        <synopsis>List of LFB Classes that this LFB Class can be run\n              in parallel with</synopsis>\n        <array>\n          <typeRef>uint32</typeRef>\n        </array>\n      </component>\n    </struct>\n  </dataTypeDef>\n</dataTypeDefs>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 4,
      "text": "<metadataDefs>\n  <metadataDef>\n    <name>ParallelMetadataSet</name>\n    <synopsis>A metadata set for parallelization-related LFBs\n       </synopsis>\n    <metadataID>32</metadataID>\n    <struct>\n      <component componentID=\"1\">\n        <name>ParallelType</name>\n        <synopsis>The type of parallelization this packet/chunk\n                has gone through</synopsis>\n        <typeRef>ParallelTypes</typeRef>\n      </component>\n      <component componentID=\"2\">\n        <name>TaskCorrelator</name>\n        <synopsis>An identification number to specify that\n                packets or chunks originate from the same packet.\n             </synopsis>\n        <typeRef>uint32</typeRef>\n      </component>\n      <component componentID=\"3\">\n        <name>ParallelNum</name>\n        <synopsis>Defines the number of the specific packet or\n                chunk of the specific parallel ID.</synopsis>\n        <typeRef>uint32</typeRef>\n      </component>\n      <component componentID=\"4\">\n        <name>ParallelPartsCount</name>\n        <synopsis>Defines the total number of packets or chunks\n                for the specific parallel ID.</synopsis>\n        <typeRef>uint32</typeRef>\n      </component>\n    </struct>\n  </metadataDef>\n</metadataDefs>\n<LFBClassDefs>\n  <LFBClassDef LFBClassID=\"65537\">\n    <name>Ext-Splitter</name>\n    <synopsis>A Splitter LFB takes part in parallelizing the\n          processing datapath.  It will either send the same packet\n          or chunks of one packet to multiple LFBs</synopsis>\n    <version>1.0</version>\n    <inputPorts>\n      <inputPort>\n        <name>SplitterIn</name>\n        <synopsis>An input port expecting any kind of frame\n             </synopsis>\n        <expectation>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 8,
      "text": "      <frameExpected>\n        <ref>Arbitrary</ref>\n      </frameExpected>\n    </expectation>\n  </inputPort>\n</inputPorts>\n<outputPorts>\n  <outputPort group=\"true\">\n    <name>SplitterOut</name>\n    <synopsis>A parallel output port that sends the same\n            packet to all output instances or chunks of the same\n            packet to output instances.  Each chunk is sent only\n            once by the LFB.</synopsis>\n    <product>\n      <frameProduced>\n        <ref>Arbitrary</ref>\n        <ref>Chunk</ref>\n      </frameProduced>\n      <metadataProduced>\n        <ref>ParallelMetadataSet</ref>\n      </metadataProduced>\n    </product>\n  </outputPort>\n</outputPorts>\n<components>\n  <component componentID=\"1\" access=\"read-write\">\n    <name>ParallelType</name>\n    <synopsis>The type of parallelization this packet will\n            go through</synopsis>\n    <typeRef>ParallelTypes</typeRef>\n  </component>\n  <component componentID=\"2\" access=\"read-write\">\n    <name>ChunkSize</name>\n    <synopsis>The size of a chunk when a packet is split\n            into multiple chunks of the same size</synopsis>\n    <typeRef>uint32</typeRef>\n  </component>\n</components>\n<capabilities>\n  <capability componentID=\"31\">\n    <name>MinMaxChunkSize</name>\n    <synopsis>The minimum and maximum size of a chunk\n            capable of split by this LFB</synopsis>\n    <struct>\n      <component componentID=\"1\">\n        <name>MinChunkSize</name>\n        <synopsis>Minimum chunk size</synopsis>\n        <optional/>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "          <typeRef>uint32</typeRef>\n        </component>\n        <component componentID=\"2\">\n          <name>MaxChunkSize</name>\n          <synopsis>Maximum chunk size</synopsis>\n          <typeRef>uint32</typeRef>\n        </component>\n      </struct>\n    </capability>\n  </capabilities>\n</LFBClassDef>\n<LFBClassDef LFBClassID=\"65538\">\n  <name>Ext-Merger</name>\n  <synopsis>A Merger LFB receives multiple packets or multiple\n        chunks of the same packet and merge them into one merged\n        packet</synopsis>\n  <version>1.0</version>\n  <inputPorts>\n    <inputPort group=\"true\">\n      <name>MergerIn</name>\n      <synopsis>A parallel input port that accepts packets\n              or chunks from all output instances</synopsis>\n      <expectation>\n        <frameExpected>\n          <ref>Arbitrary</ref>\n          <ref>Chunk</ref>\n        </frameExpected>\n        <metadataExpected>\n          <ref>ParallelMetadataSet</ref>\n        </metadataExpected>\n      </expectation>\n    </inputPort>\n    <inputPort group=\"true\">\n      <name>InvalidIn</name>\n      <synopsis>When a packet is sent out of an error port of\n              an LFB in a parallel path, it will be sent to this\n              output port in the Merger LFB</synopsis>\n      <expectation>\n        <frameExpected>\n          <ref>Arbitrary</ref>\n          <ref>Chunk</ref>\n        </frameExpected>\n        <metadataExpected>\n          <one-of>\n            <ref>ExceptionID</ref>\n            <ref>ValidateErrorID</ref>\n          </one-of>\n        </metadataExpected>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 8,
      "text": "    </expectation>\n  </inputPort>\n</inputPorts>\n<outputPorts>\n  <outputPort>\n    <name>MergerOut</name>\n    <synopsis>An output port expecting any kind of frame\n         </synopsis>\n    <product>\n      <frameProduced>\n        <ref>Arbitrary</ref>\n      </frameProduced>\n    </product>\n  </outputPort>\n</outputPorts>\n<components>\n  <component componentID=\"1\" access=\"read-write\">\n    <name>InvalidAction</name>\n    <synopsis>What the Merge LFB will do if an invalid\n            chunk or packet is received</synopsis>\n    <atomic>\n      <baseType>uchar</baseType>\n      <specialValues>\n        <specialValue value=\"0\">\n          <name>DropAll</name>\n          <synopsis>Drop all packets or chunks\n                  </synopsis>\n        </specialValue>\n        <specialValue value=\"1\">\n          <name>Continue</name>\n          <synopsis>Continue with the merge</synopsis>\n        </specialValue>\n      </specialValues>\n    </atomic>\n  </component>\n  <component componentID=\"2\" access=\"read-write\">\n    <name>MergeWaitType</name>\n    <synopsis>Whether the Merge LFB will wait for all\n            packets or chunks to be received prior to sending\n            out a response</synopsis>\n    <typeRef>boolean</typeRef>\n  </component>\n  <component componentID=\"3\" access=\"read-write\">\n    <name>MergeWaitTimeoutTimer</name>\n    <synopsis>The time that the Merger will wait\n    for all packets or chunks within the same task to arrive\n    before considering them invalid.</synopsis>\n    <typeRef>uint32</typeRef>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 8,
      "text": "  </component>\n  <component componentID=\"4\" access=\"read-reset\">\n    <name>InvalidMergesCounter</name>\n    <synopsis>Counts the number of merges where there is at\n            least one packet/chunk that entered the Merger LFB\n            through the InvalidIn input port</synopsis>\n    <typeRef>uint32</typeRef>\n  </component>\n  <component componentID=\"5\" access=\"read-reset\">\n    <name>InvalidTotalCounter</name>\n    <synopsis>Counts the number of merges where all\n            packets/chunks entered the Merger LFB through the\n            InvalidIn input port</synopsis>\n    <typeRef>uint32</typeRef>\n  </component>\n  <component componentID=\"6\" access=\"read-reset\">\n    <name>InvalidIDCounters</name>\n    <synopsis>Counts the number of invalid merges where at\n            least one packet/chunk entered through InvalidID per\n            error ID</synopsis>\n    <struct>\n      <component componentID=\"1\">\n        <name>InvalidExceptionID</name>\n        <synopsis>Per Exception ID</synopsis>\n        <array>\n          <typeRef>uint32</typeRef>\n        </array>\n      </component>\n      <component componentID=\"2\">\n        <name>InvalidValidateErrorID</name>\n        <synopsis>Per Validate Error ID</synopsis>\n        <array>\n          <typeRef>uint32</typeRef>\n        </array>\n      </component>\n    </struct>\n  </component>\n</components>\n<events baseID=\"30\">\n  <event eventID=\"1\">\n    <name>ManyInvalids</name>\n    <synopsis>An event that specifies if there are too many\n            invalids</synopsis>\n    <eventTarget>\n      <eventField>InvalidCounter</eventField>\n    </eventTarget>\n    <eventGreaterThan/>\n    <eventReports>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 2,
      "text": "            <eventReport>\n              <eventField>InvalidMergesCounter</eventField>\n            </eventReport>\n          </eventReports>\n        </event>\n        <event eventID=\"2\">\n          <name>ManyTotalInvalids</name>\n          <synopsis>An event that specifies if there are too many\n                  invalids</synopsis>\n          <eventTarget>\n            <eventField>InvalidTotalCounter</eventField>\n          </eventTarget>\n          <eventGreaterThan/>\n          <eventReports>\n            <eventReport>\n              <eventField>InvalidTotalCounter</eventField>\n            </eventReport>\n          </eventReports>\n        </event>\n      </events>\n    </LFBClassDef>\n    <LFBClassDef LFBClassID=\"65539\">\n      <name>Ext-CoreParallelization</name>\n      <synopsis>A core LFB that specifies that the FE supports\n        parallelization instead of updating the FEObject\n        LFB</synopsis>\n      <version>1.0</version>\n      <capabilities>\n        <capability componentID=\"10\">\n          <name>ParallelLFBs</name>\n          <synopsis>A table that lists all the LFBs that can be\n              parallelized</synopsis>\n          <array>\n            <typeRef>ParallelLFBType</typeRef>\n          </array>\n        </capability>\n      </capabilities>\n    </LFBClassDef>\n  </LFBClassDefs>\n</LFBLibrary>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 22,
      "text": "Figure 6: Parallel LFB Library",
      "zh-CHS": "图6：并行LFB库"
    },
    {
      "indent": 0,
      "text": "6. IANA Considerations",
      "section_title": true,
      "zh-CHS": "6. IANA考虑"
    },
    {
      "indent": 0,
      "text": "6.1. LFB Class Names and LFB Class Identifiers",
      "section_title": true,
      "zh-CHS": "6.1. LFB类名称和LFB类标识符"
    },
    {
      "indent": 3,
      "text": "LFB classes defined by this document do not belong to LFBs defined by Standards Action. As such, the corresponding values assigned in the \"Logical Functional Block (LFB) Class Names and Class Identifiers\" registry at <http://www.iana.org/assignments/forces> are above 65535.",
      "zh-CHS": "本文件定义的LFB类不属于标准行动定义的LFB。因此，在“逻辑功能块（LFB）类名和类标识符”注册表中指定的相应值<http://www.iana.org/assignments/forces>高于65535。"
    },
    {
      "indent": 3,
      "text": "This specification includes the following LFB class names and LFB class identifiers:",
      "zh-CHS": "本规范包括以下LFB类名称和LFB类标识符："
    },
    {
      "indent": 3,
      "text": "+-------+---------------------+-------+-----------------+---------+\n| LFB   |  LFB Class Name     |  LFB  |  Description    |   Ref   |\n| Class |                     |Version|                 |         |\n| ID    |                     |       |                 |         |\n+-------+---------------------+-------+-----------------+---------+\n| 65537 |   Ext-Splitter      |  1.0  | A Splitter LFB  |   RFC   |\n|       |                     |       |  will send      |   7409  |\n|       |                     |       |either the same  |         |\n|       |                     |       |   packet or     |         |\n|       |                     |       | chunks of one   |         |\n|       |                     |       |   packet to     |         |\n|       |                     |       | multiple LFBs.  |         |\n+-------+---------------------+-------+-----------------+---------+\n| 65538 |    Ext-Merger       |   1.0 |  A Merger LFB   |   RFC   |\n|       |                     |       |    receives     |   7409  |\n|       |                     |       |    multiple     |         |\n|       |                     |       |   packets or    |         |\n|       |                     |       |    multiple     |         |\n|       |                     |       | chunks of the   |         |\n|       |                     |       |  same packet    |         |\n|       |                     |       |   and merges    |         |\n|       |                     |       | them into one.  |         |\n+-------+---------------------+-------+-----------------+---------+\n| 65539 | Ext-                |   1.0 | A core LFB to   |   RFC   |\n|       | CoreParallelization |       | signify the     |   7409  |\n|       |                     |       | parallelization |         |\n|       |                     |       |   capability    |         |\n+-------+---------------------+-------+-----------------+---------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "Logical Functional Block (LFB) Class Names and Class Identifiers",
      "zh-CHS": "逻辑功能块（LFB）类名和类标识符"
    },
    {
      "indent": 0,
      "text": "6.2. Metadata ID",
      "section_title": true,
      "zh-CHS": "6.2. 元数据ID"
    },
    {
      "indent": 3,
      "text": "The Metadata ID namespace is 32-bits long. Values assigned by this specification are:",
      "zh-CHS": "元数据ID命名空间的长度为32位。本规范指定的值为："
    },
    {
      "indent": 13,
      "text": "+------------+---------------------+-----------+\n|   Value    |         Name        | Reference |\n+------------+---------------------+-----------+\n| 0x00000010 | ParallelMetadataSet |  RFC 7409 |\n+------------+---------------------+-----------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 16,
      "text": "Metadata ID Assigned by this Specification",
      "zh-CHS": "此规范分配的元数据ID"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "zh-CHS": "7. 安全考虑"
    },
    {
      "indent": 3,
      "text": "This document does not alter either the ForCES model [RFC5812] or the ForCES protocol [RFC5810]. As such, it has no impact on their security considerations. This document simply defines the operational parameters and capabilities of LFBs that perform parallelization and not how parallelization is implemented. Finally, this document does not attempt to analyze the presence or possibility of security interactions created by allowing parallel operations on packets. Any such issues, if they exist, are for the designers of the particular data path, not the general mechanism.",
      "zh-CHS": "本文件不改变部队模型[RFC5812]或部队协议[RFC5810]。因此，这对他们的安全考虑没有影响。本文档仅定义执行并行化的LFB的操作参数和功能，而不是如何实现并行化。最后，本文不试图分析通过允许对数据包进行并行操作而产生的安全交互的存在或可能性。任何此类问题（如果存在）都是针对特定数据路径的设计者，而不是针对一般机制。"
    },
    {
      "indent": 0,
      "text": "8. References",
      "section_title": true,
      "zh-CHS": "8. 工具书类"
    },
    {
      "indent": 0,
      "text": "8.1. Normative References",
      "section_title": true,
      "zh-CHS": "8.1. 规范性引用文件"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "zh-CHS": "[RFC2119]Bradner，S.，“RFC中用于表示需求水平的关键词”，BCP 14，RFC 2119，1997年3月<http://www.rfc-editor.org/info/rfc2119>."
    },
    {
      "indent": 3,
      "text": "[RFC5810] Doria, A., Hadi Salim, J., Haas, R., Khosravi, H., Wang, W., Dong, L., Gopal, R., and J. Halpern, \"Forwarding and Control Element Separation (ForCES) Protocol Specification\", RFC 5810, March 2010, <http://www.rfc-editor.org/info/rfc5810>.",
      "zh-CHS": "[RFC5810]Doria，A.，Hadi Salim，J.，Haas，R.，Khosravi，H.，Wang，W.，Dong，L.，Gopal，R.，和J.Halpern，“转发和控制元件分离（部队）协议规范”，RFC 58102010年3月<http://www.rfc-editor.org/info/rfc5810>."
    },
    {
      "indent": 3,
      "text": "[RFC5812] Halpern, J. and J. Hadi Salim, \"Forwarding and Control Element Separation (ForCES) Forwarding Element Model\", RFC 5812, March 2010, <http://www.rfc-editor.org/info/rfc5812>.",
      "zh-CHS": "[RFC5812]Halpern，J.和J.Hadi Salim，“转发和控制单元分离（部队）转发单元模型”，RFC 5812，2010年3月<http://www.rfc-editor.org/info/rfc5812>."
    },
    {
      "indent": 3,
      "text": "[RFC6956] Wang, W., Haleplidis, E., Ogawa, K., Li, C., and J. Halpern, \"Forwarding and Control Element Separation (ForCES) Logical Function Block (LFB) Library\", RFC 6956, June 2013, <http://www.rfc-editor.org/info/rfc6956>.",
      "zh-CHS": "[RFC6956]Wang，W.，Haleplidis，E.，Ogawa，K.，Li，C.，和J.Halpern，“转发和控制元件分离（部队）逻辑功能块（LFB）库”，RFC 69562013年6月<http://www.rfc-editor.org/info/rfc6956>."
    },
    {
      "indent": 3,
      "text": "[RFC7408] Haleplidis, E., \"Forwarding and Control Element Separation (ForCES) Model Extension\", RFC 7408, November 2014, <http://www.rfc-editor.org/info/rfc7408>.",
      "zh-CHS": "[RFC7408]Haleplidis，E.“转发和控制单元分离（部队）模型扩展”，RFC 7408，2014年11月<http://www.rfc-editor.org/info/rfc7408>."
    },
    {
      "indent": 0,
      "text": "8.2. Informative References",
      "section_title": true,
      "zh-CHS": "8.2. 资料性引用"
    },
    {
      "indent": 3,
      "text": "[Cilk] Massachusetts Institute of Technology, \"The Cilk Project\", <http://supertech.csail.mit.edu/cilk/>.",
      "zh-CHS": "[Cilk]麻省理工学院，“Cilk项目”<http://supertech.csail.mit.edu/cilk/>."
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "zh-CHS": "致谢"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank Edward Crabbe for the initial discussion that led to the creation of this document. They also thank Jamal Hadi Salim and Dave Hood for comments and discussions and Adrian Farrel for his AD review that made this document better. Finally, the authors thank Francis Dupont for his Gen-Art review and Magnus Nystroem for his security review both of which refined this document to its final shape.",
      "zh-CHS": "作者要感谢Edward Crabbe的初步讨论，这导致了本文件的创建。他们还感谢贾马尔·哈迪·萨利姆（Jamal Hadi Salim）和戴夫·胡德（Dave Hood）的评论和讨论，并感谢阿德里安·法雷尔（Adrian Farrel）的广告评论，使本文档变得更好。最后，作者感谢弗朗西斯·杜邦（Francis Dupont）的Gen Art review和马格纳斯·尼斯特罗姆（Magnus Nystroem）的安全评论，这两篇评论都将本文档细化到了最终的形式。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "zh-CHS": "作者地址"
    },
    {
      "indent": 3,
      "text": "Evangelos Haleplidis University of Patras Department of Electrical and Computer Engineering Patras 26500 Greece",
      "zh-CHS": "佩特雷大学电气与计算机工程系帕特雷26500希腊分校"
    },
    {
      "indent": 3,
      "text": "EMail: ehalep@ece.upatras.gr",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Joel Halpern Ericsson P.O. Box 6049 Leesburg, VA 20178 United States",
      "zh-CHS": "美国弗吉尼亚州利斯堡市Joel Halpern Ericsson邮政信箱6049号，邮编20178"
    },
    {
      "indent": 3,
      "text": "Phone: +1 703 371 3043\nEMail: joel.halpern@ericsson.com",
      "raw": true,
      "zh-CHS": " "
    }
  ]
}