{
  "title": {
    "text": "RFC 7950: The YANG 1.1 Data Modeling Language",
    "zh-CHS": "RFC 7950"
  },
  "number": 7950,
  "created_at": "2021-11-01 09:15:44.979386+08:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                 M. Bjorklund, Ed.\nRequest for Comments: 7950                                Tail-f Systems\nCategory: Standards Track                                    August 2016\nISSN: 2070-1721",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 18,
      "text": "The YANG 1.1 Data Modeling Language",
      "zh-CHS": "YANG 1.1数据建模语言"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "zh-CHS": "摘要"
    },
    {
      "indent": 3,
      "text": "YANG is a data modeling language used to model configuration data, state data, Remote Procedure Calls, and notifications for network management protocols. This document describes the syntax and semantics of version 1.1 of the YANG language. YANG version 1.1 is a maintenance release of the YANG language, addressing ambiguities and defects in the original specification. There are a small number of backward incompatibilities from YANG version 1. This document also specifies the YANG mappings to the Network Configuration Protocol (NETCONF).",
      "zh-CHS": "YANG是一种数据建模语言，用于为网络管理协议的配置数据、状态数据、远程过程调用和通知建模。本文档描述了YANG语言1.1版的语法和语义。YANG版本1.1是YANG语言的维护版本，解决了原始规范中的歧义和缺陷。YANG版本1中存在少量向后不兼容。本文档还指定了到网络配置协议（NETCONF）的映射。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "zh-CHS": "关于下段备忘"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "zh-CHS": "这是一份互联网标准跟踪文件。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "zh-CHS": "本文件是互联网工程任务组（IETF）的产品。它代表了IETF社区的共识。它已经接受了公众审查，并已被互联网工程指导小组（IESG）批准出版。有关互联网标准的更多信息，请参见RFC 7841第2节。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7950.",
      "zh-CHS": "有关本文件当前状态、任何勘误表以及如何提供反馈的信息，请访问http://www.rfc-editor.org/info/rfc7950."
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "zh-CHS": "版权公告"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2016 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "zh-CHS": "版权所有（c）2016 IETF信托基金和确定为文件作者的人员。版权所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "zh-CHS": "本文件受BCP 78和IETF信托有关IETF文件的法律规定的约束(http://trustee.ietf.org/license-info)自本文件出版之日起生效。请仔细阅读这些文件，因为它们描述了您对本文件的权利和限制。从本文件中提取的代码组件必须包括信托法律条款第4.e节中所述的简化BSD许可证文本，并提供简化BSD许可证中所述的无担保。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "zh-CHS": "本文件可能包含2008年11月10日之前发布或公开的IETF文件或IETF贡献中的材料。控制某些材料版权的人员可能未授予IETF信托允许在IETF标准流程之外修改此类材料的权利。在未从控制此类材料版权的人员处获得充分许可的情况下，不得在IETF标准流程之外修改本文件，也不得在IETF标准流程之外创建其衍生作品，除了将其格式化以RFC形式发布或将其翻译成英语以外的其他语言。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "zh-CHS": "目录"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................9\n   1.1. Summary of Changes from RFC 6020 ..........................10\n2. Key Words ......................................................12\n3. Terminology ....................................................12\n   3.1. A Note on Examples ........................................16\n4. YANG Overview ..................................................16\n   4.1. Functional Overview .......................................16\n   4.2. Language Overview .........................................18\n        4.2.1. Modules and Submodules .............................18\n        4.2.2. Data Modeling Basics ...............................19\n        4.2.3. Configuration and State Data .......................23\n        4.2.4. Built-In Types .....................................24\n        4.2.5. Derived Types (typedef) ............................25\n        4.2.6. Reusable Node Groups (grouping) ....................25\n        4.2.7. Choices ............................................27\n        4.2.8. Extending Data Models (augment) ....................28\n        4.2.9. Operation Definitions ..............................29\n        4.2.10. Notification Definitions ..........................31\n5. Language Concepts ..............................................32\n   5.1. Modules and Submodules ....................................32\n        5.1.1. Import and Include by Revision .....................33\n        5.1.2. Module Hierarchies .................................34\n   5.2. File Layout ...............................................36\n   5.3. XML Namespaces ............................................36\n        5.3.1. YANG XML Namespace .................................36\n   5.4. Resolving Grouping, Type, and Identity Names ..............37\n   5.5. Nested Typedefs and Groupings .............................37\n   5.6. Conformance ...............................................38\n        5.6.1. Basic Behavior .....................................38\n        5.6.2. Optional Features ..................................38\n        5.6.3. Deviations .........................................39\n        5.6.4. Announcing Conformance Information in NETCONF ......40\n        5.6.5. Implementing a Module ..............................40\n   5.7. Datastore Modification ....................................44\n6. YANG Syntax ....................................................44\n   6.1. Lexical Tokenization ......................................45\n        6.1.1. Comments ...........................................45\n        6.1.2. Tokens .............................................45\n        6.1.3. Quoting ............................................45\n   6.2. Identifiers ...............................................47\n        6.2.1. Identifiers and Their Namespaces ...................47\n   6.3. Statements ................................................48\n        6.3.1. Language Extensions ................................48\n   6.4. XPath Evaluations .........................................49\n        6.4.1. XPath Context ......................................50\n   6.5. Schema Node Identifier ....................................54",
      "raw": true,
      "toc": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "7. YANG Statements ................................................55\n   7.1. The \"module\" Statement ....................................55\n        7.1.1. The module's Substatements .........................56\n        7.1.2. The \"yang-version\" Statement .......................57\n        7.1.3. The \"namespace\" Statement ..........................57\n        7.1.4. The \"prefix\" Statement .............................57\n        7.1.5. The \"import\" Statement .............................58\n        7.1.6. The \"include\" Statement ............................59\n        7.1.7. The \"organization\" Statement .......................60\n        7.1.8. The \"contact\" Statement ............................60\n        7.1.9. The \"revision\" Statement ...........................60\n        7.1.10. Usage Example .....................................61\n   7.2. The \"submodule\" Statement .................................62\n        7.2.1. The submodule's Substatements ......................63\n        7.2.2. The \"belongs-to\" Statement .........................63\n        7.2.3. Usage Example ......................................64\n   7.3. The \"typedef\" Statement ...................................65\n        7.3.1. The typedef's Substatements ........................65\n        7.3.2. The typedef's \"type\" Statement .....................65\n        7.3.3. The \"units\" Statement ..............................65\n        7.3.4. The typedef's \"default\" Statement ..................66\n        7.3.5. Usage Example ......................................66\n   7.4. The \"type\" Statement ......................................66\n        7.4.1. The type's Substatements ...........................67\n   7.5. The \"container\" Statement .................................67\n        7.5.1. Containers with Presence ...........................67\n        7.5.2. The container's Substatements ......................68\n        7.5.3. The \"must\" Statement ...............................69\n        7.5.4. The must's Substatements ...........................70\n        7.5.5. The \"presence\" Statement ...........................71\n        7.5.6. The container's Child Node Statements ..............71\n        7.5.7. XML Encoding Rules .................................71\n        7.5.8. NETCONF <edit-config> Operations ...................72\n        7.5.9. Usage Example ......................................72\n   7.6. The \"leaf\" Statement ......................................73\n        7.6.1. The leaf's Default Value ...........................74\n        7.6.2. The leaf's Substatements ...........................75\n        7.6.3. The leaf's \"type\" Statement ........................75\n        7.6.4. The leaf's \"default\" Statement .....................75\n        7.6.5. The leaf's \"mandatory\" Statement ...................76\n        7.6.6. XML Encoding Rules .................................76\n        7.6.7. NETCONF <edit-config> Operations ...................76\n        7.6.8. Usage Example ......................................77\n   7.7. The \"leaf-list\" Statement .................................77\n        7.7.1. Ordering ...........................................78\n        7.7.2. The leaf-list's Default Values .....................79\n        7.7.3. The leaf-list's Substatements ......................80\n        7.7.4. The leaf-list's \"default\" Statement ................80",
      "raw": true,
      "toc": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "     7.7.5. The \"min-elements\" Statement .......................80\n     7.7.6. The \"max-elements\" Statement .......................81\n     7.7.7. The \"ordered-by\" Statement .........................81\n     7.7.8. XML Encoding Rules .................................82\n     7.7.9. NETCONF <edit-config> Operations ...................82\n     7.7.10. Usage Example .....................................83\n7.8. The \"list\" Statement ......................................84\n     7.8.1. The list's Substatements ...........................85\n     7.8.2. The list's \"key\" Statement .........................85\n     7.8.3. The list's \"unique\" Statement ......................86\n     7.8.4. The list's Child Node Statements ...................87\n     7.8.5. XML Encoding Rules .................................88\n     7.8.6. NETCONF <edit-config> Operations ...................88\n     7.8.7. Usage Example ......................................90\n7.9. The \"choice\" Statement ....................................93\n     7.9.1. The choice's Substatements .........................94\n     7.9.2. The choice's \"case\" Statement ......................94\n     7.9.3. The choice's \"default\" Statement ...................96\n     7.9.4. The choice's \"mandatory\" Statement .................98\n     7.9.5. XML Encoding Rules .................................98\n     7.9.6. Usage Example ......................................99\n7.10. The \"anydata\" Statement .................................100\n     7.10.1. The anydata's Substatements ......................100\n     7.10.2. XML Encoding Rules ...............................101\n     7.10.3. NETCONF <edit-config> Operations .................101\n     7.10.4. Usage Example ....................................101\n7.11. The \"anyxml\" Statement ..................................102\n     7.11.1. The anyxml's Substatements .......................103\n     7.11.2. XML Encoding Rules ...............................103\n     7.11.3. NETCONF <edit-config> Operations .................103\n     7.11.4. Usage Example ....................................104\n7.12. The \"grouping\" Statement ................................104\n     7.12.1. The grouping's Substatements .....................105\n     7.12.2. Usage Example ....................................105\n7.13. The \"uses\" Statement ....................................106\n     7.13.1. The uses's Substatements .........................106\n     7.13.2. The \"refine\" Statement ...........................106\n     7.13.3. XML Encoding Rules ...............................107\n     7.13.4. Usage Example ....................................107\n7.14. The \"rpc\" Statement .....................................108\n     7.14.1. The rpc's Substatements ..........................109\n     7.14.2. The \"input\" Statement ............................109\n     7.14.3. The \"output\" Statement ...........................110\n     7.14.4. NETCONF XML Encoding Rules .......................111\n     7.14.5. Usage Example ....................................112",
      "raw": true,
      "toc": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "   7.15. The \"action\" Statement ..................................113\n        7.15.1. The action's Substatements .......................114\n        7.15.2. NETCONF XML Encoding Rules .......................114\n        7.15.3. Usage Example ....................................115\n   7.16. The \"notification\" Statement ............................116\n        7.16.1. The notification's Substatements .................117\n        7.16.2. NETCONF XML Encoding Rules .......................117\n        7.16.3. Usage Example ....................................118\n   7.17. The \"augment\" Statement .................................119\n        7.17.1. The augment's Substatements ......................121\n        7.17.2. XML Encoding Rules ...............................121\n        7.17.3. Usage Example ....................................122\n   7.18. The \"identity\" Statement ................................124\n        7.18.1. The identity's Substatements .....................124\n        7.18.2. The \"base\" Statement .............................124\n        7.18.3. Usage Example ....................................125\n   7.19. The \"extension\" Statement ...............................126\n        7.19.1. The extension's Substatements ....................126\n        7.19.2. The \"argument\" Statement .........................127\n        7.19.3. Usage Example ....................................127\n   7.20. Conformance-Related Statements ..........................128\n        7.20.1. The \"feature\" Statement ..........................128\n        7.20.2. The \"if-feature\" Statement .......................130\n        7.20.3. The \"deviation\" Statement ........................131\n   7.21. Common Statements .......................................134\n        7.21.1. The \"config\" Statement ...........................134\n        7.21.2. The \"status\" Statement ...........................135\n        7.21.3. The \"description\" Statement ......................136\n        7.21.4. The \"reference\" Statement ........................136\n        7.21.5. The \"when\" Statement .............................136\n8. Constraints ...................................................138\n   8.1. Constraints on Data ......................................138\n   8.2. Configuration Data Modifications .........................139\n   8.3. NETCONF Constraint Enforcement Model .....................139\n        8.3.1. Payload Parsing ...................................139\n        8.3.2. NETCONF <edit-config> Processing ..................140\n        8.3.3. Validation ........................................141\n9. Built-In Types ................................................141\n   9.1. Canonical Representation .................................141\n   9.2. The Integer Built-In Types ...............................142\n        9.2.1. Lexical Representation ............................142\n        9.2.2. Canonical Form ....................................143\n        9.2.3. Restrictions ......................................143\n        9.2.4. The \"range\" Statement .............................143\n        9.2.5. Usage Example .....................................144",
      "raw": true,
      "toc": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "9.3. The decimal64 Built-In Type ..............................144\n     9.3.1. Lexical Representation ............................145\n     9.3.2. Canonical Form ....................................145\n     9.3.3. Restrictions ......................................145\n     9.3.4. The \"fraction-digits\" Statement ...................145\n     9.3.5. Usage Example .....................................146\n9.4. The string Built-In Type .................................146\n     9.4.1. Lexical Representation ............................146\n     9.4.2. Canonical Form ....................................147\n     9.4.3. Restrictions ......................................147\n     9.4.4. The \"length\" Statement ............................147\n     9.4.5. The \"pattern\" Statement ...........................148\n     9.4.6. The \"modifier\" Statement ..........................148\n     9.4.7. Usage Example .....................................149\n9.5. The boolean Built-In Type ................................150\n     9.5.1. Lexical Representation ............................150\n     9.5.2. Canonical Form ....................................150\n     9.5.3. Restrictions ......................................150\n9.6. The enumeration Built-In Type ............................150\n     9.6.1. Lexical Representation ............................150\n     9.6.2. Canonical Form ....................................151\n     9.6.3. Restrictions ......................................151\n     9.6.4. The \"enum\" Statement ..............................151\n     9.6.5. Usage Example .....................................152\n9.7. The bits Built-In Type ...................................154\n     9.7.1. Restrictions ......................................154\n     9.7.2. Lexical Representation ............................154\n     9.7.3. Canonical Form ....................................154\n     9.7.4. The \"bit\" Statement ...............................155\n     9.7.5. Usage Example .....................................156\n9.8. The binary Built-In Type .................................157\n     9.8.1. Restrictions ......................................157\n     9.8.2. Lexical Representation ............................157\n     9.8.3. Canonical Form ....................................157\n9.9. The leafref Built-In Type ................................157\n     9.9.1. Restrictions ......................................158\n     9.9.2. The \"path\" Statement ..............................158\n     9.9.3. The \"require-instance\" Statement ..................159\n     9.9.4. Lexical Representation ............................159\n     9.9.5. Canonical Form ....................................159\n     9.9.6. Usage Example .....................................159\n9.10. The identityref Built-In Type ...........................163\n     9.10.1. Restrictions .....................................163\n     9.10.2. The identityref's \"base\" Statement ...............163\n     9.10.3. Lexical Representation ...........................163\n     9.10.4. Canonical Form ...................................164\n     9.10.5. Usage Example ....................................164",
      "raw": true,
      "toc": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "   9.11. The empty Built-In Type .................................165\n        9.11.1. Restrictions .....................................165\n        9.11.2. Lexical Representation ...........................165\n        9.11.3. Canonical Form ...................................165\n        9.11.4. Usage Example ....................................166\n   9.12. The union Built-In Type .................................166\n        9.12.1. Restrictions .....................................166\n        9.12.2. Lexical Representation ...........................166\n        9.12.3. Canonical Form ...................................167\n        9.12.4. Usage Example ....................................167\n   9.13. The instance-identifier Built-In Type ...................168\n        9.13.1. Restrictions .....................................168\n        9.13.2. Lexical Representation ...........................169\n        9.13.3. Canonical Form ...................................169\n        9.13.4. Usage Example ....................................169\n10. XPath Functions ..............................................170\n   10.1. Function for Node Sets ..................................170\n        10.1.1. current() ........................................170\n   10.2. Function for Strings ....................................170\n        10.2.1. re-match() .......................................170\n   10.3. Function for the YANG Types \"leafref\" and\n         \"instance-identifier\" ...................................171\n        10.3.1. deref() ..........................................171\n   10.4. Functions for the YANG Type \"identityref\" ...............172\n        10.4.1. derived-from() ...................................172\n        10.4.2. derived-from-or-self() ...........................174\n   10.5. Function for the YANG Type \"enumeration\" ................174\n        10.5.1. enum-value() .....................................174\n   10.6. Function for the YANG Type \"bits\" .......................175\n        10.6.1. bit-is-set() .....................................175\n11. Updating a Module ............................................176\n12. Coexistence with YANG Version 1 ..............................179\n13. YIN ..........................................................179\n   13.1. Formal YIN Definition ...................................180\n        13.1.1. Usage Example ....................................182\n14. YANG ABNF Grammar ............................................184\n15. NETCONF Error Responses for YANG-Related Errors ..............211\n   15.1. Error Message for Data That Violates a \"unique\"\n         Statement ...............................................211\n   15.2. Error Message for Data That Violates a\n         \"max-elements\" Statement ................................211\n   15.3. Error Message for Data That Violates a\n         \"min-elements\" Statement ................................211\n   15.4. Error Message for Data That Violates a \"must\"\n         Statement ...............................................212\n   15.5. Error Message for Data That Violates a\n         \"require-instance\" Statement ............................212",
      "raw": true,
      "toc": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "   15.6. Error Message for Data That Violates a Mandatory\n         \"choice\" Statement ......................................212\n   15.7. Error Message for the \"insert\" Operation ................212\n16. IANA Considerations ..........................................213\n17. Security Considerations ......................................213\n18. References ...................................................214\n   18.1. Normative References ....................................214\n   18.2. Informative References ..................................215\nAcknowledgements .................................................217\nContributors .....................................................217\nAuthor's Address .................................................217",
      "raw": true,
      "toc": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "zh-CHS": "1. 介绍"
    },
    {
      "indent": 3,
      "text": "YANG is a data modeling language originally designed to model configuration and state data manipulated by the Network Configuration Protocol (NETCONF), NETCONF Remote Procedure Calls, and NETCONF notifications [RFC6241]. Since the publication of YANG version 1 [RFC6020], YANG has been used or proposed to be used for other protocols (e.g., RESTCONF [RESTCONF] and the Constrained Application Protocol (CoAP) Management Interface (CoMI) [CoMI]). Further, encodings other than XML have been proposed (e.g., JSON [RFC7951]).",
      "zh-CHS": "YANG是一种数据建模语言，最初设计用于对由网络配置协议（NETCONF）、NETCONF远程过程调用和NETCONF通知[RFC6241]操作的配置和状态数据进行建模。自YANG版本1[RFC6020]发布以来，YANG已被用于或拟用于其他协议（例如RESTCONF[RESTCONF]和受限应用协议（CoAP）管理接口（CoMI）[CoMI]）。此外，还提出了XML以外的编码（例如，JSON[RFC7951]）。"
    },
    {
      "indent": 3,
      "text": "This document describes the syntax and semantics of version 1.1 of the YANG language. It also describes how a data model defined in a YANG module is encoded in the Extensible Markup Language (XML) [XML] and how NETCONF operations are used to manipulate the data. Other protocols and encodings are possible but are out of scope for this specification.",
      "zh-CHS": "本文档描述了YANG语言1.1版的语法和语义。它还描述了如何用可扩展标记语言（XML）[XML]对模块中定义的数据模型进行编码，以及如何使用NETCONF操作来操作数据。其他协议和编码是可能的，但不在本规范的范围内。"
    },
    {
      "indent": 3,
      "text": "In terms of developing YANG data models, [YANG-Guidelines] provides some guidelines and recommendations.",
      "zh-CHS": "在开发YANG数据模型方面，[YANG指南]提供了一些指南和建议。"
    },
    {
      "indent": 3,
      "text": "Note that this document does not obsolete RFC 6020 [RFC6020].",
      "zh-CHS": "请注意，本文件并未废除RFC 6020[RFC6020]。"
    },
    {
      "indent": 0,
      "text": "1.1. Summary of Changes from RFC 6020",
      "section_title": true,
      "zh-CHS": "1.1. RFC 6020变更汇总表"
    },
    {
      "indent": 3,
      "text": "This document defines version 1.1 of the YANG language. YANG version 1.1 is a maintenance release of the YANG language, addressing ambiguities and defects in the original specification [RFC6020].",
      "zh-CHS": "本文件定义了YANG语言的1.1版。YANG版本1.1是YANG语言的维护版本，解决了原始规范[RFC6020]中的歧义和缺陷。"
    },
    {
      "indent": 3,
      "text": "The following changes are not backward compatible with YANG version 1:",
      "zh-CHS": "以下更改与YANG版本1不向后兼容："
    },
    {
      "indent": 3,
      "text": "o Changed the rules for the interpretation of escaped characters in double-quoted strings. This is a backward-incompatible change from YANG version 1. When updating a YANG version 1 module to 1.1 and the module uses a character sequence that is now illegal, the string must be changed to match the new rules. See Section 6.1.3 for details.",
      "zh-CHS": "o 更改了双引号字符串中转义字符的解释规则。这是对YANG版本1的向后不兼容更改。当将版本1模块更新为1.1并且模块使用的字符序列现在是非法的时，必须更改字符串以匹配新规则。详见第6.1.3节。"
    },
    {
      "indent": 3,
      "text": "o An unquoted string cannot contain any single or double quote characters. This is a backward-incompatible change from YANG version 1. When updating a YANG version 1 module to 1.1 and the module uses such quote characters, the string must be changed to match the new rules. See Section 6.1.3 for details.",
      "zh-CHS": "o 未加引号的字符串不能包含任何单引号或双引号字符。这是对YANG版本1的向后不兼容更改。将第1版模块更新为1.1版时，如果模块使用此类引号字符，则必须更改字符串以匹配新规则。详见第6.1.3节。"
    },
    {
      "indent": 3,
      "text": "o Made \"when\" and \"if-feature\" illegal on list keys. This is a backward-incompatible change from YANG version 1. When updating a YANG version 1 module to 1.1 and the module uses these constructs, they must be removed to match the new rules.",
      "zh-CHS": "o 使列表键上的“何时”和“如果”功能非法。这是对YANG版本1的向后不兼容更改。将第1版模块更新为1.1版并且模块使用这些结构时，必须删除这些结构以匹配新规则。"
    },
    {
      "indent": 3,
      "text": "o Defined the legal characters in YANG modules. When updating a YANG version 1 module to 1.1, any characters that are now illegal must be removed. See Section 6 for details.",
      "zh-CHS": "o 定义了杨模块中的法律特征。将1版模块更新为1.1时，必须删除所有现在非法的字符。详见第6节。"
    },
    {
      "indent": 3,
      "text": "o Made noncharacters illegal in the built-in type \"string\". This change affects the runtime behavior of YANG-based protocols.",
      "zh-CHS": "o 使内置类型“string”中的非字符非法。此更改会影响基于YANG的协议的运行时行为。"
    },
    {
      "indent": 3,
      "text": "The following additional changes have been done to YANG:",
      "zh-CHS": "对YANG进行了以下附加更改："
    },
    {
      "indent": 3,
      "text": "o Changed the YANG version from \"1\" to \"1.1\".",
      "zh-CHS": "o 将YANG版本从“1”更改为“1.1”。"
    },
    {
      "indent": 3,
      "text": "o Made the \"yang-version\" statement mandatory in YANG version \"1.1\".",
      "zh-CHS": "o 在杨版“1.1”中强制执行“杨版”声明。"
    },
    {
      "indent": 3,
      "text": "o Extended the \"if-feature\" syntax to be a boolean expression over feature names.",
      "zh-CHS": "o 扩展了“if feature”语法，使其成为功能名称上的布尔表达式。"
    },
    {
      "indent": 3,
      "text": "o Allow \"if-feature\" in \"bit\", \"enum\", and \"identity\".",
      "zh-CHS": "o 允许在“位”、“枚举”和“标识”中使用“如果特征”。"
    },
    {
      "indent": 3,
      "text": "o Allow \"if-feature\" in \"refine\".",
      "zh-CHS": "o 在“优化”中允许“如果特征”。"
    },
    {
      "indent": 3,
      "text": "o Allow \"choice\" as a shorthand \"case\" statement (see Section 7.9.2).",
      "zh-CHS": "o 允许“选择”作为简写的“案例”陈述（见第7.9.2节）。"
    },
    {
      "indent": 3,
      "text": "o Added a new substatement \"modifier\" to the \"pattern\" statement (see Section 9.4.6).",
      "zh-CHS": "o 在“模式”语句中添加了新的子语句“修饰符”（见第9.4.6节）。"
    },
    {
      "indent": 3,
      "text": "o Allow \"must\" in \"input\", \"output\", and \"notification\".",
      "zh-CHS": "o 在“输入”、“输出”和“通知”中允许“必须”。"
    },
    {
      "indent": 3,
      "text": "o Allow \"require-instance\" in leafref.",
      "zh-CHS": "o 允许在leafref中使用“require instance”。"
    },
    {
      "indent": 3,
      "text": "o Allow \"description\" and \"reference\" in \"import\" and \"include\".",
      "zh-CHS": "o 在“导入”和“包含”中允许“说明”和“引用”。"
    },
    {
      "indent": 3,
      "text": "o Allow imports of multiple revisions of a module.",
      "zh-CHS": "o 允许导入模块的多个修订版。"
    },
    {
      "indent": 3,
      "text": "o Allow \"augment\" to add conditionally mandatory nodes (see Section 7.17).",
      "zh-CHS": "o 允许“增强”添加有条件的强制性节点（见第7.17节）。"
    },
    {
      "indent": 3,
      "text": "o Added a set of new XML Path Language (XPath) functions in Section 10.",
      "zh-CHS": "o 在第10节中添加了一组新的XML路径语言（XPath）函数。"
    },
    {
      "indent": 3,
      "text": "o Clarified the XPath context's tree in Section 6.4.1.",
      "zh-CHS": "o 在第6.4.1节中阐明了XPath上下文的树。"
    },
    {
      "indent": 3,
      "text": "o Defined the string value of an identityref in XPath expressions (see Section 9.10).",
      "zh-CHS": "o 在XPath表达式中定义identityref的字符串值（请参见第9.10节）。"
    },
    {
      "indent": 3,
      "text": "o Clarified what unprefixed names mean in leafrefs in typedefs (see Sections 6.4.1 and 9.9.2).",
      "zh-CHS": "o 阐明typedefs中leafrefs中未固定名称的含义（见第6.4.1节和第9.9.2节）。"
    },
    {
      "indent": 3,
      "text": "o Allow identities to be derived from multiple base identities (see Sections 7.18 and 9.10).",
      "zh-CHS": "o 允许从多个基本标识派生标识（见第7.18节和第9.10节）。"
    },
    {
      "indent": 3,
      "text": "o Allow enumerations and bits to be subtyped (see Sections 9.6 and 9.7).",
      "zh-CHS": "o 允许对枚举和位进行子类型化（参见第9.6节和第9.7节）。"
    },
    {
      "indent": 3,
      "text": "o Allow leaf-lists to have default values (see Section 7.7.2).",
      "zh-CHS": "o 允许叶列表具有默认值（见第7.7.2节）。"
    },
    {
      "indent": 3,
      "text": "o Allow non-unique values in non-configuration leaf-lists (see Section 7.7).",
      "zh-CHS": "o 在非配置叶列表中允许非唯一值（见第7.7节）。"
    },
    {
      "indent": 3,
      "text": "o Use syntax for case-sensitive strings (as per [RFC7405]) in the grammar.",
      "zh-CHS": "o 语法中区分大小写的字符串使用语法（按照[RFC7405]）。"
    },
    {
      "indent": 3,
      "text": "o Changed the module advertisement mechanism (see Section 5.6.4).",
      "zh-CHS": "o 更改了模块广告机制（见第5.6.4节）。"
    },
    {
      "indent": 3,
      "text": "o Changed the scoping rules for definitions in submodules. A submodule can now reference all definitions in all submodules that belong to the same module, without using the \"include\" statement.",
      "zh-CHS": "o 更改了子模块中定义的作用域规则。子模块现在可以引用属于同一模块的所有子模块中的所有定义，而无需使用“include”语句。"
    },
    {
      "indent": 3,
      "text": "o Added a new statement \"action\", which is used to define operations tied to data nodes.",
      "zh-CHS": "o 添加了一个新语句“action”，用于定义绑定到数据节点的操作。"
    },
    {
      "indent": 3,
      "text": "o Allow notifications to be tied to data nodes.",
      "zh-CHS": "o 允许将通知绑定到数据节点。"
    },
    {
      "indent": 3,
      "text": "o Added a new data definition statement \"anydata\" (see Section 7.10), which is RECOMMENDED to be used instead of \"anyxml\" when the data can be modeled in YANG.",
      "zh-CHS": "o 添加了一个新的数据定义语句“anydata”（参见第7.10节），建议在数据可以用XML建模时使用该语句代替“anyxml”。"
    },
    {
      "indent": 3,
      "text": "o Allow types \"empty\" and \"leafref\" in unions.",
      "zh-CHS": "o 允许在联合中使用类型“empty”和“leafref”。"
    },
    {
      "indent": 3,
      "text": "o Allow type \"empty\" in a key.",
      "zh-CHS": "o 允许在键中键入“empty”。"
    },
    {
      "indent": 3,
      "text": "o Removed the restriction that identifiers could not start with the characters \"xml\".",
      "zh-CHS": "o 删除了标识符不能以字符“xml”开头的限制。"
    },
    {
      "indent": 3,
      "text": "The following changes have been done to the NETCONF mapping:",
      "zh-CHS": "对NETCONF映射进行了以下更改："
    },
    {
      "indent": 3,
      "text": "o A server advertises support for YANG 1.1 modules by using ietf-yang-library [RFC7895] instead of listing them as capabilities in the <hello> message.",
      "zh-CHS": "o 服务器通过使用ietf YANG library[RFC7895]而不是在<hello>消息中将其作为功能列出，来宣传对YANG 1.1模块的支持。"
    },
    {
      "indent": 0,
      "text": "2. Key Words",
      "section_title": true,
      "zh-CHS": "2. 关键词"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119].",
      "zh-CHS": "本文件中的关键词“必须”、“不得”、“必需”、“应”、“不应”、“建议”、“不建议”、“可”和“可选”应按照BCP 14[RFC2119]中的说明进行解释。"
    },
    {
      "indent": 0,
      "text": "3. Terminology",
      "section_title": true,
      "zh-CHS": "3. 术语"
    },
    {
      "indent": 3,
      "text": "The following terms are used within this document:",
      "zh-CHS": "本文件中使用了以下术语："
    },
    {
      "indent": 3,
      "text": "o action: An operation defined for a node in the data tree.",
      "zh-CHS": "o 操作：为数据树中的节点定义的操作。"
    },
    {
      "indent": 3,
      "text": "o anydata: A data node that can contain an unknown set of nodes that can be modeled by YANG, except anyxml.",
      "zh-CHS": "o anydata：一个数据节点，可以包含一组未知的节点，这些节点可以由YANG建模，anyxml除外。"
    },
    {
      "indent": 3,
      "text": "o anyxml: A data node that can contain an unknown chunk of XML data.",
      "zh-CHS": "o anyxml：可以包含未知XML数据块的数据节点。"
    },
    {
      "indent": 3,
      "text": "o augment: Adds new schema nodes to a previously defined schema node.",
      "zh-CHS": "o 扩充：将新架构节点添加到先前定义的架构节点。"
    },
    {
      "indent": 3,
      "text": "o base type: The type from which a derived type was derived, which may be either a built-in type or another derived type.",
      "zh-CHS": "o 基类型：派生类型的派生类型，可以是内置类型或其他派生类型。"
    },
    {
      "indent": 3,
      "text": "o built-in type: A YANG data type defined in the YANG language, such as uint32 or string.",
      "zh-CHS": "o 内置类型：用YANG语言定义的YANG数据类型，如uint32或字符串。"
    },
    {
      "indent": 3,
      "text": "o choice: A schema node where only one of a number of identified alternatives is valid.",
      "zh-CHS": "o 选择：一个模式节点，其中许多已识别的备选方案中只有一个是有效的。"
    },
    {
      "indent": 3,
      "text": "o client: An entity that can access YANG-defined data on a server, over some network management protocol.",
      "zh-CHS": "o 客户机：可以通过某种网络管理协议访问服务器上定义的数据的实体。"
    },
    {
      "indent": 3,
      "text": "o conformance: A measure of how accurately a server follows a data model.",
      "zh-CHS": "o 一致性：衡量服务器遵循数据模型的准确程度。"
    },
    {
      "indent": 3,
      "text": "o container: An interior data node that exists in at most one instance in the data tree. A container has no value, but rather a set of child nodes.",
      "zh-CHS": "o 容器：数据树中最多存在一个实例的内部数据节点。容器没有值，而是一组子节点。"
    },
    {
      "indent": 3,
      "text": "o data definition statement: A statement that defines new data nodes. One of \"container\", \"leaf\", \"leaf-list\", \"list\", \"choice\", \"case\", \"augment\", \"uses\", \"anydata\", and \"anyxml\".",
      "zh-CHS": "o 数据定义语句：定义新数据节点的语句。“容器”、“叶”、“叶列表”、“列表”、“选择”、“案例”、“扩充”、“使用”、“任意数据”和“任意XML”之一。"
    },
    {
      "indent": 3,
      "text": "o data model: A data model describes how data is represented and accessed.",
      "zh-CHS": "o 数据模型：数据模型描述如何表示和访问数据。"
    },
    {
      "indent": 3,
      "text": "o data node: A node in the schema tree that can be instantiated in a data tree. One of container, leaf, leaf-list, list, anydata, and anyxml.",
      "zh-CHS": "o 数据节点：架构树中可以在数据树中实例化的节点。容器、叶、叶列表、列表、anydata和anyxml之一。"
    },
    {
      "indent": 3,
      "text": "o data tree: An instantiated tree of any data modeled with YANG, e.g., configuration data, state data, combined configuration and state data, RPC or action input, RPC or action output, or notification.",
      "zh-CHS": "o 数据树：使用YANG建模的任何数据的实例化树，例如，配置数据、状态数据、组合配置和状态数据、RPC或操作输入、RPC或操作输出或通知。"
    },
    {
      "indent": 3,
      "text": "o derived type: A type that is derived from a built-in type (such as uint32) or another derived type.",
      "zh-CHS": "o 派生类型：从内置类型（如uint32）或其他派生类型派生的类型。"
    },
    {
      "indent": 3,
      "text": "o extension: An extension attaches non-YANG semantics to statements. The \"extension\" statement defines new statements to express these semantics.",
      "zh-CHS": "o 扩展：扩展将非YANG语义附加到语句。“extension”语句定义了新的语句来表达这些语义。"
    },
    {
      "indent": 3,
      "text": "o feature: A mechanism for marking a portion of the model as optional. Definitions can be tagged with a feature name and are only valid on servers that support that feature.",
      "zh-CHS": "o 特性：将模型的一部分标记为可选的机制。定义可以使用功能名称进行标记，并且仅在支持该功能的服务器上有效。"
    },
    {
      "indent": 3,
      "text": "o grouping: A reusable set of schema nodes, which may be used locally in the module and by other modules that import from it. The \"grouping\" statement is not a data definition statement and, as such, does not define any nodes in the schema tree.",
      "zh-CHS": "o 分组：一组可重用的模式节点，可在模块中本地使用，也可由从模块导入的其他模块使用。“grouping”语句不是数据定义语句，因此不定义模式树中的任何节点。"
    },
    {
      "indent": 3,
      "text": "o identifier: A string used to identify different kinds of YANG items by name.",
      "zh-CHS": "o 标识符：用于按名称标识不同类型项目的字符串。"
    },
    {
      "indent": 3,
      "text": "o identity: A globally unique, abstract, and untyped name.",
      "zh-CHS": "o 标识：全局唯一、抽象和非类型化的名称。"
    },
    {
      "indent": 3,
      "text": "o instance identifier: A mechanism for identifying a particular node in a data tree.",
      "zh-CHS": "o 实例标识符：用于标识数据树中特定节点的机制。"
    },
    {
      "indent": 3,
      "text": "o interior node: Nodes within a hierarchy that are not leaf nodes.",
      "zh-CHS": "o 内部节点：层次中不是叶节点的节点。"
    },
    {
      "indent": 3,
      "text": "o leaf: A data node that exists in at most one instance in the data tree. A leaf has a value but no child nodes.",
      "zh-CHS": "o 叶：数据树中最多存在一个实例的数据节点。叶有一个值，但没有子节点。"
    },
    {
      "indent": 3,
      "text": "o leaf-list: Like the leaf node but defines a set of uniquely identifiable nodes rather than a single node. Each node has a value but no child nodes.",
      "zh-CHS": "o 叶列表：与叶节点类似，但定义了一组唯一可识别的节点，而不是单个节点。每个节点都有一个值，但没有子节点。"
    },
    {
      "indent": 3,
      "text": "o list: An interior data node that may exist in multiple instances in the data tree. A list has no value, but rather a set of child nodes.",
      "zh-CHS": "o 列表：可能存在于数据树中多个实例中的内部数据节点。列表没有值，而是一组子节点。"
    },
    {
      "indent": 3,
      "text": "o mandatory node: A mandatory node is one of:",
      "zh-CHS": "o 强制节点：强制节点是以下节点之一："
    },
    {
      "indent": 6,
      "text": "* A leaf, choice, anydata, or anyxml node with a \"mandatory\" statement with the value \"true\".",
      "zh-CHS": "* 具有值为“true”的“强制”语句的叶、选项、anydata或anyxml节点。"
    },
    {
      "indent": 6,
      "text": "* A list or leaf-list node with a \"min-elements\" statement with a value greater than zero.",
      "zh-CHS": "* 具有值大于零的“min elements”语句的列表或叶列表节点。"
    },
    {
      "indent": 6,
      "text": "* A container node without a \"presence\" statement and that has at least one mandatory node as a child.",
      "zh-CHS": "* 没有“presence”语句且至少有一个强制节点作为子节点的容器节点。"
    },
    {
      "indent": 3,
      "text": "o module: A YANG module defines hierarchies of schema nodes. With its definitions and the definitions it imports or includes from elsewhere, a module is self-contained and \"compilable\".",
      "zh-CHS": "o 模块：模块定义模式节点的层次结构。通过定义以及从其他地方导入或包含的定义，模块是自包含的且“可编译的”。"
    },
    {
      "indent": 3,
      "text": "o non-presence container: A container that has no meaning of its own, existing only to contain child nodes.",
      "zh-CHS": "o 非存在容器：一个没有自己意义的容器，存在只是为了包含子节点。"
    },
    {
      "indent": 3,
      "text": "o presence container: A container where the presence of the container itself carries some meaning.",
      "zh-CHS": "o 存在容器：容器本身的存在具有某种意义的容器。"
    },
    {
      "indent": 3,
      "text": "o RPC: A Remote Procedure Call.",
      "zh-CHS": "o RPC：远程过程调用。"
    },
    {
      "indent": 3,
      "text": "o RPC operation: A specific Remote Procedure Call.",
      "zh-CHS": "o RPC操作：特定的远程过程调用。"
    },
    {
      "indent": 3,
      "text": "o schema node: A node in the schema tree. One of action, container, leaf, leaf-list, list, choice, case, rpc, input, output, notification, anydata, and anyxml.",
      "zh-CHS": "o 架构节点：架构树中的节点。操作、容器、叶、叶列表、列表、选项、大小写、rpc、输入、输出、通知、anydata和anyxml之一。"
    },
    {
      "indent": 3,
      "text": "o schema node identifier: A mechanism for identifying a particular node in the schema tree.",
      "zh-CHS": "o 模式节点标识符：用于标识模式树中特定节点的机制。"
    },
    {
      "indent": 3,
      "text": "o schema tree: The definition hierarchy specified within a module.",
      "zh-CHS": "o 架构树：模块中指定的定义层次结构。"
    },
    {
      "indent": 3,
      "text": "o server: An entity that provides access to YANG-defined data to a client, over some network management protocol.",
      "zh-CHS": "o 服务器：通过某种网络管理协议向客户机提供对已定义数据的访问的实体。"
    },
    {
      "indent": 3,
      "text": "o server deviation: A failure of the server to implement a module faithfully.",
      "zh-CHS": "o 服务器偏差：服务器未能忠实地实现模块。"
    },
    {
      "indent": 3,
      "text": "o submodule: A partial module definition that contributes derived types, groupings, data nodes, RPCs, actions, and notifications to a module. A YANG module can be constructed from a number of submodules.",
      "zh-CHS": "o 子模块：向模块提供派生类型、分组、数据节点、RPC、操作和通知的部分模块定义。杨模可以由许多子模构成。"
    },
    {
      "indent": 3,
      "text": "o top-level data node: A data node where there is no other data node between it and a \"module\" or \"submodule\" statement.",
      "zh-CHS": "o 顶级数据节点：与“模块”或“子模块”语句之间没有其他数据节点的数据节点。"
    },
    {
      "indent": 3,
      "text": "o uses: The \"uses\" statement is used to instantiate the set of schema nodes defined in a \"grouping\" statement. The instantiated nodes may be refined and augmented to tailor them to any specific needs.",
      "zh-CHS": "o uses：“uses”语句用于实例化在“grouping”语句中定义的模式节点集。可以对实例化的节点进行细化和扩充，以使其适应任何特定需求。"
    },
    {
      "indent": 3,
      "text": "o value space: For a data type; the set of values permitted by the data type. For a leaf or leaf-list instance; the value space of its data type.",
      "zh-CHS": "o 值空间：用于数据类型；数据类型允许的值集。对于叶或叶列表实例；其数据类型的值空间。"
    },
    {
      "indent": 3,
      "text": "The following terms are defined in [RFC6241]:",
      "zh-CHS": "[RFC6241]中定义了以下术语："
    },
    {
      "indent": 3,
      "text": "o configuration data",
      "zh-CHS": "o 配置数据"
    },
    {
      "indent": 3,
      "text": "o configuration datastore",
      "zh-CHS": "o 配置数据存储"
    },
    {
      "indent": 3,
      "text": "o datastore",
      "zh-CHS": "o 数据存储"
    },
    {
      "indent": 3,
      "text": "o state data",
      "zh-CHS": "o 状态数据"
    },
    {
      "indent": 3,
      "text": "When modeled with YANG, a datastore is realized as an instantiated data tree.",
      "zh-CHS": "当使用YANG建模时，数据存储被实现为实例化的数据树。"
    },
    {
      "indent": 3,
      "text": "When modeled with YANG, a configuration datastore is realized as an instantiated data tree with configuration data.",
      "zh-CHS": "当使用YANG建模时，配置数据存储被实现为带有配置数据的实例化数据树。"
    },
    {
      "indent": 0,
      "text": "3.1. A Note on Examples",
      "section_title": true,
      "zh-CHS": "3.1. 例注"
    },
    {
      "indent": 3,
      "text": "Throughout this document, there are many examples of YANG statements. These examples are supposed to illustrate certain features and are not supposed to be complete, valid YANG modules.",
      "zh-CHS": "在本文件中，有许多杨陈述的例子。这些示例旨在说明某些功能，而不是完整、有效的模块。"
    },
    {
      "indent": 0,
      "text": "4. YANG Overview",
      "section_title": true,
      "zh-CHS": "4. 杨总览"
    },
    {
      "indent": 3,
      "text": "This non-normative section is intended to give a high-level overview of YANG to first-time readers.",
      "zh-CHS": "本非规范性章节旨在向初次阅读的读者提供杨的高级概述。"
    },
    {
      "indent": 0,
      "text": "4.1. Functional Overview",
      "section_title": true,
      "zh-CHS": "4.1. 功能概述"
    },
    {
      "indent": 3,
      "text": "YANG is a language originally designed to model data for the NETCONF protocol. A YANG module defines hierarchies of data that can be used for NETCONF-based operations, including configuration, state data, RPCs, and notifications. This allows a complete description of all data sent between a NETCONF client and server. Although out of scope for this specification, YANG can also be used with protocols other than NETCONF.",
      "zh-CHS": "YANG是一种最初设计用于为NETCONF协议建模数据的语言。模块定义了可用于基于NETCONF的操作的数据层次结构，包括配置、状态数据、RPC和通知。这允许完整描述NETCONF客户端和服务器之间发送的所有数据。尽管超出了本规范的范围，但YANG也可用于NETCONF以外的协议。"
    },
    {
      "indent": 3,
      "text": "YANG models the hierarchical organization of data as a tree in which each node has a name, and either a value or a set of child nodes. YANG provides clear and concise descriptions of the nodes, as well as the interaction between those nodes.",
      "zh-CHS": "YANG将数据的分层组织建模为一棵树，其中每个节点都有一个名称、一个值或一组子节点。YANG对节点以及这些节点之间的交互进行了清晰简洁的描述。"
    },
    {
      "indent": 3,
      "text": "YANG structures data models into modules and submodules. A module can import definitions from other external modules and can include definitions from submodules. The hierarchy can be augmented, allowing one module to add data nodes to the hierarchy defined in another module. This augmentation can be conditional, with new nodes appearing only if certain conditions are met.",
      "zh-CHS": "YANG将数据模型分为模块和子模块。模块可以从其他外部模块导入定义，也可以包含子模块的定义。层次结构可以扩充，允许一个模块向另一个模块中定义的层次结构添加数据节点。这种扩展可以是有条件的，只有在满足某些条件时才会出现新节点。"
    },
    {
      "indent": 3,
      "text": "YANG data models can describe constraints to be enforced on the data, restricting the presence or value of nodes based on the presence or value of other nodes in the hierarchy. These constraints are enforceable by either the client or the server.",
      "zh-CHS": "YANG数据模型可以描述对数据实施的约束，根据层次结构中其他节点的存在或值限制节点的存在或值。这些约束可由客户端或服务器强制执行。"
    },
    {
      "indent": 3,
      "text": "YANG defines a set of built-in types and has a type mechanism through which additional types may be defined. Derived types can restrict their base type's set of valid values using mechanisms like range or pattern restrictions that can be enforced by clients or servers. They can also define usage conventions for use of the derived type, such as a string-based type that contains a hostname.",
      "zh-CHS": "YANG定义了一组内置类型，并具有一种类型机制，通过该机制可以定义其他类型。派生类型可以使用诸如范围或模式限制之类的机制来限制其基类型的有效值集，这些机制可以由客户端或服务器强制实施。它们还可以定义使用派生类型的使用约定，例如包含主机名的基于字符串的类型。"
    },
    {
      "indent": 3,
      "text": "YANG permits the definition of reusable groupings of nodes. The usage of these groupings can refine or augment the nodes, allowing it to tailor the nodes to its particular needs. Derived types and groupings can be defined in one module and used in either the same module or another module that imports it.",
      "zh-CHS": "YANG允许定义可重用的节点分组。这些分组的使用可以细化或扩充节点，使其能够根据特定需求定制节点。派生类型和分组可以在一个模块中定义，并在同一个模块或导入它的另一个模块中使用。"
    },
    {
      "indent": 3,
      "text": "YANG data hierarchy constructs include defining lists where list entries are identified by keys that distinguish them from each other. Such lists may be defined as either sorted by user or automatically sorted by the system. For user-sorted lists, operations are defined for manipulating the order of the list entries.",
      "zh-CHS": "数据层次结构包括定义列表，其中列表项由键标识，键将它们彼此区分开来。此类列表可定义为按用户排序或由系统自动排序。对于用户排序的列表，定义了用于操纵列表项顺序的操作。"
    },
    {
      "indent": 3,
      "text": "YANG modules can be translated into an equivalent XML syntax called YANG Independent Notation (YIN) (Section 13), allowing applications using XML parsers and Extensible Stylesheet Language Transformations (XSLT) scripts to operate on the models. The conversion from YANG to YIN is semantically lossless, so content in YIN can be round-tripped back into YANG.",
      "zh-CHS": "YANG模块可以转换为一种等价的XML语法，称为YANG独立表示法（YIN）（第13节），允许使用XML解析器和可扩展样式表语言转换（XSLT）脚本的应用程序在模型上操作。从阳到阴的转换在语义上是无损的，因此阴中的内容可以循环回到阳中。"
    },
    {
      "indent": 3,
      "text": "YANG is an extensible language, allowing extensions to be defined by standards bodies, vendors, and individuals. The statement syntax allows these extensions to coexist with standard YANG statements in a natural way, while extensions in a YANG module stand out sufficiently for the reader to notice them.",
      "zh-CHS": "YANG是一种可扩展语言，允许标准机构、供应商和个人定义扩展。语句语法允许这些扩展以一种自然的方式与标准的YANG语句共存，而YANG模块中的扩展足以让读者注意到它们。"
    },
    {
      "indent": 3,
      "text": "YANG resists the tendency to solve all possible problems, limiting the problem space to allow expression of data models for network management protocols such as NETCONF, not arbitrary XML documents or arbitrary data models.",
      "zh-CHS": "YANG抵制解决所有可能问题的趋势，限制了问题空间，以允许网络管理协议（如NETCONF）的数据模型表达，而不是任意XML文档或任意数据模型。"
    },
    {
      "indent": 3,
      "text": "To the extent possible, YANG maintains compatibility with the Simple Network Management Protocol's (SNMP's) SMIv2 (Structure of Management Information version 2 [RFC2578] [RFC2579]). SMIv2-based MIB modules can be automatically translated into YANG modules for read-only access [RFC6643]. However, YANG is not concerned with reverse translation from YANG to SMIv2.",
      "zh-CHS": "YANG尽可能保持与简单网络管理协议（SNMP）SMIv2（管理信息结构版本2[RFC2578][RFC2579]）的兼容性。基于SMIv2的MIB模块可以自动转换为只读访问的模块[RFC6643]。然而，杨并不关心从杨到SMIv2的反向翻译。"
    },
    {
      "indent": 0,
      "text": "4.2. Language Overview",
      "section_title": true,
      "zh-CHS": "4.2. 语言概述"
    },
    {
      "indent": 3,
      "text": "This section introduces some important constructs used in YANG that will aid in the understanding of the language specifics in later sections.",
      "zh-CHS": "本节介绍YANG中使用的一些重要结构，这些结构将有助于理解后面章节中的语言细节。"
    },
    {
      "indent": 0,
      "text": "4.2.1. Modules and Submodules",
      "section_title": true,
      "zh-CHS": "4.2.1. 模与子模"
    },
    {
      "indent": 3,
      "text": "YANG data models are defined in modules. A module contains a collection of related definitions.",
      "zh-CHS": "YANG数据模型在模块中定义。模块包含相关定义的集合。"
    },
    {
      "indent": 3,
      "text": "A module contains three types of statements: module header statements, \"revision\" statements, and definition statements. The module header statements describe the module and give information about the module itself, the \"revision\" statements give information about the history of the module, and the definition statements are the body of the module where the data model is defined.",
      "zh-CHS": "模块包含三种类型的语句：模块标题语句、“修订”语句和定义语句。模块标题语句描述模块并提供关于模块本身的信息，“修订”语句提供关于模块历史的信息，定义语句是定义数据模型的模块主体。"
    },
    {
      "indent": 3,
      "text": "A server may implement a number of modules, allowing multiple views of the same data or multiple views of disjoint subsections of the server's data. Alternatively, the server may implement only one module that defines all available data.",
      "zh-CHS": "服务器可以实现多个模块，允许相同数据的多个视图或服务器数据不相交子部分的多个视图。或者，服务器可以仅实现一个定义所有可用数据的模块。"
    },
    {
      "indent": 3,
      "text": "A module may have portions of its definitions separated into submodules, based on the needs of the module designer. The external view remains that of a single module, regardless of the presence or size of its submodules.",
      "zh-CHS": "根据模块设计者的需要，模块可以将其定义的部分划分为子模块。外部视图保持单个模块的视图，无论其子模块的存在或大小。"
    },
    {
      "indent": 3,
      "text": "The \"import\" statement allows a module or submodule to reference definitions defined in other modules.",
      "zh-CHS": "“import”语句允许模块或子模块引用在其他模块中定义的定义。"
    },
    {
      "indent": 3,
      "text": "The \"include\" statement is used in a module to identify each submodule that belongs to it.",
      "zh-CHS": "“include”语句在模块中用于标识属于它的每个子模块。"
    },
    {
      "indent": 0,
      "text": "4.2.2. Data Modeling Basics",
      "section_title": true,
      "zh-CHS": "4.2.2. 数据建模基础"
    },
    {
      "indent": 3,
      "text": "YANG defines four main types of data nodes for data modeling. In each of the following subsections, the examples show the YANG syntax as well as a corresponding XML encoding. The syntax of YANG statements is defined in Section 6.3.",
      "zh-CHS": "YANG为数据建模定义了四种主要类型的数据节点。在下面的每个小节中，示例都显示了YANG语法以及相应的XML编码。YANG语句的语法定义见第6.3节。"
    },
    {
      "indent": 0,
      "text": "4.2.2.1. Leaf Nodes",
      "section_title": true,
      "zh-CHS": "4.2.2.1. 叶节点"
    },
    {
      "indent": 3,
      "text": "A leaf instance contains simple data like an integer or a string. It has exactly one value of a particular type and no child nodes.",
      "zh-CHS": "叶实例包含简单的数据，如整数或字符串。它只有一个特定类型的值，并且没有子节点。"
    },
    {
      "indent": 3,
      "text": "YANG Example:",
      "zh-CHS": "杨举例："
    },
    {
      "indent": 5,
      "text": "leaf host-name {\n  type string;\n  description\n    \"Hostname for this system.\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "XML Encoding Example:",
      "zh-CHS": "XML编码示例："
    },
    {
      "indent": 5,
      "text": "<host-name>my.example.com</host-name>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The \"leaf\" statement is covered in Section 7.6.",
      "zh-CHS": "第7.6节介绍了“叶”声明。"
    },
    {
      "indent": 0,
      "text": "4.2.2.2. Leaf-List Nodes",
      "section_title": true,
      "zh-CHS": "4.2.2.2. 叶列表节点"
    },
    {
      "indent": 3,
      "text": "A leaf-list defines a sequence of values of a particular type.",
      "zh-CHS": "叶列表定义特定类型的值序列。"
    },
    {
      "indent": 3,
      "text": "YANG Example:",
      "zh-CHS": "杨举例："
    },
    {
      "indent": 5,
      "text": "leaf-list domain-search {\n  type string;\n  description\n    \"List of domain names to search.\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "XML Encoding Example:",
      "zh-CHS": "XML编码示例："
    },
    {
      "indent": 5,
      "text": "<domain-search>high.example.com</domain-search>\n<domain-search>low.example.com</domain-search>\n<domain-search>everywhere.example.com</domain-search>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The \"leaf-list\" statement is covered in Section 7.7.",
      "zh-CHS": "第7.7节介绍了“叶列表”声明。"
    },
    {
      "indent": 0,
      "text": "4.2.2.3. Container Nodes",
      "section_title": true,
      "zh-CHS": "4.2.2.3. 容器节点"
    },
    {
      "indent": 3,
      "text": "A container is used to group related nodes in a subtree. A container has only child nodes and no value. A container may contain any number of child nodes of any type (leafs, lists, containers, leaf-lists, actions, and notifications).",
      "zh-CHS": "容器用于将子树中的相关节点分组。容器只有子节点，没有值。容器可以包含任意数量的任意类型的子节点（叶、列表、容器、叶列表、操作和通知）。"
    },
    {
      "indent": 3,
      "text": "YANG Example:",
      "zh-CHS": "杨举例："
    },
    {
      "indent": 5,
      "text": "container system {\n  container login {\n    leaf message {\n      type string;\n      description\n        \"Message given at start of login session.\";\n    }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "XML Encoding Example:",
      "zh-CHS": "XML编码示例："
    },
    {
      "indent": 5,
      "text": "<system>\n  <login>\n    <message>Good morning</message>\n  </login>\n</system>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The \"container\" statement is covered in Section 7.5.",
      "zh-CHS": "第7.5节介绍了“容器”声明。"
    },
    {
      "indent": 0,
      "text": "4.2.2.4. List Nodes",
      "section_title": true,
      "zh-CHS": "4.2.2.4. 列表节点"
    },
    {
      "indent": 3,
      "text": "A list defines a sequence of list entries. Each entry is like a container and is uniquely identified by the values of its key leafs if it has any key leafs defined. A list can define multiple key leafs and may contain any number of child nodes of any type (including leafs, lists, containers, etc.).",
      "zh-CHS": "列表定义了一系列列表条目。每个条目就像一个容器，如果定义了任何键叶，则通过其键叶的值来唯一标识。列表可以定义多个键叶，并且可以包含任意数量的任何类型的子节点（包括叶、列表、容器等）。"
    },
    {
      "indent": 3,
      "text": "YANG Example:",
      "zh-CHS": "杨举例："
    },
    {
      "indent": 5,
      "text": "list user {\n  key \"name\";\n  leaf name {\n    type string;\n  }\n  leaf full-name {\n    type string;\n  }\n  leaf class {\n    type string;\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "XML Encoding Example:",
      "zh-CHS": "XML编码示例："
    },
    {
      "indent": 5,
      "text": "<user>\n  <name>glocks</name>\n  <full-name>Goldie Locks</full-name>\n  <class>intruder</class>\n</user>\n<user>\n  <name>snowey</name>\n  <full-name>Snow White</full-name>\n  <class>free-loader</class>\n</user>\n<user>\n  <name>rzell</name>\n  <full-name>Rapun Zell</full-name>\n  <class>tower</class>\n</user>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The \"list\" statement is covered in Section 7.8.",
      "zh-CHS": "第7.8节介绍了“列表”说明。"
    },
    {
      "indent": 0,
      "text": "4.2.2.5. Example Module",
      "section_title": true,
      "zh-CHS": "4.2.2.5. 示例模块"
    },
    {
      "indent": 3,
      "text": "These statements are combined to define the module:",
      "zh-CHS": "这些语句组合起来定义模块："
    },
    {
      "indent": 5,
      "text": "// Contents of \"example-system.yang\"\nmodule example-system {\n  yang-version 1.1;\n  namespace \"urn:example:system\";\n  prefix \"sys\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "organization \"Example Inc.\";\ncontact \"joe@example.com\";\ndescription\n  \"The module for entities implementing the Example system.\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "revision 2007-06-09 {\n  description \"Initial revision.\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "container system {\n  leaf host-name {\n    type string;\n    description\n      \"Hostname for this system.\";\n  }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "leaf-list domain-search {\n  type string;\n  description\n    \"List of domain names to search.\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "container login {\n  leaf message {\n    type string;\n    description\n      \"Message given at start of login session.\";\n  }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "      list user {\n        key \"name\";\n        leaf name {\n          type string;\n        }\n        leaf full-name {\n          type string;\n        }\n        leaf class {\n          type string;\n        }\n      }\n    }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "4.2.3. Configuration and State Data",
      "section_title": true,
      "zh-CHS": "4.2.3. 配置和状态数据"
    },
    {
      "indent": 3,
      "text": "YANG can model state data, as well as configuration data, based on the \"config\" statement. When a node is tagged with \"config false\", its subhierarchy is flagged as state data. If it is tagged with \"config true\", its subhierarchy is flagged as configuration data. Parent containers, lists, and key leafs are reported also, giving the context for the state data.",
      "zh-CHS": "YANG可以根据“config”语句对状态数据和配置数据进行建模。当一个节点被标记为“config false”时，它的子层次结构被标记为状态数据。如果它被标记为“config true”，则其子层次结构被标记为配置数据。还报告父容器、列表和键叶，为状态数据提供上下文。"
    },
    {
      "indent": 3,
      "text": "In this example, two leafs are defined for each interface, a configured speed and an observed speed.",
      "zh-CHS": "在本例中，为每个接口定义了两个LEAF，一个配置速度和一个观察速度。"
    },
    {
      "indent": 5,
      "text": "list interface {\n  key \"name\";\n  config true;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "  leaf name {\n    type string;\n  }\n  leaf speed {\n    type enumeration {\n      enum 10m;\n      enum 100m;\n      enum auto;\n    }\n  }\n  leaf observed-speed {\n    type uint32;\n    config false;\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The \"config\" statement is covered in Section 7.21.1.",
      "zh-CHS": "第7.21.1节介绍了“config”语句。"
    },
    {
      "indent": 0,
      "text": "4.2.4. Built-In Types",
      "section_title": true,
      "zh-CHS": "4.2.4. 内置类型"
    },
    {
      "indent": 3,
      "text": "YANG has a set of built-in types, similar to those of many programming languages, but with some differences due to special requirements of network management. The following table summarizes the built-in types discussed in Section 9:",
      "zh-CHS": "YANG有一组内置类型，类似于许多编程语言的类型，但由于网络管理的特殊要求而有所不同。下表总结了第9节中讨论的内置类型："
    },
    {
      "indent": 7,
      "text": "+---------------------+-------------------------------------+\n| Name                | Description                         |\n+---------------------+-------------------------------------+\n| binary              | Any binary data                     |\n| bits                | A set of bits or flags              |\n| boolean             | \"true\" or \"false\"                   |\n| decimal64           | 64-bit signed decimal number        |\n| empty               | A leaf that does not have any value |\n| enumeration         | One of an enumerated set of strings |\n| identityref         | A reference to an abstract identity |\n| instance-identifier | A reference to a data tree node     |\n| int8                | 8-bit signed integer                |\n| int16               | 16-bit signed integer               |\n| int32               | 32-bit signed integer               |\n| int64               | 64-bit signed integer               |\n| leafref             | A reference to a leaf instance      |\n| string              | A character string                  |\n| uint8               | 8-bit unsigned integer              |\n| uint16              | 16-bit unsigned integer             |\n| uint32              | 32-bit unsigned integer             |\n| uint64              | 64-bit unsigned integer             |\n| union               | Choice of member types              |\n+---------------------+-------------------------------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The \"type\" statement is covered in Section 7.4.",
      "zh-CHS": "“类型”说明见第7.4节。"
    },
    {
      "indent": 0,
      "text": "4.2.5. Derived Types (typedef)",
      "section_title": true,
      "zh-CHS": "4.2.5. 派生类型（typedef）"
    },
    {
      "indent": 3,
      "text": "YANG can define derived types from base types using the \"typedef\" statement. A base type can be either a built-in type or a derived type, allowing a hierarchy of derived types.",
      "zh-CHS": "YANG可以使用“typedef”语句从基类型定义派生类型。基类型可以是内置类型或派生类型，允许派生类型的层次结构。"
    },
    {
      "indent": 3,
      "text": "A derived type can be used as the argument for the \"type\" statement.",
      "zh-CHS": "派生类型可用作“type”语句的参数。"
    },
    {
      "indent": 3,
      "text": "YANG Example:",
      "zh-CHS": "杨举例："
    },
    {
      "indent": 5,
      "text": "typedef percent {\n  type uint8 {\n    range \"0 .. 100\";\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "leaf completed {\n  type percent;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "XML Encoding Example:",
      "zh-CHS": "XML编码示例："
    },
    {
      "indent": 5,
      "text": "<completed>20</completed>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The \"typedef\" statement is covered in Section 7.3.",
      "zh-CHS": "第7.3节介绍了“typedef”语句。"
    },
    {
      "indent": 0,
      "text": "4.2.6. Reusable Node Groups (grouping)",
      "section_title": true,
      "zh-CHS": "4.2.6. 可重用节点组（分组）"
    },
    {
      "indent": 3,
      "text": "Groups of nodes can be assembled into reusable collections using the \"grouping\" statement. A grouping defines a set of nodes that are instantiated with the \"uses\" statement.",
      "zh-CHS": "可以使用“grouping”语句将节点组组装成可重用的集合。分组定义了一组用“uses”语句实例化的节点。"
    },
    {
      "indent": 3,
      "text": "YANG Example:",
      "zh-CHS": "杨举例："
    },
    {
      "indent": 5,
      "text": "grouping target {\n  leaf address {\n    type inet:ip-address;\n    description \"Target IP address.\";\n  }\n  leaf port {\n    type inet:port-number;\n     description \"Target port number.\";\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "container peer {\n  container destination {\n    uses target;\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "XML Encoding Example:",
      "zh-CHS": "XML编码示例："
    },
    {
      "indent": 5,
      "text": "<peer>\n  <destination>\n    <address>2001:db8::2</address>\n    <port>830</port>\n  </destination>\n</peer>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The grouping can be refined as it is used, allowing certain statements to be overridden. In this example, the description is refined:",
      "zh-CHS": "分组可以在使用时进行细化，允许覆盖某些语句。在本例中，对描述进行了细化："
    },
    {
      "indent": 5,
      "text": "container connection {\n  container source {\n    uses target {\n      refine \"address\" {\n        description \"Source IP address.\";\n      }\n      refine \"port\" {\n        description \"Source port number.\";\n      }\n    }\n  }\n  container destination {\n    uses target {\n      refine \"address\" {\n        description \"Destination IP address.\";\n      }\n      refine \"port\" {\n        description \"Destination port number.\";\n      }\n    }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The \"grouping\" statement is covered in Section 7.12.",
      "zh-CHS": "第7.12节介绍了“分组”声明。"
    },
    {
      "indent": 0,
      "text": "4.2.7. Choices",
      "section_title": true,
      "zh-CHS": "4.2.7. 选择"
    },
    {
      "indent": 3,
      "text": "YANG allows the data model to segregate incompatible nodes into distinct choices using the \"choice\" and \"case\" statements. The \"choice\" statement contains a set of \"case\" statements that define sets of schema nodes that cannot appear together. Each \"case\" may contain multiple nodes, but each node may appear in only one \"case\" under a \"choice\".",
      "zh-CHS": "YANG允许数据模型使用“choice”和“case”语句将不兼容的节点分隔为不同的选项。“choice”语句包含一组“case”语句，用于定义不能同时出现的模式节点集。每个“案例”可能包含多个节点，但每个节点可能仅出现在“选项”下的一个“案例”中。"
    },
    {
      "indent": 3,
      "text": "The choice and case nodes appear only in the schema tree and not in the data tree. The additional levels of hierarchy are not needed beyond the conceptual schema. The presence of a case is indicated by the presence of one or more of the nodes within it.",
      "zh-CHS": "choice和case节点仅显示在架构树中，而不显示在数据树中。除了概念模式之外，不需要额外的层次结构。案例的存在通过案例中一个或多个节点的存在来表示。"
    },
    {
      "indent": 3,
      "text": "Since only one of the choice's cases can be valid at any time, when a node from one case is created in the data tree, all nodes from all other cases are implicitly deleted. The server handles the enforcement of the constraint, preventing incompatibilities from existing in the configuration.",
      "zh-CHS": "由于在任何时候只有一个选项的案例是有效的，因此当在数据树中创建一个案例中的节点时，所有其他案例中的所有节点都将被隐式删除。服务器处理约束的实施，防止配置中存在不兼容。"
    },
    {
      "indent": 3,
      "text": "YANG Example:",
      "zh-CHS": "杨举例："
    },
    {
      "indent": 5,
      "text": "container food {\n  choice snack {\n    case sports-arena {\n      leaf pretzel {\n        type empty;\n      }\n      leaf beer {\n        type empty;\n      }\n    }\n    case late-night {\n      leaf chocolate {\n        type enumeration {\n          enum dark;\n          enum milk;\n          enum first-available;\n        }\n      }\n    }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "XML Encoding Example:",
      "zh-CHS": "XML编码示例："
    },
    {
      "indent": 5,
      "text": "<food>\n  <pretzel/>\n  <beer/>\n</food>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The \"choice\" statement is covered in Section 7.9.",
      "zh-CHS": "“选择”声明见第7.9节。"
    },
    {
      "indent": 0,
      "text": "4.2.8. Extending Data Models (augment)",
      "section_title": true,
      "zh-CHS": "4.2.8. 扩展数据模型（扩充）"
    },
    {
      "indent": 3,
      "text": "YANG allows a module to insert additional nodes into data models, including both the current module (and its submodules) and an external module. This is useful, for example, for vendors to add vendor-specific parameters to standard data models in an interoperable way.",
      "zh-CHS": "YANG允许模块将其他节点插入数据模型，包括当前模块（及其子模块）和外部模块。例如，这对于供应商以可互操作的方式向标准数据模型添加供应商特定的参数非常有用。"
    },
    {
      "indent": 3,
      "text": "The \"augment\" statement defines the location in the data model hierarchy where new nodes are inserted, and the \"when\" statement defines the conditions when the new nodes are valid.",
      "zh-CHS": "“augment”语句定义了数据模型层次结构中插入新节点的位置，“when”语句定义了新节点有效的条件。"
    },
    {
      "indent": 3,
      "text": "When a server implements a module containing an \"augment\" statement, that implies that the server's implementation of the augmented module contains the additional nodes.",
      "zh-CHS": "当服务器实现一个包含“augment”语句的模块时，这意味着服务器的扩展模块实现包含额外的节点。"
    },
    {
      "indent": 3,
      "text": "YANG Example:",
      "zh-CHS": "杨举例："
    },
    {
      "indent": 5,
      "text": "augment /system/login/user {\n  when \"class != 'wheel'\";\n  leaf uid {\n    type uint16 {\n      range \"1000 .. 30000\";\n    }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "This example defines a \"uid\" node that is valid only when the user's \"class\" is not \"wheel\".",
      "zh-CHS": "此示例定义了一个“uid”节点，该节点仅在用户的“类”不是“轮子”时才有效。"
    },
    {
      "indent": 3,
      "text": "If a module augments another module, the XML elements that are added to the encoding are in the namespace of the augmenting module. For example, if the above augmentation were in a module with prefix \"other\", the XML would look like:",
      "zh-CHS": "如果一个模块扩展另一个模块，则添加到编码中的XML元素位于扩展模块的命名空间中。例如，如果上述扩展位于前缀为“other”的模块中，则XML将如下所示："
    },
    {
      "indent": 3,
      "text": "XML Encoding Example:",
      "zh-CHS": "XML编码示例："
    },
    {
      "indent": 5,
      "text": "<user>\n  <name>alicew</name>\n  <full-name>Alice N. Wonderland</full-name>\n  <class>drop-out</class>\n  <other:uid>1024</other:uid>\n</user>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The \"augment\" statement is covered in Section 7.17.",
      "zh-CHS": "第7.17节介绍了“增强”声明。"
    },
    {
      "indent": 0,
      "text": "4.2.9. Operation Definitions",
      "section_title": true,
      "zh-CHS": "4.2.9. 操作定义"
    },
    {
      "indent": 3,
      "text": "YANG allows the definition of operations. The operations' names, input parameters, and output parameters are modeled using YANG data definition statements. Operations on the top level in a module are defined with the \"rpc\" statement. Operations can also be tied to a container or list data node. Such operations are defined with the \"action\" statement.",
      "zh-CHS": "杨允许定义操作。使用数据定义语句对操作的名称、输入参数和输出参数进行建模。模块中顶层的操作是用“rpc”语句定义的。操作也可以绑定到容器或列表数据节点。这些操作是用“action”语句定义的。"
    },
    {
      "indent": 3,
      "text": "YANG Example for an operation at the top level:",
      "zh-CHS": "顶层操作的示例："
    },
    {
      "indent": 5,
      "text": "rpc activate-software-image {\n  input {\n    leaf image-name {\n      type string;\n    }\n  }\n  output {\n    leaf status {\n      type string;\n    }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "NETCONF XML Example:",
      "zh-CHS": "NETCONF XML示例："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <activate-software-image xmlns=\"http://example.com/system\">\n    <image-name>example-fw-2.3</image-name>\n  </activate-software-image>\n</rpc>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "<rpc-reply message-id=\"101\"\n           xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <status xmlns=\"http://example.com/system\">\n    The image example-fw-2.3 is being installed.\n  </status>\n</rpc-reply>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "YANG Example for an operation tied to a list data node:",
      "zh-CHS": "绑定到列表数据节点的操作示例："
    },
    {
      "indent": 5,
      "text": "list interface {\n  key \"name\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "leaf name {\n  type string;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "  action ping {\n    input {\n      leaf destination {\n        type inet:ip-address;\n      }\n    }\n    output {\n      leaf packet-loss {\n        type uint8;\n      }\n    }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "NETCONF XML Example:",
      "zh-CHS": "NETCONF XML示例："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"102\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <action xmlns=\"urn:ietf:params:xml:ns:yang:1\">\n    <interface xmlns=\"http://example.com/system\">\n      <name>eth1</name>\n      <ping>\n        <destination>192.0.2.1</destination>\n      </ping>\n    </interface>\n  </action>\n</rpc>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "<rpc-reply message-id=\"102\"\n           xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n           xmlns:sys=\"http://example.com/system\">\n  <sys:packet-loss>60</sys:packet-loss>\n</rpc-reply>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The \"rpc\" statement is covered in Section 7.14, and the \"action\" statement is covered in Section 7.15.",
      "zh-CHS": "第7.14节介绍了“rpc”声明，第7.15节介绍了“行动”声明。"
    },
    {
      "indent": 0,
      "text": "4.2.10. Notification Definitions",
      "section_title": true,
      "zh-CHS": "4.2.10. 通知定义"
    },
    {
      "indent": 3,
      "text": "YANG allows the definition of notifications. YANG data definition statements are used to model the content of the notification.",
      "zh-CHS": "YANG允许定义通知。数据定义语句用于对通知的内容建模。"
    },
    {
      "indent": 3,
      "text": "YANG Example:",
      "zh-CHS": "杨举例："
    },
    {
      "indent": 5,
      "text": "notification link-failure {\n  description\n    \"A link failure has been detected.\";\n  leaf if-name {\n    type leafref {\n      path \"/interface/name\";\n    }\n  }\n  leaf if-admin-status {\n    type admin-status;\n  }\n  leaf if-oper-status {\n    type oper-status;\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "NETCONF XML Example:",
      "zh-CHS": "NETCONF XML示例："
    },
    {
      "indent": 5,
      "text": "<notification\n    xmlns=\"urn:ietf:params:netconf:capability:notification:1.0\">\n  <eventTime>2007-09-01T10:00:00Z</eventTime>\n  <link-failure xmlns=\"urn:example:system\">\n    <if-name>so-1/2/3.0</if-name>\n    <if-admin-status>up</if-admin-status>\n    <if-oper-status>down</if-oper-status>\n  </link-failure>\n</notification>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The \"notification\" statement is covered in Section 7.16.",
      "zh-CHS": "“通知”声明见第7.16节。"
    },
    {
      "indent": 0,
      "text": "5. Language Concepts",
      "section_title": true,
      "zh-CHS": "5. 语言概念"
    },
    {
      "indent": 0,
      "text": "5.1. Modules and Submodules",
      "section_title": true,
      "zh-CHS": "5.1. 模与子模"
    },
    {
      "indent": 3,
      "text": "The module is the base unit of definition in YANG. A module defines a single data model. A module can also augment an existing data model with additional nodes.",
      "zh-CHS": "模块是杨定义的基本单位。模块定义单个数据模型。模块还可以使用附加节点来扩充现有数据模型。"
    },
    {
      "indent": 3,
      "text": "Submodules are partial modules that contribute definitions to a module. A module may include any number of submodules, but each submodule may belong to only one module.",
      "zh-CHS": "子模块是为模块提供定义的部分模块。一个模块可以包括任意数量的子模块，但每个子模块只能属于一个模块。"
    },
    {
      "indent": 3,
      "text": "Developers of YANG modules and submodules are RECOMMENDED to choose names for their modules that will have a low probability of colliding with standard or other enterprise modules, e.g., by using the enterprise or organization name as a prefix for the module name. Within a server, all module names MUST be unique.",
      "zh-CHS": "建议模块和子模块的开发人员为其模块选择与标准模块或其他企业模块发生冲突的可能性较低的名称，例如，使用企业或组织名称作为模块名称的前缀。在服务器中，所有模块名称都必须是唯一的。"
    },
    {
      "indent": 3,
      "text": "A module uses the \"include\" statement to list all its submodules. A module, or submodule belonging to that module, can reference definitions in the module and all submodules included by the module.",
      "zh-CHS": "模块使用“include”语句列出其所有子模块。模块或属于该模块的子模块可以引用该模块中的定义以及该模块包含的所有子模块。"
    },
    {
      "indent": 3,
      "text": "A module or submodule uses the \"import\" statement to reference external modules. Statements in the module or submodule can reference definitions in the external module using the prefix specified in the \"import\" statement.",
      "zh-CHS": "模块或子模块使用“import”语句引用外部模块。模块或子模块中的语句可以使用“import”语句中指定的前缀引用外部模块中的定义。"
    },
    {
      "indent": 3,
      "text": "For backward compatibility with YANG version 1, a submodule MAY use the \"include\" statement to reference other submodules within its module, but this is not necessary in YANG version 1.1. A submodule can reference any definition in the module it belongs to and in all submodules included by the module. A submodule MUST NOT include different revisions of other submodules than the revisions that its module includes.",
      "zh-CHS": "为了与YANG版本1向后兼容，子模块可以使用“include”语句引用其模块内的其他子模块，但在YANG版本1.1中不需要这样做。子模块可以引用其所属模块中的任何定义以及该模块包含的所有子模块中的任何定义。子模块不得包含与其模块包含的版本不同的其他子模块版本。"
    },
    {
      "indent": 3,
      "text": "A module or submodule MUST NOT include submodules from other modules, and a submodule MUST NOT import its own module.",
      "zh-CHS": "模块或子模块不得包含来自其他模块的子模块，并且子模块不得导入自己的模块。"
    },
    {
      "indent": 3,
      "text": "The \"import\" and \"include\" statements are used to make definitions available from other modules:",
      "zh-CHS": "“import”和“include”语句用于从其他模块提供定义："
    },
    {
      "indent": 3,
      "text": "o For a module or submodule to reference definitions in an external module, the external module MUST be imported.",
      "zh-CHS": "o 要使模块或子模块引用外部模块中的定义，必须导入外部模块。"
    },
    {
      "indent": 3,
      "text": "o A module MUST include all its submodules.",
      "zh-CHS": "o 模块必须包括其所有子模块。"
    },
    {
      "indent": 3,
      "text": "o A module, or submodule belonging to that module, MAY reference definitions in the module and all submodules included by the module.",
      "zh-CHS": "o 模块或属于该模块的子模块可以引用该模块中的定义以及该模块包含的所有子模块。"
    },
    {
      "indent": 3,
      "text": "There MUST NOT be any circular chains of imports. For example, if module \"a\" imports module \"b\", \"b\" cannot import \"a\".",
      "zh-CHS": "不得有任何环形进口链。例如，如果模块“a”导入模块“b”，则“b”无法导入“a”。"
    },
    {
      "indent": 3,
      "text": "When a definition in an external module is referenced, a locally defined prefix MUST be used, followed by a colon (\":\") and then the external identifier. References to definitions in the local module MAY use the prefix notation. Since built-in data types do not belong to any module and have no prefix, references to built-in data types (e.g., int32) cannot use the prefix notation. The syntax for a reference to a definition is formally defined by the rule \"identifier-ref\" in Section 14.",
      "zh-CHS": "引用外部模块中的定义时，必须使用本地定义的前缀，后跟冒号（“：”），然后是外部标识符。对本地模块中定义的引用可以使用前缀表示法。由于内置数据类型不属于任何模块且没有前缀，因此对内置数据类型（例如int32）的引用不能使用前缀表示法。引用定义的语法由第14节中的规则“标识符ref”正式定义。"
    },
    {
      "indent": 0,
      "text": "5.1.1. Import and Include by Revision",
      "section_title": true,
      "zh-CHS": "5.1.1. 通过修订导入和包含"
    },
    {
      "indent": 3,
      "text": "Published modules evolve independently over time. In order to allow for this evolution, modules can be imported using specific revisions. Initially, a module imports the revisions of other modules that are current when the module is written. As future revisions of the imported modules are published, the importing module is unaffected and its contents are unchanged. When the author of the module is prepared to move to the most recently published revision of an imported module, the module is republished with an updated \"import\" statement. By republishing with the new revision, the authors explicitly indicate their acceptance of any changes in the imported module.",
      "zh-CHS": "已发布的模块会随着时间的推移独立演化。为了允许这种演变，可以使用特定的修订版导入模块。最初，模块导入其他模块的修订版，这些修订版在编写模块时是最新的。随着导入模块的未来版本的发布，导入模块不受影响，其内容不变。当模块的作者准备移动到导入模块的最新发布版本时，将使用更新的“导入”语句重新发布该模块。通过使用新版本重新发布，作者明确表示接受导入模块中的任何更改。"
    },
    {
      "indent": 3,
      "text": "For submodules, the issue is related but simpler. A module or submodule that includes submodules may specify the revision of the included submodules. If a submodule changes, any module or submodule that includes it by revision needs to be updated to reference the new revision.",
      "zh-CHS": "对于子模块，问题是相关的，但更简单。包含子模块的模块或子模块可以指定包含子模块的版本。如果子模块发生更改，则需要更新按修订包含它的任何模块或子模块，以引用新修订。"
    },
    {
      "indent": 3,
      "text": "For example, module \"b\" imports module \"a\".",
      "zh-CHS": "例如，模块“b”导入模块“a”。"
    },
    {
      "indent": 5,
      "text": "module a {\n  yang-version 1.1;\n  namespace \"urn:example:a\";\n  prefix \"a\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "  revision 2008-01-01 { ... }\n  grouping a {\n    leaf eh { .... }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "module b {\n  yang-version 1.1;\n  namespace \"urn:example:b\";\n  prefix \"b\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "import a {\n  prefix \"p\";\n  revision-date 2008-01-01;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "  container bee {\n    uses p:a;\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "When the author of \"a\" publishes a new revision, the changes may not be acceptable to the author of \"b\". If the new revision is acceptable, the author of \"b\" can republish with an updated revision in the \"import\" statement.",
      "zh-CHS": "当“a”的作者发布新版本时，“b”的作者可能不接受这些更改。如果新版本可以接受，“b”的作者可以在“导入”语句中使用更新版本重新发布。"
    },
    {
      "indent": 3,
      "text": "If a module is not imported with a specific revision, it is undefined which revision is used.",
      "zh-CHS": "如果模块未随特定版本一起导入，则未定义使用哪个版本。"
    },
    {
      "indent": 0,
      "text": "5.1.2. Module Hierarchies",
      "section_title": true,
      "zh-CHS": "5.1.2. 模块层次结构"
    },
    {
      "indent": 3,
      "text": "YANG allows modeling of data in multiple hierarchies, where data may have more than one top-level node. Each top-level data node in a module defines a separate hierarchy. Models that have multiple top-level nodes are sometimes convenient and are supported by YANG.",
      "zh-CHS": "YANG允许在多个层次结构中对数据进行建模，其中数据可能有多个顶级节点。模块中的每个顶级数据节点定义一个单独的层次结构。具有多个顶级节点的模型有时很方便，并且受到YANG的支持。"
    },
    {
      "indent": 0,
      "text": "5.1.2.1. NETCONF XML Encoding",
      "section_title": true,
      "zh-CHS": "5.1.2.1. NETCONF XML编码"
    },
    {
      "indent": 3,
      "text": "NETCONF is capable of carrying any XML content as the payload in the <config> and <data> elements. The top-level nodes of YANG modules are encoded as child elements, in any order, within these elements. This encapsulation guarantees that the corresponding NETCONF messages are always well-formed XML documents.",
      "zh-CHS": "NETCONF能够在<config>和<data>元素中承载任何XML内容作为有效负载。YANG模块的顶级节点在这些元素中以任意顺序编码为子元素。这种封装保证了相应的NETCONF消息始终是格式良好的XML文档。"
    },
    {
      "indent": 3,
      "text": "For example, an instance of:",
      "zh-CHS": "例如，以下实例："
    },
    {
      "indent": 5,
      "text": "module example-config {\n  yang-version 1.1;\n  namespace \"urn:example:config\";\n  prefix \"co\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "  container system { ... }\n  container routing { ... }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "could be encoded in NETCONF as:",
      "zh-CHS": "可以在NETCONF中编码为："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <edit-config>\n    <target>\n      <running/>\n    </target>\n    <config>\n      <system xmlns=\"urn:example:config\">\n        <!-- system data here -->\n      </system>\n      <routing xmlns=\"urn:example:config\">\n        <!-- routing data here -->\n      </routing>\n    </config>\n  </edit-config>\n</rpc>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "5.2. File Layout",
      "section_title": true,
      "zh-CHS": "5.2. 文件布局"
    },
    {
      "indent": 3,
      "text": "YANG modules and submodules are typically stored in files, one \"module\" or \"submodule\" statement per file. The name of the file SHOULD be of the form:",
      "zh-CHS": "模块和子模块通常存储在文件中，每个文件有一个“module”或“submodule”语句。文件名的格式应为："
    },
    {
      "indent": 5,
      "text": "module-or-submodule-name ['@' revision-date] ( '.yang' / '.yin' )",
      "zh-CHS": "模块或子模块名称['@'修订日期]（'.yang'/'.yin'）"
    },
    {
      "indent": 3,
      "text": "\"module-or-submodule-name\" is the name of the module or submodule, and the optional \"revision-date\" is the latest revision of the module or submodule, as defined by the \"revision\" statement (Section 7.1.9).",
      "zh-CHS": "“模块或子模块名称”是模块或子模块的名称，可选的“修订日期”是“修订”声明（第7.1.9节）中定义的模块或子模块的最新版本。"
    },
    {
      "indent": 3,
      "text": "The file extension \".yang\" denotes that the contents of the file are written with YANG syntax (Section 6), and \".yin\" denotes that the contents of the file are written with YIN syntax (Section 13).",
      "zh-CHS": "文件扩展名“.yang”表示文件内容使用yang语法编写（第6节），“.yin”表示文件内容使用yin语法编写（第13节）。"
    },
    {
      "indent": 3,
      "text": "YANG parsers can find imported modules and included submodules via this convention.",
      "zh-CHS": "YANG解析器可以通过此约定查找导入的模块和包含的子模块。"
    },
    {
      "indent": 0,
      "text": "5.3. XML Namespaces",
      "section_title": true,
      "zh-CHS": "5.3. XML名称空间"
    },
    {
      "indent": 3,
      "text": "All YANG definitions are specified within a module. Each module is bound to a distinct XML namespace [XML-NAMES], which is a globally unique URI [RFC3986]. A NETCONF client or server uses the namespace during XML encoding of data.",
      "zh-CHS": "所有定义都在模块中指定。每个模块都绑定到一个不同的XML名称空间[XML-NAMES]，这是一个全局唯一的URI[RFC3986]。NETCONF客户端或服务器在数据的XML编码期间使用名称空间。"
    },
    {
      "indent": 3,
      "text": "XML namespaces for modules published in RFC streams [RFC4844] MUST be assigned by IANA; see Section 14 in [RFC6020].",
      "zh-CHS": "RFC streams[RFC4844]中发布的模块的XML名称空间必须由IANA分配；参见[RFC6020]中的第14节。"
    },
    {
      "indent": 3,
      "text": "XML namespaces for private modules are assigned by the organization owning the module without a central registry. Namespace URIs MUST be chosen so they cannot collide with standard or other enterprise namespaces -- for example, by using the enterprise or organization name in the namespace.",
      "zh-CHS": "私有模块的XML名称空间由拥有该模块的组织分配，而无需中央注册表。必须选择名称空间URI，以便它们不会与标准或其他企业名称空间冲突——例如，通过在名称空间中使用企业或组织名称。"
    },
    {
      "indent": 3,
      "text": "The \"namespace\" statement is covered in Section 7.1.3.",
      "zh-CHS": "第7.1.3节介绍了“名称空间”语句。"
    },
    {
      "indent": 0,
      "text": "5.3.1. YANG XML Namespace",
      "section_title": true,
      "zh-CHS": "5.3.1. XML名称空间"
    },
    {
      "indent": 3,
      "text": "YANG defines an XML namespace for NETCONF <edit-config> operations, <error-info> content, and the <action> element. The name of this namespace is \"urn:ietf:params:xml:ns:yang:1\".",
      "zh-CHS": "YANG为NETCONF<edit config>操作、<error info>内容和<action>元素定义了一个XML名称空间。此命名空间的名称为“urn:ietf:params:xml:ns:yang:1”。"
    },
    {
      "indent": 0,
      "text": "5.4. Resolving Grouping, Type, and Identity Names",
      "section_title": true,
      "zh-CHS": "5.4. 解析分组、类型和标识名"
    },
    {
      "indent": 3,
      "text": "Grouping, type, and identity names are resolved in the context in which they are defined, rather than the context in which they are used. Users of groupings, typedefs, and identities are not required to import modules or include submodules to satisfy all references made by the original definition. This behaves like static scoping in a conventional programming language.",
      "zh-CHS": "分组、类型和标识名在定义它们的上下文中解析，而不是在使用它们的上下文中解析。分组、typedef和标识的用户无需导入模块或包含子模块以满足原始定义所做的所有引用。这与传统编程语言中的静态作用域类似。"
    },
    {
      "indent": 3,
      "text": "For example, if a module defines a grouping in which a type is referenced, when the grouping is used in a second module, the type is resolved in the context of the original module, not the second module. There is no ambiguity if both modules define the type.",
      "zh-CHS": "例如，如果一个模块定义了一个引用类型的分组，则当该分组在第二个模块中使用时，该类型将在原始模块的上下文中解析，而不是在第二个模块中解析。如果两个模块都定义了类型，则不会有歧义。"
    },
    {
      "indent": 0,
      "text": "5.5. Nested Typedefs and Groupings",
      "section_title": true,
      "zh-CHS": "5.5. 嵌套的typedef和分组"
    },
    {
      "indent": 3,
      "text": "Typedefs and groupings may appear nested under many YANG statements, allowing these to be lexically scoped by the statement hierarchy under which they appear. This allows types and groupings to be defined near where they are used, rather than placing them at the top level of the hierarchy. The close proximity increases readability.",
      "zh-CHS": "typedef和groupings可能嵌套在许多YANG语句下，允许它们在词汇上受它们出现的语句层次结构的限制。这允许在使用类型和分组的位置附近定义它们，而不是将它们放在层次结构的顶层。近距离增加了可读性。"
    },
    {
      "indent": 3,
      "text": "Scoping also allows types to be defined without concern for naming conflicts between types in different submodules. Type names can be specified without adding leading strings designed to prevent name collisions within large modules.",
      "zh-CHS": "作用域还允许定义类型，而不必担心不同子模块中类型之间的命名冲突。可以在不添加前导字符串的情况下指定类型名，前导字符串旨在防止大型模块中的名称冲突。"
    },
    {
      "indent": 3,
      "text": "Finally, scoping allows the module author to keep types and groupings private to their module or submodule, preventing their reuse. Since only top-level types and groupings (i.e., those appearing as substatements to a \"module\" or \"submodule\" statement) can be used outside the module or submodule, the developer has more control over what pieces of their module are presented to the outside world, supporting the need to hide internal information and maintaining a boundary between what is shared with the outside world and what is kept private.",
      "zh-CHS": "最后，作用域允许模块作者将类型和分组保持为其模块或子模块的私有，从而防止其重用。由于只有顶级类型和分组（即，那些作为“模块”或“子模块”语句的子状态出现的类型和分组）可以在模块或子模块之外使用，因此开发人员可以更好地控制向外部世界展示其模块的哪些部分，支持隐藏内部信息的需要，并在与外部世界共享的信息和保密的信息之间保持界限。"
    },
    {
      "indent": 3,
      "text": "Scoped definitions MUST NOT shadow definitions at a higher scope. A type or grouping cannot be defined if a higher level in the statement hierarchy has a definition with a matching identifier.",
      "zh-CHS": "作用域定义不能在更高的作用域中隐藏定义。如果语句层次结构中的较高级别具有具有匹配标识符的定义，则无法定义类型或分组。"
    },
    {
      "indent": 3,
      "text": "A reference to an unprefixed type or grouping, or one that uses the prefix of the current module, is resolved by locating the matching \"typedef\" or \"grouping\" statement among the immediate substatements of each ancestor statement.",
      "zh-CHS": "通过在每个祖先语句的直接子语句中定位匹配的“typedef”或“grouping”语句，可以解析对未固定类型或分组的引用，或对使用当前模块前缀的类型或分组的引用。"
    },
    {
      "indent": 0,
      "text": "5.6. Conformance",
      "section_title": true,
      "zh-CHS": "5.6. 一致性"
    },
    {
      "indent": 3,
      "text": "Conformance to a model is a measure of how accurately a server follows the model. Generally speaking, servers are responsible for implementing the model faithfully, allowing applications to treat servers that implement the model identically. Deviations from the model can reduce the utility of the model and increase the fragility of applications that use it.",
      "zh-CHS": "模型的一致性是衡量服务器遵循模型的准确程度的一个指标。一般来说，服务器负责忠实地实现模型，允许应用程序以相同的方式对待实现模型的服务器。偏离模型会降低模型的实用性，并增加使用它的应用程序的脆弱性。"
    },
    {
      "indent": 3,
      "text": "YANG modelers have three mechanisms for conformance:",
      "zh-CHS": "YANG建模者有三种一致性机制："
    },
    {
      "indent": 3,
      "text": "o the basic behavior of the model",
      "zh-CHS": "o 模型的基本行为"
    },
    {
      "indent": 3,
      "text": "o optional features that are part of the model",
      "zh-CHS": "o 作为模型一部分的可选功能"
    },
    {
      "indent": 3,
      "text": "o deviations from the model",
      "zh-CHS": "o 与模型的偏差"
    },
    {
      "indent": 3,
      "text": "We will consider each of these in sequence.",
      "zh-CHS": "我们将依次考虑每一个问题。"
    },
    {
      "indent": 0,
      "text": "5.6.1. Basic Behavior",
      "section_title": true,
      "zh-CHS": "5.6.1. 基本行为"
    },
    {
      "indent": 3,
      "text": "The model defines a contract between a YANG-based client and server; this contract allows both parties to have faith that the other knows the syntax and semantics behind the modeled data. The strength of YANG lies in the strength of this contract.",
      "zh-CHS": "该模型定义了基于YANG的客户端和服务器之间的契约；本合同允许双方相信另一方知道建模数据背后的语法和语义。杨的力量在于这份合同的力量。"
    },
    {
      "indent": 0,
      "text": "5.6.2. Optional Features",
      "section_title": true,
      "zh-CHS": "5.6.2. 可选功能"
    },
    {
      "indent": 3,
      "text": "In many models, the modeler will allow sections of the model to be conditional. The server controls whether these conditional portions of the model are supported or valid for that particular server.",
      "zh-CHS": "在许多模型中，建模者将允许模型的部分是有条件的。服务器控制模型的这些条件部分对于特定服务器是否受支持或有效。"
    },
    {
      "indent": 3,
      "text": "For example, a syslog data model may choose to include the ability to save logs locally, but the modeler will realize that this is only possible if the server has local storage. If there is no local storage, an application should not tell the server to save logs.",
      "zh-CHS": "例如，syslog数据模型可能会选择包含本地保存日志的功能，但建模人员会意识到，只有在服务器具有本地存储的情况下，这才是可能的。如果没有本地存储，应用程序不应该告诉服务器保存日志。"
    },
    {
      "indent": 3,
      "text": "YANG supports this conditional mechanism using a construct called \"feature\". Features give the modeler a mechanism for making portions of the module conditional in a manner that is controlled by the server. The model can express constructs that are not universally present in all servers. These features are included in the model definition, allowing a consistent view and allowing applications to learn which features are supported and tailor their behavior to the server.",
      "zh-CHS": "YANG使用一种称为“特征”的结构来支持这种条件机制。特性为建模者提供了一种机制，使模块的某些部分以服务器控制的方式具有条件。该模型可以表示并非所有服务器中都普遍存在的结构。这些特性包含在模型定义中，允许一致的视图，并允许应用程序了解支持哪些特性，并根据服务器调整其行为。"
    },
    {
      "indent": 3,
      "text": "A module may declare any number of features, identified by simple strings, and may make portions of the module optional based on those features. If the server supports a feature, then the corresponding portions of the module are valid for that server. If the server doesn't support the feature, those parts of the module are not valid, and applications should behave accordingly.",
      "zh-CHS": "一个模块可以声明任意数量的特性，由简单字符串标识，并且可以基于这些特性使模块的部分成为可选的。如果服务器支持某项功能，则模块的相应部分对该服务器有效。如果服务器不支持该功能，则模块的这些部分无效，应用程序应相应地运行。"
    },
    {
      "indent": 3,
      "text": "Features are defined using the \"feature\" statement. Definitions in the module that are conditional to the feature are noted by the \"if-feature\" statement.",
      "zh-CHS": "使用“功能”语句定义功能。模块中与功能相关的定义由“if feature”语句注释。"
    },
    {
      "indent": 3,
      "text": "Further details are available in Section 7.20.1.",
      "zh-CHS": "更多详情见第7.20.1节。"
    },
    {
      "indent": 0,
      "text": "5.6.3. Deviations",
      "section_title": true,
      "zh-CHS": "5.6.3. 偏差"
    },
    {
      "indent": 3,
      "text": "In an ideal world, all servers would be required to implement the model exactly as defined, and deviations from the model would not be allowed. But in the real world, servers are often not able or designed to implement the model as written. For YANG-based automation to deal with these server deviations, a mechanism must exist for servers to inform applications of the specifics of such deviations.",
      "zh-CHS": "在理想情况下，所有服务器都需要完全按照定义实现模型，并且不允许偏离模型。但在现实世界中，服务器通常无法或设计为实现所编写的模型。为了使基于YANG的自动化能够处理这些服务器偏差，服务器必须有一种机制来通知应用程序这些偏差的具体情况。"
    },
    {
      "indent": 3,
      "text": "For example, a BGP module may allow any number of BGP peers, but a particular server may only support 16 BGP peers. Any application configuring the 17th peer will receive an error. While an error may suffice to let the application know it cannot add another peer, it would be far better if the application had prior knowledge of this limitation and could prevent the user from starting down the path that could not succeed.",
      "zh-CHS": "例如，BGP模块可允许任意数量的BGP对等点，但特定服务器可能仅支持16个BGP对等点。任何配置第17个对等点的应用程序都将收到错误。虽然一个错误可能足以让应用程序知道它无法添加另一个对等点，但如果应用程序事先知道这一限制，并且可以阻止用户沿着无法成功的路径启动，那就更好了。"
    },
    {
      "indent": 3,
      "text": "Server deviations are declared using the \"deviation\" statement, which takes as its argument a string that identifies a node in the schema tree. The contents of the statement detail the manner in which the server implementation deviates from the contract as defined in the module.",
      "zh-CHS": "服务器偏差是使用“偏差”语句声明的，该语句以标识模式树中节点的字符串作为参数。该语句的内容详细说明了服务器实现偏离模块中定义的契约的方式。"
    },
    {
      "indent": 3,
      "text": "Further details are available in Section 7.20.3.",
      "zh-CHS": "更多详情见第7.20.3节。"
    },
    {
      "indent": 0,
      "text": "5.6.4. Announcing Conformance Information in NETCONF",
      "section_title": true,
      "zh-CHS": "5.6.4. 在NETCONF中宣布一致性信息"
    },
    {
      "indent": 3,
      "text": "This document defines the following mechanism for announcing conformance information. Other mechanisms may be defined by future specifications.",
      "zh-CHS": "本文档定义了以下发布一致性信息的机制。其他机制可能由未来的规范定义。"
    },
    {
      "indent": 3,
      "text": "A NETCONF server MUST announce the modules it implements (see Section 5.6.5) by implementing the YANG module \"ietf-yang-library\" defined in [RFC7895] and listing all implemented modules in the \"/modules-state/module\" list.",
      "zh-CHS": "NETCONF服务器必须通过实现[RFC7895]中定义的YANG模块“ietf YANG library”并在“/模块状态/模块”列表中列出所有实现的模块来宣布其实现的模块（见第5.6.5节）。"
    },
    {
      "indent": 3,
      "text": "The server also MUST advertise the following capability in the <hello> message (line breaks and whitespaces are used for formatting reasons only):",
      "zh-CHS": "服务器还必须在<hello>消息中公布以下功能（换行符和空格仅用于格式化原因）："
    },
    {
      "indent": 5,
      "text": "urn:ietf:params:netconf:capability:yang-library:1.0?\n  revision=<date>&module-set-id=<id>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The parameter \"revision\" has the same value as the revision date of the \"ietf-yang-library\" module implemented by the server. This parameter MUST be present.",
      "zh-CHS": "参数“revision”的值与服务器实现的“ietf yang library”模块的修订日期相同。此参数必须存在。"
    },
    {
      "indent": 3,
      "text": "The parameter \"module-set-id\" has the same value as the leaf \"/modules-state/module-set-id\" from \"ietf-yang-library\". This parameter MUST be present.",
      "zh-CHS": "参数“模块集id”的值与“ietf库”中的叶“/模块状态/模块集id”的值相同。此参数必须存在。"
    },
    {
      "indent": 3,
      "text": "With this mechanism, a client can cache the supported modules for a server and only update the cache if the \"module-set-id\" value in the <hello> message changes.",
      "zh-CHS": "通过这种机制，客户机可以缓存服务器支持的模块，并且只有在<hello>消息中的“module set id”值更改时才更新缓存。"
    },
    {
      "indent": 0,
      "text": "5.6.5. Implementing a Module",
      "section_title": true,
      "zh-CHS": "5.6.5. 实现模块"
    },
    {
      "indent": 3,
      "text": "A server implements a module if it implements the module's data nodes, RPCs, actions, notifications, and deviations.",
      "zh-CHS": "如果服务器实现了模块的数据节点、RPC、操作、通知和偏差，则服务器将实现该模块。"
    },
    {
      "indent": 3,
      "text": "A server MUST NOT implement more than one revision of a module.",
      "zh-CHS": "服务器不能实现一个模块的多个版本。"
    },
    {
      "indent": 3,
      "text": "If a server implements a module A that imports a module B, and A uses any node from B in an \"augment\" or \"path\" statement that the server supports, then the server MUST implement a revision of module B that has these nodes defined. This is regardless of whether module B is imported by revision or not.",
      "zh-CHS": "如果服务器实现了导入模块B的模块a，并且a在服务器支持的“augment”或“path”语句中使用了来自B的任何节点，则服务器必须实现定义了这些节点的模块B的修订版。这与模块B是否通过修订版导入无关。"
    },
    {
      "indent": 3,
      "text": "If a server implements a module A that imports a module C without specifying the revision date of module C and the server does not implement C (e.g., if C only defines some typedefs), the server MUST list module C in the \"/modules-state/module\" list from \"ietf-yang-library\" [RFC7895], and it MUST set the leaf \"conformance-type\" to \"import\" for this module.",
      "zh-CHS": "如果服务器实现的模块a导入模块C而未指定模块C的修订日期，并且服务器未实现C（例如，如果C仅定义了一些TypeDef），则服务器必须在“ietf yang library”[RFC7895]的“/模块状态/模块”列表中列出模块C，并且必须将叶“一致性类型”设置为“导入”对于本模块。"
    },
    {
      "indent": 3,
      "text": "If a server lists a module C in the \"/modules-state/module\" list from \"ietf-yang-library\" and there are other modules Ms listed that import C without specifying the revision date of module C, the server MUST use the definitions from the most recent revision of C listed for modules Ms.",
      "zh-CHS": "如果服务器在“ietf yang library”中的“/模块状态/模块”列表中列出模块C，并且列出的其他模块Ms在未指定模块C的修订日期的情况下导入C，则服务器必须使用为模块Ms列出的最新版本C中的定义。"
    },
    {
      "indent": 3,
      "text": "The reason for these rules is that clients need to be able to know the specific data model structure and types of all leafs and leaf-lists implemented in a server.",
      "zh-CHS": "这些规则的原因是，客户机需要能够知道服务器中实现的所有叶和叶列表的特定数据模型结构和类型。"
    },
    {
      "indent": 3,
      "text": "For example, with these modules:",
      "zh-CHS": "例如，使用这些模块："
    },
    {
      "indent": 5,
      "text": "module a {\n  yang-version 1.1;\n  namespace \"urn:example:a\";\n  prefix \"a\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "import b {\n  revision-date 2015-01-01;\n}\nimport c;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "revision 2015-01-01;",
      "zh-CHS": "修订版2015-01-01；"
    },
    {
      "indent": 7,
      "text": "feature foo;",
      "zh-CHS": "特写富；"
    },
    {
      "indent": 7,
      "text": "augment \"/b:x\" {\n  if-feature foo;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "  leaf y {\n    type b:myenum;\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "  container a {\n    leaf x {\n      type c:bar;\n    }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "module b {\n  yang-version 1.1;\n  namespace \"urn:example:b\";\n  prefix \"b\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "revision 2015-01-01;",
      "zh-CHS": "修订版2015-01-01；"
    },
    {
      "indent": 7,
      "text": "typedef myenum {\n  type enumeration {\n    enum zero;\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "  container x {\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "module b {\n  yang-version 1.1;\n  namespace \"urn:example:b\";\n  prefix \"b\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "revision 2015-04-04;\nrevision 2015-01-01;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "typedef myenum {\n  type enumeration {\n    enum zero; // added in 2015-01-01\n    enum one;  // added in 2015-04-04\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "  container x {  // added in 2015-01-01\n    container y; // added in 2015-04-04\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "module c {\n  yang-version 1.1;\n  namespace \"urn:example:c\";\n  prefix \"c\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "revision 2015-02-02;",
      "zh-CHS": "修订版2015-02-02；"
    },
    {
      "indent": 5,
      "text": "  typedef bar {\n    ...\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "module c {\n  yang-version 1.1;\n  namespace \"urn:example:c\";\n  prefix \"c\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "revision 2015-03-03;\nrevision 2015-02-02;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "  typedef bar {\n    ...\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "A server that implements revision \"2015-01-01\" of module \"a\" and supports feature \"foo\" can implement revision \"2015-01-01\" or \"2015-04-04\" of module \"b\". Since \"b\" was imported by revision, the type of leaf \"/b:x/a:y\" is the same, regardless of which revision of \"b\" the server implements.",
      "zh-CHS": "实现模块“A”的版本“2015-01-01”并支持功能“foo”的服务器可以实现模块“b”的版本“2015-01-01”或“2015-04-04”。由于“b”是通过修订版导入的，因此叶“/b:x/a:y”的类型是相同的，无论服务器实现的是“b”的哪个修订版。"
    },
    {
      "indent": 3,
      "text": "A server that implements module \"a\" but does not support feature \"foo\" does not have to implement module \"b\".",
      "zh-CHS": "实现模块“A”但不支持功能“foo”的服务器不必实现模块“b”。"
    },
    {
      "indent": 3,
      "text": "A server that implements revision \"2015-01-01\" of module \"a\" picks any revision of module \"c\" and lists it in the \"/modules-state/module\" list from \"ietf-yang-library\".",
      "zh-CHS": "实现模块“A”的版本“2015-01-01”的服务器会选择模块“c”的任何版本，并将其列在“ietf库”的“/模块状态/模块”列表中。"
    },
    {
      "indent": 3,
      "text": "The following XML encoding example shows valid data for the \"/modules-state/module\" list for a server that implements module \"a\":",
      "zh-CHS": "以下XML编码示例显示了实现模块“a”的服务器的“/modules state/module”列表的有效数据："
    },
    {
      "indent": 5,
      "text": "<modules-state\n    xmlns=\"urn:ietf:params:xml:ns:yang:ietf-yang-library\">\n  <module-set-id>ee1ecb017370cafd</module-set-id>\n  <module>\n    <name>a</name>\n    <revision>2015-01-01</revision>\n    <namespace>urn:example:a</namespace>\n    <feature>foo</feature>\n    <conformance-type>implement</conformance-type>\n  </module>\n  <module>\n    <name>b</name>\n    <revision>2015-04-04</revision>\n    <namespace>urn:example:b</namespace>\n    <conformance-type>implement</conformance-type>\n  </module>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "  <module>\n    <name>c</name>\n    <revision>2015-02-02</revision>\n    <namespace>urn:example:c</namespace>\n    <conformance-type>import</conformance-type>\n  </module>\n</modules-state>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "5.7. Datastore Modification",
      "section_title": true,
      "zh-CHS": "5.7. 数据存储修改"
    },
    {
      "indent": 3,
      "text": "Data models may allow the server to alter the configuration datastore in ways not explicitly directed via network management protocol messages. For example, a data model may define leafs that are assigned system-generated values when the client does not provide one. A formal mechanism for specifying the circumstances where these changes are allowed is out of scope for this specification.",
      "zh-CHS": "数据模型可能允许服务器以未通过网络管理协议消息明确指示的方式更改配置数据存储。例如，数据模型可以定义在客户端不提供时分配给系统生成值的LEAF。用于指定允许这些更改的情况的正式机制超出了本规范的范围。"
    },
    {
      "indent": 0,
      "text": "6. YANG Syntax",
      "section_title": true,
      "zh-CHS": "6. 阳语法"
    },
    {
      "indent": 3,
      "text": "The YANG syntax is similar to that of SMIng [RFC3780] and programming languages like C and C++. This C-like syntax was chosen specifically for its readability, since YANG values the time and effort of the readers of models above those of modules writers and YANG tool-chain developers. This section introduces the YANG syntax.",
      "zh-CHS": "杨语法类似于SMI[RCF380]和C语言和C++语言。这种类似C的语法是专门为其可读性而选择的，因为YANG重视模型读者的时间和精力，而不是模块作者和YANG工具链开发人员的时间和精力。本节介绍YANG语法。"
    },
    {
      "indent": 3,
      "text": "Legal characters in YANG modules are the Unicode and ISO/IEC 10646 [ISO.10646] characters, including tab, carriage return, and line feed but excluding the other C0 control characters, the surrogate blocks, and the noncharacters. The character syntax is formally defined by the rule \"yang-char\" in Section 14.",
      "zh-CHS": "模块中的合法字符是Unicode和ISO/IEC 10646[ISO.10646]字符，包括制表符、回车符和换行符，但不包括其他C0控制字符、代理块和非字符。字符语法由第14节中的规则“yang char”正式定义。"
    },
    {
      "indent": 3,
      "text": "YANG modules and submodules are stored in files using the UTF-8 [RFC3629] character encoding.",
      "zh-CHS": "模块和子模块使用UTF-8[RFC3629]字符编码存储在文件中。"
    },
    {
      "indent": 3,
      "text": "Lines in a YANG module end with a carriage return-line feed combination or with a line feed alone. A carriage return that is not followed by a line feed may only appear inside a quoted string (Section 6.1.3). Note that carriage returns and line feeds that appear inside quoted strings become part of the value of the string without modification; the value of a multi-line quoted string contains the same form of line ends as those lines of the YANG module.",
      "zh-CHS": "杨氏模块中的管线以托架返回管线馈送组合或单独管线馈送结束。未后跟换行符的回车符只能出现在带引号的字符串中（第6.1.3节）。请注意，出现在带引号的字符串中的回车符和换行符在未经修改的情况下成为字符串值的一部分；多行引号字符串的值包含与模块中的行相同形式的行尾。"
    },
    {
      "indent": 0,
      "text": "6.1. Lexical Tokenization",
      "section_title": true,
      "zh-CHS": "6.1. 词汇标记化"
    },
    {
      "indent": 3,
      "text": "YANG modules are parsed as a series of tokens. This section details the rules for recognizing tokens from an input stream. YANG tokenization rules are both simple and powerful. The simplicity is driven by a need to keep the parsers easy to implement, while the power is driven by the fact that modelers need to express their models in readable formats.",
      "zh-CHS": "YANG模块被解析为一系列标记。本节详细介绍了从输入流识别令牌的规则。YANG标记化规则既简单又强大。简单性是由保持解析器易于实现的需要驱动的，而强大的驱动力是由建模者需要以可读的格式表达他们的模型这一事实驱动的。"
    },
    {
      "indent": 0,
      "text": "6.1.1. Comments",
      "section_title": true,
      "zh-CHS": "6.1.1. 评论"
    },
    {
      "indent": 3,
      "text": "Comments are C++ style. A single line comment starts with \"//\" and ends at the end of the line. A block comment starts with \"/*\" and ends with the nearest following \"*/\".",
      "zh-CHS": "注释是C++风格。单行注释以“/”开头，并在行尾结束。块注释以“/*”开头，以最近的“*/”结尾。"
    },
    {
      "indent": 3,
      "text": "Note that inside a quoted string (Section 6.1.3), these character pairs are never interpreted as the start or end of a comment.",
      "zh-CHS": "请注意，在带引号的字符串中（第6.1.3节），这些字符对永远不会解释为注释的开始或结束。"
    },
    {
      "indent": 0,
      "text": "6.1.2. Tokens",
      "section_title": true,
      "zh-CHS": "6.1.2. 代币"
    },
    {
      "indent": 3,
      "text": "A token in YANG is either a keyword, a string, a semicolon (\";\"), or braces (\"{\" or \"}\"). A string can be quoted or unquoted. A keyword is either one of the YANG keywords defined in this document, or a prefix identifier, followed by a colon (\":\"), followed by a language extension keyword. Keywords are case sensitive. See Section 6.2 for a formal definition of identifiers.",
      "zh-CHS": "YANG中的标记可以是关键字、字符串、分号（“；”）或大括号（“{”或“}”）。字符串可以是带引号的或不带引号的。关键字可以是本文档中定义的关键字之一，也可以是前缀标识符，后跟冒号（“：”），后跟语言扩展关键字。关键字区分大小写。标识符的正式定义见第6.2节。"
    },
    {
      "indent": 0,
      "text": "6.1.3. Quoting",
      "section_title": true,
      "zh-CHS": "6.1.3. 引用"
    },
    {
      "indent": 3,
      "text": "An unquoted string is any sequence of characters that does not contain any space, tab, carriage return, or line feed characters, a single or double quote character, a semicolon (\";\"), braces (\"{\" or \"}\"), or comment sequences (\"//\", \"/*\", or \"*/\").",
      "zh-CHS": "无引号字符串是不包含任何空格、制表符、回车符或换行符、单引号或双引号字符、分号（“；”）、大括号（“{”或“}”）或注释序列（“//”、“/*”）的任何字符序列。"
    },
    {
      "indent": 3,
      "text": "Note that any keyword can legally appear as an unquoted string.",
      "zh-CHS": "请注意，任何关键字都可以合法地显示为不带引号的字符串。"
    },
    {
      "indent": 3,
      "text": "Within an unquoted string, every character is preserved. Note that this means that the backslash character does not have any special meaning in an unquoted string.",
      "zh-CHS": "在不带引号的字符串中，每个字符都被保留。请注意，这意味着反斜杠字符在无引号的字符串中没有任何特殊含义。"
    },
    {
      "indent": 3,
      "text": "If a double-quoted string contains a line break followed by space or tab characters that are used to indent the text according to the layout in the YANG file, this leading whitespace is stripped from the string, up to and including the column of the starting double quote character, or to the first non-whitespace character, whichever occurs first. Any tab character in a succeeding line that must be examined for stripping is first converted into 8 space characters.",
      "zh-CHS": "如果双引号字符串包含一个换行符，后跟空格或制表符，用于根据YANG文件中的布局缩进文本，则该前导空格将从字符串中剥离，直至并包括起始双引号字符的列，或第一个非空格字符，以先发生的为准。后续行中必须进行剥离检查的任何制表符首先转换为8个空格字符。"
    },
    {
      "indent": 3,
      "text": "If a double-quoted string contains space or tab characters before a line break, this trailing whitespace is stripped from the string.",
      "zh-CHS": "如果双引号字符串在换行符之前包含空格或制表符，则会从字符串中删除该尾随空格。"
    },
    {
      "indent": 3,
      "text": "A single-quoted string (enclosed within ' ') preserves each character within the quotes. A single quote character cannot occur in a single-quoted string, even when preceded by a backslash.",
      "zh-CHS": "单引号字符串（括在“”中）保留引号中的每个字符。单引号字符不能出现在单引号字符串中，即使前面有反斜杠。"
    },
    {
      "indent": 3,
      "text": "Within a double-quoted string (enclosed within \" \"), a backslash character introduces a representation of a special character, which depends on the character that immediately follows the backslash:",
      "zh-CHS": "在双引号字符串（括在“”中）中，反斜杠字符引入特殊字符的表示形式，这取决于紧跟在反斜杠后面的字符："
    },
    {
      "indent": 4,
      "text": "\\n newline \\t a tab character \\\" a double quote \\\\ a single backslash",
      "zh-CHS": "\\n换行符\\t制表符\\“双引号\\\\单反斜杠”"
    },
    {
      "indent": 3,
      "text": "The backslash MUST NOT be followed by any other character.",
      "zh-CHS": "反斜杠后面不能跟任何其他字符。"
    },
    {
      "indent": 3,
      "text": "If a quoted string is followed by a plus character (\"+\"), followed by another quoted string, the two strings are concatenated into one string, allowing multiple concatenations to build one string. Whitespace, line breaks, and comments are allowed between the quoted strings and the plus character.",
      "zh-CHS": "如果一个带引号的字符串后跟一个加号（“+”），后跟另一个带引号的字符串，则这两个字符串将连接成一个字符串，从而允许多个连接生成一个字符串。带引号的字符串和加号字符之间允许有空格、换行符和注释。"
    },
    {
      "indent": 3,
      "text": "In double-quoted strings, whitespace trimming is done before substitution of backslash-escaped characters. Concatenation is performed as the last step.",
      "zh-CHS": "在双引号字符串中，空格修剪是在替换反斜杠转义字符之前完成的。连接作为最后一步执行。"
    },
    {
      "indent": 0,
      "text": "6.1.3.1. Quoting Examples",
      "section_title": true,
      "zh-CHS": "6.1.3.1. 举出例子"
    },
    {
      "indent": 3,
      "text": "The following strings are equivalent:",
      "zh-CHS": "以下字符串是等效的："
    },
    {
      "indent": 5,
      "text": "hello \"hello\" 'hello' \"hel\" + \"lo\" 'hel' + \"lo\"",
      "zh-CHS": "喂喂喂喂喂喂喂喂喂喂喂喂喂喂喂喂喂喂喂喂喂喂喂喂喂喂喂喂喂"
    },
    {
      "indent": 3,
      "text": "The following examples show some special strings:",
      "zh-CHS": "以下示例显示了一些特殊字符串："
    },
    {
      "indent": 5,
      "text": "\"\\\"\" - string containing a double quote '\"' - string containing a double quote \"\\n\" - string containing a newline character '\\n' - string containing a backslash followed by the character n",
      "zh-CHS": "“\\”“-包含双引号的字符串”-包含双引号的字符串“\\n”-包含换行符“\\n”-包含反斜杠后跟字符n的字符串"
    },
    {
      "indent": 3,
      "text": "The following examples show some illegal strings:",
      "zh-CHS": "以下示例显示了一些非法字符串："
    },
    {
      "indent": 5,
      "text": "'''' - a single-quoted string cannot contain single quotes \"\"\" - a double quote must be escaped in a double-quoted string",
      "zh-CHS": "“”“”-单引号字符串不能包含单引号“”-双引号字符串中必须转义双引号"
    },
    {
      "indent": 3,
      "text": "The following strings are equivalent:",
      "zh-CHS": "以下字符串是等效的："
    },
    {
      "indent": 9,
      "text": "\"first line second line\"",
      "zh-CHS": "“第一行第二行”"
    },
    {
      "indent": 5,
      "text": "\"first line\\n\" + \" second line\"",
      "zh-CHS": "“第一行\\n”+“第二行”"
    },
    {
      "indent": 0,
      "text": "6.2. Identifiers",
      "section_title": true,
      "zh-CHS": "6.2. 标识符"
    },
    {
      "indent": 3,
      "text": "Identifiers are used to identify different kinds of YANG items by name. Each identifier starts with an uppercase or lowercase ASCII letter or an underscore character, followed by zero or more ASCII letters, digits, underscore characters, hyphens, and dots. Implementations MUST support identifiers up to 64 characters in length and MAY support longer identifiers. Identifiers are case sensitive. The identifier syntax is formally defined by the rule \"identifier\" in Section 14. Identifiers can be specified as quoted or unquoted strings.",
      "zh-CHS": "标识符用于按名称标识不同种类的项目。每个标识符以大写或小写ASCII字母或下划线字符开头，后跟零个或多个ASCII字母、数字、下划线字符、连字符和点。实现必须支持长度不超过64个字符的标识符，并且可能支持更长的标识符。标识符区分大小写。标识符语法由第14节中的“标识符”规则正式定义。标识符可以指定为带引号或不带引号的字符串。"
    },
    {
      "indent": 0,
      "text": "6.2.1. Identifiers and Their Namespaces",
      "section_title": true,
      "zh-CHS": "6.2.1. 标识符及其名称空间"
    },
    {
      "indent": 3,
      "text": "Each identifier is valid in a namespace that depends on the type of the YANG item being defined. All identifiers defined in a namespace MUST be unique.",
      "zh-CHS": "每个标识符在命名空间中都是有效的，该命名空间取决于所定义项的类型。命名空间中定义的所有标识符都必须是唯一的。"
    },
    {
      "indent": 3,
      "text": "o All module and submodule names share the same global module identifier namespace.",
      "zh-CHS": "o 所有模块和子模块名称共享相同的全局模块标识符命名空间。"
    },
    {
      "indent": 3,
      "text": "o All extension names defined in a module and its submodules share the same extension identifier namespace.",
      "zh-CHS": "o 模块及其子模块中定义的所有扩展名共享相同的扩展标识符命名空间。"
    },
    {
      "indent": 3,
      "text": "o All feature names defined in a module and its submodules share the same feature identifier namespace.",
      "zh-CHS": "o 模块及其子模块中定义的所有功能名称共享相同的功能标识符命名空间。"
    },
    {
      "indent": 3,
      "text": "o All identity names defined in a module and its submodules share the same identity identifier namespace.",
      "zh-CHS": "o 模块及其子模块中定义的所有标识名共享相同的标识标识符命名空间。"
    },
    {
      "indent": 3,
      "text": "o All derived type names defined within a parent node or at the top level of the module or its submodules share the same type identifier namespace. This namespace is scoped to all descendant nodes of the parent node or module. This means that any descendant node may use that typedef, and it MUST NOT define a typedef with the same name.",
      "zh-CHS": "o 在父节点内或在模块或其子模块的顶层定义的所有派生类型名称共享相同的类型标识符命名空间。此命名空间的作用域为父节点或模块的所有子节点。这意味着任何子节点都可以使用该typedef，并且它不能定义具有相同名称的typedef。"
    },
    {
      "indent": 3,
      "text": "o All grouping names defined within a parent node or at the top level of the module or its submodules share the same grouping identifier namespace. This namespace is scoped to all descendant nodes of the parent node or module. This means that any descendant node may use that grouping, and it MUST NOT define a grouping with the same name.",
      "zh-CHS": "o 在父节点内或在模块或其子模块的顶层定义的所有分组名称共享相同的分组标识符命名空间。此命名空间的作用域为父节点或模块的所有子节点。这意味着任何子节点都可以使用该分组，并且不能使用相同的名称定义分组。"
    },
    {
      "indent": 3,
      "text": "o All leafs, leaf-lists, lists, containers, choices, rpcs, actions, notifications, anydatas, and anyxmls defined (directly or through a \"uses\" statement) within a parent node or at the top level of the module or its submodules share the same identifier namespace. This namespace is scoped to the parent node or module, unless the parent node is a case node. In that case, the namespace is scoped to the closest ancestor node that is not a case or choice node.",
      "zh-CHS": "o 父节点内或模块或其子模块顶层定义的所有叶、叶列表、列表、容器、选项、RPC、操作、通知、anydata和anyxml（直接或通过“uses”语句）共享相同的标识符命名空间。除非父节点是案例节点，否则此命名空间的作用域为父节点或模块。在这种情况下，名称空间的作用域是最接近的祖先节点，该节点不是case或choice节点。"
    },
    {
      "indent": 3,
      "text": "o All cases within a choice share the same case identifier namespace. This namespace is scoped to the parent choice node.",
      "zh-CHS": "o 选项中的所有案例共享相同的案例标识符命名空间。此命名空间的作用域为父选择节点。"
    },
    {
      "indent": 3,
      "text": "Forward references are allowed in YANG.",
      "zh-CHS": "在YANG中允许向前引用。"
    },
    {
      "indent": 0,
      "text": "6.3. Statements",
      "section_title": true,
      "zh-CHS": "6.3. 声明"
    },
    {
      "indent": 3,
      "text": "A YANG module contains a sequence of statements. Each statement starts with a keyword, followed by zero or one argument, followed by either a semicolon (\";\") or a block of substatements enclosed within braces (\"{ }\"):",
      "zh-CHS": "模块包含一系列语句。每个语句都以关键字开头，后跟零或一个参数，后跟分号（；）或大括号（{}）中包含的子语句块："
    },
    {
      "indent": 5,
      "text": "statement = keyword [argument] (\";\" / \"{\" *statement \"}\")",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The argument is a string, as defined in Section 6.1.2.",
      "zh-CHS": "参数是一个字符串，如第6.1.2节所定义。"
    },
    {
      "indent": 0,
      "text": "6.3.1. Language Extensions",
      "section_title": true,
      "zh-CHS": "6.3.1. 语言外延"
    },
    {
      "indent": 3,
      "text": "A module can introduce YANG extensions by using the \"extension\" keyword (see Section 7.19). The extensions can be imported by other modules with the \"import\" statement (see Section 7.1.5). When an imported extension is used, the extension's keyword MUST be qualified using the prefix with which the extension's module was imported. If an extension is used in the module where it is defined, the extension's keyword MUST be qualified with the prefix of this module.",
      "zh-CHS": "一个模块可以通过使用“extension”关键字引入YANG扩展（参见第7.19节）。其他模块可以使用“导入”语句导入扩展（参见第7.1.5节）。使用导入的扩展时，必须使用导入扩展模块时使用的前缀限定扩展的关键字。如果在定义扩展的模块中使用扩展，则扩展的关键字必须使用此模块的前缀限定。"
    },
    {
      "indent": 3,
      "text": "The processing of extensions depends on whether support for those extensions is claimed for a given YANG parser or the tool set in which it is embedded. An unsupported extension appearing in a YANG module as an unknown-statement (see Section 14) MAY be ignored in its entirety. Any supported extension MUST be processed in accordance with the specification governing that extension.",
      "zh-CHS": "扩展的处理取决于对这些扩展的支持是针对给定的语法分析器还是嵌入该语法分析器的工具集。在YANG模块中出现的作为未知语句的不受支持的扩展（参见第14节）可以全部忽略。任何受支持的扩展必须按照管理该扩展的规范进行处理。"
    },
    {
      "indent": 3,
      "text": "Care must be taken when defining extensions so that modules that use the extensions are meaningful also for applications that do not support the extensions.",
      "zh-CHS": "定义扩展时必须小心，以便使用扩展的模块对不支持扩展的应用程序也有意义。"
    },
    {
      "indent": 0,
      "text": "6.4. XPath Evaluations",
      "section_title": true,
      "zh-CHS": "6.4. XPath求值"
    },
    {
      "indent": 3,
      "text": "YANG relies on XML Path Language (XPath) 1.0 [XPATH] as a notation for specifying many inter-node references and dependencies. An implementation is not required to implement an XPath interpreter but MUST ensure that the requirements encoded in the data model are enforced. The manner of enforcement is an implementation decision. The XPath expressions MUST be syntactically correct, and all prefixes used MUST be present in the XPath context (see Section 6.4.1). An implementation may choose to implement them by hand, rather than using the XPath expression directly.",
      "zh-CHS": "YANG依赖XML路径语言（XPath）1.0[XPath]作为指定许多节点间引用和依赖关系的表示法。实现XPath解释器不需要实现，但必须确保执行数据模型中编码的需求。执行方式是一项执行决定。XPath表达式必须语法正确，并且使用的所有前缀必须出现在XPath上下文中（请参见第6.4.1节）。实现可以选择手工实现，而不是直接使用XPath表达式。"
    },
    {
      "indent": 3,
      "text": "The data model used in the XPath expressions is the same as that used in XPath 1.0 [XPATH], with the same extension for root node children as used by XSLT 1.0 (see Section 3.1 in [XSLT]). Specifically, it means that the root node may have any number of element nodes as its children.",
      "zh-CHS": "XPath表达式中使用的数据模型与XPath 1.0[XPath]中使用的数据模型相同，根节点子节点的扩展与XSLT 1.0使用的扩展相同（请参见[XSLT]中的第3.1节）。具体来说，这意味着根节点可以有任意数量的元素节点作为其子节点。"
    },
    {
      "indent": 3,
      "text": "The data tree has no concept of document order. An implementation needs to choose some document order, but how it is done is an implementation decision. This means that XPath expressions in YANG modules SHOULD NOT rely on any specific document order.",
      "zh-CHS": "数据树没有文档顺序的概念。一个实现需要选择一些文档顺序，但如何执行是一个实现决策。这意味着模块中的XPath表达式不应该依赖于任何特定的文档顺序。"
    },
    {
      "indent": 3,
      "text": "Numbers in XPath 1.0 are IEEE 754 [IEEE754-2008] double-precision floating-point values; see Section 3.5 in [XPATH]. This means that some values of int64, uint64, and decimal64 types (see Sections 9.2 and 9.3) cannot be exactly represented in XPath expressions. Therefore, due caution should be exercised when using nodes with 64-bit numeric values in XPath expressions. In particular, numerical comparisons involving equality may yield unexpected results.",
      "zh-CHS": "XPath 1.0中的数字是IEEE 754[IEEE754-2008]双精度浮点值；请参见[XPATH]中的第3.5节。这意味着int64、uint64和decimal64类型的某些值（参见第9.2节和第9.3节）无法在XPath表达式中精确表示。因此，在XPath表达式中使用具有64位数值的节点时，应特别小心。特别是，涉及等式的数值比较可能会产生意想不到的结果。"
    },
    {
      "indent": 3,
      "text": "For example, consider the following definition:",
      "zh-CHS": "例如，考虑下面的定义："
    },
    {
      "indent": 5,
      "text": "leaf lxiv {\n  type decimal64 {\n    fraction-digits 18;\n  }\n  must \". <= 10\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "An instance of the \"lxiv\" leaf having the value of 10.0000000000000001 will then successfully pass validation.",
      "zh-CHS": "值为10.0000000000000001的“lxiv”叶实例将成功通过验证。"
    },
    {
      "indent": 0,
      "text": "6.4.1. XPath Context",
      "section_title": true,
      "zh-CHS": "6.4.1. XPath上下文"
    },
    {
      "indent": 3,
      "text": "All YANG XPath expressions share the following XPath context definition:",
      "zh-CHS": "所有XPath表达式共享以下XPath上下文定义："
    },
    {
      "indent": 3,
      "text": "o The set of namespace declarations is the set of all \"import\" statements' prefix and namespace pairs in the module where the XPath expression is specified, and the \"prefix\" statement's prefix for the \"namespace\" statement's URI.",
      "zh-CHS": "o 名称空间声明集是指定XPath表达式的模块中所有“导入”语句的前缀和名称空间对的集合，以及“名称空间”语句URI的“前缀”语句的前缀。"
    },
    {
      "indent": 3,
      "text": "o Names without a namespace prefix belong to the same namespace as the identifier of the current node. Inside a grouping, that namespace is affected by where the grouping is used (see Section 7.13). Inside a typedef, that namespace is affected by where the typedef is referenced. If a typedef is defined and referenced within a grouping, the namespace is affected by where the grouping is used (see Section 7.13).",
      "zh-CHS": "o 没有名称空间前缀的名称与当前节点的标识符属于同一名称空间。在分组中，名称空间受分组使用位置的影响（参见第7.13节）。在typedef中，该名称空间受typedef引用位置的影响。如果在分组中定义并引用了typedef，则名称空间受分组使用位置的影响（请参见第7.13节）。"
    },
    {
      "indent": 3,
      "text": "o The function library is the core function library defined in [XPATH] and the functions defined in Section 10.",
      "zh-CHS": "o 函数库是[XPATH]中定义的核心函数库和第10节中定义的函数。"
    },
    {
      "indent": 3,
      "text": "o The set of variable bindings is empty.",
      "zh-CHS": "o 变量绑定集为空。"
    },
    {
      "indent": 3,
      "text": "The mechanism for handling unprefixed names is adopted from XPath 2.0 [XPATH2.0] and helps simplify XPath expressions in YANG. No ambiguity may ever arise, because YANG node identifiers are always qualified names with a non-null namespace URI.",
      "zh-CHS": "处理不固定名称的机制来自XPATH2.0[XPATH2.0]，有助于简化XML中的XPath表达式。不会出现歧义，因为节点标识符始终是具有非空命名空间URI的限定名称。"
    },
    {
      "indent": 3,
      "text": "The accessible tree depends on where the statement with the XPath expression is defined:",
      "zh-CHS": "可访问树取决于使用XPath表达式定义语句的位置："
    },
    {
      "indent": 3,
      "text": "o If the XPath expression is defined in a substatement to a data node that represents configuration, the accessible tree is the data in the datastore where the context node exists. The root node has all top-level configuration data nodes in all modules as children.",
      "zh-CHS": "o 如果XPath表达式是在表示配置的数据节点的子状态中定义的，则可访问树是存在上下文节点的数据存储中的数据。根节点将所有模块中的所有顶级配置数据节点作为子节点。"
    },
    {
      "indent": 3,
      "text": "o If the XPath expression is defined in a substatement to a data node that represents state data, the accessible tree is all state data in the server, and the running configuration datastore. The root node has all top-level data nodes in all modules as children.",
      "zh-CHS": "o 如果XPath表达式是在表示状态数据的数据节点的子状态中定义的，则可访问树是服务器中的所有状态数据以及正在运行的配置数据存储。根节点将所有模块中的所有顶级数据节点作为子节点。"
    },
    {
      "indent": 3,
      "text": "o If the XPath expression is defined in a substatement to a \"notification\" statement, the accessible tree is the notification instance, all state data in the server, and the running configuration datastore. If the notification is defined on the top level in a module, then the root node has the node",
      "zh-CHS": "o 如果XPath表达式是在“notification”语句的子语句中定义的，那么可访问的树就是通知实例、服务器中的所有状态数据以及正在运行的配置数据存储。如果通知是在模块的顶层定义的，则根节点具有该节点"
    },
    {
      "indent": 6,
      "text": "representing the notification being defined and all top-level data nodes in all modules as children. Otherwise, the root node has all top-level data nodes in all modules as children.",
      "zh-CHS": "将正在定义的通知和所有模块中的所有顶级数据节点表示为子节点。否则，根节点将所有模块中的所有顶级数据节点作为子节点。"
    },
    {
      "indent": 3,
      "text": "o If the XPath expression is defined in a substatement to an \"input\" statement in an \"rpc\" or \"action\" statement, the accessible tree is the RPC or action operation instance, all state data in the server, and the running configuration datastore. The root node has top-level data nodes in all modules as children. Additionally, for an RPC, the root node also has the node representing the RPC operation being defined as a child. The node representing the operation being defined has the operation's input parameters as children.",
      "zh-CHS": "o 如果XPath表达式是在“rpc”或“action”语句中的“input”语句的子语句中定义的，则可访问的树是rpc或action操作实例、服务器中的所有状态数据以及正在运行的配置数据存储。根节点在所有模块中都有顶级数据节点作为子节点。此外，对于RPC，根节点还将表示RPC操作的节点定义为子节点。表示所定义操作的节点将操作的输入参数作为子节点。"
    },
    {
      "indent": 3,
      "text": "o If the XPath expression is defined in a substatement to an \"output\" statement in an \"rpc\" or \"action\" statement, the accessible tree is the RPC or action operation instance, all state data in the server, and the running configuration datastore. The root node has top-level data nodes in all modules as children. Additionally, for an RPC, the root node also has the node representing the RPC operation being defined as a child. The node representing the operation being defined has the operation's output parameters as children.",
      "zh-CHS": "o 如果XPath表达式是在“rpc”或“action”语句中的“output”语句的子语句中定义的，则可访问的树是rpc或action操作实例、服务器中的所有状态数据以及正在运行的配置数据存储。根节点在所有模块中都有顶级数据节点作为子节点。此外，对于RPC，根节点还将表示RPC操作的节点定义为子节点。表示所定义操作的节点将操作的输出参数作为子级。"
    },
    {
      "indent": 3,
      "text": "In the accessible tree, all leafs and leaf-lists with default values in use exist (see Sections 7.6.1 and 7.7.2).",
      "zh-CHS": "在可访问树中，存在使用默认值的所有叶和叶列表（见第7.6.1和7.7.2节）。"
    },
    {
      "indent": 3,
      "text": "If a node that exists in the accessible tree has a non-presence container as a child, then the non-presence container also exists in the accessible tree.",
      "zh-CHS": "如果存在于可访问树中的节点具有作为子节点的不存在容器，则该不存在容器也存在于可访问树中。"
    },
    {
      "indent": 3,
      "text": "The context node varies with the YANG XPath expression and is specified where the YANG statement with the XPath expression is defined.",
      "zh-CHS": "上下文节点随YANG XPath表达式的不同而变化，并在定义带有XPath表达式的YANG语句的位置指定。"
    },
    {
      "indent": 0,
      "text": "6.4.1.1. Examples",
      "section_title": true,
      "zh-CHS": "6.4.1.1. 例子"
    },
    {
      "indent": 3,
      "text": "Given the following module:",
      "zh-CHS": "鉴于以下模块："
    },
    {
      "indent": 5,
      "text": "module example-a {\n  yang-version 1.1;\n  namespace urn:example:a;\n  prefix a;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "  container a {\n    list b {\n      key id;\n      leaf id {\n        type string;\n      }\n      notification down {\n        leaf reason {\n          type string;\n        }\n      }\n      action reset {\n        input {\n          leaf delay {\n            type uint32;\n          }\n        }\n        output {\n          leaf result {\n            type string;\n          }\n        }\n      }\n    }\n  }\n  notification failure {\n    leaf b-ref {\n      type leafref {\n        path \"/a/b/id\";\n      }\n    }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "and given the following data tree, specified in XML:",
      "zh-CHS": "并给出以下以XML指定的数据树："
    },
    {
      "indent": 5,
      "text": "<a xmlns=\"urn:example:a\">\n  <b>\n    <id>1</id>\n  </b>\n  <b>\n    <id>2</id>\n  </b>\n</a>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The accessible tree for a notification \"down\" on /a/b[id=\"2\"] is:",
      "zh-CHS": "/a/b[id=“2”]上通知“关闭”的可访问树为："
    },
    {
      "indent": 5,
      "text": "<a xmlns=\"urn:example:a\">\n  <b>\n    <id>1</id>\n  </b>\n  <b>\n    <id>2</id>\n    <down>\n      <reason>error</reason>\n    </down>\n  </b>\n</a>\n// possibly other top-level nodes here",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The accessible tree for an action invocation of \"reset\" on /a/b[id=\"1\"] with the \"when\" parameter set to \"10\" would be:",
      "zh-CHS": "当“when”参数设置为“10”时，/a/b[id=“1”]上的“reset”操作调用的可访问树为："
    },
    {
      "indent": 5,
      "text": "<a xmlns=\"urn:example:a\">\n  <b>\n    <id>1</id>\n    <reset>\n      <delay>10</delay>\n    </reset>\n  </b>\n  <b>\n    <id>2</id>\n  </b>\n</a>\n// possibly other top-level nodes here",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The accessible tree for the action output of this action is:",
      "zh-CHS": "此操作的操作输出的可访问树为："
    },
    {
      "indent": 5,
      "text": "<a xmlns=\"urn:example:a\">\n  <b>\n    <id>1</id>\n    <reset>\n      <result>ok</result>\n    </reset>\n  </b>\n  <b>\n    <id>2</id>\n  </b>\n</a>\n// possibly other top-level nodes here",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The accessible tree for a notification \"failure\" could be:",
      "zh-CHS": "通知“失败”的可访问树可以是："
    },
    {
      "indent": 5,
      "text": "<a xmlns=\"urn:example:a\">\n  <b>\n    <id>1</id>\n  </b>\n  <b>\n    <id>2</id>\n  </b>\n</a>\n<failure>\n  <b-ref>2</b-ref>\n</failure>\n// possibly other top-level nodes here",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "6.5. Schema Node Identifier",
      "section_title": true,
      "zh-CHS": "6.5. 模式节点标识符"
    },
    {
      "indent": 3,
      "text": "A schema node identifier is a string that identifies a node in the schema tree. It has two forms, \"absolute\" and \"descendant\", defined by the rules \"absolute-schema-nodeid\" and \"descendant-schema-nodeid\" in Section 14, respectively. A schema node identifier consists of a path of identifiers, separated by slashes (\"/\"). In an absolute schema node identifier, the first identifier after the leading slash is any top-level schema node in the local module or in an imported module.",
      "zh-CHS": "架构节点标识符是标识架构树中节点的字符串。它有两种形式，“绝对”和“后代”，分别由第14节中的规则“绝对模式节点ID”和“后代模式节点ID”定义。架构节点标识符由标识符路径组成，由斜杠（“/”）分隔。在绝对模式节点标识符中，前导斜杠后的第一个标识符是本地模块或导入模块中的任何顶级模式节点。"
    },
    {
      "indent": 3,
      "text": "References to identifiers defined in external modules MUST be qualified with appropriate prefixes, and references to identifiers defined in the current module and its submodules MAY use a prefix.",
      "zh-CHS": "对外部模块中定义的标识符的引用必须使用适当的前缀进行限定，对当前模块及其子模块中定义的标识符的引用可以使用前缀。"
    },
    {
      "indent": 3,
      "text": "For example, to identify the child node \"b\" of top-level node \"a\", the string \"/a/b\" can be used.",
      "zh-CHS": "例如，要标识顶级节点“a”的子节点“b”，可以使用字符串“/a/b”。"
    },
    {
      "indent": 0,
      "text": "7. YANG Statements",
      "section_title": true,
      "zh-CHS": "7. 杨声明"
    },
    {
      "indent": 3,
      "text": "The following sections describe all of the YANG statements.",
      "zh-CHS": "以下各节描述了所有杨陈述。"
    },
    {
      "indent": 3,
      "text": "Note that even a statement that does not have any substatements defined in YANG can have vendor-specific extensions as substatements. For example, the \"description\" statement does not have any substatements defined in YANG, but the following is legal:",
      "zh-CHS": "请注意，即使没有在YANG中定义任何子状态的语句也可以将特定于供应商的扩展作为子状态。例如，“description”语句在YANG中没有定义任何子语句，但以下语句是合法的："
    },
    {
      "indent": 5,
      "text": "description \"Some text.\" {\n  ex:documentation-flag 5;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.1. The \"module\" Statement",
      "section_title": true,
      "zh-CHS": "7.1. “模块”语句"
    },
    {
      "indent": 3,
      "text": "The \"module\" statement defines the module's name and groups all statements that belong to the module together. The \"module\" statement's argument is the name of the module, followed by a block of substatements that holds detailed module information. The module name is an identifier (see Section 6.2).",
      "zh-CHS": "“module”语句定义模块的名称，并将属于该模块的所有语句分组在一起。“module”语句的参数是模块的名称，后跟一个包含详细模块信息的子语句块。模块名称是一个标识符（见第6.2节）。"
    },
    {
      "indent": 3,
      "text": "Names of modules published in RFC streams [RFC4844] MUST be assigned by IANA; see Section 14 in [RFC6020].",
      "zh-CHS": "在RFC流[RFC4844]中发布的模块名称必须由IANA分配；参见[RFC6020]中的第14节。"
    },
    {
      "indent": 3,
      "text": "Private module names are assigned by the organization owning the module without a central registry. See Section 5.1 for recommendations on how to name modules.",
      "zh-CHS": "私有模块名称由拥有该模块的组织分配，而无需中央注册表。有关如何命名模块的建议，请参见第5.1节。"
    },
    {
      "indent": 3,
      "text": "A module typically has the following layout:",
      "zh-CHS": "模块通常具有以下布局："
    },
    {
      "indent": 5,
      "text": "module <module-name> {",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "// header information\n<yang-version statement>\n<namespace statement>\n<prefix statement>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "// linkage statements\n<import statements>\n<include statements>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "// meta-information\n<organization statement>\n<contact statement>\n<description statement>\n<reference statement>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "// revision history\n<revision statements>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "  // module definitions\n  <other statements>\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.1.1. The module's Substatements",
      "section_title": true,
      "zh-CHS": "7.1.1. 模块的子状态"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| anydata      | 7.10    | 0..n        |\n| anyxml       | 7.11    | 0..n        |\n| augment      | 7.17    | 0..n        |\n| choice       | 7.9     | 0..n        |\n| contact      | 7.1.8   | 0..1        |\n| container    | 7.5     | 0..n        |\n| description  | 7.21.3  | 0..1        |\n| deviation    | 7.20.3  | 0..n        |\n| extension    | 7.19    | 0..n        |\n| feature      | 7.20.1  | 0..n        |\n| grouping     | 7.12    | 0..n        |\n| identity     | 7.18    | 0..n        |\n| import       | 7.1.5   | 0..n        |\n| include      | 7.1.6   | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| namespace    | 7.1.3   | 1           |\n| notification | 7.16    | 0..n        |\n| organization | 7.1.7   | 0..1        |\n| prefix       | 7.1.4   | 1           |\n| reference    | 7.21.4  | 0..1        |\n| revision     | 7.1.9   | 0..n        |\n| rpc          | 7.14    | 0..n        |\n| typedef      | 7.3     | 0..n        |\n| uses         | 7.13    | 0..n        |\n| yang-version | 7.1.2   | 1           |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.1.2. The \"yang-version\" Statement",
      "section_title": true,
      "zh-CHS": "7.1.2. “杨版”声明"
    },
    {
      "indent": 3,
      "text": "The \"yang-version\" statement specifies which version of the YANG language was used in developing the module. The statement's argument is a string. It MUST contain the value \"1.1\" for YANG modules defined based on this specification.",
      "zh-CHS": "“yang version”语句指定在开发模块时使用的yang语言版本。语句的参数是字符串。它必须包含根据本规范定义的模块的值“1.1”。"
    },
    {
      "indent": 3,
      "text": "A module or submodule that doesn't contain the \"yang-version\" statement, or one that contains the value \"1\", is developed for YANG version 1, defined in [RFC6020].",
      "zh-CHS": "不包含“yang version”语句或包含值“1”的模块或子模块是为[RFC6020]中定义的yang version 1开发的。"
    },
    {
      "indent": 3,
      "text": "Handling of the \"yang-version\" statement for versions other than \"1.1\" (the version defined here) is out of scope for this specification. Any document that defines a higher version will need to define the backward compatibility of such a higher version.",
      "zh-CHS": "对于“1.1”以外的版本（此处定义的版本）处理“yang version”语句超出了本规范的范围。任何定义更高版本的文档都需要定义这样一个更高版本的向后兼容性。"
    },
    {
      "indent": 3,
      "text": "For compatibility between YANG versions 1 and 1.1, see Section 12.",
      "zh-CHS": "有关版本1和1.1之间的兼容性，请参见第12节。"
    },
    {
      "indent": 0,
      "text": "7.1.3. The \"namespace\" Statement",
      "section_title": true,
      "zh-CHS": "7.1.3. “namespace”语句"
    },
    {
      "indent": 3,
      "text": "The \"namespace\" statement defines the XML namespace that all identifiers defined by the module are qualified by in the XML encoding, with the exception of identifiers for data nodes, action nodes, and notification nodes defined inside a grouping (see Section 7.13 for details). The argument to the \"namespace\" statement is the URI of the namespace.",
      "zh-CHS": "“namespace”语句定义了XML名称空间，模块定义的所有标识符在XML编码中都由该名称空间限定，但分组中定义的数据节点、操作节点和通知节点的标识符除外（有关详细信息，请参阅第7.13节）。“namespace”语句的参数是名称空间的URI。"
    },
    {
      "indent": 3,
      "text": "See also Section 5.3.",
      "zh-CHS": "另见第5.3节。"
    },
    {
      "indent": 0,
      "text": "7.1.4. The \"prefix\" Statement",
      "section_title": true,
      "zh-CHS": "7.1.4. “前缀”语句"
    },
    {
      "indent": 3,
      "text": "The \"prefix\" statement is used to define the prefix associated with the module and its namespace. The \"prefix\" statement's argument is the prefix string that is used as a prefix to access a module. The prefix string MAY be used with the module to refer to definitions contained in the module, e.g., \"if:ifName\". A prefix is an identifier (see Section 6.2).",
      "zh-CHS": "“prefix”语句用于定义与模块及其命名空间关联的前缀。“prefix”语句的参数是用作访问模块前缀的前缀字符串。前缀字符串可与模块一起使用，以引用模块中包含的定义，例如，“if:ifName”。前缀是一种标识符（见第6.2节）。"
    },
    {
      "indent": 3,
      "text": "When used inside the \"module\" statement, the \"prefix\" statement defines the prefix suggested to be used when this module is imported.",
      "zh-CHS": "在“module”语句中使用时，“prefix”语句定义导入此模块时建议使用的前缀。"
    },
    {
      "indent": 3,
      "text": "To improve readability of the NETCONF XML, a NETCONF client or server that generates XML or XPath that uses prefixes SHOULD use the prefix defined by the module as the XML namespace prefix, unless there is a conflict.",
      "zh-CHS": "为提高NETCONF XML的可读性，生成使用前缀的XML或XPath的NETCONF客户端或服务器应使用模块定义的前缀作为XML命名空间前缀，除非存在冲突。"
    },
    {
      "indent": 3,
      "text": "When used inside the \"import\" statement, the \"prefix\" statement defines the prefix to be used when accessing definitions inside the imported module. When a reference to an identifier from the imported module is used, the prefix string for the imported module followed by a colon (\":\") and the identifier is used, e.g., \"if:ifIndex\". To improve readability of YANG modules, the prefix defined by a module SHOULD be used when the module is imported, unless there is a conflict. If there is a conflict, i.e., two different modules that both have defined the same prefix are imported, at least one of them MUST be imported with a different prefix.",
      "zh-CHS": "在“import”语句中使用时，“prefix”语句定义访问导入模块中的定义时要使用的前缀。使用对导入模块标识符的引用时，将使用导入模块的前缀字符串，后跟冒号（“：”）和标识符，例如“if:ifIndex”。为提高模块的可读性，导入模块时应使用模块定义的前缀，除非存在冲突。如果存在冲突，即导入两个定义了相同前缀的不同模块，则必须使用不同前缀导入其中至少一个模块。"
    },
    {
      "indent": 3,
      "text": "All prefixes, including the prefix for the module itself, MUST be unique within the module or submodule.",
      "zh-CHS": "所有前缀（包括模块本身的前缀）在模块或子模块中必须是唯一的。"
    },
    {
      "indent": 0,
      "text": "7.1.5. The \"import\" Statement",
      "section_title": true,
      "zh-CHS": "7.1.5. “进口”声明"
    },
    {
      "indent": 3,
      "text": "The \"import\" statement makes definitions from one module available inside another module or submodule. The argument is the name of the module to import, and the statement is followed by a block of substatements that holds detailed import information. When a module is imported, the importing module may:",
      "zh-CHS": "“import”语句使一个模块中的定义在另一个模块或子模块中可用。参数是要导入的模块的名称，语句后面是一个包含详细导入信息的子语句块。导入模块时，导入模块可以："
    },
    {
      "indent": 3,
      "text": "o use any grouping and typedef defined at the top level in the imported module or its submodules.",
      "zh-CHS": "o 使用在导入的模块或其子模块的顶层定义的任何分组和typedef。"
    },
    {
      "indent": 3,
      "text": "o use any extension, feature, and identity defined in the imported module or its submodules.",
      "zh-CHS": "o 使用导入的模块或其子模块中定义的任何扩展、功能和标识。"
    },
    {
      "indent": 3,
      "text": "o use any node in the imported module's schema tree in \"must\", \"path\", and \"when\" statements, or as the target node in \"augment\" and \"deviation\" statements.",
      "zh-CHS": "o 在“must”、“path”和“when”语句中使用导入模块模式树中的任何节点，或者在“augment”和“develope”语句中作为目标节点。"
    },
    {
      "indent": 3,
      "text": "The mandatory \"prefix\" substatement assigns a prefix for the imported module that is scoped to the importing module or submodule. Multiple \"import\" statements may be specified to import from different modules.",
      "zh-CHS": "必填的“prefix”子语句为导入的模块分配一个前缀，其作用域为导入模块或子模块。可以指定多个“导入”语句从不同的模块导入。"
    },
    {
      "indent": 3,
      "text": "When the optional \"revision-date\" substatement is present, any typedef, grouping, extension, feature, and identity referenced by definitions in the local module are taken from the specified revision of the imported module. It is an error if the specified revision of the imported module does not exist. If no \"revision-date\" substatement is present, it is undefined from which revision of the module they are taken.",
      "zh-CHS": "当存在可选的“修订日期”子状态时，本地模块中定义引用的任何类型定义、分组、扩展、特征和标识都将取自导入模块的指定版本。如果导入模块的指定版本不存在，则为错误。如果不存在“修订日期”子语句，则未定义从哪个版本获取这些子语句的模块。"
    },
    {
      "indent": 3,
      "text": "Multiple revisions of the same module can be imported, provided that different prefixes are used.",
      "zh-CHS": "如果使用不同的前缀，可以导入同一模块的多个版本。"
    },
    {
      "indent": 17,
      "text": "+---------------+---------+-------------+\n| substatement  | section | cardinality |\n+---------------+---------+-------------+\n| description   | 7.21.3  | 0..1        |\n| prefix        | 7.1.4   | 1           |\n| reference     | 7.21.4  | 0..1        |\n| revision-date | 7.1.5.1 | 0..1        |\n+---------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 24,
      "text": "The import's Substatements",
      "zh-CHS": "导入的子语句"
    },
    {
      "indent": 0,
      "text": "7.1.5.1. The import's \"revision-date\" Statement",
      "section_title": true,
      "zh-CHS": "7.1.5.1. 进口的“修订日期”声明"
    },
    {
      "indent": 3,
      "text": "The import's \"revision-date\" statement is used to specify the version of the module to import.",
      "zh-CHS": "导入的“修订日期”语句用于指定要导入的模块的版本。"
    },
    {
      "indent": 0,
      "text": "7.1.6. The \"include\" Statement",
      "section_title": true,
      "zh-CHS": "7.1.6. “包括”声明"
    },
    {
      "indent": 3,
      "text": "The \"include\" statement is used to make content from a submodule available to that submodule's parent module. The argument is an identifier that is the name of the submodule to include. Modules are only allowed to include submodules that belong to that module, as defined by the \"belongs-to\" statement (see Section 7.2.2).",
      "zh-CHS": "“include”语句用于将子模块中的内容提供给该子模块的父模块。参数是一个标识符，它是要包含的子模块的名称。模块仅允许包含属于该模块的子模块，如“属于”语句所定义（见第7.2.2节）。"
    },
    {
      "indent": 3,
      "text": "When a module includes a submodule, it incorporates the contents of the submodule into the node hierarchy of the module.",
      "zh-CHS": "当模块包含子模块时，它会将子模块的内容合并到模块的节点层次结构中。"
    },
    {
      "indent": 3,
      "text": "For backward compatibility with YANG version 1, a submodule is allowed to include another submodule belonging to the same module, but this is not necessary in YANG version 1.1 (see Section 5.1).",
      "zh-CHS": "为了与YANG版本1向后兼容，允许子模块包含属于同一模块的另一个子模块，但在YANG版本1.1中不需要这样做（参见第5.1节）。"
    },
    {
      "indent": 3,
      "text": "When the optional \"revision-date\" substatement is present, the specified revision of the submodule is included in the module. It is an error if the specified revision of the submodule does not exist. If no \"revision-date\" substatement is present, it is undefined which revision of the submodule is included.",
      "zh-CHS": "当存在可选的“修订日期”子状态时，子模块的指定修订将包含在模块中。如果子模块的指定版本不存在，则为错误。如果不存在“修订日期”子语句，则未定义包含子模块的哪个修订。"
    },
    {
      "indent": 3,
      "text": "Multiple revisions of the same submodule MUST NOT be included.",
      "zh-CHS": "不得包含同一子模块的多个修订版。"
    },
    {
      "indent": 17,
      "text": "+---------------+---------+-------------+\n| substatement  | section | cardinality |\n+---------------+---------+-------------+\n| description   | 7.21.3  | 0..1        |\n| reference     | 7.21.4  | 0..1        |\n| revision-date | 7.1.5.1 | 0..1        |\n+---------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 23,
      "text": "The includes's Substatements",
      "zh-CHS": "包含的子语句"
    },
    {
      "indent": 0,
      "text": "7.1.7. The \"organization\" Statement",
      "section_title": true,
      "zh-CHS": "7.1.7. “组织”声明"
    },
    {
      "indent": 3,
      "text": "The \"organization\" statement defines the party responsible for this module. The argument is a string that is used to specify a textual description of the organization(s) under whose auspices this module was developed.",
      "zh-CHS": "“组织”声明定义了负责此模块的一方。参数是一个字符串，用于指定在其主持下开发此模块的组织的文本描述。"
    },
    {
      "indent": 0,
      "text": "7.1.8. The \"contact\" Statement",
      "section_title": true,
      "zh-CHS": "7.1.8. “接触”声明"
    },
    {
      "indent": 3,
      "text": "The \"contact\" statement provides contact information for the module. The argument is a string that is used to specify contact information for the person or persons to whom technical queries concerning this module should be sent, such as their name, postal address, telephone number, and electronic mail address.",
      "zh-CHS": "“contact”语句提供模块的联系信息。参数是一个字符串，用于指定应向其发送有关此模块的技术查询的人员的联系信息，如姓名、邮政地址、电话号码和电子邮件地址。"
    },
    {
      "indent": 0,
      "text": "7.1.9. The \"revision\" Statement",
      "section_title": true,
      "zh-CHS": "7.1.9. “修订”声明"
    },
    {
      "indent": 3,
      "text": "The \"revision\" statement specifies the editorial revision history of the module, including the initial revision. A series of \"revision\" statements detail the changes in the module's definition. The argument is a date string in the format \"YYYY-MM-DD\", followed by a block of substatements that holds detailed revision information. A module SHOULD have at least one \"revision\" statement. For every published editorial change, a new one SHOULD be added in front of the revisions sequence so that all revisions are in reverse chronological order.",
      "zh-CHS": "“修订”语句指定模块的编辑修订历史记录，包括初始修订。一系列“修订”声明详细说明了模块定义中的更改。参数是格式为“YYYY-MM-DD”的日期字符串，后跟一块保存详细修订信息的子状态。一个模块应该至少有一个“修订”语句。对于每个已发布的编辑更改，应在修订顺序之前添加一个新的修订，以便所有修订都按相反的时间顺序进行。"
    },
    {
      "indent": 0,
      "text": "7.1.9.1. The revision's Substatements",
      "section_title": true,
      "zh-CHS": "7.1.9.1. 修订版的子条款"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| description  | 7.21.3  | 0..1        |\n| reference    | 7.21.4  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.1.10. Usage Example",
      "section_title": true,
      "zh-CHS": "7.1.10. 用法示例"
    },
    {
      "indent": 3,
      "text": "The following example relies on [RFC6991].",
      "zh-CHS": "以下示例依赖于[RFC6991]。"
    },
    {
      "indent": 5,
      "text": "module example-system {\n  yang-version 1.1;\n  namespace \"urn:example:system\";\n  prefix \"sys\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "import ietf-yang-types {\n  prefix \"yang\";\n  reference \"RFC 6991: Common YANG Data Types\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "include example-types;",
      "zh-CHS": "包括示例类型；"
    },
    {
      "indent": 7,
      "text": "organization \"Example Inc.\"; contact \"Joe L. User",
      "zh-CHS": "组织“范例公司”；联系“Joe L.用户”"
    },
    {
      "indent": 10,
      "text": "Example Inc. 42 Anywhere Drive Nowhere, CA 95134 USA",
      "zh-CHS": "示例公司42 Anywhere Drive Nowhere，加利福尼亚州95134美国"
    },
    {
      "indent": 10,
      "text": "Phone: +1 800 555 0100\nEmail: joe@example.com\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "description \"The module for entities implementing the Example system.\";",
      "zh-CHS": "说明“实施示例系统的实体模块”；"
    },
    {
      "indent": 7,
      "text": "revision 2007-06-09 {\n  description \"Initial revision.\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": " // definitions follow... }",
      "zh-CHS": "//定义如下…}"
    },
    {
      "indent": 0,
      "text": "7.2. The \"submodule\" Statement",
      "section_title": true,
      "zh-CHS": "7.2. “submodule”语句"
    },
    {
      "indent": 3,
      "text": "While the primary unit in YANG is a module, a YANG module can itself be constructed out of several submodules. Submodules allow a module designer to split a complex model into several pieces where all the submodules contribute to a single namespace, which is defined by the module that includes the submodules.",
      "zh-CHS": "虽然YANG中的主要单元是一个模块，但YANG模块本身可以由几个子模块构成。子模块允许模块设计器将复杂模型拆分为多个部分，其中所有子模块都贡献给单个名称空间，该名称空间由包含子模块的模块定义。"
    },
    {
      "indent": 3,
      "text": "The \"submodule\" statement defines the submodule's name, and it groups all statements that belong to the submodule together. The \"submodule\" statement's argument is the name of the submodule, followed by a block of substatements that holds detailed submodule information. The submodule name is an identifier (see Section 6.2).",
      "zh-CHS": "“submodule”语句定义子模块的名称，并将属于该子模块的所有语句分组在一起。“submodule”语句的参数是子模块的名称，后跟一个包含详细子模块信息的子语句块。子模块名称是一个标识符（见第6.2节）。"
    },
    {
      "indent": 3,
      "text": "Names of submodules published in RFC streams [RFC4844] MUST be assigned by IANA; see Section 14 in [RFC6020].",
      "zh-CHS": "在RFC streams[RFC4844]中发布的子模块名称必须由IANA分配；参见[RFC6020]中的第14节。"
    },
    {
      "indent": 3,
      "text": "Private submodule names are assigned by the organization owning the submodule without a central registry. See Section 5.1 for recommendations on how to name submodules.",
      "zh-CHS": "私有子模块名称由拥有该子模块的组织分配，而无需中央注册表。有关如何命名子模块的建议，请参见第5.1节。"
    },
    {
      "indent": 3,
      "text": "A submodule typically has the following layout:",
      "zh-CHS": "子模块通常具有以下布局："
    },
    {
      "indent": 5,
      "text": "submodule <module-name> {",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "<yang-version statement>",
      "zh-CHS": "<yang版本声明>"
    },
    {
      "indent": 7,
      "text": "// module identification\n<belongs-to statement>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "// linkage statements\n<import statements>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "// meta-information\n<organization statement>\n<contact statement>\n<description statement>\n<reference statement>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "// revision history\n<revision statements>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "  // module definitions\n  <other statements>\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.2.1. The submodule's Substatements",
      "section_title": true,
      "zh-CHS": "7.2.1. 子模块的子状态"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| anydata      | 7.10    | 0..n        |\n| anyxml       | 7.11    | 0..n        |\n| augment      | 7.17    | 0..n        |\n| belongs-to   | 7.2.2   | 1           |\n| choice       | 7.9     | 0..n        |\n| contact      | 7.1.8   | 0..1        |\n| container    | 7.5     | 0..n        |\n| description  | 7.21.3  | 0..1        |\n| deviation    | 7.20.3  | 0..n        |\n| extension    | 7.19    | 0..n        |\n| feature      | 7.20.1  | 0..n        |\n| grouping     | 7.12    | 0..n        |\n| identity     | 7.18    | 0..n        |\n| import       | 7.1.5   | 0..n        |\n| include      | 7.1.6   | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| notification | 7.16    | 0..n        |\n| organization | 7.1.7   | 0..1        |\n| reference    | 7.21.4  | 0..1        |\n| revision     | 7.1.9   | 0..n        |\n| rpc          | 7.14    | 0..n        |\n| typedef      | 7.3     | 0..n        |\n| uses         | 7.13    | 0..n        |\n| yang-version | 7.1.2   | 1           |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.2.2. The \"belongs-to\" Statement",
      "section_title": true,
      "zh-CHS": "7.2.2. “属于”声明"
    },
    {
      "indent": 3,
      "text": "The \"belongs-to\" statement specifies the module to which the submodule belongs. The argument is an identifier that is the name of the module.",
      "zh-CHS": "“属于”语句指定子模块所属的模块。参数是一个标识符，它是模块的名称。"
    },
    {
      "indent": 3,
      "text": "A submodule MUST only be included by either the module to which it belongs or another submodule that belongs to that module.",
      "zh-CHS": "子模块只能由其所属的模块或属于该模块的另一个子模块包含。"
    },
    {
      "indent": 3,
      "text": "The mandatory \"prefix\" substatement assigns a prefix for the module to which the submodule belongs. All definitions in the module that the submodule belongs to and all its submodules can be accessed by using the prefix.",
      "zh-CHS": "强制性的“prefix”子语句为子模块所属的模块指定前缀。子模块所属模块及其所有子模块中的所有定义都可以使用前缀进行访问。"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| prefix       | 7.1.4   | 1           |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 23,
      "text": "The belongs-to's Substatement",
      "zh-CHS": "该函数属于的子状态"
    },
    {
      "indent": 0,
      "text": "7.2.3. Usage Example",
      "section_title": true,
      "zh-CHS": "7.2.3. 用法示例"
    },
    {
      "indent": 5,
      "text": "submodule example-types {\n  yang-version 1.1;\n  belongs-to \"example-system\" {\n    prefix \"sys\";\n  }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "import ietf-yang-types {\n  prefix \"yang\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "organization \"Example Inc.\"; contact \"Joe L. User",
      "zh-CHS": "组织“范例公司”；联系“Joe L.用户”"
    },
    {
      "indent": 10,
      "text": "Example Inc. 42 Anywhere Drive Nowhere, CA 95134 USA",
      "zh-CHS": "示例公司42 Anywhere Drive Nowhere，加利福尼亚州95134美国"
    },
    {
      "indent": 10,
      "text": "Phone: +1 800 555 0100\nEmail: joe@example.com\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "description \"This submodule defines common Example types.\";",
      "zh-CHS": "description“此子模块定义常见的示例类型。”；"
    },
    {
      "indent": 7,
      "text": "revision \"2007-06-09\" {\n  description \"Initial revision.\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": " // definitions follow... }",
      "zh-CHS": "//定义如下…}"
    },
    {
      "indent": 0,
      "text": "7.3. The \"typedef\" Statement",
      "section_title": true,
      "zh-CHS": "7.3. “typedef”语句"
    },
    {
      "indent": 3,
      "text": "The \"typedef\" statement defines a new type that may be used locally in the module or submodule, and by other modules that import from it, according to the rules in Section 5.5. The new type is called the \"derived type\", and the type from which it was derived is called the \"base type\". All derived types can be traced back to a YANG built-in type.",
      "zh-CHS": "根据第5.5节中的规则，“typedef”语句定义了一个新类型，该类型可以在模块或子模块中本地使用，也可以由从中导入的其他模块使用。新类型称为“派生类型”，派生它的类型称为“基类型”。所有派生类型都可以追溯到内置类型。"
    },
    {
      "indent": 3,
      "text": "The \"typedef\" statement's argument is an identifier that is the name of the type to be defined and MUST be followed by a block of substatements that holds detailed typedef information.",
      "zh-CHS": "“typedef”语句的参数是一个标识符，它是要定义的类型的名称，后面必须跟一个包含详细typedef信息的子语句块。"
    },
    {
      "indent": 3,
      "text": "The name of the type MUST NOT be one of the YANG built-in types. If the typedef is defined at the top level of a YANG module or submodule, the name of the type to be defined MUST be unique within the module.",
      "zh-CHS": "类型的名称不能是内置类型之一。如果typedef是在模块或子模块的顶层定义的，则要定义的类型名称在模块中必须是唯一的。"
    },
    {
      "indent": 0,
      "text": "7.3.1. The typedef's Substatements",
      "section_title": true,
      "zh-CHS": "7.3.1. typedef的子状态"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| default      | 7.3.4   | 0..1        |\n| description  | 7.21.3  | 0..1        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| type         | 7.3.2   | 1           |\n| units        | 7.3.3   | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.3.2. The typedef's \"type\" Statement",
      "section_title": true,
      "zh-CHS": "7.3.2. typedef的“type”语句"
    },
    {
      "indent": 3,
      "text": "The \"type\" statement, which MUST be present, defines the base type from which this type is derived. See Section 7.4 for details.",
      "zh-CHS": "必须存在的“type”语句定义了派生此类型的基类型。详见第7.4节。"
    },
    {
      "indent": 0,
      "text": "7.3.3. The \"units\" Statement",
      "section_title": true,
      "zh-CHS": "7.3.3. “单位”声明"
    },
    {
      "indent": 3,
      "text": "The \"units\" statement, which is optional, takes as an argument a string that contains a textual definition of the units associated with the type.",
      "zh-CHS": "“units”语句是可选的，它将包含与类型关联的单元的文本定义的字符串作为参数。"
    },
    {
      "indent": 0,
      "text": "7.3.4. The typedef's \"default\" Statement",
      "section_title": true,
      "zh-CHS": "7.3.4. typedef的“default”语句"
    },
    {
      "indent": 3,
      "text": "The \"default\" statement takes as an argument a string that contains a default value for the new type.",
      "zh-CHS": "“default”语句将包含新类型的默认值的字符串作为参数。"
    },
    {
      "indent": 3,
      "text": "The value of the \"default\" statement MUST be valid according to the type specified in the \"type\" statement.",
      "zh-CHS": "根据“type”语句中指定的类型，“default”语句的值必须有效。"
    },
    {
      "indent": 3,
      "text": "If the base type has a default value and the new derived type does not specify a new default value, the base type's default value is also the default value of the new derived type.",
      "zh-CHS": "如果基类型具有默认值，而新派生类型未指定新的默认值，则基类型的默认值也是新派生类型的默认值。"
    },
    {
      "indent": 3,
      "text": "If the type's default value is not valid according to the new restrictions specified in a derived type or leaf definition, the derived type or leaf definition MUST specify a new default value compatible with the restrictions.",
      "zh-CHS": "如果根据派生类型或叶定义中指定的新限制，类型的默认值无效，则派生类型或叶定义必须指定与这些限制兼容的新默认值。"
    },
    {
      "indent": 0,
      "text": "7.3.5. Usage Example",
      "section_title": true,
      "zh-CHS": "7.3.5. 用法示例"
    },
    {
      "indent": 5,
      "text": "typedef listen-ipv4-address {\n  type inet:ipv4-address;\n  default \"0.0.0.0\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.4. The \"type\" Statement",
      "section_title": true,
      "zh-CHS": "7.4. “类型”语句"
    },
    {
      "indent": 3,
      "text": "The \"type\" statement takes as an argument a string that is the name of a YANG built-in type (see Section 9) or a derived type (see Section 7.3), followed by an optional block of substatements that is used to put further restrictions on the type.",
      "zh-CHS": "“type”语句将一个字符串作为参数，该字符串是内置类型（见第9节）或派生类型（见第7.3节）的名称，后跟一个可选的子语句块，用于对该类型施加进一步的限制。"
    },
    {
      "indent": 3,
      "text": "The restrictions that can be applied depend on the type being restricted. The restriction statements for all built-in types are described in the subsections of Section 9.",
      "zh-CHS": "可以应用的限制取决于被限制的类型。所有内置类型的限制说明见第9节的小节。"
    },
    {
      "indent": 0,
      "text": "7.4.1. The type's Substatements",
      "section_title": true,
      "zh-CHS": "7.4.1. 类型的子状态"
    },
    {
      "indent": 15,
      "text": "+------------------+---------+-------------+\n| substatement     | section | cardinality |\n+------------------+---------+-------------+\n| base             | 7.18.2  | 0..n        |\n| bit              | 9.7.4   | 0..n        |\n| enum             | 9.6.4   | 0..n        |\n| fraction-digits  | 9.3.4   | 0..1        |\n| length           | 9.4.4   | 0..1        |\n| path             | 9.9.2   | 0..1        |\n| pattern          | 9.4.5   | 0..n        |\n| range            | 9.2.4   | 0..1        |\n| require-instance | 9.9.3   | 0..1        |\n| type             | 7.4     | 0..n        |\n+------------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.5. The \"container\" Statement",
      "section_title": true,
      "zh-CHS": "7.5. “容器”语句"
    },
    {
      "indent": 3,
      "text": "The \"container\" statement is used to define an interior data node in the schema tree. It takes one argument, which is an identifier, followed by a block of substatements that holds detailed container information.",
      "zh-CHS": "“container”语句用于定义模式树中的内部数据节点。它有一个参数，它是一个标识符，后跟一个包含详细容器信息的子语句块。"
    },
    {
      "indent": 3,
      "text": "A container node does not have a value, but it has a list of child nodes in the data tree. The child nodes are defined in the container's substatements.",
      "zh-CHS": "容器节点没有值，但在数据树中有子节点列表。子节点在容器的子状态中定义。"
    },
    {
      "indent": 0,
      "text": "7.5.1. Containers with Presence",
      "section_title": true,
      "zh-CHS": "7.5.1. 存在的容器"
    },
    {
      "indent": 3,
      "text": "YANG supports two styles of containers, those that exist only for organizing the hierarchy of data nodes and those whose presence in the data tree has an explicit meaning.",
      "zh-CHS": "YANG支持两种类型的容器，一种是仅用于组织数据节点层次结构的容器，另一种是在数据树中具有明确含义的容器。"
    },
    {
      "indent": 3,
      "text": "In the first style, the container has no meaning of its own, existing only to contain child nodes. In particular, the presence of the container node with no child nodes is semantically equivalent to the absence of the container node. YANG calls this style a \"non-presence container\". This is the default style.",
      "zh-CHS": "在第一种样式中，容器本身没有意义，只存在于包含子节点的地方。特别是，没有子节点的容器节点的存在在语义上等同于没有容器节点。杨称这种风格为“不存在的容器”。这是默认样式。"
    },
    {
      "indent": 3,
      "text": "For example, the set of scrambling options for Synchronous Optical Network (SONET) interfaces may be placed inside a \"scrambling\" container to enhance the organization of the configuration hierarchy and to keep these nodes together. The \"scrambling\" node itself has no meaning, so removing the node when it becomes empty relieves the user from performing this task.",
      "zh-CHS": "例如，用于同步光网络（SONET）接口的一组加扰选项可放置在“加扰”容器内，以增强配置层次结构的组织并将这些节点保持在一起。“加扰”节点本身没有任何意义，因此在节点变空时移除节点可以免除用户执行此任务。"
    },
    {
      "indent": 3,
      "text": "In the second style, the presence of the container itself carries some meaning, representing a single bit of data.",
      "zh-CHS": "在第二种样式中，容器本身的存在具有某种意义，表示单个数据位。"
    },
    {
      "indent": 3,
      "text": "For configuration data, the container acts as both a configuration knob and a means of organizing related configuration nodes. These containers are explicitly created and deleted.",
      "zh-CHS": "对于配置数据，容器充当配置旋钮和组织相关配置节点的手段。这些容器是显式创建和删除的。"
    },
    {
      "indent": 3,
      "text": "YANG calls this style a \"presence container\", and it is indicated using the \"presence\" statement, which takes as its argument a text string indicating what the presence of the node means.",
      "zh-CHS": "YANG将这种样式称为“状态容器”，并使用“状态”语句表示，该语句将一个文本字符串作为其参数，指示节点的存在意味着什么。"
    },
    {
      "indent": 3,
      "text": "For example, an \"ssh\" container may turn on the ability to log into the server using Secure SHell (SSH) but can also contain any SSH-related configuration knobs, such as connection rates or retry limits.",
      "zh-CHS": "例如，“ssh”容器可以启用使用Secure SHell（ssh）登录服务器的功能，但也可以包含任何与ssh相关的配置旋钮，例如连接速率或重试限制。"
    },
    {
      "indent": 3,
      "text": "The \"presence\" statement (see Section 7.5.5) is used to give semantics to the existence of the container in the data tree.",
      "zh-CHS": "“presence”语句（见第7.5.5节）用于为数据树中容器的存在提供语义。"
    },
    {
      "indent": 0,
      "text": "7.5.2. The container's Substatements",
      "section_title": true,
      "zh-CHS": "7.5.2. 容器的子状态"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| action       | 7.15    | 0..n        |\n| anydata      | 7.10    | 0..n        |\n| anyxml       | 7.11    | 0..n        |\n| choice       | 7.9     | 0..n        |\n| config       | 7.21.1  | 0..1        |\n| container    | 7.5     | 0..n        |\n| description  | 7.21.3  | 0..1        |\n| grouping     | 7.12    | 0..n        |\n| if-feature   | 7.20.2  | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| must         | 7.5.3   | 0..n        |\n| notification | 7.16    | 0..n        |\n| presence     | 7.5.5   | 0..1        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| typedef      | 7.3     | 0..n        |\n| uses         | 7.13    | 0..n        |\n| when         | 7.21.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.5.3. The \"must\" Statement",
      "section_title": true,
      "zh-CHS": "7.5.3. “必须”声明"
    },
    {
      "indent": 3,
      "text": "The \"must\" statement, which is optional, takes as an argument a string that contains an XPath expression (see Section 6.4). It is used to formally declare a constraint on valid data. The constraint is enforced according to the rules in Section 8.",
      "zh-CHS": "“must”语句是可选的，它将包含XPath表达式的字符串作为参数（参见第6.4节）。它用于正式声明对有效数据的约束。根据第8节中的规则强制执行约束。"
    },
    {
      "indent": 3,
      "text": "When a datastore is validated, all \"must\" constraints are conceptually evaluated once for each node in the accessible tree (see Section 6.4.1).",
      "zh-CHS": "验证数据存储时，所有“必须”约束在概念上对可访问树中的每个节点评估一次（见第6.4.1节）。"
    },
    {
      "indent": 3,
      "text": "All such constraints MUST evaluate to \"true\" for the data to be valid.",
      "zh-CHS": "所有这些约束必须评估为“true”，数据才有效。"
    },
    {
      "indent": 3,
      "text": "The XPath expression is conceptually evaluated in the following context, in addition to the definition in Section 6.4.1:",
      "zh-CHS": "除了第6.4.1节中的定义外，XPath表达式在以下上下文中进行概念性评估："
    },
    {
      "indent": 3,
      "text": "o If the \"must\" statement is a substatement of a \"notification\" statement, the context node is the node representing the notification in the accessible tree.",
      "zh-CHS": "o 如果“必须”语句是“通知”语句的子语句，则上下文节点是可访问树中表示通知的节点。"
    },
    {
      "indent": 3,
      "text": "o If the \"must\" statement is a substatement of an \"input\" statement, the context node is the node representing the operation in the accessible tree.",
      "zh-CHS": "o 如果“必须”语句是“输入”语句的子语句，则上下文节点是表示可访问树中的操作的节点。"
    },
    {
      "indent": 3,
      "text": "o If the \"must\" statement is a substatement of an \"output\" statement, the context node is the node representing the operation in the accessible tree.",
      "zh-CHS": "o 如果“必须”语句是“输出”语句的子语句，则上下文节点是表示可访问树中的操作的节点。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, the context node is the node in the accessible tree for which the \"must\" statement is defined.",
      "zh-CHS": "o 否则，上下文节点是可访问树中定义了“必须”语句的节点。"
    },
    {
      "indent": 3,
      "text": "The result of the XPath expression is converted to a boolean value using the standard XPath rules.",
      "zh-CHS": "XPath表达式的结果使用标准XPath规则转换为布尔值。"
    },
    {
      "indent": 3,
      "text": "Note that since all leaf values in the data tree are conceptually stored in their canonical form (see Section 9.1), any XPath comparisons are done on the canonical value.",
      "zh-CHS": "请注意，由于数据树中的所有叶值在概念上都以其规范形式存储（请参见第9.1节），因此所有XPath比较都是在规范值上进行的。"
    },
    {
      "indent": 3,
      "text": "Also note that the XPath expression is conceptually evaluated. This means that an implementation does not have to use an XPath evaluator in the server. How the evaluation is done in practice is an implementation decision.",
      "zh-CHS": "还要注意，XPath表达式是在概念上计算的。这意味着实现不必在服务器中使用XPath计算器。如何在实践中进行评估是一项实施决策。"
    },
    {
      "indent": 0,
      "text": "7.5.4. The must's Substatements",
      "section_title": true,
      "zh-CHS": "7.5.4. 必须的子状态"
    },
    {
      "indent": 17,
      "text": "+---------------+---------+-------------+\n| substatement  | section | cardinality |\n+---------------+---------+-------------+\n| description   | 7.21.3  | 0..1        |\n| error-app-tag | 7.5.4.2 | 0..1        |\n| error-message | 7.5.4.1 | 0..1        |\n| reference     | 7.21.4  | 0..1        |\n+---------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.5.4.1. The \"error-message\" Statement",
      "section_title": true,
      "zh-CHS": "7.5.4.1. “错误消息”语句"
    },
    {
      "indent": 3,
      "text": "The \"error-message\" statement, which is optional, takes a string as an argument. If the constraint evaluates to \"false\", the string is passed as <error-message> in the <rpc-error> in NETCONF.",
      "zh-CHS": "“error message”语句是可选的，它将字符串作为参数。如果约束的计算结果为“false”，则在NETCONF的<rpc error>中，字符串作为<error message>传递。"
    },
    {
      "indent": 0,
      "text": "7.5.4.2. The \"error-app-tag\" Statement",
      "section_title": true,
      "zh-CHS": "7.5.4.2. “error-app-tag”语句"
    },
    {
      "indent": 3,
      "text": "The \"error-app-tag\" statement, which is optional, takes a string as an argument. If the constraint evaluates to \"false\", the string is passed as <error-app-tag> in the <rpc-error> in NETCONF.",
      "zh-CHS": "“error-app-tag”语句是可选的，它将字符串作为参数。如果约束的计算结果为“false”，则在NETCONF的<rpc error>中，字符串作为<error app tag>传递。"
    },
    {
      "indent": 0,
      "text": "7.5.4.3. Usage Example of must and error-message",
      "section_title": true,
      "zh-CHS": "7.5.4.3. must和错误消息的用法示例"
    },
    {
      "indent": 5,
      "text": "container interface {\n  leaf ifType {\n    type enumeration {\n      enum ethernet;\n      enum atm;\n    }\n  }\n  leaf ifMTU {\n    type uint32;\n  }\n  must 'ifType != \"ethernet\" or ifMTU = 1500' {\n    error-message \"An Ethernet MTU must be 1500\";\n  }\n  must 'ifType != \"atm\" or'\n     + ' (ifMTU <= 17966 and ifMTU >= 64)' {\n    error-message \"An ATM MTU must be 64 .. 17966\";\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.5.5. The \"presence\" Statement",
      "section_title": true,
      "zh-CHS": "7.5.5. “在场”声明"
    },
    {
      "indent": 3,
      "text": "The \"presence\" statement assigns a meaning to the presence of a container in the data tree. It takes as an argument a string that contains a textual description of what the node's presence means.",
      "zh-CHS": "“presence”语句为数据树中容器的存在赋予了意义。它接受一个字符串作为参数，该字符串包含节点存在的含义的文本描述。"
    },
    {
      "indent": 3,
      "text": "If a container has the \"presence\" statement, the container's existence in the data tree carries some meaning. Otherwise, the container is used to give some structure to the data, and it carries no meaning by itself.",
      "zh-CHS": "如果一个容器有“presence”语句，那么该容器在数据树中的存在就具有某种意义。否则，容器被用来为数据提供某种结构，它本身没有任何意义。"
    },
    {
      "indent": 3,
      "text": "See Section 7.5.1 for additional information.",
      "zh-CHS": "更多信息见第7.5.1节。"
    },
    {
      "indent": 0,
      "text": "7.5.6. The container's Child Node Statements",
      "section_title": true,
      "zh-CHS": "7.5.6. 容器的子节点语句"
    },
    {
      "indent": 3,
      "text": "Within a container, the \"container\", \"leaf\", \"list\", \"leaf-list\", \"uses\", \"choice\", \"anydata\", and \"anyxml\" statements can be used to define child nodes to the container.",
      "zh-CHS": "在容器中，“container”、“leaf”、“list”、“leaf list”、“uses”、“choice”、“anydata”和“anyxml”语句可用于定义容器的子节点。"
    },
    {
      "indent": 0,
      "text": "7.5.7. XML Encoding Rules",
      "section_title": true,
      "zh-CHS": "7.5.7. XML编码规则"
    },
    {
      "indent": 3,
      "text": "A container node is encoded as an XML element. The element's local name is the container's identifier, and its namespace is the module's XML namespace (see Section 7.1.3).",
      "zh-CHS": "容器节点编码为XML元素。元素的本地名称是容器的标识符，其名称空间是模块的XML名称空间（参见第7.1.3节）。"
    },
    {
      "indent": 3,
      "text": "The container's child nodes are encoded as subelements to the container element. If the container defines RPC or action input or output parameters, these subelements are encoded in the same order as they are defined within the \"container\" statement. Otherwise, the subelements are encoded in any order.",
      "zh-CHS": "容器的子节点被编码为容器元素的子元素。如果容器定义了RPC或操作输入或输出参数，则这些子元素的编码顺序与“container”语句中定义的顺序相同。否则，子元素按任意顺序编码。"
    },
    {
      "indent": 3,
      "text": "Any whitespace between the subelements to the container is insignificant, i.e., an implementation MAY insert whitespace characters between subelements.",
      "zh-CHS": "容器的子元素之间的任何空白都是无关紧要的，即，实现可以在子元素之间插入空白字符。"
    },
    {
      "indent": 3,
      "text": "If a non-presence container does not have any child nodes, the container may or may not be present in the XML encoding.",
      "zh-CHS": "如果不存在容器没有任何子节点，则该容器可能存在于XML编码中，也可能不存在于XML编码中。"
    },
    {
      "indent": 0,
      "text": "7.5.8. NETCONF <edit-config> Operations",
      "section_title": true,
      "zh-CHS": "7.5.8. NETCONF<edit config>操作"
    },
    {
      "indent": 3,
      "text": "Containers can be created, deleted, replaced, and modified through <edit-config> by using the \"operation\" attribute (see Section 7.2 in [RFC6241]) in the container's XML element.",
      "zh-CHS": "可以通过<edit config>在容器的XML元素中使用“operation”属性（参见[RFC6241]中的第7.2节）来创建、删除、替换和修改容器。"
    },
    {
      "indent": 3,
      "text": "If a container does not have a \"presence\" statement and the last child node is deleted, the NETCONF server MAY delete the container.",
      "zh-CHS": "如果容器没有“presence”语句，并且删除了最后一个子节点，NETCONF服务器可能会删除该容器。"
    },
    {
      "indent": 3,
      "text": "When a NETCONF server processes an <edit-config> request, the elements of procedure for the container node are as follows:",
      "zh-CHS": "当NETCONF服务器处理<edit config>请求时，容器节点的过程元素如下所示："
    },
    {
      "indent": 3,
      "text": "o If the operation is \"merge\" or \"replace\", the node is created if it does not exist.",
      "zh-CHS": "o 如果操作为“合并”或“替换”，则会在节点不存在时创建该节点。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"create\", the node is created if it does not exist. If the node already exists, a \"data-exists\" error is returned.",
      "zh-CHS": "o 如果操作为“创建”，则在节点不存在时创建该节点。如果节点已经存在，则返回“数据存在”错误。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"delete\", the node is deleted if it exists. If the node does not exist, a \"data-missing\" error is returned.",
      "zh-CHS": "o 如果操作为“删除”，则删除节点（如果存在）。如果节点不存在，则返回“数据丢失”错误。"
    },
    {
      "indent": 0,
      "text": "7.5.9. Usage Example",
      "section_title": true,
      "zh-CHS": "7.5.9. 用法示例"
    },
    {
      "indent": 3,
      "text": "Given the following container definition:",
      "zh-CHS": "给定以下容器定义："
    },
    {
      "indent": 5,
      "text": "container system {\n  description\n    \"Contains various system parameters.\";\n  container services {\n    description\n      \"Configure externally available services.\";\n    container \"ssh\" {\n      presence \"Enables SSH\";\n      description\n        \"SSH service-specific configuration.\";\n      // more leafs, containers, and stuff here...\n    }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example:",
      "zh-CHS": "对应的XML实例示例："
    },
    {
      "indent": 5,
      "text": "<system>\n  <services>\n    <ssh/>\n  </services>\n</system>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Since the <ssh> element is present, SSH is enabled.",
      "zh-CHS": "由于存在<ssh>元素，因此启用了ssh。"
    },
    {
      "indent": 3,
      "text": "To delete a container with an <edit-config>:",
      "zh-CHS": "要删除带有<edit config>的容器，请执行以下操作："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <edit-config>\n    <target>\n      <running/>\n    </target>\n    <config>\n      <system xmlns=\"urn:example:config\">\n        <services>\n          <ssh nc:operation=\"delete\"/>\n        </services>\n      </system>\n    </config>\n  </edit-config>\n</rpc>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.6. The \"leaf\" Statement",
      "section_title": true,
      "zh-CHS": "7.6. “叶子”声明"
    },
    {
      "indent": 3,
      "text": "The \"leaf\" statement is used to define a leaf node in the schema tree. It takes one argument, which is an identifier, followed by a block of substatements that holds detailed leaf information.",
      "zh-CHS": "“leaf”语句用于在模式树中定义叶节点。它有一个参数，它是一个标识符，后跟一个包含详细叶信息的子语句块。"
    },
    {
      "indent": 3,
      "text": "A leaf node has a value, but no child nodes, in the data tree. Conceptually, the value in the data tree is always in the canonical form (see Section 9.1).",
      "zh-CHS": "叶节点在数据树中有一个值，但没有子节点。从概念上讲，数据树中的值始终采用规范形式（参见第9.1节）。"
    },
    {
      "indent": 3,
      "text": "A leaf node exists in zero or one instance in the data tree.",
      "zh-CHS": "叶节点存在于数据树中的零个或一个实例中。"
    },
    {
      "indent": 3,
      "text": "The \"leaf\" statement is used to define a scalar variable of a particular built-in or derived type.",
      "zh-CHS": "“leaf”语句用于定义特定内置或派生类型的标量变量。"
    },
    {
      "indent": 0,
      "text": "7.6.1. The leaf's Default Value",
      "section_title": true,
      "zh-CHS": "7.6.1. 叶的默认值"
    },
    {
      "indent": 3,
      "text": "The default value of a leaf is the value that the server uses if the leaf does not exist in the data tree. The usage of the default value depends on the leaf's closest ancestor node in the schema tree that is not a non-presence container (see Section 7.5.1):",
      "zh-CHS": "如果叶在数据树中不存在，则叶的默认值是服务器使用的值。默认值的使用取决于叶在模式树中最近的祖先节点，该节点不是非存在容器（参见第7.5.1节）："
    },
    {
      "indent": 3,
      "text": "o If no such ancestor exists in the schema tree, the default value MUST be used.",
      "zh-CHS": "o 如果模式树中不存在这样的祖先，则必须使用默认值。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, if this ancestor is a case node, the default value MUST be used if any node from the case exists in the data tree or the case node is the choice's default case, and if no nodes from any other case exist in the data tree.",
      "zh-CHS": "o 否则，如果此祖先是案例节点，则如果数据树中存在案例中的任何节点，或者案例节点是选项的默认案例，并且如果数据树中不存在任何其他案例中的节点，则必须使用默认值。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, the default value MUST be used if the ancestor node exists in the data tree.",
      "zh-CHS": "o 否则，如果数据树中存在祖先节点，则必须使用默认值。"
    },
    {
      "indent": 3,
      "text": "In these cases, the default value is said to be in use.",
      "zh-CHS": "在这些情况下，默认值被称为正在使用。"
    },
    {
      "indent": 3,
      "text": "Note that if the leaf or any of its ancestors has a \"when\" condition or \"if-feature\" expression that evaluates to \"false\", then the default value is not in use.",
      "zh-CHS": "请注意，如果叶或其任何祖先具有计算结果为“false”的“when”条件或“if feature”表达式，则默认值不在使用中。"
    },
    {
      "indent": 3,
      "text": "When the default value is in use, the server MUST operationally behave as if the leaf was present in the data tree with the default value as its value.",
      "zh-CHS": "当使用默认值时，服务器在操作上的行为必须与叶在数据树中以默认值作为其值一样。"
    },
    {
      "indent": 3,
      "text": "If a leaf has a \"default\" statement, the leaf's default value is the value of the \"default\" statement. Otherwise, if the leaf's type has a default value and the leaf is not mandatory, then the leaf's default value is the type's default value. In all other cases, the leaf does not have a default value.",
      "zh-CHS": "如果一个叶子有一个“default”语句，那么叶子的默认值就是“default”语句的值。否则，如果叶的类型具有默认值且叶不是必需的，则叶的默认值是该类型的默认值。在所有其他情况下，叶没有默认值。"
    },
    {
      "indent": 0,
      "text": "7.6.2. The leaf's Substatements",
      "section_title": true,
      "zh-CHS": "7.6.2. 叶的亚基"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| config       | 7.21.1  | 0..1        |\n| default      | 7.6.4   | 0..1        |\n| description  | 7.21.3  | 0..1        |\n| if-feature   | 7.20.2  | 0..n        |\n| mandatory    | 7.6.5   | 0..1        |\n| must         | 7.5.3   | 0..n        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| type         | 7.6.3   | 1           |\n| units        | 7.3.3   | 0..1        |\n| when         | 7.21.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.6.3. The leaf's \"type\" Statement",
      "section_title": true,
      "zh-CHS": "7.6.3. 叶的“类型”语句"
    },
    {
      "indent": 3,
      "text": "The \"type\" statement, which MUST be present, takes as an argument the name of an existing built-in or derived type. The optional substatements specify restrictions on this type. See Section 7.4 for details.",
      "zh-CHS": "必须存在的“type”语句将现有内置类型或派生类型的名称作为参数。可选子语句指定此类型的限制。详见第7.4节。"
    },
    {
      "indent": 0,
      "text": "7.6.4. The leaf's \"default\" Statement",
      "section_title": true,
      "zh-CHS": "7.6.4. 叶的“默认”语句"
    },
    {
      "indent": 3,
      "text": "The \"default\" statement, which is optional, takes as an argument a string that contains a default value for the leaf.",
      "zh-CHS": "“default”语句是可选的，它将包含叶的默认值的字符串作为参数。"
    },
    {
      "indent": 3,
      "text": "The value of the \"default\" statement MUST be valid according to the type specified in the leaf's \"type\" statement.",
      "zh-CHS": "根据叶的“type”语句中指定的类型，“default”语句的值必须有效。"
    },
    {
      "indent": 3,
      "text": "The \"default\" statement MUST NOT be present on nodes where \"mandatory\" is \"true\".",
      "zh-CHS": "“default”语句不能出现在“mandatory”为“true”的节点上。"
    },
    {
      "indent": 3,
      "text": "The definition of the default value MUST NOT be marked with an \"if-feature\" statement. For example, the following is illegal:",
      "zh-CHS": "默认值的定义不得用“if feature”语句标记。例如，以下行为是非法的："
    },
    {
      "indent": 5,
      "text": "leaf color {\n  type enumeration {\n    enum blue { if-feature blue; }\n    ...\n  }\n  default blue; // illegal - enum value is conditional\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.6.5. The leaf's \"mandatory\" Statement",
      "section_title": true,
      "zh-CHS": "7.6.5. 叶的“强制性”声明"
    },
    {
      "indent": 3,
      "text": "The \"mandatory\" statement, which is optional, takes as an argument the string \"true\" or \"false\" and puts a constraint on valid data. If not specified, the default is \"false\".",
      "zh-CHS": "“mandatory”语句是可选的，它将字符串“true”或“false”作为参数，并对有效数据进行约束。如果未指定，则默认值为“false”。"
    },
    {
      "indent": 3,
      "text": "If \"mandatory\" is \"true\", the behavior of the constraint depends on the type of the leaf's closest ancestor node in the schema tree that is not a non-presence container (see Section 7.5.1):",
      "zh-CHS": "如果“mandatory”为“true”，则约束的行为取决于模式树中叶的最近祖先节点的类型，该节点不是非存在容器（请参见第7.5.1节）："
    },
    {
      "indent": 3,
      "text": "o If no such ancestor exists in the schema tree, the leaf MUST exist.",
      "zh-CHS": "o 如果模式树中不存在这样的祖先，那么叶必须存在。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, if this ancestor is a case node, the leaf MUST exist if any node from the case exists in the data tree.",
      "zh-CHS": "o 否则，如果此祖先是案例节点，则如果案例中的任何节点存在于数据树中，则该叶必须存在。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, the leaf MUST exist if the ancestor node exists in the data tree.",
      "zh-CHS": "o 否则，如果数据树中存在祖先节点，则叶必须存在。"
    },
    {
      "indent": 3,
      "text": "This constraint is enforced according to the rules in Section 8.",
      "zh-CHS": "此约束根据第8节中的规则强制执行。"
    },
    {
      "indent": 0,
      "text": "7.6.6. XML Encoding Rules",
      "section_title": true,
      "zh-CHS": "7.6.6. XML编码规则"
    },
    {
      "indent": 3,
      "text": "A leaf node is encoded as an XML element. The element's local name is the leaf's identifier, and its namespace is the module's XML namespace (see Section 7.1.3).",
      "zh-CHS": "叶节点编码为XML元素。元素的本地名称是叶的标识符，其名称空间是模块的XML名称空间（参见第7.1.3节）。"
    },
    {
      "indent": 3,
      "text": "The value of the leaf node is encoded to XML according to the type and is sent as character data in the element.",
      "zh-CHS": "叶节点的值根据类型编码为XML，并作为元素中的字符数据发送。"
    },
    {
      "indent": 3,
      "text": "See Section 7.6.8 for an example.",
      "zh-CHS": "示例见第7.6.8节。"
    },
    {
      "indent": 0,
      "text": "7.6.7. NETCONF <edit-config> Operations",
      "section_title": true,
      "zh-CHS": "7.6.7. NETCONF<edit config>操作"
    },
    {
      "indent": 3,
      "text": "When a NETCONF server processes an <edit-config> request, the elements of procedure for the leaf node are as follows:",
      "zh-CHS": "当NETCONF服务器处理<edit config>请求时，叶节点的过程元素如下所示："
    },
    {
      "indent": 3,
      "text": "o If the operation is \"merge\" or \"replace\", the node is created if it does not exist, and its value is set to the value found in the XML RPC data.",
      "zh-CHS": "o 如果操作为“merge”或“replace”，则将在节点不存在时创建该节点，并将其值设置为在XML RPC数据中找到的值。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"create\", the node is created if it does not exist. If the node already exists, a \"data-exists\" error is returned.",
      "zh-CHS": "o 如果操作为“创建”，则在节点不存在时创建该节点。如果节点已经存在，则返回“数据存在”错误。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"delete\", the node is deleted if it exists. If the node does not exist, a \"data-missing\" error is returned.",
      "zh-CHS": "o 如果操作为“删除”，则删除节点（如果存在）。如果节点不存在，则返回“数据丢失”错误。"
    },
    {
      "indent": 0,
      "text": "7.6.8. Usage Example",
      "section_title": true,
      "zh-CHS": "7.6.8. 用法示例"
    },
    {
      "indent": 3,
      "text": "Given the following \"leaf\" statement, placed in the previously defined \"ssh\" container (see Section 7.5.9):",
      "zh-CHS": "给出以下“leaf”语句，放在前面定义的“ssh”容器中（参见第7.5.9节）："
    },
    {
      "indent": 5,
      "text": "leaf port {\n  type inet:port-number;\n  default 22;\n  description\n    \"The port to which the SSH server listens.\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example:",
      "zh-CHS": "对应的XML实例示例："
    },
    {
      "indent": 5,
      "text": "<port>2022</port>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "To set the value of a leaf with an <edit-config>:",
      "zh-CHS": "要使用<edit config>设置叶的值，请执行以下操作："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <edit-config>\n    <target>\n      <running/>\n    </target>\n    <config>\n      <system xmlns=\"urn:example:config\">\n        <services>\n          <ssh>\n            <port>2022</port>\n          </ssh>\n        </services>\n      </system>\n    </config>\n  </edit-config>\n</rpc>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.7. The \"leaf-list\" Statement",
      "section_title": true,
      "zh-CHS": "7.7. “叶列表”语句"
    },
    {
      "indent": 3,
      "text": "Where the \"leaf\" statement is used to define a simple scalar variable of a particular type, the \"leaf-list\" statement is used to define an array of a particular type. The \"leaf-list\" statement takes one argument, which is an identifier, followed by a block of substatements that holds detailed leaf-list information.",
      "zh-CHS": "如果“leaf”语句用于定义特定类型的简单标量变量，“leaf list”语句用于定义特定类型的数组。“叶列表”语句接受一个参数，该参数是一个标识符，后跟一个包含详细叶列表信息的子语句块。"
    },
    {
      "indent": 3,
      "text": "In configuration data, the values in a leaf-list MUST be unique.",
      "zh-CHS": "在配置数据中，叶列表中的值必须是唯一的。"
    },
    {
      "indent": 3,
      "text": "The definitions of the default values MUST NOT be marked with an \"if-feature\" statement.",
      "zh-CHS": "默认值的定义不得用“if feature”语句标记。"
    },
    {
      "indent": 3,
      "text": "Conceptually, the values in the data tree MUST be in the canonical form (see Section 9.1).",
      "zh-CHS": "从概念上讲，数据树中的值必须采用规范形式（见第9.1节）。"
    },
    {
      "indent": 0,
      "text": "7.7.1. Ordering",
      "section_title": true,
      "zh-CHS": "7.7.1. 订购"
    },
    {
      "indent": 3,
      "text": "YANG supports two styles for ordering the entries within lists and leaf-lists. In many lists, the order of list entries does not impact the implementation of the list's configuration, and the server is free to sort the list entries in any reasonable order. The \"description\" string for the list may suggest an order to the server implementor. YANG calls this style of list \"system ordered\"; such lists are indicated with the statement \"ordered-by system\".",
      "zh-CHS": "YANG支持两种样式对列表和叶列表中的条目进行排序。在许多列表中，列表项的顺序不会影响列表配置的实现，服务器可以按照任何合理的顺序对列表项进行排序。列表的“description”字符串可能会向服务器实现者建议一个顺序。杨称这种类型的列表为“系统有序”；此类列表用“按系统排序”的语句表示。"
    },
    {
      "indent": 3,
      "text": "For example, a list of valid users would typically be sorted alphabetically, since the order in which the users appeared in the configuration would not impact the creation of those users' accounts.",
      "zh-CHS": "例如，有效用户列表通常按字母顺序排序，因为用户在配置中出现的顺序不会影响这些用户帐户的创建。"
    },
    {
      "indent": 3,
      "text": "In the other style of lists, the order of list entries matters for the implementation of the list's configuration and the user is responsible for ordering the entries, while the server maintains that order. YANG calls this style of list \"user ordered\"; such lists are indicated with the statement \"ordered-by user\".",
      "zh-CHS": "在另一种类型的列表中，列表条目的顺序对列表配置的实现很重要，用户负责对条目进行排序，而服务器则维持该顺序。杨称这种类型的列表为“用户订购”；此类列表用“按用户排序”的语句表示。"
    },
    {
      "indent": 3,
      "text": "For example, the order in which packet filter entries are applied to incoming traffic may affect how that traffic is filtered. The user would need to decide if the filter entry that discards all TCP traffic should be applied before or after the filter entry that allows all traffic from trusted interfaces. The choice of order would be crucial.",
      "zh-CHS": "例如，分组过滤器条目应用于传入流量的顺序可能会影响该流量的过滤方式。用户需要决定是否应在允许来自受信任接口的所有流量的筛选器条目之前或之后应用丢弃所有TCP流量的筛选器条目。秩序的选择至关重要。"
    },
    {
      "indent": 3,
      "text": "YANG provides a rich set of facilities within NETCONF's <edit-config> operation that allows the order of list entries in user-ordered lists to be controlled. List entries may be inserted or rearranged, positioned as the first or last entry in the list, or positioned before or after another specific entry.",
      "zh-CHS": "YANG在NETCONF的<edit config>操作中提供了一组丰富的工具，允许控制用户排序列表中列表项的顺序。列表条目可以插入或重新排列，定位为列表中的第一个或最后一个条目，或者定位在另一个特定条目之前或之后。"
    },
    {
      "indent": 3,
      "text": "The \"ordered-by\" statement is covered in Section 7.7.7.",
      "zh-CHS": "第7.7.7节介绍了“订购人”声明。"
    },
    {
      "indent": 0,
      "text": "7.7.2. The leaf-list's Default Values",
      "section_title": true,
      "zh-CHS": "7.7.2. 叶列表的默认值"
    },
    {
      "indent": 3,
      "text": "The default values of a leaf-list are the values that the server uses if the leaf-list does not exist in the data tree. The usage of the default values depends on the leaf-list's closest ancestor node in the schema tree that is not a non-presence container (see Section 7.5.1):",
      "zh-CHS": "叶列表的默认值是服务器在数据树中不存在叶列表时使用的值。默认值的使用取决于叶列表在模式树中最近的祖先节点，该节点不是非存在容器（请参阅第7.5.1节）："
    },
    {
      "indent": 3,
      "text": "o If no such ancestor exists in the schema tree, the default values MUST be used.",
      "zh-CHS": "o 如果模式树中不存在这样的祖先，则必须使用默认值。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, if this ancestor is a case node, the default values MUST be used if any node from the case exists in the data tree or the case node is the choice's default case, and if no nodes from any other case exist in the data tree.",
      "zh-CHS": "o 否则，如果此祖先是案例节点，则如果案例中的任何节点存在于数据树中，或者案例节点是选项的默认案例，并且如果数据树中不存在任何其他案例中的节点，则必须使用默认值。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, the default values MUST be used if the ancestor node exists in the data tree.",
      "zh-CHS": "o 否则，如果数据树中存在祖先节点，则必须使用默认值。"
    },
    {
      "indent": 3,
      "text": "In these cases, the default values are said to be in use.",
      "zh-CHS": "在这些情况下，默认值被称为正在使用。"
    },
    {
      "indent": 3,
      "text": "Note that if the leaf-list or any of its ancestors has a \"when\" condition or \"if-feature\" expression that evaluates to \"false\", then the default values are not in use.",
      "zh-CHS": "请注意，如果叶列表或其任何祖先具有计算结果为“false”的“when”条件或“if feature”表达式，则默认值不在使用中。"
    },
    {
      "indent": 3,
      "text": "When the default values are in use, the server MUST operationally behave as if the leaf-list was present in the data tree with the default values as its values.",
      "zh-CHS": "当使用默认值时，服务器在操作上的行为必须与叶列表以默认值作为其值出现在数据树中一样。"
    },
    {
      "indent": 3,
      "text": "If a leaf-list has one or more \"default\" statements, the leaf-list's default values are the values of the \"default\" statements, and if the leaf-list is user ordered, the default values are used in the order of the \"default\" statements. Otherwise, if the leaf-list's type has a default value and the leaf-list does not have a \"min-elements\" statement with a value greater than or equal to one, then the leaf-list's default value is one instance of the type's default value. In all other cases, the leaf-list does not have any default values.",
      "zh-CHS": "如果叶列表有一个或多个“default”语句，则叶列表的默认值是“default”语句的值，如果叶列表是用户排序的，则按照“default”语句的顺序使用默认值。否则，如果叶列表的类型具有默认值，并且叶列表没有值大于或等于1的“min elements”语句，则叶列表的默认值是该类型默认值的一个实例。在所有其他情况下，叶列表没有任何默认值。"
    },
    {
      "indent": 0,
      "text": "7.7.3. The leaf-list's Substatements",
      "section_title": true,
      "zh-CHS": "7.7.3. 叶列表的子状态"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| config       | 7.21.1  | 0..1        |\n| default      | 7.7.4   | 0..n        |\n| description  | 7.21.3  | 0..1        |\n| if-feature   | 7.20.2  | 0..n        |\n| max-elements | 7.7.6   | 0..1        |\n| min-elements | 7.7.5   | 0..1        |\n| must         | 7.5.3   | 0..n        |\n| ordered-by   | 7.7.7   | 0..1        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| type         | 7.4     | 1           |\n| units        | 7.3.3   | 0..1        |\n| when         | 7.21.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.7.4. The leaf-list's \"default\" Statement",
      "section_title": true,
      "zh-CHS": "7.7.4. 叶列表的“default”语句"
    },
    {
      "indent": 3,
      "text": "The \"default\" statement, which is optional, takes as an argument a string that contains a default value for the leaf-list.",
      "zh-CHS": "“default”语句是可选的，它将包含叶列表的默认值的字符串作为参数。"
    },
    {
      "indent": 3,
      "text": "The value of the \"default\" statement MUST be valid according to the type specified in the leaf-list's \"type\" statement.",
      "zh-CHS": "根据叶列表的“type”语句中指定的类型，“default”语句的值必须有效。"
    },
    {
      "indent": 3,
      "text": "The \"default\" statement MUST NOT be present on nodes where \"min-elements\" has a value greater than or equal to one.",
      "zh-CHS": "“default”语句不得出现在“min elements”值大于或等于1的节点上。"
    },
    {
      "indent": 0,
      "text": "7.7.5. The \"min-elements\" Statement",
      "section_title": true,
      "zh-CHS": "7.7.5. “最小元素”语句"
    },
    {
      "indent": 3,
      "text": "The \"min-elements\" statement, which is optional, takes as an argument a non-negative integer that puts a constraint on valid list entries. A valid leaf-list or list MUST have at least min-elements entries.",
      "zh-CHS": "“min elements”语句是可选的，它将一个非负整数作为参数，该非负整数对有效的列表项进行约束。有效的叶列表或列表必须至少包含min元素条目。"
    },
    {
      "indent": 3,
      "text": "If no \"min-elements\" statement is present, it defaults to zero.",
      "zh-CHS": "如果不存在“min elements”语句，则默认为零。"
    },
    {
      "indent": 3,
      "text": "The behavior of the constraint depends on the type of the leaf-list's or list's closest ancestor node in the schema tree that is not a non-presence container (see Section 7.5.1):",
      "zh-CHS": "约束的行为取决于模式树中不是非存在容器的叶列表或列表最近祖先节点的类型（参见第7.5.1节）："
    },
    {
      "indent": 3,
      "text": "o If no such ancestor exists in the schema tree, the constraint is enforced.",
      "zh-CHS": "o 如果模式树中不存在这样的祖先，则强制执行约束。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, if this ancestor is a case node, the constraint is enforced if any other node from the case exists.",
      "zh-CHS": "o 否则，如果此祖先是案例节点，则如果案例中存在任何其他节点，则强制执行约束。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, it is enforced if the ancestor node exists.",
      "zh-CHS": "o 否则，如果祖先节点存在，则强制执行。"
    },
    {
      "indent": 3,
      "text": "The constraint is further enforced according to the rules in Section 8.",
      "zh-CHS": "根据第8节中的规则，进一步实施约束。"
    },
    {
      "indent": 0,
      "text": "7.7.6. The \"max-elements\" Statement",
      "section_title": true,
      "zh-CHS": "7.7.6. “最大元素”语句"
    },
    {
      "indent": 3,
      "text": "The \"max-elements\" statement, which is optional, takes as an argument a positive integer or the string \"unbounded\", which puts a constraint on valid list entries. A valid leaf-list or list always has at most max-elements entries.",
      "zh-CHS": "“max elements”语句是可选的，它将一个正整数或字符串“unbounded”作为参数，该字符串对有效列表项施加约束。有效的叶列表或列表始终最多包含max elements条目。"
    },
    {
      "indent": 3,
      "text": "If no \"max-elements\" statement is present, it defaults to \"unbounded\".",
      "zh-CHS": "如果不存在“max elements”语句，则默认为“unbounded”。"
    },
    {
      "indent": 3,
      "text": "The \"max-elements\" constraint is enforced according to the rules in Section 8.",
      "zh-CHS": "“最大元素”约束根据第8节中的规则强制执行。"
    },
    {
      "indent": 0,
      "text": "7.7.7. The \"ordered-by\" Statement",
      "section_title": true,
      "zh-CHS": "7.7.7. “orderby”语句"
    },
    {
      "indent": 3,
      "text": "The \"ordered-by\" statement defines whether the order of entries within a list are determined by the user or the system. The argument is one of the strings \"system\" or \"user\". If not present, ordering defaults to \"system\".",
      "zh-CHS": "“ordered by”语句定义列表中条目的顺序是由用户还是由系统确定的。参数是字符串“system”或“user”之一。如果不存在，则订购默认为“系统”。"
    },
    {
      "indent": 3,
      "text": "This statement is ignored if the list represents state data, RPC output parameters, or notification content.",
      "zh-CHS": "如果列表表示状态数据、RPC输出参数或通知内容，则忽略此语句。"
    },
    {
      "indent": 3,
      "text": "See Section 7.7.1 for additional information.",
      "zh-CHS": "更多信息见第7.7.1节。"
    },
    {
      "indent": 0,
      "text": "7.7.7.1. ordered-by system",
      "section_title": true,
      "zh-CHS": "7.7.7.1. 按系统排序"
    },
    {
      "indent": 3,
      "text": "The entries in the list are ordered according to an order determined by the system. The \"description\" string for the list may suggest an order to the server implementor. If not, an implementation is free to order the entries in any order. An implementation SHOULD use the same order for the same data, regardless of how the data were created. Using a deterministic order will make comparisons possible using simple tools like \"diff\".",
      "zh-CHS": "列表中的条目根据系统确定的顺序排序。列表的“description”字符串可能会向服务器实现者建议一个顺序。如果没有，则实现可以按任意顺序对条目进行排序。无论数据是如何创建的，实现都应该对相同的数据使用相同的顺序。使用确定性顺序可以使用“diff”等简单工具进行比较。"
    },
    {
      "indent": 3,
      "text": "This is the default order.",
      "zh-CHS": "这是默认顺序。"
    },
    {
      "indent": 0,
      "text": "7.7.7.2. ordered-by user",
      "section_title": true,
      "zh-CHS": "7.7.7.2. 按用户订购"
    },
    {
      "indent": 3,
      "text": "The entries in the list are ordered according to an order defined by the user. In NETCONF, this order is controlled by using special XML attributes in the <edit-config> request. See Section 7.7.9 for details.",
      "zh-CHS": "列表中的条目按照用户定义的顺序排序。在NETCONF中，这个顺序是通过在<edit config>请求中使用特殊的XML属性来控制的。详见第7.7.9节。"
    },
    {
      "indent": 0,
      "text": "7.7.8. XML Encoding Rules",
      "section_title": true,
      "zh-CHS": "7.7.8. XML编码规则"
    },
    {
      "indent": 3,
      "text": "A leaf-list node is encoded as a series of XML elements. Each element's local name is the leaf-list's identifier, and its namespace is the module's XML namespace (see Section 7.1.3).",
      "zh-CHS": "叶列表节点编码为一系列XML元素。每个元素的本地名称是叶列表的标识符，其名称空间是模块的XML名称空间（参见第7.1.3节）。"
    },
    {
      "indent": 3,
      "text": "The value of each leaf-list entry is encoded to XML according to the type and is sent as character data in the element.",
      "zh-CHS": "每个叶列表条目的值根据类型编码为XML，并作为元素中的字符数据发送。"
    },
    {
      "indent": 3,
      "text": "The XML elements representing leaf-list entries MUST appear in the order specified by the user if the leaf-list is \"ordered-by user\"; otherwise, the order is implementation dependent. The XML elements representing leaf-list entries MAY be interleaved with elements for siblings of the leaf-list, unless the leaf-list defines RPC or action input or output parameters.",
      "zh-CHS": "如果叶列表是“按用户排序”的，则表示叶列表条目的XML元素必须按照用户指定的顺序出现；否则，顺序取决于实现。表示叶列表条目的XML元素可以与叶列表的同级元素交错，除非叶列表定义了RPC或操作输入或输出参数。"
    },
    {
      "indent": 3,
      "text": "See Section 7.7.10 for an example.",
      "zh-CHS": "示例见第7.7.10节。"
    },
    {
      "indent": 0,
      "text": "7.7.9. NETCONF <edit-config> Operations",
      "section_title": true,
      "zh-CHS": "7.7.9. NETCONF<edit config>操作"
    },
    {
      "indent": 3,
      "text": "Leaf-list entries can be created and deleted, but not modified, through <edit-config>, by using the \"operation\" attribute in the leaf-list entry's XML element.",
      "zh-CHS": "通过使用叶列表条目的XML元素中的“operation”属性，可以创建和删除叶列表条目，但不能修改。"
    },
    {
      "indent": 3,
      "text": "In an \"ordered-by user\" leaf-list, the attributes \"insert\" and \"value\" in the YANG XML namespace (Section 5.3.1) can be used to control where in the leaf-list the entry is inserted. These can be used during \"create\" operations to insert a new leaf-list entry, or during \"merge\" or \"replace\" operations to insert a new leaf-list entry or move an existing one.",
      "zh-CHS": "在“按用户排序”叶列表中，XML命名空间（第5.3.1节）中的属性“插入”和“值”可用于控制在叶列表中插入条目的位置。这些可以在“创建”操作期间用于插入新的叶列表条目，或在“合并”或“替换”操作期间用于插入新的叶列表条目或移动现有的叶列表条目。"
    },
    {
      "indent": 3,
      "text": "The \"insert\" attribute can take the values \"first\", \"last\", \"before\", and \"after\". If the value is \"before\" or \"after\", the \"value\" attribute MUST also be used to specify an existing entry in the leaf-list.",
      "zh-CHS": "“insert”属性可以采用值“first”、“last”、“before”和“after”。如果值为“before”或“after”，则“value”属性还必须用于指定叶列表中的现有条目。"
    },
    {
      "indent": 3,
      "text": "If no \"insert\" attribute is present in the \"create\" operation, it defaults to \"last\".",
      "zh-CHS": "如果“创建”操作中不存在“插入”属性，则默认为“最后”。"
    },
    {
      "indent": 3,
      "text": "If several entries in an \"ordered-by user\" leaf-list are modified in the same <edit-config> request, the entries are modified one at a time, in the order of the XML elements in the request.",
      "zh-CHS": "如果在同一<edit config>请求中修改了“ordered by user”（按用户排序）叶列表中的多个条目，则按照请求中XML元素的顺序一次修改一个条目。"
    },
    {
      "indent": 3,
      "text": "In a <copy-config> or in an <edit-config> with a \"replace\" operation that covers the entire leaf-list, the leaf-list order is the same as the order of the XML elements in the request.",
      "zh-CHS": "在包含整个叶列表的“replace”操作的<copy config>或<edit config>中，叶列表顺序与请求中XML元素的顺序相同。"
    },
    {
      "indent": 3,
      "text": "When a NETCONF server processes an <edit-config> request, the elements of procedure for a leaf-list node are as follows:",
      "zh-CHS": "当NETCONF服务器处理<edit config>请求时，叶列表节点的过程元素如下所示："
    },
    {
      "indent": 3,
      "text": "o If the operation is \"merge\" or \"replace\", the leaf-list entry is created if it does not exist.",
      "zh-CHS": "o 如果操作为“合并”或“替换”，则会在叶列表条目不存在时创建该条目。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"create\", the leaf-list entry is created if it does not exist. If the leaf-list entry already exists, a \"data-exists\" error is returned.",
      "zh-CHS": "o 如果操作为“创建”，则会创建不存在的叶列表条目。如果叶列表条目已经存在，则返回“数据存在”错误。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"delete\", the entry is deleted from the leaf-list if it exists. If the leaf-list entry does not exist, a \"data-missing\" error is returned.",
      "zh-CHS": "o 如果操作为“删除”，则该条目将从叶列表中删除（如果存在）。如果叶列表条目不存在，则返回“数据丢失”错误。"
    },
    {
      "indent": 0,
      "text": "7.7.10. Usage Example",
      "section_title": true,
      "zh-CHS": "7.7.10. 用法示例"
    },
    {
      "indent": 5,
      "text": "leaf-list allow-user {\n  type string;\n  description\n    \"A list of user name patterns to allow.\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example:",
      "zh-CHS": "对应的XML实例示例："
    },
    {
      "indent": 5,
      "text": "<allow-user>alice</allow-user>\n<allow-user>bob</allow-user>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "To create a new element in this list, using the default <edit-config> operation \"merge\":",
      "zh-CHS": "要在此列表中创建新元素，请使用默认的<edit config>操作“merge”："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <edit-config>\n    <target>\n      <running/>\n    </target>\n    <config>\n      <system xmlns=\"urn:example:config\">\n        <services>\n          <ssh>\n            <allow-user>eric</allow-user>\n          </ssh>\n        </services>\n      </system>\n    </config>\n  </edit-config>\n</rpc>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Given the following ordered-by user leaf-list:",
      "zh-CHS": "给定按用户叶列表排序的以下内容："
    },
    {
      "indent": 5,
      "text": "leaf-list cipher {\n  type string;\n  ordered-by user;\n  description\n    \"A list of ciphers.\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The following would be used to insert a new cipher \"blowfish-cbc\" after \"3des-cbc\":",
      "zh-CHS": "以下内容将用于在“3des cbc”之后插入新密码“河豚cbc”："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"102\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:yang=\"urn:ietf:params:xml:ns:yang:1\">\n  <edit-config>\n    <target>\n      <running/>\n    </target>\n    <config>\n      <system xmlns=\"urn:example:config\">\n        <services>\n          <ssh>\n            <cipher nc:operation=\"create\"\n                    yang:insert=\"after\"\n                    yang:value=\"3des-cbc\">blowfish-cbc</cipher>\n          </ssh>\n        </services>\n      </system>\n    </config>\n  </edit-config>\n</rpc>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.8. The \"list\" Statement",
      "section_title": true,
      "zh-CHS": "7.8. “名单”声明"
    },
    {
      "indent": 3,
      "text": "The \"list\" statement is used to define an interior data node in the schema tree. A list node may exist in multiple instances in the data tree. Each such instance is known as a list entry. The \"list\" statement takes one argument, which is an identifier, followed by a block of substatements that holds detailed list information.",
      "zh-CHS": "“list”语句用于定义模式树中的内部数据节点。列表节点可能存在于数据树中的多个实例中。每个这样的实例称为列表条目。“list”语句接受一个参数，它是一个标识符，后跟一个包含详细列表信息的子语句块。"
    },
    {
      "indent": 3,
      "text": "A list entry is uniquely identified by the values of the list's keys, if defined.",
      "zh-CHS": "列表项由列表键的值唯一标识（如果已定义）。"
    },
    {
      "indent": 0,
      "text": "7.8.1. The list's Substatements",
      "section_title": true,
      "zh-CHS": "7.8.1. 列表的子状态"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| action       | 7.15    | 0..n        |\n| anydata      | 7.10    | 0..n        |\n| anyxml       | 7.11    | 0..n        |\n| choice       | 7.9     | 0..n        |\n| config       | 7.21.1  | 0..1        |\n| container    | 7.5     | 0..n        |\n| description  | 7.21.3  | 0..1        |\n| grouping     | 7.12    | 0..n        |\n| if-feature   | 7.20.2  | 0..n        |\n| key          | 7.8.2   | 0..1        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| max-elements | 7.7.6   | 0..1        |\n| min-elements | 7.7.5   | 0..1        |\n| must         | 7.5.3   | 0..n        |\n| notification | 7.16    | 0..n        |\n| ordered-by   | 7.7.7   | 0..1        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| typedef      | 7.3     | 0..n        |\n| unique       | 7.8.3   | 0..n        |\n| uses         | 7.13    | 0..n        |\n| when         | 7.21.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.8.2. The list's \"key\" Statement",
      "section_title": true,
      "zh-CHS": "7.8.2. 列表的“关键”语句"
    },
    {
      "indent": 3,
      "text": "The \"key\" statement, which MUST be present if the list represents configuration and MAY be present otherwise, takes as an argument a string that specifies a space-separated list of one or more leaf identifiers of this list. A leaf identifier MUST NOT appear more than once in the key. Each such leaf identifier MUST refer to a child leaf of the list. The leafs can be defined directly in substatements to the list or in groupings used in the list.",
      "zh-CHS": "如果列表表示配置，则“key”语句必须存在，否则可能存在。该语句将字符串作为参数，指定此列表的一个或多个叶标识符的以空格分隔的列表。叶标识符在键中不能出现多次。每个这样的叶标识符必须引用列表的子叶。可以直接在列表的子状态或列表中使用的分组中定义LEAF。"
    },
    {
      "indent": 3,
      "text": "The combined values of all the leafs specified in the key are used to uniquely identify a list entry. All key leafs MUST be given values when a list entry is created. Thus, any default values in the key leafs or their types are ignored. Any \"mandatory\" statements in the key leafs are ignored.",
      "zh-CHS": "键中指定的所有叶的组合值用于唯一标识列表项。创建列表条目时，必须为所有键叶指定值。因此，将忽略键叶或其类型中的任何默认值。忽略键叶中的任何“强制”语句。"
    },
    {
      "indent": 3,
      "text": "A leaf that is part of the key can be of any built-in or derived type.",
      "zh-CHS": "作为键的一部分的叶可以是任何内置或派生类型。"
    },
    {
      "indent": 3,
      "text": "All key leafs in a list MUST have the same value for their \"config\" as the list itself.",
      "zh-CHS": "列表中的所有键叶的“配置”值必须与列表本身的值相同。"
    },
    {
      "indent": 3,
      "text": "The key string syntax is formally defined by the rule \"key-arg\" in Section 14.",
      "zh-CHS": "键字符串语法由第14节中的规则“key arg”正式定义。"
    },
    {
      "indent": 0,
      "text": "7.8.3. The list's \"unique\" Statement",
      "section_title": true,
      "zh-CHS": "7.8.3. 该列表的“唯一”声明"
    },
    {
      "indent": 3,
      "text": "The \"unique\" statement is used to put constraints on valid list entries. It takes as an argument a string that contains a space-separated list of schema node identifiers, which MUST be given in the descendant form (see the rule \"descendant-schema-nodeid\" in Section 14). Each such schema node identifier MUST refer to a leaf.",
      "zh-CHS": "“unique”语句用于对有效列表项进行约束。它将包含模式节点标识符的空格分隔列表的字符串作为参数，这些标识符必须以子代形式给出（请参见第14节中的规则“子代模式节点ID”）。每个这样的模式节点标识符必须引用一个叶。"
    },
    {
      "indent": 3,
      "text": "If one of the referenced leafs represents configuration data, then all of the referenced leafs MUST represent configuration data.",
      "zh-CHS": "如果其中一个引用的leaf表示配置数据，那么所有引用的leaf都必须表示配置数据。"
    },
    {
      "indent": 3,
      "text": "The \"unique\" constraint specifies that the combined values of all the leaf instances specified in the argument string, including leafs with default values, MUST be unique within all list entry instances in which all referenced leafs exist or have default values. The constraint is enforced according to the rules in Section 8.",
      "zh-CHS": "“唯一”约束指定参数字符串中指定的所有叶实例（包括具有默认值的叶）的组合值在所有引用叶存在或具有默认值的所有列表条目实例中必须是唯一的。根据第8节中的规则强制执行约束。"
    },
    {
      "indent": 3,
      "text": "The unique string syntax is formally defined by the rule \"unique-arg\" in Section 14.",
      "zh-CHS": "唯一字符串语法由第14节中的规则“unique arg”正式定义。"
    },
    {
      "indent": 0,
      "text": "7.8.3.1. Usage Example",
      "section_title": true,
      "zh-CHS": "7.8.3.1. 用法示例"
    },
    {
      "indent": 3,
      "text": "With the following list:",
      "zh-CHS": "以下是："
    },
    {
      "indent": 5,
      "text": "list server {\n  key \"name\";\n  unique \"ip port\";\n  leaf name {\n    type string;\n  }\n  leaf ip {\n    type inet:ip-address;\n  }\n  leaf port {\n    type inet:port-number;\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "the following configuration is not valid:",
      "zh-CHS": "以下配置无效："
    },
    {
      "indent": 5,
      "text": "<server>\n  <name>smtp</name>\n  <ip>192.0.2.1</ip>\n  <port>25</port>\n</server>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "<server>\n  <name>http</name>\n  <ip>192.0.2.1</ip>\n  <port>25</port>\n</server>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The following configuration is valid, since the \"http\" and \"ftp\" list entries do not have a value for all referenced leafs and are thus not taken into account when the \"unique\" constraint is enforced:",
      "zh-CHS": "以下配置是有效的，因为“http”和“ftp”列表项没有针对所有引用的leaf的值，因此在强制执行“unique”约束时不考虑这些值："
    },
    {
      "indent": 5,
      "text": "<server>\n  <name>smtp</name>\n  <ip>192.0.2.1</ip>\n  <port>25</port>\n</server>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "<server>\n  <name>http</name>\n  <ip>192.0.2.1</ip>\n</server>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "<server>\n  <name>ftp</name>\n  <ip>192.0.2.1</ip>\n</server>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.8.4. The list's Child Node Statements",
      "section_title": true,
      "zh-CHS": "7.8.4. 列表的子节点语句"
    },
    {
      "indent": 3,
      "text": "Within a list, the \"container\", \"leaf\", \"list\", \"leaf-list\", \"uses\", \"choice\", \"anydata\", and \"anyxml\" statements can be used to define child nodes to the list.",
      "zh-CHS": "在列表中，“container”、“leaf”、“list”、“leaf list”、“uses”、“choice”、“anydata”和“anyxml”语句可用于定义列表的子节点。"
    },
    {
      "indent": 0,
      "text": "7.8.5. XML Encoding Rules",
      "section_title": true,
      "zh-CHS": "7.8.5. XML编码规则"
    },
    {
      "indent": 3,
      "text": "A list is encoded as a series of XML elements, one for each entry in the list. Each element's local name is the list's identifier, and its namespace is the module's XML namespace (see Section 7.1.3). There is no XML element surrounding the list as a whole.",
      "zh-CHS": "列表被编码为一系列XML元素，列表中的每个条目对应一个XML元素。每个元素的本地名称是列表的标识符，其名称空间是模块的XML名称空间（参见第7.1.3节）。整个列表周围没有XML元素。"
    },
    {
      "indent": 3,
      "text": "The list's key nodes are encoded as subelements to the list's identifier element, in the same order as they are defined within the \"key\" statement.",
      "zh-CHS": "列表的关键节点被编码为列表标识符元素的子元素，其顺序与“key”语句中定义的顺序相同。"
    },
    {
      "indent": 3,
      "text": "The rest of the list's child nodes are encoded as subelements to the list element, after the keys. If the list defines RPC or action input or output parameters, the subelements are encoded in the same order as they are defined within the \"list\" statement. Otherwise, the subelements are encoded in any order.",
      "zh-CHS": "列表的其余子节点在键之后编码为列表元素的子元素。如果列表定义了RPC或操作输入或输出参数，则子元素的编码顺序与“list”语句中定义的顺序相同。否则，子元素按任意顺序编码。"
    },
    {
      "indent": 3,
      "text": "Any whitespace between the subelements to the list entry is insignificant, i.e., an implementation MAY insert whitespace characters between subelements.",
      "zh-CHS": "列表项的子元素之间的任何空白都是无关紧要的，即，实现可以在子元素之间插入空白字符。"
    },
    {
      "indent": 3,
      "text": "The XML elements representing list entries MUST appear in the order specified by the user if the list is \"ordered-by user\"; otherwise, the order is implementation dependent. The XML elements representing list entries MAY be interleaved with elements for siblings of the list, unless the list defines RPC or action input or output parameters.",
      "zh-CHS": "如果列表是“按用户排序”的，则表示列表项的XML元素必须按照用户指定的顺序出现；否则，顺序取决于实现。表示列表项的XML元素可以与列表同级的元素交错，除非列表定义了RPC或操作输入或输出参数。"
    },
    {
      "indent": 0,
      "text": "7.8.6. NETCONF <edit-config> Operations",
      "section_title": true,
      "zh-CHS": "7.8.6. NETCONF<edit config>操作"
    },
    {
      "indent": 3,
      "text": "List entries can be created, deleted, replaced, and modified through <edit-config> by using the \"operation\" attribute in the list's XML element. In each case, the values of all keys are used to uniquely identify a list entry. If all keys are not specified for a list entry, a \"missing-element\" error is returned.",
      "zh-CHS": "通过使用列表XML元素中的“operation”属性，可以通过<edit config>创建、删除、替换和修改列表条目。在每种情况下，所有键的值都用于唯一标识列表条目。如果没有为列表项指定所有键，则返回“缺少元素”错误。"
    },
    {
      "indent": 3,
      "text": "In an \"ordered-by user\" list, the attributes \"insert\" and \"key\" in the YANG XML namespace (Section 5.3.1) can be used to control where in the list the entry is inserted. These can be used during \"create\" operations to insert a new list entry, or during \"merge\" or \"replace\" operations to insert a new list entry or move an existing one.",
      "zh-CHS": "在“按用户排序”列表中，XML名称空间（第5.3.1节）中的属性“插入”和“键”可用于控制条目在列表中插入的位置。可以在“创建”操作期间插入新列表项，或在“合并”或“替换”操作期间插入新列表项或移动现有列表项。"
    },
    {
      "indent": 3,
      "text": "The \"insert\" attribute can take the values \"first\", \"last\", \"before\", and \"after\". If the value is \"before\" or \"after\", the \"key\" attribute MUST also be used, to specify an existing element in the list. The value of the \"key\" attribute is the key predicates of the full instance identifier (see Section 9.13) for the list entry.",
      "zh-CHS": "“insert”属性可以采用值“first”、“last”、“before”和“after”。如果值为“before”或“after”，则还必须使用“key”属性来指定列表中的现有元素。“key”属性的值是列表项的完整实例标识符（见第9.13节）的键谓词。"
    },
    {
      "indent": 3,
      "text": "If no \"insert\" attribute is present in the \"create\" operation, it defaults to \"last\".",
      "zh-CHS": "如果“创建”操作中不存在“插入”属性，则默认为“最后”。"
    },
    {
      "indent": 3,
      "text": "If several entries in an \"ordered-by user\" list are modified in the same <edit-config> request, the entries are modified one at a time, in the order of the XML elements in the request.",
      "zh-CHS": "如果在同一个<edit config>请求中修改了“ordered by user”（按用户排序）列表中的多个条目，则会按照请求中XML元素的顺序一次修改一个条目。"
    },
    {
      "indent": 3,
      "text": "In a <copy-config> or in an <edit-config> with a \"replace\" operation that covers the entire list, the list entry order is the same as the order of the XML elements in the request.",
      "zh-CHS": "在<copy config>或具有覆盖整个列表的“replace”操作的<edit config>中，列表条目顺序与请求中XML元素的顺序相同。"
    },
    {
      "indent": 3,
      "text": "When a NETCONF server processes an <edit-config> request, the elements of procedure for a list node are as follows:",
      "zh-CHS": "当NETCONF服务器处理<edit config>请求时，列表节点的过程元素如下所示："
    },
    {
      "indent": 3,
      "text": "o If the operation is \"merge\" or \"replace\", the list entry is created if it does not exist. If the list entry already exists and the \"insert\" and \"key\" attributes are present, the list entry is moved according to the values of the \"insert\" and \"key\" attributes. If the list entry exists and the \"insert\" and \"key\" attributes are not present, the list entry is not moved.",
      "zh-CHS": "o 如果操作为“合并”或“替换”，则会在列表项不存在时创建该列表项。如果列表项已经存在并且存在“插入”和“键”属性，则列表项将根据“插入”和“键”属性的值移动。如果列表条目存在且“插入”和“键”属性不存在，则列表条目不会移动。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"create\", the list entry is created if it does not exist. If the list entry already exists, a \"data-exists\" error is returned.",
      "zh-CHS": "o 如果操作为“创建”，则在列表项不存在时创建列表项。如果列表条目已经存在，则返回“数据存在”错误。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"delete\", the entry is deleted from the list if it exists. If the list entry does not exist, a \"data-missing\" error is returned.",
      "zh-CHS": "o 如果操作为“删除”，则该条目将从列表中删除（如果存在）。如果列表项不存在，则返回“数据丢失”错误。"
    },
    {
      "indent": 0,
      "text": "7.8.7. Usage Example",
      "section_title": true,
      "zh-CHS": "7.8.7. 用法示例"
    },
    {
      "indent": 3,
      "text": "Given the following list:",
      "zh-CHS": "鉴于以下清单："
    },
    {
      "indent": 5,
      "text": "list user {\n  key \"name\";\n  config true;\n  description\n    \"This is a list of users in the system.\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "  leaf name {\n    type string;\n  }\n  leaf type {\n    type string;\n  }\n  leaf full-name {\n    type string;\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example:",
      "zh-CHS": "对应的XML实例示例："
    },
    {
      "indent": 5,
      "text": "<user>\n  <name>fred</name>\n  <type>admin</type>\n  <full-name>Fred Flintstone</full-name>\n</user>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "To create a new user \"barney\":",
      "zh-CHS": "要创建新用户“barney”："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <edit-config>\n    <target>\n      <running/>\n    </target>\n    <config>\n      <system xmlns=\"urn:example:config\">\n        <user nc:operation=\"create\">\n          <name>barney</name>\n          <type>admin</type>\n          <full-name>Barney Rubble</full-name>\n        </user>\n      </system>\n    </config>\n  </edit-config>\n</rpc>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "To change the type of \"fred\" to \"superuser\":",
      "zh-CHS": "要将“fred”的类型更改为“超级用户”："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"102\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <edit-config>\n    <target>\n      <running/>\n    </target>\n    <config>\n      <system xmlns=\"urn:example:config\">\n        <user>\n          <name>fred</name>\n          <type>superuser</type>\n        </user>\n      </system>\n    </config>\n  </edit-config>\n</rpc>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Given the following ordered-by user list:",
      "zh-CHS": "给定以下按用户顺序排列的列表："
    },
    {
      "indent": 5,
      "text": "list user {\n  description\n    \"This is a list of users in the system.\";\n  ordered-by user;\n  config true;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "key \"first-name surname\";",
      "zh-CHS": "键“名字姓氏”；"
    },
    {
      "indent": 5,
      "text": "  leaf first-name {\n    type string;\n  }\n  leaf surname {\n    type string;\n  }\n  leaf type {\n    type string;\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The following would be used to insert a new user \"barney rubble\" after the user \"fred flintstone\":",
      "zh-CHS": "以下内容将用于在用户“fred flintstone”之后插入新用户“barney Bruse”："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:yang=\"urn:ietf:params:xml:ns:yang:1\">\n  <edit-config>\n    <target>\n      <running/>\n    </target>\n    <config>\n      <system xmlns=\"urn:example:config\"\n           xmlns:ex=\"urn:example:config\">\n        <user nc:operation=\"create\"\n              yang:insert=\"after\"\n              yang:key=\"[ex:first-name='fred']\n                        [ex:surname='flintstone']\">\n          <first-name>barney</first-name>\n          <surname>rubble</surname>\n          <type>admin</type>\n        </user>\n      </system>\n    </config>\n  </edit-config>\n</rpc>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The following would be used to move the user \"barney rubble\" before the user \"fred flintstone\":",
      "zh-CHS": "以下内容将用于在用户“fred flintstone”之前移动用户“barney碎石”："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"102\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:yang=\"urn:ietf:params:xml:ns:yang:1\">\n  <edit-config>\n    <target>\n      <running/>\n    </target>\n    <config>\n      <system xmlns=\"urn:example:config\"\n           xmlns:ex=\"urn:example:config\">\n        <user nc:operation=\"merge\"\n              yang:insert=\"before\"\n              yang:key=\"[ex:name='fred']\n                        [ex:surname='flintstone']\">\n          <first-name>barney</first-name>\n          <surname>rubble</surname>\n        </user>\n      </system>\n    </config>\n  </edit-config>\n</rpc>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.9. The \"choice\" Statement",
      "section_title": true,
      "zh-CHS": "7.9. “选择”声明"
    },
    {
      "indent": 3,
      "text": "The \"choice\" statement defines a set of alternatives, only one of which may be present in any one data tree. The argument is an identifier, followed by a block of substatements that holds detailed choice information. The identifier is used to identify the choice node in the schema tree. A choice node does not exist in the data tree.",
      "zh-CHS": "“choice”语句定义了一组备选方案，其中只有一个可能出现在任何一个数据树中。参数是一个标识符，后跟一个包含详细选择信息的子语句块。标识符用于标识模式树中的选择节点。数据树中不存在选择节点。"
    },
    {
      "indent": 3,
      "text": "A choice consists of a number of branches, each defined with a \"case\" substatement. Each branch contains a number of child nodes. The nodes from at most one of the choice's branches exist at the same time.",
      "zh-CHS": "选项由多个分支组成，每个分支都定义了一个“case”子语句。每个分支包含多个子节点。最多一个选项分支中的节点同时存在。"
    },
    {
      "indent": 3,
      "text": "Since only one of the choice's cases can be valid at any time in the data tree, the creation of a node from one case implicitly deletes all nodes from all other cases. If a request creates a node from a case, the server will delete any existing nodes that are defined in other cases inside the choice.",
      "zh-CHS": "由于在数据树中任何时候只有一个选项的案例有效，因此从一个案例创建节点会隐式删除所有其他案例中的所有节点。如果请求从案例中创建节点，服务器将删除在选项中的其他案例中定义的任何现有节点。"
    },
    {
      "indent": 0,
      "text": "7.9.1. The choice's Substatements",
      "section_title": true,
      "zh-CHS": "7.9.1. 选择的子状态"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| anydata      | 7.10    | 0..n        |\n| anyxml       | 7.11    | 0..n        |\n| case         | 7.9.2   | 0..n        |\n| choice       | 7.9     | 0..n        |\n| config       | 7.21.1  | 0..1        |\n| container    | 7.5     | 0..n        |\n| default      | 7.9.3   | 0..1        |\n| description  | 7.21.3  | 0..1        |\n| if-feature   | 7.20.2  | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| mandatory    | 7.9.4   | 0..1        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| when         | 7.21.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.9.2. The choice's \"case\" Statement",
      "section_title": true,
      "zh-CHS": "7.9.2. 选择的“案例”陈述"
    },
    {
      "indent": 3,
      "text": "The \"case\" statement is used to define branches of the choice. It takes as an argument an identifier, followed by a block of substatements that holds detailed case information.",
      "zh-CHS": "“case”语句用于定义选项的分支。它将标识符作为参数，后跟一个包含详细案例信息的子语句块。"
    },
    {
      "indent": 3,
      "text": "The identifier is used to identify the case node in the schema tree. A case node does not exist in the data tree.",
      "zh-CHS": "标识符用于标识模式树中的案例节点。数据树中不存在案例节点。"
    },
    {
      "indent": 3,
      "text": "Within a \"case\" statement, the \"anydata\", \"anyxml\", \"choice\", \"container\", \"leaf\", \"list\", \"leaf-list\", and \"uses\" statements can be used to define child nodes to the case node. The identifiers of all these child nodes MUST be unique within all cases in a choice. For example, the following is illegal:",
      "zh-CHS": "在“case”语句中，“anydata”、“anyxml”、“choice”、“container”、“leaf”、“list”、“leaf list”和“uses”语句可用于定义case节点的子节点。所有这些子节点的标识符在选项的所有情况下都必须是唯一的。例如，以下行为是非法的："
    },
    {
      "indent": 5,
      "text": "choice interface-type {     // This example is illegal YANG\n  case a {\n    leaf ethernet { ... }\n  }\n  case b {\n    container ethernet { ...}\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "As a shorthand, the \"case\" statement can be omitted if the branch contains a single \"anydata\", \"anyxml\", \"choice\", \"container\", \"leaf\", \"list\", or \"leaf-list\" statement. In this case, the case node still exists in the schema tree, and its identifier is the same as the identifier of the child node. Schema node identifiers (Section 6.5) MUST always explicitly include case node identifiers. The following example:",
      "zh-CHS": "简而言之，如果分支包含单个“anydata”、“anyxml”、“choice”、“container”、“leaf”、“list”或“leaf list”语句，则可以省略“case”语句。在这种情况下，案例节点仍然存在于模式树中，其标识符与子节点的标识符相同。模式节点标识符（第6.5节）必须始终明确包括案例节点标识符。下面是一个例子："
    },
    {
      "indent": 5,
      "text": "choice interface-type {\n  container ethernet { ... }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "is equivalent to:",
      "zh-CHS": "相当于："
    },
    {
      "indent": 5,
      "text": "choice interface-type {\n  case ethernet {\n    container ethernet { ... }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The case identifier MUST be unique within a choice.",
      "zh-CHS": "案例标识符在选项中必须是唯一的。"
    },
    {
      "indent": 0,
      "text": "7.9.2.1. The case's Substatements",
      "section_title": true,
      "zh-CHS": "7.9.2.1. 本案的子条款"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| anydata      | 7.10    | 0..n        |\n| anyxml       | 7.11    | 0..n        |\n| choice       | 7.9     | 0..n        |\n| container    | 7.5     | 0..n        |\n| description  | 7.21.3  | 0..1        |\n| if-feature   | 7.20.2  | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| uses         | 7.13    | 0..n        |\n| when         | 7.21.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.9.3. The choice's \"default\" Statement",
      "section_title": true,
      "zh-CHS": "7.9.3. 选项的“默认”语句"
    },
    {
      "indent": 3,
      "text": "The \"default\" statement indicates if a case should be considered as the default if no child nodes from any of the choice's cases exist. The argument is the identifier of the default \"case\" statement. If the \"default\" statement is missing, there is no default case.",
      "zh-CHS": "“default”语句表示如果该选项的任何案例都不存在子节点，则该案例是否应被视为默认案例。参数是默认“case”语句的标识符。如果缺少“default”语句，则不存在默认情况。"
    },
    {
      "indent": 3,
      "text": "The \"default\" statement MUST NOT be present on choices where \"mandatory\" is \"true\".",
      "zh-CHS": "“默认”语句不得出现在“强制”为“真”的选项上。"
    },
    {
      "indent": 3,
      "text": "The default case is only important when considering the \"default\" statements of nodes under the cases (i.e., default values of leafs and leaf-lists, and default cases of nested choices). The default values and nested default cases under the default case are used if none of the nodes under any of the cases are present.",
      "zh-CHS": "默认情况仅在考虑情况下节点的“默认”语句时才重要（即，叶和叶列表的默认值，以及嵌套选择的默认情况）。如果任何案例下的节点都不存在，则使用默认案例下的默认值和嵌套默认案例。"
    },
    {
      "indent": 3,
      "text": "There MUST NOT be any mandatory nodes (Section 3) directly under the default case.",
      "zh-CHS": "默认情况下不得有任何强制节点（第3节）。"
    },
    {
      "indent": 3,
      "text": "Default values for child nodes under a case are only used if one of the nodes under that case is present or if that case is the default case. If none of the nodes under a case are present and the case is not the default case, the default values of the cases' child nodes are ignored.",
      "zh-CHS": "仅当案例下的一个节点存在或该案例为默认案例时，才会使用该案例下的子节点的默认值。如果案例下的所有节点都不存在且案例不是默认案例，则案例子节点的默认值将被忽略。"
    },
    {
      "indent": 3,
      "text": "In this example, the choice defaults to \"interval\", and the default value will be used if none of \"daily\", \"time-of-day\", or \"manual\" are present. If \"daily\" is present, the default value for \"time-of-day\" will be used.",
      "zh-CHS": "在本例中，该选项默认为“interval”，如果“daily”、“time of day”或“manual”均不存在，则将使用默认值。如果存在“每日”，则将使用“每日时间”的默认值。"
    },
    {
      "indent": 5,
      "text": "container transfer {\n  choice how {\n    default interval;\n    case interval {\n      leaf interval {\n        type uint16;\n        units minutes;\n        default 30;\n      }\n    }\n    case daily {\n      leaf daily {\n        type empty;\n      }\n      leaf time-of-day {\n        type string;\n        units 24-hour-clock;\n        default \"01.00\";\n      }\n    }\n    case manual {\n      leaf manual {\n        type empty;\n      }\n    }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.9.4. The choice's \"mandatory\" Statement",
      "section_title": true,
      "zh-CHS": "7.9.4. 选择的“强制性”声明"
    },
    {
      "indent": 3,
      "text": "The \"mandatory\" statement, which is optional, takes as an argument the string \"true\" or \"false\" and puts a constraint on valid data. If \"mandatory\" is \"true\", at least one node from exactly one of the choice's case branches MUST exist.",
      "zh-CHS": "“mandatory”语句是可选的，它将字符串“true”或“false”作为参数，并对有效数据进行约束。如果“mandatory”为“true”，则必须至少存在一个节点，该节点恰好来自该选项的一个案例分支。"
    },
    {
      "indent": 3,
      "text": "If not specified, the default is \"false\".",
      "zh-CHS": "如果未指定，则默认值为“false”。"
    },
    {
      "indent": 3,
      "text": "The behavior of the constraint depends on the type of the choice's closest ancestor node in the schema tree that is not a non-presence container (see Section 7.5.1):",
      "zh-CHS": "约束的行为取决于模式树中选择的最近祖先节点的类型，该节点不是非存在容器（参见第7.5.1节）："
    },
    {
      "indent": 3,
      "text": "o If no such ancestor exists in the schema tree, the constraint is enforced.",
      "zh-CHS": "o 如果模式树中不存在这样的祖先，则强制执行约束。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, if this ancestor is a case node, the constraint is enforced if any other node from the case exists.",
      "zh-CHS": "o 否则，如果此祖先是案例节点，则如果案例中存在任何其他节点，则强制执行约束。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, it is enforced if the ancestor node exists.",
      "zh-CHS": "o 否则，如果祖先节点存在，则强制执行。"
    },
    {
      "indent": 3,
      "text": "The constraint is further enforced according to the rules in Section 8.",
      "zh-CHS": "根据第8节中的规则，进一步实施约束。"
    },
    {
      "indent": 0,
      "text": "7.9.5. XML Encoding Rules",
      "section_title": true,
      "zh-CHS": "7.9.5. XML编码规则"
    },
    {
      "indent": 3,
      "text": "The choice and case nodes are not visible in XML.",
      "zh-CHS": "choice和case节点在XML中不可见。"
    },
    {
      "indent": 3,
      "text": "The child nodes of the selected \"case\" statement MUST be encoded in the same order as they are defined in the \"case\" statement if they are part of an RPC or action input or output parameter definition. Otherwise, the subelements are encoded in any order.",
      "zh-CHS": "如果所选“case”语句的子节点是RPC或操作输入或输出参数定义的一部分，则必须按照在“case”语句中定义的顺序对其进行编码。否则，子元素按任意顺序编码。"
    },
    {
      "indent": 0,
      "text": "7.9.6. Usage Example",
      "section_title": true,
      "zh-CHS": "7.9.6. 用法示例"
    },
    {
      "indent": 3,
      "text": "Given the following choice:",
      "zh-CHS": "鉴于以下选择："
    },
    {
      "indent": 5,
      "text": "container protocol {\n  choice name {\n    case a {\n      leaf udp {\n        type empty;\n      }\n    }\n    case b {\n      leaf tcp {\n        type empty;\n      }\n    }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example:",
      "zh-CHS": "对应的XML实例示例："
    },
    {
      "indent": 5,
      "text": "<protocol>\n  <tcp/>\n</protocol>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "To change the protocol from TCP to UDP:",
      "zh-CHS": "要将协议从TCP更改为UDP，请执行以下操作："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <edit-config>\n    <target>\n      <running/>\n    </target>\n    <config>\n      <system xmlns=\"urn:example:config\">\n        <protocol>\n          <udp nc:operation=\"create\"/>\n        </protocol>\n      </system>\n    </config>\n  </edit-config>\n</rpc>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.10. The \"anydata\" Statement",
      "section_title": true,
      "zh-CHS": "7.10. “anydata”语句"
    },
    {
      "indent": 3,
      "text": "The \"anydata\" statement defines an interior node in the schema tree. It takes one argument, which is an identifier, followed by a block of substatements that holds detailed anydata information.",
      "zh-CHS": "“anydata”语句定义模式树中的内部节点。它有一个参数，它是一个标识符，后跟一个包含详细anydata信息的子语句块。"
    },
    {
      "indent": 3,
      "text": "The \"anydata\" statement is used to represent an unknown set of nodes that can be modeled with YANG, except anyxml, but for which the data model is not known at module design time. It is possible, though not required, for the data model for anydata content to become known through protocol signaling or other means that are outside the scope of this document.",
      "zh-CHS": "“anydata”语句用于表示可以使用YANG建模的未知节点集，anyxml除外，但在模块设计时数据模型未知。任何数据内容的数据模型都可以通过协议信令或本文件范围之外的其他方式而为人所知，尽管不是必需的。"
    },
    {
      "indent": 3,
      "text": "An example of where anydata can be useful is a list of received notifications where the specific notifications are not known at design time.",
      "zh-CHS": "anydata有用的一个示例是接收到的通知列表，其中特定的通知在设计时是未知的。"
    },
    {
      "indent": 3,
      "text": "An anydata node cannot be augmented (see Section 7.17).",
      "zh-CHS": "不能扩充anydata节点（参见第7.17节）。"
    },
    {
      "indent": 3,
      "text": "An anydata node exists in zero or one instance in the data tree.",
      "zh-CHS": "anydata节点存在于数据树中的零个或一个实例中。"
    },
    {
      "indent": 3,
      "text": "An implementation may or may not know the data model used to model a specific instance of an anydata node.",
      "zh-CHS": "实现可能知道也可能不知道用于对anydata节点的特定实例建模的数据模型。"
    },
    {
      "indent": 3,
      "text": "Since the use of anydata limits the manipulation of the content, the \"anydata\" statement SHOULD NOT be used to define configuration data.",
      "zh-CHS": "由于anydata的使用限制了对内容的操作，“anydata”语句不应用于定义配置数据。"
    },
    {
      "indent": 0,
      "text": "7.10.1. The anydata's Substatements",
      "section_title": true,
      "zh-CHS": "7.10.1. anydata的子语句"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| config       | 7.21.1  | 0..1        |\n| description  | 7.21.3  | 0..1        |\n| if-feature   | 7.20.2  | 0..n        |\n| mandatory    | 7.6.5   | 0..1        |\n| must         | 7.5.3   | 0..n        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| when         | 7.21.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.10.2. XML Encoding Rules",
      "section_title": true,
      "zh-CHS": "7.10.2. XML编码规则"
    },
    {
      "indent": 3,
      "text": "An anydata node is encoded as an XML element. The element's local name is the anydata's identifier, and its namespace is the module's XML namespace (see Section 7.1.3). The value of the anydata node is a set of nodes, which are encoded as XML subelements to the anydata element.",
      "zh-CHS": "anydata节点编码为XML元素。元素的本地名称是anydata的标识符，其名称空间是模块的XML名称空间（参见第7.1.3节）。anydata节点的值是一组节点，这些节点被编码为anydata元素的XML子元素。"
    },
    {
      "indent": 0,
      "text": "7.10.3. NETCONF <edit-config> Operations",
      "section_title": true,
      "zh-CHS": "7.10.3. NETCONF<edit config>操作"
    },
    {
      "indent": 3,
      "text": "An anydata node is treated as an opaque chunk of data. This data can be modified in its entirety only.",
      "zh-CHS": "anydata节点被视为不透明的数据块。此数据只能全部修改。"
    },
    {
      "indent": 3,
      "text": "Any \"operation\" attributes present on subelements of an anydata node are ignored by the NETCONF server.",
      "zh-CHS": "NETCONF服务器将忽略anydata节点子元素上的任何“操作”属性。"
    },
    {
      "indent": 3,
      "text": "When a NETCONF server processes an <edit-config> request, the elements of procedure for the anydata node are as follows:",
      "zh-CHS": "当NETCONF服务器处理<edit config>请求时，anydata节点的过程元素如下所示："
    },
    {
      "indent": 3,
      "text": "o If the operation is \"merge\" or \"replace\", the node is created if it does not exist, and its value is set to the subelements of the anydata node found in the XML RPC data.",
      "zh-CHS": "o 如果操作为“merge”或“replace”，则将在节点不存在时创建该节点，并将其值设置为在XML RPC数据中找到的anydata节点的子元素。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"create\", the node is created if it does not exist, and its value is set to the subelements of the anydata node found in the XML RPC data. If the node already exists, a \"data-exists\" error is returned.",
      "zh-CHS": "o 如果操作为“create”，则将在节点不存在时创建该节点，并将其值设置为在XML RPC数据中找到的anydata节点的子元素。如果节点已经存在，则返回“数据存在”错误。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"delete\", the node is deleted if it exists. If the node does not exist, a \"data-missing\" error is returned.",
      "zh-CHS": "o 如果操作为“删除”，则删除节点（如果存在）。如果节点不存在，则返回“数据丢失”错误。"
    },
    {
      "indent": 0,
      "text": "7.10.4. Usage Example",
      "section_title": true,
      "zh-CHS": "7.10.4. 用法示例"
    },
    {
      "indent": 3,
      "text": "Given the following \"anydata\" statement:",
      "zh-CHS": "给出以下“anydata”语句："
    },
    {
      "indent": 5,
      "text": "list logged-notification {\n  key time;\n  leaf time {\n    type yang:date-and-time;\n  }\n  anydata data;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The following is a valid encoding of such a list instance:",
      "zh-CHS": "以下是此类列表实例的有效编码："
    },
    {
      "indent": 5,
      "text": "<logged-notification>\n  <time>2014-07-29T13:43:12Z</time>\n  <data>\n    <notification\n      xmlns=\"urn:ietf:params:xml:ns:netconf:notification:1.0\">\n      <eventTime>2014-07-29T13:43:01Z</eventTime>\n      <event xmlns=\"urn:example:event\">\n        <event-class>fault</event-class>\n        <reporting-entity>\n          <card>Ethernet0</card>\n        </reporting-entity>\n        <severity>major</severity>\n      </event>\n    </notification>\n  </data>\n</logged-notification>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.11. The \"anyxml\" Statement",
      "section_title": true,
      "zh-CHS": "7.11. “anyxml”语句"
    },
    {
      "indent": 3,
      "text": "The \"anyxml\" statement defines an interior node in the schema tree. It takes one argument, which is an identifier, followed by a block of substatements that holds detailed anyxml information.",
      "zh-CHS": "“anyxml”语句在模式树中定义一个内部节点。它有一个参数，它是一个标识符，后跟一个包含详细的anyxml信息的子语句块。"
    },
    {
      "indent": 3,
      "text": "The \"anyxml\" statement is used to represent an unknown chunk of XML. No restrictions are placed on the XML. This can be useful, for example, in RPC replies. An example is the <filter> parameter in the <get-config> operation in NETCONF.",
      "zh-CHS": "“anyxml”语句用于表示未知的XML块。对XML没有任何限制。这可能很有用，例如，在RPC回复中。一个例子是NETCONF中<get config>操作中的<filter>参数。"
    },
    {
      "indent": 3,
      "text": "An anyxml node cannot be augmented (see Section 7.17).",
      "zh-CHS": "不能扩充anyxml节点（参见第7.17节）。"
    },
    {
      "indent": 3,
      "text": "An anyxml node exists in zero or one instance in the data tree.",
      "zh-CHS": "anyxml节点存在于数据树中的零个或一个实例中。"
    },
    {
      "indent": 3,
      "text": "Since the use of anyxml limits the manipulation of the content, the \"anyxml\" statement SHOULD NOT be used to define configuration data.",
      "zh-CHS": "由于anyxml的使用限制了对内容的操作，“anyxml”语句不应用于定义配置数据。"
    },
    {
      "indent": 3,
      "text": "It should be noted that in YANG version 1, \"anyxml\" was the only statement that could model an unknown hierarchy of data. In many cases, this unknown hierarchy of data is actually modeled in YANG, but the specific YANG data model is not known at design time. In these situations, it is RECOMMENDED to use \"anydata\" (Section 7.10) instead of \"anyxml\".",
      "zh-CHS": "应该注意的是，在YANG版本1中，“anyxml”是唯一可以对未知数据层次结构建模的语句。在许多情况下，这种未知的数据层次结构实际上是在YANG中建模的，但具体的YANG数据模型在设计时是未知的。在这些情况下，建议使用“anydata”（第7.10节）而不是“anyxml”。"
    },
    {
      "indent": 0,
      "text": "7.11.1. The anyxml's Substatements",
      "section_title": true,
      "zh-CHS": "7.11.1. anyxml的子语句"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| config       | 7.21.1  | 0..1        |\n| description  | 7.21.3  | 0..1        |\n| if-feature   | 7.20.2  | 0..n        |\n| mandatory    | 7.6.5   | 0..1        |\n| must         | 7.5.3   | 0..n        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| when         | 7.21.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.11.2. XML Encoding Rules",
      "section_title": true,
      "zh-CHS": "7.11.2. XML编码规则"
    },
    {
      "indent": 3,
      "text": "An anyxml node is encoded as an XML element. The element's local name is the anyxml's identifier, and its namespace is the module's XML namespace (see Section 7.1.3). The value of the anyxml node is encoded as XML content of this element.",
      "zh-CHS": "anyxml节点编码为XML元素。元素的本地名称是anyxml的标识符，其名称空间是模块的XML名称空间（参见第7.1.3节）。anyxml节点的值被编码为该元素的XML内容。"
    },
    {
      "indent": 3,
      "text": "Note that any XML prefixes used in the encoding are local to each instance encoding. This means that the same XML may be encoded differently by different implementations.",
      "zh-CHS": "请注意，编码中使用的任何XML前缀都是每个实例编码的本地前缀。这意味着相同的XML可以通过不同的实现进行不同的编码。"
    },
    {
      "indent": 0,
      "text": "7.11.3. NETCONF <edit-config> Operations",
      "section_title": true,
      "zh-CHS": "7.11.3. NETCONF<edit config>操作"
    },
    {
      "indent": 3,
      "text": "An anyxml node is treated as an opaque chunk of data. This data can be modified in its entirety only.",
      "zh-CHS": "anyxml节点被视为不透明的数据块。此数据只能全部修改。"
    },
    {
      "indent": 3,
      "text": "Any \"operation\" attributes present on subelements of an anyxml node are ignored by the NETCONF server.",
      "zh-CHS": "NETCONF服务器将忽略anyxml节点子元素上的任何“操作”属性。"
    },
    {
      "indent": 3,
      "text": "When a NETCONF server processes an <edit-config> request, the elements of procedure for the anyxml node are as follows:",
      "zh-CHS": "当NETCONF服务器处理<edit config>请求时，anyxml节点的过程元素如下所示："
    },
    {
      "indent": 3,
      "text": "o If the operation is \"merge\" or \"replace\", the node is created if it does not exist, and its value is set to the XML content of the anyxml node found in the XML RPC data.",
      "zh-CHS": "o 如果操作为“merge”或“replace”，则将在节点不存在时创建该节点，并将其值设置为在XML RPC数据中找到的anyxml节点的XML内容。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"create\", the node is created if it does not exist, and its value is set to the XML content of the anyxml node found in the XML RPC data. If the node already exists, a \"data-exists\" error is returned.",
      "zh-CHS": "o 如果操作为“create”，则将在节点不存在时创建该节点，并将其值设置为在XML RPC数据中找到的anyxml节点的XML内容。如果节点已经存在，则返回“数据存在”错误。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"delete\", the node is deleted if it exists. If the node does not exist, a \"data-missing\" error is returned.",
      "zh-CHS": "o 如果操作为“删除”，则删除节点（如果存在）。如果节点不存在，则返回“数据丢失”错误。"
    },
    {
      "indent": 0,
      "text": "7.11.4. Usage Example",
      "section_title": true,
      "zh-CHS": "7.11.4. 用法示例"
    },
    {
      "indent": 3,
      "text": "Given the following \"anyxml\" statement:",
      "zh-CHS": "给出以下“anyxml”语句："
    },
    {
      "indent": 5,
      "text": "anyxml html-info;",
      "zh-CHS": "任何XML html信息；"
    },
    {
      "indent": 3,
      "text": "The following are two valid encodings of the same anyxml value:",
      "zh-CHS": "以下是相同anyxml值的两个有效编码："
    },
    {
      "indent": 6,
      "text": "<html-info>\n  <p xmlns=\"http://www.w3.org/1999/xhtml\">\n    This is <em>very</em> cool.\n  </p>\n</html-info>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "<html-info>\n  <x:p xmlns:x=\"http://www.w3.org/1999/xhtml\">\n    This is <x:em>very</x:em> cool.\n  </x:p>\n</html-info>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.12. The \"grouping\" Statement",
      "section_title": true,
      "zh-CHS": "7.12. “分组”语句"
    },
    {
      "indent": 3,
      "text": "The \"grouping\" statement is used to define a reusable block of nodes, which may be used locally in the module or submodule, and by other modules that import from it, according to the rules in Section 5.5. It takes one argument, which is an identifier, followed by a block of substatements that holds detailed grouping information.",
      "zh-CHS": "“分组”语句用于定义一个可重用的节点块，根据第5.5节中的规则，该节点块可以在模块或子模块中本地使用，也可以由从中导入的其他模块使用。它采用一个参数（标识符），后跟一个包含详细分组信息的子语句块。"
    },
    {
      "indent": 3,
      "text": "The \"grouping\" statement is not a data definition statement and, as such, does not define any nodes in the schema tree.",
      "zh-CHS": "“grouping”语句不是数据定义语句，因此不定义模式树中的任何节点。"
    },
    {
      "indent": 3,
      "text": "A grouping is like a \"structure\" or a \"record\" in conventional programming languages.",
      "zh-CHS": "分组就像传统编程语言中的“结构”或“记录”。"
    },
    {
      "indent": 3,
      "text": "Once a grouping is defined, it can be referenced in a \"uses\" statement (see Section 7.13). A grouping MUST NOT reference itself, neither directly nor indirectly through a chain of other groupings.",
      "zh-CHS": "一旦定义了分组，就可以在“使用”语句中引用它（参见第7.13节）。分组不得直接或间接通过其他分组链引用自身。"
    },
    {
      "indent": 3,
      "text": "If the grouping is defined at the top level of a YANG module or submodule, the grouping's identifier MUST be unique within the module.",
      "zh-CHS": "如果分组是在模块或子模块的顶层定义的，则分组的标识符在模块内必须是唯一的。"
    },
    {
      "indent": 3,
      "text": "A grouping is more than just a mechanism for textual substitution; it also defines a collection of nodes. Identifiers appearing inside the grouping are resolved relative to the scope in which the grouping is defined, not where it is used. Prefix mappings, type names, grouping names, and extension usage are evaluated in the hierarchy",
      "zh-CHS": "分组不仅仅是一种文本替换机制；它还定义了一个节点集合。出现在分组中的标识符是相对于定义分组的范围而不是使用分组的位置来解析的。前缀映射、类型名称、分组名称和扩展使用在层次结构中进行评估"
    },
    {
      "indent": 3,
      "text": "where the \"grouping\" statement appears. For extensions, this means that extensions defined as direct children to a \"grouping\" statement are applied to the grouping itself.",
      "zh-CHS": "出现“分组”语句的位置。对于扩展，这意味着定义为“grouping”语句的直接子级的扩展将应用于分组本身。"
    },
    {
      "indent": 3,
      "text": "Note that if a grouping defines an action or a notification node in its hierarchy, then it cannot be used in all contexts. For example, it cannot be used in an rpc definition. See Sections 7.15 and 7.16.",
      "zh-CHS": "请注意，如果分组在其层次结构中定义了操作或通知节点，则不能在所有上下文中使用它。例如，它不能在rpc定义中使用。见第7.15节和第7.16节。"
    },
    {
      "indent": 0,
      "text": "7.12.1. The grouping's Substatements",
      "section_title": true,
      "zh-CHS": "7.12.1. 分组的子状态"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| action       | 7.15    | 0..n        |\n| anydata      | 7.10    | 0..n        |\n| anyxml       | 7.11    | 0..n        |\n| choice       | 7.9     | 0..n        |\n| container    | 7.5     | 0..n        |\n| description  | 7.21.3  | 0..1        |\n| grouping     | 7.12    | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| notification | 7.16    | 0..n        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| typedef      | 7.3     | 0..n        |\n| uses         | 7.13    | 0..n        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.12.2. Usage Example",
      "section_title": true,
      "zh-CHS": "7.12.2. 用法示例"
    },
    {
      "indent": 5,
      "text": "import ietf-inet-types {\n  prefix \"inet\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "grouping endpoint {\n  description \"A reusable endpoint group.\";\n  leaf ip {\n    type inet:ip-address;\n  }\n  leaf port {\n    type inet:port-number;\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.13. The \"uses\" Statement",
      "section_title": true,
      "zh-CHS": "7.13. “使用”语句"
    },
    {
      "indent": 3,
      "text": "The \"uses\" statement is used to reference a \"grouping\" definition. It takes one argument, which is the name of the grouping.",
      "zh-CHS": "“uses”语句用于引用“grouping”定义。它接受一个参数，即分组的名称。"
    },
    {
      "indent": 3,
      "text": "The effect of a \"uses\" reference to a grouping is that the nodes defined by the grouping are copied into the current schema tree and are then updated according to the \"refine\" and \"augment\" statements.",
      "zh-CHS": "对分组的“uses”引用的效果是将分组定义的节点复制到当前模式树中，然后根据“refine”和“augment”语句进行更新。"
    },
    {
      "indent": 3,
      "text": "The identifiers defined in the grouping are not bound to a namespace until the contents of the grouping are added to the schema tree via a \"uses\" statement that does not appear inside a \"grouping\" statement, at which point they are bound to the namespace of the current module.",
      "zh-CHS": "分组中定义的标识符不会绑定到名称空间，直到分组的内容通过“uses”语句添加到架构树中，该语句不出现在“grouping”语句中，此时它们被绑定到当前模块的名称空间。"
    },
    {
      "indent": 0,
      "text": "7.13.1. The uses's Substatements",
      "section_title": true,
      "zh-CHS": "7.13.1. 用户的子状态"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| augment      | 7.17    | 0..n        |\n| description  | 7.21.3  | 0..1        |\n| if-feature   | 7.20.2  | 0..n        |\n| reference    | 7.21.4  | 0..1        |\n| refine       | 7.13.2  | 0..n        |\n| status       | 7.21.2  | 0..1        |\n| when         | 7.21.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.13.2. The \"refine\" Statement",
      "section_title": true,
      "zh-CHS": "7.13.2. “细化”声明"
    },
    {
      "indent": 3,
      "text": "Some of the properties of each node in the grouping can be refined with the \"refine\" statement. The argument is a string that identifies a node in the grouping. This node is called the refine's target node. If a node in the grouping is not present as a target node of a \"refine\" statement, it is not refined and thus is used exactly as it was defined in the grouping.",
      "zh-CHS": "分组中每个节点的某些属性可以使用“refine”语句进行细化。参数是标识分组中节点的字符串。此节点称为优化的目标节点。如果分组中的某个节点未作为“refine”语句的目标节点出现，则该节点不会被细化，因此其使用方式与分组中定义的完全相同。"
    },
    {
      "indent": 3,
      "text": "The argument string is a descendant schema node identifier (see Section 6.5).",
      "zh-CHS": "参数字符串是子模式节点标识符（参见第6.5节）。"
    },
    {
      "indent": 3,
      "text": "The following refinements can be done:",
      "zh-CHS": "可以进行以下改进："
    },
    {
      "indent": 3,
      "text": "o A leaf or choice node may get a default value, or a new default value if it already had one.",
      "zh-CHS": "o 叶节点或选择节点可能会获得默认值，如果已经有默认值，则可能会获得新的默认值。"
    },
    {
      "indent": 3,
      "text": "o A leaf-list node may get a set of default values, or a new set of default values if it already had defaults; i.e., the set of refined default values replaces the defaults already given.",
      "zh-CHS": "o 叶列表节点可以获得一组默认值，如果已经有默认值，则可以获得一组新的默认值；i、 例如，经过优化的默认值集将替换已经给定的默认值。"
    },
    {
      "indent": 3,
      "text": "o Any node may get a specialized \"description\" string.",
      "zh-CHS": "o 任何节点都可以获得专门的“描述”字符串。"
    },
    {
      "indent": 3,
      "text": "o Any node may get a specialized \"reference\" string.",
      "zh-CHS": "o 任何节点都可以获得专门的“引用”字符串。"
    },
    {
      "indent": 3,
      "text": "o Any node may get a different \"config\" statement.",
      "zh-CHS": "o 任何节点都可能得到不同的“config”语句。"
    },
    {
      "indent": 3,
      "text": "o A leaf, anydata, anyxml, or choice node may get a different \"mandatory\" statement.",
      "zh-CHS": "o 叶、anydata、anyxml或choice节点可能会得到不同的“强制”语句。"
    },
    {
      "indent": 3,
      "text": "o A container node may get a \"presence\" statement.",
      "zh-CHS": "o 容器节点可能会得到“presence”语句。"
    },
    {
      "indent": 3,
      "text": "o A leaf, leaf-list, list, container, anydata, or anyxml node may get additional \"must\" expressions.",
      "zh-CHS": "o 叶、叶列表、列表、容器、anydata或anyxml节点可能会获得其他“必须”表达式。"
    },
    {
      "indent": 3,
      "text": "o A leaf-list or list node may get a different \"min-elements\" or \"max-elements\" statement.",
      "zh-CHS": "o 叶列表或列表节点可能会得到不同的“最小元素”或“最大元素”语句。"
    },
    {
      "indent": 3,
      "text": "o A leaf, leaf-list, list, container, choice, case, anydata, or anyxml node may get additional \"if-feature\" expressions.",
      "zh-CHS": "o 叶、叶列表、列表、容器、选项、大小写、anydata或anyxml节点可能会得到额外的“if-feature”表达式。"
    },
    {
      "indent": 3,
      "text": "o Any node can get refined extensions, if the extension allows refinement. See Section 7.19 for details.",
      "zh-CHS": "o 如果扩展允许细化，任何节点都可以获得细化扩展。详见第7.19节。"
    },
    {
      "indent": 0,
      "text": "7.13.3. XML Encoding Rules",
      "section_title": true,
      "zh-CHS": "7.13.3. XML编码规则"
    },
    {
      "indent": 3,
      "text": "Each node in the grouping is encoded as if it was defined inline, even if it is imported from another module with another XML namespace.",
      "zh-CHS": "分组中的每个节点都被编码为内联定义，即使它是从另一个具有另一个XML命名空间的模块导入的。"
    },
    {
      "indent": 0,
      "text": "7.13.4. Usage Example",
      "section_title": true,
      "zh-CHS": "7.13.4. 用法示例"
    },
    {
      "indent": 3,
      "text": "To use the \"endpoint\" grouping defined in Section 7.12.2 in a definition of an HTTP server in some other module, we can do:",
      "zh-CHS": "要在其他模块的HTTP服务器定义中使用第7.12.2节中定义的“端点”分组，我们可以执行以下操作："
    },
    {
      "indent": 5,
      "text": "import example-system {\n  prefix \"sys\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "container http-server {\n  leaf name {\n    type string;\n  }\n  uses sys:endpoint;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example:",
      "zh-CHS": "对应的XML实例示例："
    },
    {
      "indent": 5,
      "text": "<http-server>\n  <name>extern-web</name>\n  <ip>192.0.2.1</ip>\n  <port>80</port>\n</http-server>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "If port 80 should be the default for the HTTP server, a default can be added:",
      "zh-CHS": "如果HTTP服务器的默认端口为80，则可以添加默认端口："
    },
    {
      "indent": 5,
      "text": "container http-server {\n  leaf name {\n    type string;\n  }\n  uses sys:endpoint {\n    refine port {\n      default 80;\n    }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "If we want to define a list of servers and each server has \"ip\" and \"port\" as keys, we can do:",
      "zh-CHS": "如果我们要定义一个服务器列表，并且每个服务器都有“ip”和“端口”作为密钥，我们可以执行以下操作："
    },
    {
      "indent": 5,
      "text": "list server {\n  key \"ip port\";\n  leaf name {\n    type string;\n  }\n  uses sys:endpoint;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The following is an error:",
      "zh-CHS": "以下是一个错误："
    },
    {
      "indent": 5,
      "text": "container http-server {\n  uses sys:endpoint;\n  leaf ip {          // illegal - same identifier \"ip\" used twice\n    type string;\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.14. The \"rpc\" Statement",
      "section_title": true,
      "zh-CHS": "7.14. “rpc”语句"
    },
    {
      "indent": 3,
      "text": "The \"rpc\" statement is used to define an RPC operation. It takes one argument, which is an identifier, followed by a block of substatements that holds detailed rpc information. This argument is the name of the RPC.",
      "zh-CHS": "“rpc”语句用于定义rpc操作。它有一个参数，它是一个标识符，后跟一个包含详细rpc信息的子语句块。此参数是RPC的名称。"
    },
    {
      "indent": 3,
      "text": "The \"rpc\" statement defines an rpc node in the schema tree. Under the rpc node, a schema node with the name \"input\" and a schema node with the name \"output\" are also defined. The nodes \"input\" and \"output\" are defined in the module's namespace.",
      "zh-CHS": "“rpc”语句在模式树中定义了一个rpc节点。在rpc节点下，还定义了名为“input”的模式节点和名为“output”的模式节点。节点“输入”和“输出”在模块的命名空间中定义。"
    },
    {
      "indent": 0,
      "text": "7.14.1. The rpc's Substatements",
      "section_title": true,
      "zh-CHS": "7.14.1. rpc的子状态"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| description  | 7.21.3  | 0..1        |\n| grouping     | 7.12    | 0..n        |\n| if-feature   | 7.20.2  | 0..n        |\n| input        | 7.14.2  | 0..1        |\n| output       | 7.14.3  | 0..1        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| typedef      | 7.3     | 0..n        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.14.2. The \"input\" Statement",
      "section_title": true,
      "zh-CHS": "7.14.2. “输入”语句"
    },
    {
      "indent": 3,
      "text": "The \"input\" statement, which is optional, is used to define input parameters to the operation. It does not take an argument. The substatements to \"input\" define nodes under the operation's input node.",
      "zh-CHS": "“input”语句是可选的，用于定义操作的输入参数。这不需要争论。“input”的子语句定义操作输入节点下的节点。"
    },
    {
      "indent": 3,
      "text": "If a leaf in the input tree has a \"mandatory\" statement with the value \"true\", the leaf MUST be present in an RPC invocation.",
      "zh-CHS": "如果输入树中的某个叶具有值为“true”的“强制”语句，则该叶必须存在于RPC调用中。"
    },
    {
      "indent": 3,
      "text": "If a leaf in the input tree has a default value, the server MUST use this value in the same cases as those described in Section 7.6.1. In these cases, the server MUST operationally behave as if the leaf was present in the RPC invocation with the default value as its value.",
      "zh-CHS": "如果输入树中的叶具有默认值，则服务器必须在与第7.6.1节所述相同的情况下使用该值。在这些情况下，服务器必须在操作上表现得像RPC调用中存在叶一样，并以默认值作为其值。"
    },
    {
      "indent": 3,
      "text": "If a leaf-list in the input tree has one or more default values, the server MUST use these values in the same cases as those described in Section 7.7.2. In these cases, the server MUST operationally behave as if the leaf-list was present in the RPC invocation with the default values as its values.",
      "zh-CHS": "如果输入树中的叶列表具有一个或多个默认值，则服务器必须在与第7.7.2节所述相同的情况下使用这些值。在这些情况下，服务器必须在操作上表现得像RPC调用中存在叶列表一样，并使用默认值作为其值。"
    },
    {
      "indent": 3,
      "text": "Since the input tree is not part of any datastore, all \"config\" statements for nodes in the input tree are ignored.",
      "zh-CHS": "由于输入树不是任何数据存储的一部分，因此将忽略输入树中节点的所有“config”语句。"
    },
    {
      "indent": 3,
      "text": "If any node has a \"when\" statement that would evaluate to \"false\", then this node MUST NOT be present in the input tree.",
      "zh-CHS": "如果任何节点的“when”语句的计算结果为“false”，则该节点不得出现在输入树中。"
    },
    {
      "indent": 0,
      "text": "7.14.2.1. The input's Substatements",
      "section_title": true,
      "zh-CHS": "7.14.2.1. 输入的子语句"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| anydata      | 7.10    | 0..n        |\n| anyxml       | 7.11    | 0..n        |\n| choice       | 7.9     | 0..n        |\n| container    | 7.5     | 0..n        |\n| grouping     | 7.12    | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| must         | 7.5.3   | 0..n        |\n| typedef      | 7.3     | 0..n        |\n| uses         | 7.13    | 0..n        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.14.3. The \"output\" Statement",
      "section_title": true,
      "zh-CHS": "7.14.3. “输出”语句"
    },
    {
      "indent": 3,
      "text": "The \"output\" statement, which is optional, is used to define output parameters to the RPC operation. It does not take an argument. The substatements to \"output\" define nodes under the operation's output node.",
      "zh-CHS": "“output”语句是可选的，用于定义RPC操作的输出参数。这不需要争论。“output”的子语句定义操作的输出节点下的节点。"
    },
    {
      "indent": 3,
      "text": "If a leaf in the output tree has a \"mandatory\" statement with the value \"true\", the leaf MUST be present in an RPC reply.",
      "zh-CHS": "如果输出树中的某个叶具有值为“true”的“mandatory”语句，则该叶必须出现在RPC应答中。"
    },
    {
      "indent": 3,
      "text": "If a leaf in the output tree has a default value, the client MUST use this value in the same cases as those described in Section 7.6.1. In these cases, the client MUST operationally behave as if the leaf was present in the RPC reply with the default value as its value.",
      "zh-CHS": "如果输出树中的叶具有默认值，则客户端必须在与第7.6.1节所述相同的情况下使用该值。在这些情况下，客户端必须在操作上表现得像RPC应答中存在叶一样，并将默认值作为其值。"
    },
    {
      "indent": 3,
      "text": "If a leaf-list in the output tree has one or more default values, the client MUST use these values in the same cases as those described in Section 7.7.2. In these cases, the client MUST operationally behave as if the leaf-list was present in the RPC reply with the default values as its values.",
      "zh-CHS": "如果输出树中的叶列表具有一个或多个默认值，则客户端必须在与第7.7.2节所述相同的情况下使用这些值。在这些情况下，客户端必须在操作上表现得像RPC应答中存在叶列表一样，并使用默认值作为其值。"
    },
    {
      "indent": 3,
      "text": "Since the output tree is not part of any datastore, all \"config\" statements for nodes in the output tree are ignored.",
      "zh-CHS": "由于输出树不是任何数据存储的一部分，因此将忽略输出树中节点的所有“config”语句。"
    },
    {
      "indent": 3,
      "text": "If any node has a \"when\" statement that would evaluate to \"false\", then this node MUST NOT be present in the output tree.",
      "zh-CHS": "如果任何节点的“when”语句的计算结果为“false”，则该节点不得出现在输出树中。"
    },
    {
      "indent": 0,
      "text": "7.14.3.1. The output's Substatements",
      "section_title": true,
      "zh-CHS": "7.14.3.1. 输出的子语句"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| anydata      | 7.10    | 0..n        |\n| anyxml       | 7.11    | 0..n        |\n| choice       | 7.9     | 0..n        |\n| container    | 7.5     | 0..n        |\n| grouping     | 7.12    | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| must         | 7.5.3   | 0..n        |\n| typedef      | 7.3     | 0..n        |\n| uses         | 7.13    | 0..n        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.14.4. NETCONF XML Encoding Rules",
      "section_title": true,
      "zh-CHS": "7.14.4. NETCONF XML编码规则"
    },
    {
      "indent": 3,
      "text": "An rpc node is encoded as a child XML element to the <rpc> element, as designated by the substitution group \"rpcOperation\" in [RFC6241]. The element's local name is the rpc's identifier, and its namespace is the module's XML namespace (see Section 7.1.3).",
      "zh-CHS": "rpc节点被编码为<rpc>元素的子XML元素，由[RFC6241]中的替换组“rpcOperation”指定。元素的本地名称是rpc的标识符，其名称空间是模块的XML名称空间（参见第7.1.3节）。"
    },
    {
      "indent": 3,
      "text": "Input parameters are encoded as child XML elements to the rpc node's XML element, in the same order as they are defined within the \"input\" statement.",
      "zh-CHS": "输入参数被编码为rpc节点XML元素的子XML元素，其顺序与“Input”语句中定义的顺序相同。"
    },
    {
      "indent": 3,
      "text": "If the RPC operation invocation succeeded and no output parameters are returned, the <rpc-reply> contains a single <ok/> element defined in [RFC6241]. If output parameters are returned, they are encoded as child elements to the <rpc-reply> element defined in [RFC6241], in the same order as they are defined within the \"output\" statement.",
      "zh-CHS": "如果RPC操作调用成功且未返回任何输出参数，<RPC reply>包含[RFC6241]中定义的单个<ok/>元素。如果返回输出参数，则将其编码为[RFC6241]中定义的<rpc reply>元素的子元素，其顺序与“output”语句中定义的顺序相同。"
    },
    {
      "indent": 0,
      "text": "7.14.5. Usage Example",
      "section_title": true,
      "zh-CHS": "7.14.5. 用法示例"
    },
    {
      "indent": 3,
      "text": "The following example defines an RPC operation:",
      "zh-CHS": "以下示例定义了RPC操作："
    },
    {
      "indent": 5,
      "text": "module example-rock {\n  yang-version 1.1;\n  namespace \"urn:example:rock\";\n  prefix \"rock\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "  rpc rock-the-house {\n    input {\n      leaf zip-code {\n        type string;\n      }\n    }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example of the complete rpc and rpc-reply:",
      "zh-CHS": "完整rpc和rpc应答的对应XML实例示例："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <rock-the-house xmlns=\"urn:example:rock\">\n    <zip-code>27606-0100</zip-code>\n  </rock-the-house>\n</rpc>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "<rpc-reply message-id=\"101\"\n           xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <ok/>\n</rpc-reply>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.15. The \"action\" Statement",
      "section_title": true,
      "zh-CHS": "7.15. “行动”声明"
    },
    {
      "indent": 3,
      "text": "The \"action\" statement is used to define an operation connected to a specific container or list data node. It takes one argument, which is an identifier, followed by a block of substatements that holds detailed action information. The argument is the name of the action.",
      "zh-CHS": "“action”语句用于定义连接到特定容器或列表数据节点的操作。它有一个参数，它是一个标识符，后跟一个包含详细操作信息的子语句块。参数是操作的名称。"
    },
    {
      "indent": 3,
      "text": "The \"action\" statement defines an action node in the schema tree. Under the action node, a schema node with the name \"input\" and a schema node with the name \"output\" are also defined. The nodes \"input\" and \"output\" are defined in the module's namespace.",
      "zh-CHS": "“action”语句在模式树中定义了一个action节点。在action节点下，还定义了名为“input”的模式节点和名为“output”的模式节点。节点“输入”和“输出”在模块的命名空间中定义。"
    },
    {
      "indent": 3,
      "text": "An action MUST NOT be defined within an rpc, another action, or a notification, i.e., an action node MUST NOT have an rpc, action, or a notification node as one of its ancestors in the schema tree. For example, this means that it is an error if a grouping that contains an action somewhere in its node hierarchy is used in a notification definition.",
      "zh-CHS": "不得在rpc、其他操作或通知中定义操作，即操作节点不得将rpc、操作或通知节点作为其在架构树中的祖先之一。例如，这意味着如果在通知定义中使用了在其节点层次结构中某处包含操作的分组，则这是一个错误。"
    },
    {
      "indent": 3,
      "text": "An action MUST NOT have any ancestor node that is a list node without a \"key\" statement.",
      "zh-CHS": "操作不能有任何祖先节点是没有“key”语句的列表节点。"
    },
    {
      "indent": 3,
      "text": "Since an action cannot be defined at the top level of a module or in a \"case\" statement, it is an error if a grouping that contains an action at the top of its node hierarchy is used at the top level of a module or in a case definition.",
      "zh-CHS": "由于无法在模块的顶层或“case”语句中定义操作，因此，如果在模块的顶层或案例定义中使用在其节点层次结构顶部包含操作的分组，则为错误。"
    },
    {
      "indent": 3,
      "text": "The difference between an action and an rpc is that an action is tied to a node in the datastore, whereas an rpc is not. When an action is invoked, the node in the datastore is specified along with the name of the action and the input parameters.",
      "zh-CHS": "动作和rpc之间的区别在于动作绑定到数据存储中的节点，而rpc不绑定。调用操作时，将指定数据存储中的节点以及操作的名称和输入参数。"
    },
    {
      "indent": 0,
      "text": "7.15.1. The action's Substatements",
      "section_title": true,
      "zh-CHS": "7.15.1. 动作的子状态"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| description  | 7.21.3  | 0..1        |\n| grouping     | 7.12    | 0..n        |\n| if-feature   | 7.20.2  | 0..n        |\n| input        | 7.14.2  | 0..1        |\n| output       | 7.14.3  | 0..1        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| typedef      | 7.3     | 0..n        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.15.2. NETCONF XML Encoding Rules",
      "section_title": true,
      "zh-CHS": "7.15.2. NETCONF XML编码规则"
    },
    {
      "indent": 3,
      "text": "When an action is invoked, an element with the local name \"action\" in the namespace \"urn:ietf:params:xml:ns:yang:1\" (see Section 5.3.1) is encoded as a child XML element to the <rpc> element defined in [RFC6241], as designated by the substitution group \"rpcOperation\" in [RFC6241].",
      "zh-CHS": "调用操作时，命名空间“urn:ietf:params:xml:ns:yang:1”（参见第5.3.1节）中本地名为“action”的元素将被编码为[RFC6241]中定义的<rpc>元素的子xml元素，由[RFC6241]中的替换组“rpcOperation”指定。"
    },
    {
      "indent": 3,
      "text": "The <action> element contains a hierarchy of nodes that identifies the node in the datastore. It MUST contain all containers and list nodes in the direct path from the top level down to the list or container containing the action. For lists, all key leafs MUST also be included. The innermost container or list contains an XML element that carries the name of the defined action. Within this element, the input parameters are encoded as child XML elements, in the same order as they are defined within the \"input\" statement.",
      "zh-CHS": "<action>元素包含一个节点层次结构，用于标识数据存储中的节点。它必须包含从顶层到包含操作的列表或容器的直接路径中的所有容器和列表节点。对于列表，还必须包括所有键叶。最里面的容器或列表包含一个XML元素，该元素携带已定义操作的名称。在这个元素中，输入参数被编码为子XML元素，其顺序与“input”语句中定义的顺序相同。"
    },
    {
      "indent": 3,
      "text": "Only one action can be invoked in one <rpc>. If more than one action is present in the <rpc>, the server MUST reply with a \"bad-element\" <error-tag> in the <rpc-error>.",
      "zh-CHS": "在一个<rpc>中只能调用一个操作。如果<rpc>中存在多个操作，服务器必须在<rpc error>中使用“bad element”<error tag>进行响应。"
    },
    {
      "indent": 3,
      "text": "If the action operation invocation succeeded and no output parameters are returned, the <rpc-reply> contains a single <ok/> element defined in [RFC6241]. If output parameters are returned, they are encoded as child elements to the <rpc-reply> element defined in [RFC6241], in the same order as they are defined within the \"output\" statement.",
      "zh-CHS": "如果操作调用成功且未返回任何输出参数，<rpc reply>包含[RFC6241]中定义的单个<ok/>元素。如果返回输出参数，则将其编码为[RFC6241]中定义的<rpc reply>元素的子元素，其顺序与“output”语句中定义的顺序相同。"
    },
    {
      "indent": 0,
      "text": "7.15.3. Usage Example",
      "section_title": true,
      "zh-CHS": "7.15.3. 用法示例"
    },
    {
      "indent": 3,
      "text": "The following example defines an action to reset one server at a server farm:",
      "zh-CHS": "以下示例定义了在服务器场重置一台服务器的操作："
    },
    {
      "indent": 5,
      "text": "module example-server-farm {\n  yang-version 1.1;\n  namespace \"urn:example:server-farm\";\n  prefix \"sfarm\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "import ietf-yang-types {\n  prefix \"yang\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": " list server {\n   key name;\n   leaf name {\n     type string;\n   }\n   action reset {\n     input {\n       leaf reset-at {\n         type yang:date-and-time;\n         mandatory true;\n        }\n      }\n      output {\n        leaf reset-finished-at {\n          type yang:date-and-time;\n          mandatory true;\n        }\n      }\n    }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example of the complete rpc and rpc-reply:",
      "zh-CHS": "完整rpc和rpc应答的对应XML实例示例："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <action xmlns=\"urn:ietf:params:xml:ns:yang:1\">\n    <server xmlns=\"urn:example:server-farm\">\n      <name>apache-1</name>\n      <reset>\n        <reset-at>2014-07-29T13:42:00Z</reset-at>\n      </reset>\n    </server>\n  </action>\n</rpc>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "<rpc-reply message-id=\"101\"\n           xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <reset-finished-at xmlns=\"urn:example:server-farm\">\n    2014-07-29T13:42:12Z\n  </reset-finished-at>\n</rpc-reply>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.16. The \"notification\" Statement",
      "section_title": true,
      "zh-CHS": "7.16. “通知”声明"
    },
    {
      "indent": 3,
      "text": "The \"notification\" statement is used to define a notification. It takes one argument, which is an identifier, followed by a block of substatements that holds detailed notification information. The \"notification\" statement defines a notification node in the schema tree.",
      "zh-CHS": "“通知”语句用于定义通知。它有一个参数，它是一个标识符，后跟一个包含详细通知信息的子语句块。“notification”语句在模式树中定义了一个通知节点。"
    },
    {
      "indent": 3,
      "text": "A notification can be defined at the top level of a module, or connected to a specific container or list data node in the schema tree.",
      "zh-CHS": "通知可以在模块的顶层定义，也可以连接到模式树中的特定容器或列表数据节点。"
    },
    {
      "indent": 3,
      "text": "A notification MUST NOT be defined within an rpc, action, or another notification, i.e., a notification node MUST NOT have an rpc, action, or a notification node as one of its ancestors in the schema tree. For example, this means that it is an error if a grouping that contains a notification somewhere in its node hierarchy is used in an rpc definition.",
      "zh-CHS": "通知不得在rpc、操作或其他通知中定义，即通知节点不得将rpc、操作或通知节点作为其在架构树中的祖先之一。例如，这意味着，如果在rpc定义中使用了在其节点层次结构中某处包含通知的分组，则这是一个错误。"
    },
    {
      "indent": 3,
      "text": "A notification MUST NOT have any ancestor node that is a list node without a \"key\" statement.",
      "zh-CHS": "通知不能有任何祖先节点是没有“key”语句的列表节点。"
    },
    {
      "indent": 3,
      "text": "Since a notification cannot be defined in a \"case\" statement, it is an error if a grouping that contains a notification at the top of its node hierarchy is used in a case definition.",
      "zh-CHS": "由于无法在“case”语句中定义通知，因此，如果在案例定义中使用在其节点层次结构顶部包含通知的分组，则为错误。"
    },
    {
      "indent": 3,
      "text": "If a leaf in the notification tree has a \"mandatory\" statement with the value \"true\", the leaf MUST be present in a notification instance.",
      "zh-CHS": "如果通知树中的某个叶具有值为“true”的“强制”语句，则该叶必须存在于通知实例中。"
    },
    {
      "indent": 3,
      "text": "If a leaf in the notification tree has a default value, the client MUST use this value in the same cases as those described in Section 7.6.1. In these cases, the client MUST operationally behave as if the leaf was present in the notification instance with the default value as its value.",
      "zh-CHS": "如果通知树中的某个叶具有默认值，则客户端必须在与第7.6.1节所述相同的情况下使用该值。在这些情况下，客户机必须在操作上表现得像通知实例中的叶一样，并以默认值作为其值。"
    },
    {
      "indent": 3,
      "text": "If a leaf-list in the notification tree has one or more default values, the client MUST use these values in the same cases as those described in Section 7.7.2. In these cases, the client MUST operationally behave as if the leaf-list was present in the notification instance with the default values as its values.",
      "zh-CHS": "如果通知树中的叶列表具有一个或多个默认值，则客户端必须在与第7.7.2节所述相同的情况下使用这些值。在这些情况下，客户机必须在操作上表现为通知实例中存在叶列表，并使用默认值作为其值。"
    },
    {
      "indent": 3,
      "text": "Since the notification tree is not part of any datastore, all \"config\" statements for nodes in the notification tree are ignored.",
      "zh-CHS": "由于通知树不是任何数据存储的一部分，因此将忽略通知树中节点的所有“config”语句。"
    },
    {
      "indent": 0,
      "text": "7.16.1. The notification's Substatements",
      "section_title": true,
      "zh-CHS": "7.16.1. 通知的子语句"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| anydata      | 7.10    | 0..n        |\n| anyxml       | 7.11    | 0..n        |\n| choice       | 7.9     | 0..n        |\n| container    | 7.5     | 0..n        |\n| description  | 7.21.3  | 0..1        |\n| grouping     | 7.12    | 0..n        |\n| if-feature   | 7.20.2  | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| must         | 7.5.3   | 0..n        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| typedef      | 7.3     | 0..n        |\n| uses         | 7.13    | 0..n        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.16.2. NETCONF XML Encoding Rules",
      "section_title": true,
      "zh-CHS": "7.16.2. NETCONF XML编码规则"
    },
    {
      "indent": 3,
      "text": "A notification node that is defined on the top level of a module is encoded as a child XML element to the <notification> element defined in \"NETCONF Event Notifications\" [RFC5277]. The element's local name is the notification's identifier, and its namespace is the module's XML namespace (see Section 7.1.3).",
      "zh-CHS": "在模块顶层定义的通知节点被编码为“NETCONF事件通知”[RFC5277]中定义的<notification>元素的子XML元素。元素的本地名称是通知的标识符，其名称空间是模块的XML名称空间（参见第7.1.3节）。"
    },
    {
      "indent": 3,
      "text": "When a notification node is defined as a child to a data node, the <notification> element defined in [RFC5277] contains a hierarchy of nodes that identifies the node in the datastore. It MUST contain all containers and list nodes from the top level down to the list or container containing the notification. For lists, all key leafs MUST also be included. The innermost container or list contains an XML element that carries the name of the defined notification.",
      "zh-CHS": "当将通知节点定义为数据节点的子节点时，[RFC5277]中定义的<notification>元素包含一个节点层次结构，用于标识数据存储中的节点。它必须包含从顶层到包含通知的列表或容器的所有容器和列表节点。对于列表，还必须包括所有键叶。最里面的容器或列表包含一个XML元素，该元素携带已定义通知的名称。"
    },
    {
      "indent": 3,
      "text": "The notification's child nodes are encoded as subelements to the notification node's XML element, in any order.",
      "zh-CHS": "通知的子节点按任意顺序编码为通知节点XML元素的子元素。"
    },
    {
      "indent": 0,
      "text": "7.16.3. Usage Example",
      "section_title": true,
      "zh-CHS": "7.16.3. 用法示例"
    },
    {
      "indent": 3,
      "text": "The following example defines a notification at the top level of a module:",
      "zh-CHS": "以下示例定义了模块顶层的通知："
    },
    {
      "indent": 5,
      "text": "module example-event {\n  yang-version 1.1;\n  namespace \"urn:example:event\";\n  prefix \"ev\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "  notification event {\n    leaf event-class {\n      type string;\n    }\n    leaf reporting-entity {\n      type instance-identifier;\n    }\n    leaf severity {\n      type string;\n    }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example of the complete notification:",
      "zh-CHS": "完整通知的对应XML实例示例："
    },
    {
      "indent": 5,
      "text": "<notification\n  xmlns=\"urn:ietf:params:xml:ns:netconf:notification:1.0\">\n  <eventTime>2008-07-08T00:01:00Z</eventTime>\n  <event xmlns=\"urn:example:event\">\n    <event-class>fault</event-class>\n    <reporting-entity>\n      /ex:interface[ex:name='Ethernet0']\n    </reporting-entity>\n    <severity>major</severity>\n  </event>\n</notification>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The following example defines a notification in a data node:",
      "zh-CHS": "以下示例定义了数据节点中的通知："
    },
    {
      "indent": 5,
      "text": "module example-interface-module {\n  yang-version 1.1;\n  namespace \"urn:example:interface-module\";\n  prefix \"if\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "  container interfaces {\n    list interface {\n      key \"name\";\n      leaf name {\n        type string;\n      }\n      notification interface-enabled {\n        leaf by-user {\n          type string;\n        }\n      }\n    }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example of the complete notification:",
      "zh-CHS": "完整通知的对应XML实例示例："
    },
    {
      "indent": 5,
      "text": "<notification\n  xmlns=\"urn:ietf:params:xml:ns:netconf:notification:1.0\">\n  <eventTime>2008-07-08T00:01:00Z</eventTime>\n  <interfaces xmlns=\"urn:example:interface-module\">\n    <interface>\n      <name>eth1</name>\n      <interface-enabled>\n        <by-user>fred</by-user>\n      </interface-enabled>\n    </interface>\n  </interfaces>\n</notification>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.17. The \"augment\" Statement",
      "section_title": true,
      "zh-CHS": "7.17. “增强”语句"
    },
    {
      "indent": 3,
      "text": "The \"augment\" statement allows a module or submodule to add to a schema tree defined in an external module, or in the current module and its submodules, and to add to the nodes from a grouping in a \"uses\" statement. The argument is a string that identifies a node in the schema tree. This node is called the augment's target node. The target node MUST be either a container, list, choice, case, input, output, or notification node. It is augmented with the nodes defined in the substatements that follow the \"augment\" statement.",
      "zh-CHS": "“augment”语句允许模块或子模块添加到外部模块或当前模块及其子模块中定义的模式树，并从“uses”语句中的分组添加到节点。参数是标识架构树中节点的字符串。此节点称为增强的目标节点。目标节点必须是容器、列表、选项、大小写、输入、输出或通知节点。它通过“augment”语句后面的子语句中定义的节点进行扩充。"
    },
    {
      "indent": 3,
      "text": "The argument string is a schema node identifier (see Section 6.5). If the \"augment\" statement is on the top level in a module or submodule, the absolute form (defined by the rule \"absolute-schema-nodeid\" in Section 14) of a schema node identifier MUST be used. If the \"augment\" statement is a substatement to the \"uses\" statement, the descendant form (defined by the rule \"descendant-schema-nodeid\" in Section 14) MUST be used.",
      "zh-CHS": "参数字符串是一个模式节点标识符（参见第6.5节）。如果“augment”语句位于模块或子模块的顶层，则必须使用模式节点标识符的绝对形式（由第14节中的“绝对模式节点标识”规则定义）。如果“augment”语句是“uses”语句的子语句，则必须使用子体形式（由第14节中的规则“后代模式nodeid”定义）。"
    },
    {
      "indent": 3,
      "text": "If the target node is a container, list, case, input, output, or notification node, the \"container\", \"leaf\", \"list\", \"leaf-list\", \"uses\", and \"choice\" statements can be used within the \"augment\" statement.",
      "zh-CHS": "如果目标节点是容器、列表、案例、输入、输出或通知节点，“容器”、“叶”、“列表”、“叶列表”、“使用”和“选择”语句可以在“增强”语句中使用。"
    },
    {
      "indent": 3,
      "text": "If the target node is a container or list node, the \"action\" and \"notification\" statements can be used within the \"augment\" statement.",
      "zh-CHS": "如果目标节点是容器或列表节点，“action”和“notification”语句可以在“augment”语句中使用。"
    },
    {
      "indent": 3,
      "text": "If the target node is a choice node, the \"case\" statement or a shorthand \"case\" statement (see Section 7.9.2) can be used within the \"augment\" statement.",
      "zh-CHS": "如果目标节点是选择节点，“case”语句或简写的“case”语句（见第7.9.2节）可在“AUMMENT”语句中使用。"
    },
    {
      "indent": 3,
      "text": "The \"augment\" statement MUST NOT add multiple nodes with the same name from the same module to the target node.",
      "zh-CHS": "“augment”语句不能将同一模块中具有相同名称的多个节点添加到目标节点。"
    },
    {
      "indent": 3,
      "text": "If the augmentation adds mandatory nodes (see Section 3) that represent configuration to a target node in another module, the augmentation MUST be made conditional with a \"when\" statement. Care must be taken when defining the \"when\" expression so that clients that do not know about the augmenting module do not break.",
      "zh-CHS": "如果扩充向另一个模块中的目标节点添加表示配置的强制节点（参见第3节），则必须使用“when”语句对扩充进行条件化。定义“when”表达式时必须小心，以便不知道扩充模块的客户端不会中断。"
    },
    {
      "indent": 3,
      "text": "In the following example, it is OK to augment the \"interface\" entry with \"mandatory-leaf\" because the augmentation depends on support for \"some-new-iftype\". The old client does not know about this type, so it would never select this type and would therefore not be adding a mandatory data node.",
      "zh-CHS": "在下面的示例中，可以使用“mandatory leaf”来扩充“interface”条目，因为扩充依赖于对“somenewiftype”的支持。旧客户端不知道此类型，因此它永远不会选择此类型，因此不会添加强制数据节点。"
    },
    {
      "indent": 5,
      "text": "module example-augment {\n  yang-version 1.1;\n  namespace \"urn:example:augment\";\n  prefix mymod;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "import ietf-interfaces {\n  prefix if;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "identity some-new-iftype {\n   base if:interface-type;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "augment \"/if:interfaces/if:interface\" {\n   when 'derived-from-or-self(if:type, \"mymod:some-new-iftype\")';",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "     leaf mandatory-leaf {\n        mandatory true;\n        type string;\n     }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.17.1. The augment's Substatements",
      "section_title": true,
      "zh-CHS": "7.17.1. 增广子状态"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| action       | 7.15    | 0..n        |\n| anydata      | 7.10    | 0..n        |\n| anyxml       | 7.11    | 0..n        |\n| case         | 7.9.2   | 0..n        |\n| choice       | 7.9     | 0..n        |\n| container    | 7.5     | 0..n        |\n| description  | 7.21.3  | 0..1        |\n| if-feature   | 7.20.2  | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| notification | 7.16    | 0..n        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| uses         | 7.13    | 0..n        |\n| when         | 7.21.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.17.2. XML Encoding Rules",
      "section_title": true,
      "zh-CHS": "7.17.2. XML编码规则"
    },
    {
      "indent": 3,
      "text": "All data nodes defined in the \"augment\" statement are defined as XML elements in the XML namespace of the module where the \"augment\" is specified.",
      "zh-CHS": "“augment”语句中定义的所有数据节点都在指定“augment”的模块的XML命名空间中定义为XML元素。"
    },
    {
      "indent": 3,
      "text": "When a node is augmented, the augmenting child nodes are encoded as subelements to the augmented node, in any order.",
      "zh-CHS": "当一个节点被扩充时，扩充的子节点以任何顺序被编码为扩充节点的子元素。"
    },
    {
      "indent": 0,
      "text": "7.17.3. Usage Example",
      "section_title": true,
      "zh-CHS": "7.17.3. 用法示例"
    },
    {
      "indent": 3,
      "text": "In namespace urn:example:interface-module, we have:",
      "zh-CHS": "在名称空间urn:example:interface module中，我们有："
    },
    {
      "indent": 5,
      "text": "container interfaces {\n  list ifEntry {\n    key \"ifIndex\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "    leaf ifIndex {\n      type uint32;\n    }\n    leaf ifDescr {\n      type string;\n    }\n    leaf ifType {\n      type iana:IfType;\n    }\n    leaf ifMtu {\n      type int32;\n    }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Then, in namespace urn:example:ds0, we have:",
      "zh-CHS": "然后，在名称空间urn:example:ds0中，我们有："
    },
    {
      "indent": 5,
      "text": "import example-interface-module {\n  prefix \"if\";\n}\naugment \"/if:interfaces/if:ifEntry\" {\n  when \"if:ifType='ds0'\";\n  leaf ds0ChannelNumber {\n    type ChannelNumber;\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example:",
      "zh-CHS": "对应的XML实例示例："
    },
    {
      "indent": 5,
      "text": "<interfaces xmlns=\"urn:example:interface-module\"\n            xmlns:ds0=\"urn:example:ds0\">\n  <ifEntry>\n    <ifIndex>1</ifIndex>\n    <ifDescr>Flintstone Inc Ethernet A562</ifDescr>\n    <ifType>ethernetCsmacd</ifType>\n    <ifMtu>1500</ifMtu>\n  </ifEntry>\n  <ifEntry>\n    <ifIndex>2</ifIndex>\n    <ifDescr>Flintstone Inc DS0</ifDescr>\n    <ifType>ds0</ifType>\n    <ds0:ds0ChannelNumber>1</ds0:ds0ChannelNumber>\n  </ifEntry>\n</interfaces>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "As another example, suppose we have the choice defined in Section 7.9.6. The following construct can be used to extend the protocol definition:",
      "zh-CHS": "作为另一个例子，假设我们有第7.9.6节中定义的选择。以下构造可用于扩展协议定义："
    },
    {
      "indent": 5,
      "text": "augment /ex:system/ex:protocol/ex:name {\n  case c {\n    leaf smtp {\n      type empty;\n    }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example:",
      "zh-CHS": "对应的XML实例示例："
    },
    {
      "indent": 5,
      "text": "<ex:system>\n  <ex:protocol>\n    <ex:tcp/>\n  </ex:protocol>\n</ex:system>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "or",
      "zh-CHS": "或"
    },
    {
      "indent": 5,
      "text": "<ex:system>\n  <ex:protocol>\n    <other:smtp/>\n  </ex:protocol>\n</ex:system>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.18. The \"identity\" Statement",
      "section_title": true,
      "zh-CHS": "7.18. “身份”声明"
    },
    {
      "indent": 3,
      "text": "The \"identity\" statement is used to define a new globally unique, abstract, and untyped identity. The identity's only purpose is to denote its name, semantics, and existence. An identity can be either defined from scratch or derived from one or more base identities. The identity's argument is an identifier that is the name of the identity. It is followed by a block of substatements that holds detailed identity information.",
      "zh-CHS": "“identity”语句用于定义新的全局唯一、抽象和非类型化标识。身份的唯一目的是表示其名称、语义和存在。标识可以从头定义，也可以从一个或多个基本标识派生。标识的参数是标识名的标识符。它后面是一个包含详细身份信息的子状态块。"
    },
    {
      "indent": 3,
      "text": "The built-in datatype \"identityref\" (see Section 9.10) can be used to reference identities within a data model.",
      "zh-CHS": "内置数据类型“identityref”（见第9.10节）可用于引用数据模型中的标识。"
    },
    {
      "indent": 0,
      "text": "7.18.1. The identity's Substatements",
      "section_title": true,
      "zh-CHS": "7.18.1. 身份的子状态"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| base         | 7.18.2  | 0..n        |\n| description  | 7.21.3  | 0..1        |\n| if-feature   | 7.20.2  | 0..n        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.18.2. The \"base\" Statement",
      "section_title": true,
      "zh-CHS": "7.18.2. “基本”陈述"
    },
    {
      "indent": 3,
      "text": "The \"base\" statement, which is optional, takes as an argument a string that is the name of an existing identity, from which the new identity is derived. If no \"base\" statement is present, the identity is defined from scratch. If multiple \"base\" statements are present, the identity is derived from all of them.",
      "zh-CHS": "“base”语句是可选的，它将一个字符串作为参数，该字符串是从中派生新标识的现有标识的名称。如果不存在“base”语句，则从零开始定义标识。如果存在多个“基本”语句，则标识将从所有这些语句派生。"
    },
    {
      "indent": 3,
      "text": "If a prefix is present on the base name, it refers to an identity defined in the module that was imported with that prefix, or the local module if the prefix matches the local module's prefix. Otherwise, an identity with the matching name MUST be defined in the current module or an included submodule.",
      "zh-CHS": "如果基名称上存在前缀，则它将引用在使用该前缀导入的模块中定义的标识，如果前缀与本地模块的前缀匹配，则它将引用本地模块中定义的标识。否则，必须在当前模块或包含的子模块中定义具有匹配名称的标识。"
    },
    {
      "indent": 3,
      "text": "An identity MUST NOT reference itself, neither directly nor indirectly through a chain of other identities.",
      "zh-CHS": "身份不能直接或间接地通过一系列其他身份来引用自身。"
    },
    {
      "indent": 3,
      "text": "The derivation of identities has the following properties:",
      "zh-CHS": "标识的派生具有以下属性："
    },
    {
      "indent": 3,
      "text": "o It is irreflexive, which means that an identity is not derived from itself.",
      "zh-CHS": "o 它是不可伸缩的，这意味着一个身份不是从它自身派生出来的。"
    },
    {
      "indent": 3,
      "text": "o It is transitive, which means that if identity B is derived from A and C is derived from B, then C is also derived from A.",
      "zh-CHS": "o 它是可传递的，也就是说，如果恒等式B是从A派生的，而C是从B派生的，那么C也是从A派生的。"
    },
    {
      "indent": 0,
      "text": "7.18.3. Usage Example",
      "section_title": true,
      "zh-CHS": "7.18.3. 用法示例"
    },
    {
      "indent": 5,
      "text": "module example-crypto-base {\n  yang-version 1.1;\n  namespace \"urn:example:crypto-base\";\n  prefix \"crypto\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "identity crypto-alg {\n  description\n    \"Base identity from which all crypto algorithms\n     are derived.\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "identity symmetric-key {\n  description\n    \"Base identity used to identify symmetric-key crypto\n     algorithms.\";\n  }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "  identity public-key {\n    description\n      \"Base identity used to identify public-key crypto\n       algorithms.\";\n    }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "module example-des {\n  yang-version 1.1;\n  namespace \"urn:example:des\";\n  prefix \"des\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "import \"example-crypto-base\" {\n  prefix \"crypto\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "identity des {\n  base \"crypto:crypto-alg\";\n  base \"crypto:symmetric-key\";\n  description \"DES crypto algorithm.\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "  identity des3 {\n    base \"crypto:crypto-alg\";\n    base \"crypto:symmetric-key\";\n    description \"Triple DES crypto algorithm.\";\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.19. The \"extension\" Statement",
      "section_title": true,
      "zh-CHS": "7.19. “扩展”声明"
    },
    {
      "indent": 3,
      "text": "The \"extension\" statement allows the definition of new statements within the YANG language. This new statement definition can be imported and used by other modules.",
      "zh-CHS": "“extension”语句允许在YANG语言中定义新语句。这个新的语句定义可以被其他模块导入和使用。"
    },
    {
      "indent": 3,
      "text": "The \"extension\" statement's argument is an identifier that is the new keyword for the extension and must be followed by a block of substatements that holds detailed extension information. The purpose of the \"extension\" statement is to define a keyword so that it can be imported and used by other modules.",
      "zh-CHS": "“extension”语句的参数是一个标识符，它是扩展的新关键字，后面必须跟一个包含详细扩展信息的子语句块。“extension”语句的目的是定义关键字，以便其他模块可以导入和使用它。"
    },
    {
      "indent": 3,
      "text": "The extension can be used like a normal YANG statement, with the statement name followed by an argument if one is defined by the \"extension\" statement, and an optional block of substatements. The statement's name is created by combining the prefix of the module in which the extension was defined, a colon (\":\"), and the extension's keyword, with no interleaving whitespace. The substatements of an extension are defined by the \"extension\" statement, using some mechanism outside the scope of this specification. Syntactically, the substatements MUST be YANG statements, including extensions defined using \"extension\" statements. YANG statements in extensions MUST follow the syntactical rules in Section 14.",
      "zh-CHS": "扩展可以像普通的YANG语句一样使用，如果由“extension”语句定义，则语句名后面跟着一个参数，以及一个可选的子语句块。该语句的名称是通过组合定义扩展的模块的前缀、冒号（“：”）和扩展的关键字创建的，没有交叉空格。扩展的子语句由“extension”语句定义，使用本规范范围之外的某种机制。在语法上，子语句必须是YANG语句，包括使用“extension”语句定义的扩展。扩展中的YANG语句必须遵循第14节中的语法规则。"
    },
    {
      "indent": 3,
      "text": "An extension can allow refinement (see Section 7.13.2) and deviations (Section 7.20.3.2), but the mechanism for how this is defined is outside the scope of this specification.",
      "zh-CHS": "扩展可允许细化（见第7.13.2节）和偏差（第7.20.3.2节），但其定义机制不在本规范范围内。"
    },
    {
      "indent": 0,
      "text": "7.19.1. The extension's Substatements",
      "section_title": true,
      "zh-CHS": "7.19.1. 扩展的子状态"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| argument     | 7.19.2  | 0..1        |\n| description  | 7.21.3  | 0..1        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.19.2. The \"argument\" Statement",
      "section_title": true,
      "zh-CHS": "7.19.2. “论点”陈述"
    },
    {
      "indent": 3,
      "text": "The \"argument\" statement, which is optional, takes as an argument a string that is the name of the argument to the keyword. If no \"argument\" statement is present, the keyword expects no argument when it is used.",
      "zh-CHS": "“argument”语句是可选的，它将作为关键字参数名称的字符串作为参数。如果不存在“argument”语句，则使用关键字时不需要参数。"
    },
    {
      "indent": 3,
      "text": "The argument's name is used in the YIN mapping, where it is used as an XML attribute or element name, depending on the argument's \"yin-element\" statement.",
      "zh-CHS": "参数的名称在YIN映射中使用，根据参数的“YIN-element”语句，它被用作XML属性或元素名称。"
    },
    {
      "indent": 0,
      "text": "7.19.2.1. The argument's Substatement",
      "section_title": true,
      "zh-CHS": "7.19.2.1. 论点的替代物"
    },
    {
      "indent": 17,
      "text": "+--------------+----------+-------------+\n| substatement | section  | cardinality |\n+--------------+----------+-------------+\n| yin-element  | 7.19.2.2 | 0..1        |\n+--------------+----------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.19.2.2. The \"yin-element\" Statement",
      "section_title": true,
      "zh-CHS": "7.19.2.2. “阴素”说"
    },
    {
      "indent": 3,
      "text": "The \"yin-element\" statement, which is optional, takes as an argument the string \"true\" or \"false\". This statement indicates whether the argument is mapped to an XML element in YIN or to an XML attribute (see Section 13).",
      "zh-CHS": "“yin元素”语句是可选的，它将字符串“true”或“false”作为参数。此语句指示参数是映射到YIN中的XML元素还是映射到XML属性（请参见第13节）。"
    },
    {
      "indent": 3,
      "text": "If no \"yin-element\" statement is present, it defaults to \"false\".",
      "zh-CHS": "如果不存在“阴元素”语句，则默认为“false”。"
    },
    {
      "indent": 0,
      "text": "7.19.3. Usage Example",
      "section_title": true,
      "zh-CHS": "7.19.3. 用法示例"
    },
    {
      "indent": 3,
      "text": "To define an extension:",
      "zh-CHS": "要定义扩展，请执行以下操作："
    },
    {
      "indent": 5,
      "text": "module example-extensions {\n  yang-version 1.1;\n  ...",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "  extension c-define {\n    description\n      \"Takes as an argument a name string.\n       Makes the code generator use the given name\n       in the #define.\";\n    argument \"name\";\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "To use the extension:",
      "zh-CHS": "要使用扩展名，请执行以下操作："
    },
    {
      "indent": 5,
      "text": "module example-interfaces {\n  yang-version 1.1;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "...\nimport example-extensions {\n  prefix \"myext\";\n}\n...",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "  container interfaces {\n    ...\n    myext:c-define \"MY_INTERFACES\";\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.20. Conformance-Related Statements",
      "section_title": true,
      "zh-CHS": "7.20. 一致性相关声明"
    },
    {
      "indent": 3,
      "text": "This section defines statements related to conformance, as described in Section 5.6.",
      "zh-CHS": "本节定义了与合规性相关的声明，如第5.6节所述。"
    },
    {
      "indent": 0,
      "text": "7.20.1. The \"feature\" Statement",
      "section_title": true,
      "zh-CHS": "7.20.1. “特色”声明"
    },
    {
      "indent": 3,
      "text": "The \"feature\" statement is used to define a mechanism by which portions of the schema are marked as conditional. A feature name is defined that can later be referenced using the \"if-feature\" statement (see Section 7.20.2). Schema nodes tagged with an \"if-feature\" statement are ignored by the server unless the server supports the given feature expression. This allows portions of the YANG module to be conditional based on conditions in the server. The model can represent the abilities of the server within the model, giving a richer model that allows for differing server abilities and roles.",
      "zh-CHS": "“feature”语句用于定义一种机制，通过该机制将模式的某些部分标记为条件。定义了一个特征名称，该名称可在以后使用“如果特征”语句引用（见第7.20.2节）。除非服务器支持给定的功能表达式，否则使用“if-feature”语句标记的模式节点将被服务器忽略。这允许模块的某些部分根据服务器中的条件设置条件。该模型可以表示模型中服务器的能力，提供了一个更丰富的模型，允许不同的服务器能力和角色。"
    },
    {
      "indent": 3,
      "text": "The argument to the \"feature\" statement is the name of the new feature and follows the rules for identifiers in Section 6.2. This name is used by the \"if-feature\" statement to tie the schema nodes to the feature.",
      "zh-CHS": "“feature”语句的参数是新特性的名称，并遵循第6.2节中的标识符规则。“if-feature”语句使用此名称将架构节点绑定到该功能。"
    },
    {
      "indent": 3,
      "text": "In this example, a feature called \"local-storage\" represents the ability for a server to store syslog messages on local storage of some sort. This feature is used to make the \"local-storage-limit\" leaf conditional on the presence of some sort of local storage. If the server does not report that it supports this feature, the \"local-storage-limit\" node is not supported.",
      "zh-CHS": "在本例中，名为“本地存储”的功能表示服务器能够在某种本地存储上存储系统日志消息。此功能用于使“本地存储限制”叶以存在某种本地存储为条件。如果服务器未报告它支持此功能，则不支持“本地存储限制”节点。"
    },
    {
      "indent": 5,
      "text": "module example-syslog {\n  yang-version 1.1;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "...\nfeature local-storage {\n  description\n    \"This feature means that the server supports local\n     storage (memory, flash, or disk) that can be used to\n     store syslog messages.\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "  container syslog {\n    leaf local-storage-limit {\n      if-feature local-storage;\n      type uint64;\n      units \"kilobyte\";\n      config false;\n      description\n        \"The amount of local storage that can be\n         used to hold syslog messages.\";\n    }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The \"if-feature\" statement can be used in many places within the YANG syntax. Definitions tagged with \"if-feature\" are ignored when the server does not support that feature.",
      "zh-CHS": "“if-feature”语句可以在YANG语法中的许多地方使用。当服务器不支持该功能时，将忽略标记为“if feature”的定义。"
    },
    {
      "indent": 3,
      "text": "A feature MUST NOT reference itself, neither directly nor indirectly through a chain of other features.",
      "zh-CHS": "特征不得直接或间接通过一系列其他特征引用自身。"
    },
    {
      "indent": 3,
      "text": "In order for a server to support a feature that is dependent on any other features (i.e., the feature has one or more \"if-feature\" substatements), the server MUST also support all the dependent features.",
      "zh-CHS": "为了使服务器支持依赖于任何其他功能的功能（即，该功能具有一个或多个“如果功能”子状态），服务器还必须支持所有依赖功能。"
    },
    {
      "indent": 0,
      "text": "7.20.1.1. The feature's Substatements",
      "section_title": true,
      "zh-CHS": "7.20.1.1. 要素的子状态"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| description  | 7.21.3  | 0..1        |\n| if-feature   | 7.20.2  | 0..n        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.20.2. The \"if-feature\" Statement",
      "section_title": true,
      "zh-CHS": "7.20.2. “if feature”语句"
    },
    {
      "indent": 3,
      "text": "The \"if-feature\" statement makes its parent statement conditional. The argument is a boolean expression over feature names. In this expression, a feature name evaluates to \"true\" if and only if the feature is supported by the server. The parent statement is implemented by servers where the boolean expression evaluates to \"true\".",
      "zh-CHS": "“if feature”语句使其父语句具有条件。参数是要素名称上的布尔表达式。在此表达式中，当且仅当服务器支持功能时，功能名称的计算结果为“true”。父语句由布尔表达式计算结果为“true”的服务器实现。"
    },
    {
      "indent": 3,
      "text": "The if-feature boolean expression syntax is formally defined by the rule \"if-feature-expr\" in Section 14. Parentheses are used to group expressions. When the expression is evaluated, the order of precedence is (highest precedence first): grouping (parentheses), \"not\", \"and\", \"or\".",
      "zh-CHS": "if功能布尔表达式语法由第14节中的“if功能表达式”规则正式定义。括号用于对表达式进行分组。计算表达式时，优先级顺序为（最高优先级优先）：分组（括号）、“非”、“或”。"
    },
    {
      "indent": 3,
      "text": "If a prefix is present on a feature name in the boolean expression, the prefixed name refers to a feature defined in the module that was imported with that prefix, or the local module if the prefix matches the local module's prefix. Otherwise, a feature with the matching name MUST be defined in the current module or an included submodule.",
      "zh-CHS": "如果布尔表达式中的要素名称上存在前缀，则带前缀的名称将引用在使用该前缀导入的模块中定义的要素，如果前缀与本地模块的前缀匹配，则引用本地模块。否则，必须在当前模块或包含的子模块中定义具有匹配名称的功能。"
    },
    {
      "indent": 3,
      "text": "A leaf that is a list key MUST NOT have any \"if-feature\" statements.",
      "zh-CHS": "作为列表键的叶不能有任何“if feature”语句。"
    },
    {
      "indent": 0,
      "text": "7.20.2.1. Usage Example",
      "section_title": true,
      "zh-CHS": "7.20.2.1. 用法示例"
    },
    {
      "indent": 3,
      "text": "In this example, the container \"target\" is implemented if either the \"outbound-tls\" or \"outbound-ssh\" feature is supported by the server.",
      "zh-CHS": "在本例中，如果服务器支持“出站tls”或“出站ssh”功能，则实现容器“target”。"
    },
    {
      "indent": 5,
      "text": "container target {\n  if-feature \"outbound-tls or outbound-ssh\";\n  ...\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The following examples are equivalent:",
      "zh-CHS": "以下示例是等效的："
    },
    {
      "indent": 5,
      "text": "if-feature \"not foo or bar and baz\";",
      "zh-CHS": "如果功能“不是foo或bar和baz”；"
    },
    {
      "indent": 5,
      "text": "if-feature \"(not foo) or (bar and baz)\";",
      "zh-CHS": "如果特征“（非foo）或（bar和baz）”；"
    },
    {
      "indent": 0,
      "text": "7.20.3. The \"deviation\" Statement",
      "section_title": true,
      "zh-CHS": "7.20.3. “偏差”陈述"
    },
    {
      "indent": 3,
      "text": "The \"deviation\" statement defines a hierarchy of a module that the server does not implement faithfully. The argument is a string that identifies the node in the schema tree where a deviation from the module occurs. This node is called the deviation's target node. The contents of the \"deviation\" statement give details about the deviation.",
      "zh-CHS": "“偏差”语句定义了服务器无法忠实实现的模块层次结构。参数是一个字符串，用于标识模式树中发生模块偏差的节点。该节点称为偏差的目标节点。“偏差”声明的内容给出了偏差的详细信息。"
    },
    {
      "indent": 3,
      "text": "The argument string is an absolute schema node identifier (see Section 6.5).",
      "zh-CHS": "参数字符串是绝对模式节点标识符（参见第6.5节）。"
    },
    {
      "indent": 3,
      "text": "Deviations define the way a server or class of servers deviate from a standard. This means that deviations MUST never be part of a published standard, since they are the mechanism for learning how implementations vary from the standards.",
      "zh-CHS": "偏差定义服务器或服务器类别偏离标准的方式。这意味着偏差决不能成为已发布标准的一部分，因为它们是了解实现如何与标准不同的机制。"
    },
    {
      "indent": 3,
      "text": "Server deviations are strongly discouraged and MUST only be used as a last resort. Telling the application how a server fails to follow a standard is no substitute for implementing the standard correctly. A server that deviates from a module is not fully compliant with the module.",
      "zh-CHS": "强烈反对服务器偏差，并且只能作为最后手段使用。告诉应用程序服务器如何未能遵循标准不能代替正确实现标准。偏离模块的服务器与该模块不完全兼容。"
    },
    {
      "indent": 3,
      "text": "However, in some cases, a particular device may not have the hardware or software ability to support parts of a standard module. When this occurs, the server makes a choice to either treat attempts to configure unsupported parts of the module as an error that is reported back to the unsuspecting application or ignore those incoming requests. Neither choice is acceptable.",
      "zh-CHS": "然而，在某些情况下，特定设备可能没有硬件或软件能力来支持标准模块的部分。发生这种情况时，服务器会选择将配置模块不受支持部分的尝试视为一个错误，并报告给不知情的应用程序，或者忽略这些传入的请求。这两种选择都是不可接受的。"
    },
    {
      "indent": 3,
      "text": "Instead, YANG allows servers to document portions of a base module that are not supported, or that are supported but with different syntax, by using the \"deviation\" statement.",
      "zh-CHS": "相反，YANG允许服务器使用“偏差”语句记录基本模块中不受支持的部分，或受支持但语法不同的部分。"
    },
    {
      "indent": 3,
      "text": "After applying all deviations announced by a server, in any order, the resulting data model MUST still be valid.",
      "zh-CHS": "在以任何顺序应用服务器宣布的所有偏差后，生成的数据模型必须仍然有效。"
    },
    {
      "indent": 0,
      "text": "7.20.3.1. The deviation's Substatements",
      "section_title": true,
      "zh-CHS": "7.20.3.1. 偏差的子状态"
    },
    {
      "indent": 17,
      "text": "+--------------+----------+-------------+\n| substatement | section  | cardinality |\n+--------------+----------+-------------+\n| description  | 7.21.3   | 0..1        |\n| deviate      | 7.20.3.2 | 1..n        |\n| reference    | 7.21.4   | 0..1        |\n+--------------+----------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.20.3.2. The \"deviate\" Statement",
      "section_title": true,
      "zh-CHS": "7.20.3.2. “偏离”陈述"
    },
    {
      "indent": 3,
      "text": "The \"deviate\" statement defines how the server's implementation of the target node deviates from its original definition. The argument is one of the strings \"not-supported\", \"add\", \"replace\", or \"delete\".",
      "zh-CHS": "“偏离”语句定义了服务器对目标节点的实现如何偏离其原始定义。参数是字符串“不支持”、“添加”、“替换”或“删除”之一。"
    },
    {
      "indent": 3,
      "text": "The argument \"not-supported\" indicates that the target node is not implemented by this server.",
      "zh-CHS": "参数“not supported”表示此服务器未实现目标节点。"
    },
    {
      "indent": 3,
      "text": "The argument \"add\" adds properties to the target node. The properties to add are identified by substatements to the \"deviate\" statement. If a property can only appear once, the property MUST NOT exist in the target node.",
      "zh-CHS": "参数“add”将属性添加到目标节点。要添加的属性由“偏离”语句的子语句标识。如果属性只能出现一次，则该属性不得存在于目标节点中。"
    },
    {
      "indent": 3,
      "text": "The argument \"replace\" replaces properties of the target node. The properties to replace are identified by substatements to the \"deviate\" statement. The properties to replace MUST exist in the target node.",
      "zh-CHS": "参数“replace”替换目标节点的属性。要替换的属性由“偏离”语句的子语句标识。要替换的属性必须存在于目标节点中。"
    },
    {
      "indent": 3,
      "text": "The argument \"delete\" deletes properties from the target node. The properties to delete are identified by substatements to the \"delete\" statement. The substatement's keyword MUST match a corresponding keyword in the target node, and the argument's string MUST be equal to the corresponding keyword's argument string in the target node.",
      "zh-CHS": "参数“delete”从目标节点删除属性。要删除的属性由“delete”语句的子语句标识。子状态的关键字必须与目标节点中相应的关键字匹配，并且参数的字符串必须等于目标节点中相应关键字的参数字符串。"
    },
    {
      "indent": 15,
      "text": "+--------------+--------------+-------------+\n| substatement | section      | cardinality |\n+--------------+--------------+-------------+\n| config       | 7.21.1       | 0..1        |\n| default      | 7.6.4, 7.7.4 | 0..n        |\n| mandatory    | 7.6.5        | 0..1        |\n| max-elements | 7.7.6        | 0..1        |\n| min-elements | 7.7.5        | 0..1        |\n| must         | 7.5.3        | 0..n        |\n| type         | 7.4          | 0..1        |\n| unique       | 7.8.3        | 0..n        |\n| units        | 7.3.3        | 0..1        |\n+--------------+--------------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 24,
      "text": "The deviate's Substatements",
      "zh-CHS": "偏离子状态"
    },
    {
      "indent": 3,
      "text": "If the target node has a property defined by an extension, this property can be deviated if the extension allows deviations. See Section 7.19 for details.",
      "zh-CHS": "如果目标节点具有由扩展定义的属性，则如果扩展允许偏差，则该属性可以偏差。详见第7.19节。"
    },
    {
      "indent": 0,
      "text": "7.20.3.3. Usage Example",
      "section_title": true,
      "zh-CHS": "7.20.3.3. 用法示例"
    },
    {
      "indent": 3,
      "text": "In this example, the server is informing client applications that it does not support the \"daytime\" service in the style of RFC 867.",
      "zh-CHS": "在本例中，服务器通知客户端应用程序它不支持RFC 867样式的“日间”服务。"
    },
    {
      "indent": 5,
      "text": "module example-deviations {\n  yang-version 1.1;\n  namespace \"urn:example:deviations\";\n  prefix md;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "import example-base {\n  prefix base;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "  deviation /base:system/base:daytime {\n    deviate not-supported;\n  }\n  ...\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "A server would advertise both modules \"example-base\" and \"example-deviations\".",
      "zh-CHS": "服务器将公布模块“示例库”和“示例偏差”。"
    },
    {
      "indent": 3,
      "text": "The following example sets a server-specific default value to a leaf that does not have a default value defined:",
      "zh-CHS": "以下示例将特定于服务器的默认值设置为未定义默认值的叶："
    },
    {
      "indent": 5,
      "text": "deviation /base:system/base:user/base:type {\n  deviate add {\n    default \"admin\"; // new users are 'admin' by default\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "In this example, the server limits the number of name servers to 3:",
      "zh-CHS": "在此示例中，服务器将名称服务器的数量限制为3："
    },
    {
      "indent": 5,
      "text": "deviation /base:system/base:name-server {\n  deviate replace {\n    max-elements 3;\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "If the original definition is:",
      "zh-CHS": "如果原始定义为："
    },
    {
      "indent": 5,
      "text": "container system {\n  must \"daytime or time\";\n  ...\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "a server might remove this \"must\" constraint by doing:",
      "zh-CHS": "服务器可以通过以下操作删除此“必须”约束："
    },
    {
      "indent": 5,
      "text": "deviation /base:system {\n  deviate delete {\n    must \"daytime or time\";\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.21. Common Statements",
      "section_title": true,
      "zh-CHS": "7.21. 共同声明"
    },
    {
      "indent": 3,
      "text": "This section defines substatements common to several other statements.",
      "zh-CHS": "本节定义了几个其他语句共有的子语句。"
    },
    {
      "indent": 0,
      "text": "7.21.1. The \"config\" Statement",
      "section_title": true,
      "zh-CHS": "7.21.1. “config”语句"
    },
    {
      "indent": 3,
      "text": "The \"config\" statement takes as an argument the string \"true\" or \"false\". If \"config\" is \"true\", the definition represents configuration. Data nodes representing configuration are part of configuration datastores.",
      "zh-CHS": "“config”语句将字符串“true”或“false”作为参数。如果“config”为“true”，则定义表示配置。表示配置的数据节点是配置数据存储的一部分。"
    },
    {
      "indent": 3,
      "text": "If \"config\" is \"false\", the definition represents state data. Data nodes representing state data are not part of configuration datastores.",
      "zh-CHS": "如果“config”为“false”，则定义表示状态数据。表示状态数据的数据节点不是配置数据存储的一部分。"
    },
    {
      "indent": 3,
      "text": "If \"config\" is not specified, the default is the same as the parent schema node's \"config\" value. If the parent node is a case node, the value is the same as the case node's parent choice node.",
      "zh-CHS": "如果未指定“config”，则默认值与父架构节点的“config”值相同。如果父节点是案例节点，则该值与案例节点的父选择节点相同。"
    },
    {
      "indent": 3,
      "text": "If the top node does not specify a \"config\" statement, the default is \"true\".",
      "zh-CHS": "如果顶部节点未指定“config”语句，则默认值为“true”。"
    },
    {
      "indent": 3,
      "text": "If a node has \"config\" set to \"false\", no node underneath it can have \"config\" set to \"true\".",
      "zh-CHS": "如果一个节点的“config”设置为“false”，那么它下面的任何节点都不能将“config”设置为“true”。"
    },
    {
      "indent": 0,
      "text": "7.21.2. The \"status\" Statement",
      "section_title": true,
      "zh-CHS": "7.21.2. “地位”声明"
    },
    {
      "indent": 3,
      "text": "The \"status\" statement takes as an argument one of the strings \"current\", \"deprecated\", or \"obsolete\".",
      "zh-CHS": "“status”语句将字符串“current”、“deprecated”或“过时”中的一个作为参数。"
    },
    {
      "indent": 3,
      "text": "o \"current\" means that the definition is current and valid.",
      "zh-CHS": "o “当前”是指定义是当前有效的。"
    },
    {
      "indent": 3,
      "text": "o \"deprecated\" indicates an obsolete definition, but it permits new/continued implementation in order to foster interoperability with older/existing implementations.",
      "zh-CHS": "o “弃用”表示一个过时的定义，但它允许新的/继续的实现，以促进与旧的/现有的实现的互操作性。"
    },
    {
      "indent": 3,
      "text": "o \"obsolete\" means that the definition is obsolete and SHOULD NOT be implemented and/or can be removed from implementations.",
      "zh-CHS": "o “过时”是指该定义已过时，不应实施和/或可从实施中删除。"
    },
    {
      "indent": 3,
      "text": "If no status is specified, the default is \"current\".",
      "zh-CHS": "如果未指定状态，则默认为“当前”。"
    },
    {
      "indent": 3,
      "text": "If a definition is \"current\", it MUST NOT reference a \"deprecated\" or \"obsolete\" definition within the same module.",
      "zh-CHS": "如果定义是“当前的”，则它不得引用同一模块中的“已弃用”或“已过时”定义。"
    },
    {
      "indent": 3,
      "text": "If a definition is \"deprecated\", it MUST NOT reference an \"obsolete\" definition within the same module.",
      "zh-CHS": "如果定义是“不推荐的”，则它不得引用同一模块中的“过时”定义。"
    },
    {
      "indent": 3,
      "text": "For example, the following is illegal:",
      "zh-CHS": "例如，以下行为是非法的："
    },
    {
      "indent": 5,
      "text": "typedef my-type {\n  status deprecated;\n  type int32;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "leaf my-leaf {\n  status current;\n  type my-type; // illegal, since my-type is deprecated\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.21.3. The \"description\" Statement",
      "section_title": true,
      "zh-CHS": "7.21.3. “说明”声明"
    },
    {
      "indent": 3,
      "text": "The \"description\" statement takes as an argument a string that contains a human-readable textual description of this definition. The text is provided in a language (or languages) chosen by the module developer; for the sake of interoperability, it is RECOMMENDED to choose a language that is widely understood among the community of network administrators who will use the module.",
      "zh-CHS": "“description”语句将包含此定义的可读文本描述的字符串作为参数。文本以模块开发人员选择的一种（或多种）语言提供；为了实现互操作性，建议选择一种将使用该模块的网络管理员社区广泛理解的语言。"
    },
    {
      "indent": 0,
      "text": "7.21.4. The \"reference\" Statement",
      "section_title": true,
      "zh-CHS": "7.21.4. “参考”声明"
    },
    {
      "indent": 3,
      "text": "The \"reference\" statement takes as an argument a string that is a human-readable cross-reference to an external document -- either another module that defines related management information or a document that provides additional information relevant to this definition.",
      "zh-CHS": "“reference”语句将一个字符串作为参数，该字符串是对外部文档（定义相关管理信息的另一个模块或提供与此定义相关的附加信息的文档）的可读交叉引用。"
    },
    {
      "indent": 3,
      "text": "For example, a typedef for a \"uri\" data type could look like:",
      "zh-CHS": "例如，“uri”数据类型的typedef可能如下所示："
    },
    {
      "indent": 5,
      "text": "typedef uri {\n  type string;\n  reference\n    \"RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\";\n  ...\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "7.21.5. The \"when\" Statement",
      "section_title": true,
      "zh-CHS": "7.21.5. “何时”陈述"
    },
    {
      "indent": 3,
      "text": "The \"when\" statement makes its parent data definition statement conditional. The node defined by the parent data definition statement is only valid when the condition specified by the \"when\" statement is satisfied. The statement's argument is an XPath expression (see Section 6.4), which is used to formally specify this condition. If the XPath expression conceptually evaluates to \"true\" for a particular instance, then the node defined by the parent data definition statement is valid; otherwise, it is not.",
      "zh-CHS": "“when”语句使其父数据定义语句具有条件。父数据定义语句定义的节点仅在满足“when”语句指定的条件时有效。该语句的参数是一个XPath表达式（参见第6.4节），用于正式指定此条件。如果XPath表达式在概念上对特定实例的计算结果为“true”，则父数据定义语句定义的节点是有效的；否则，情况并非如此。"
    },
    {
      "indent": 3,
      "text": "A leaf that is a list key MUST NOT have a \"when\" statement.",
      "zh-CHS": "作为列表键的叶不能有“when”语句。"
    },
    {
      "indent": 3,
      "text": "If a key leaf is defined in a grouping that is used in a list, the \"uses\" statement MUST NOT have a \"when\" statement.",
      "zh-CHS": "如果在列表中使用的分组中定义了键叶，则“uses”语句不能有“when”语句。"
    },
    {
      "indent": 3,
      "text": "See Section 8.3.2 for additional information.",
      "zh-CHS": "更多信息见第8.3.2节。"
    },
    {
      "indent": 3,
      "text": "The XPath expression is conceptually evaluated in the following context, in addition to the definition in Section 6.4.1:",
      "zh-CHS": "除了第6.4.1节中的定义外，XPath表达式在以下上下文中进行概念性评估："
    },
    {
      "indent": 3,
      "text": "o If the \"when\" statement is a child of an \"augment\" statement, then the context node is the augment's target node in the data tree, if the target node is a data node. Otherwise, the context node is the closest ancestor node to the target node that is also a data node. If no such node exists, the context node is the root node. The accessible tree is tentatively altered during the processing of the XPath expression by removing all instances (if any) of the nodes added by the \"augment\" statement.",
      "zh-CHS": "o 如果“when”语句是“augment”语句的子语句，则上下文节点是数据树中的augment的目标节点（如果目标节点是数据节点）。否则，上下文节点是距离目标节点（也是数据节点）最近的祖先节点。如果不存在这样的节点，则上下文节点是根节点。在XPath表达式的处理过程中，通过删除“augment”语句添加的节点的所有实例（如果有），可以暂时更改可访问树。"
    },
    {
      "indent": 3,
      "text": "o If the \"when\" statement is a child of a \"uses\", \"choice\", or \"case\" statement, then the context node is the closest ancestor node to the node with the \"when\" statement that is also a data node. If no such node exists, the context node is the root node. The accessible tree is tentatively altered during the processing of the XPath expression by removing all instances (if any) of the nodes added by the \"uses\", \"choice\", or \"case\" statement.",
      "zh-CHS": "o 如果“when”语句是“uses”、“choice”或“case”语句的子语句，则上下文节点是与同时也是数据节点的“when”语句的节点最近的祖先节点。如果不存在这样的节点，则上下文节点是根节点。在XPath表达式的处理过程中，通过删除由“uses”、“choice”或“case”语句添加的节点的所有实例（如果有），可以暂时更改可访问树。"
    },
    {
      "indent": 3,
      "text": "o If the \"when\" statement is a child of any other data definition statement, the accessible tree is tentatively altered during the processing of the XPath expression by replacing all instances of the data node for which the \"when\" statement is defined with a single dummy node with the same name, but with no value and no children. If no such instance exists, the dummy node is tentatively created. The context node is this dummy node.",
      "zh-CHS": "o 如果“when”语句是任何其他数据定义语句的子级，则在处理XPath表达式的过程中，通过将定义“when”语句的数据节点的所有实例替换为具有相同名称但没有值和子级的单个虚拟节点，可访问树将暂时更改。如果不存在这样的实例，则暂时创建虚拟节点。上下文节点就是这个虚拟节点。"
    },
    {
      "indent": 3,
      "text": "The result of the XPath expression is converted to a boolean value using the standard XPath rules.",
      "zh-CHS": "XPath表达式的结果使用标准XPath规则转换为布尔值。"
    },
    {
      "indent": 3,
      "text": "If the XPath expression references any node that also has associated \"when\" statements, those \"when\" expressions MUST be evaluated first. There MUST NOT be any circular dependencies among \"when\" expressions.",
      "zh-CHS": "如果XPath表达式引用的任何节点也有关联的“when”语句，则必须首先计算那些“when”表达式。“when”表达式之间不得存在任何循环依赖关系。"
    },
    {
      "indent": 3,
      "text": "Note that the XPath expression is conceptually evaluated. This means that an implementation does not have to use an XPath evaluator in the server. The \"when\" statement can very well be implemented with specially written code.",
      "zh-CHS": "请注意，XPath表达式是在概念上进行计算的。这意味着实现不必在服务器中使用XPath计算器。“when”语句可以用专门编写的代码很好地实现。"
    },
    {
      "indent": 0,
      "text": "8. Constraints",
      "section_title": true,
      "zh-CHS": "8. 约束条件"
    },
    {
      "indent": 0,
      "text": "8.1. Constraints on Data",
      "section_title": true,
      "zh-CHS": "8.1. 对数据的限制"
    },
    {
      "indent": 3,
      "text": "Several YANG statements define constraints on valid data. These constraints are enforced in different ways, depending on what type of data the statement defines.",
      "zh-CHS": "几个语句定义了对有效数据的约束。根据语句定义的数据类型，这些约束以不同的方式强制执行。"
    },
    {
      "indent": 3,
      "text": "o If the constraint is defined on configuration data, it MUST be true in a valid configuration data tree.",
      "zh-CHS": "o 如果约束是在配置数据上定义的，则在有效的配置数据树中必须为true。"
    },
    {
      "indent": 3,
      "text": "o If the constraint is defined on state data, it MUST be true in a valid state data tree.",
      "zh-CHS": "o 如果约束是在状态数据上定义的，则在有效的状态数据树中必须为true。"
    },
    {
      "indent": 3,
      "text": "o If the constraint is defined on notification content, it MUST be true in any notification data tree.",
      "zh-CHS": "o 如果约束是在通知内容上定义的，则在任何通知数据树中都必须为true。"
    },
    {
      "indent": 3,
      "text": "o If the constraint is defined on RPC or action input parameters, it MUST be true in an invocation of the RPC or action operation.",
      "zh-CHS": "o 如果约束是在RPC或操作输入参数上定义的，则在调用RPC或操作操作时必须为true。"
    },
    {
      "indent": 3,
      "text": "o If the constraint is defined on RPC or action output parameters, it MUST be true in the RPC or action reply.",
      "zh-CHS": "o 如果约束是在RPC或操作输出参数上定义的，则在RPC或操作回复中必须为true。"
    },
    {
      "indent": 3,
      "text": "The following properties are true in all data trees:",
      "zh-CHS": "以下属性在所有数据树中均为真："
    },
    {
      "indent": 3,
      "text": "o All leaf data values MUST match the type constraints for the leaf, including those defined in the type's \"range\", \"length\", and \"pattern\" properties.",
      "zh-CHS": "o 所有叶数据值必须与叶的类型约束匹配，包括在类型的“范围”、“长度”和“模式”属性中定义的约束。"
    },
    {
      "indent": 3,
      "text": "o All key leafs MUST be present for all list entries.",
      "zh-CHS": "o 所有列表条目的所有键叶都必须存在。"
    },
    {
      "indent": 3,
      "text": "o Nodes MUST be present for at most one case branch in all choices.",
      "zh-CHS": "o 在所有选项中，节点最多必须存在一个案例分支。"
    },
    {
      "indent": 3,
      "text": "o There MUST be no nodes tagged with \"if-feature\" present if the \"if-feature\" expression evaluates to \"false\" in the server.",
      "zh-CHS": "o 如果“if feature”表达式在服务器中的计算结果为“false”，则必须不存在标记为“if feature”的节点。"
    },
    {
      "indent": 3,
      "text": "o There MUST be no nodes tagged with \"when\" present if the \"when\" condition evaluates to \"false\" in the data tree.",
      "zh-CHS": "o 如果数据树中的“when”条件计算为“false”，则不得存在标记为“when”的节点。"
    },
    {
      "indent": 3,
      "text": "The following properties are true in a valid data tree:",
      "zh-CHS": "以下属性在有效数据树中为真："
    },
    {
      "indent": 3,
      "text": "o All \"must\" constraints MUST evaluate to \"true\".",
      "zh-CHS": "o 所有“必须”约束的计算结果必须为“真”。"
    },
    {
      "indent": 3,
      "text": "o All referential integrity constraints defined via the \"path\" statement MUST be satisfied.",
      "zh-CHS": "o 必须满足通过“path”语句定义的所有引用完整性约束。"
    },
    {
      "indent": 3,
      "text": "o All \"unique\" constraints on lists MUST be satisfied.",
      "zh-CHS": "o 必须满足列表上的所有“唯一”约束。"
    },
    {
      "indent": 3,
      "text": "o The \"mandatory\" constraint is enforced for leafs and choices, unless the node or any of its ancestors has a \"when\" condition or \"if-feature\" expression that evaluates to \"false\".",
      "zh-CHS": "o 除非节点或其任何祖先具有计算结果为“false”的“when”条件或“if feature”表达式，否则对叶和选项强制执行“mandatory”约束。"
    },
    {
      "indent": 3,
      "text": "o The \"min-elements\" and \"max-elements\" constraints are enforced for lists and leaf-lists, unless the node or any of its ancestors has a \"when\" condition or \"if-feature\" expression that evaluates to \"false\".",
      "zh-CHS": "o “最小元素”和“最大元素”约束对列表和叶列表强制执行，除非节点或其任何祖先具有计算结果为“false”的“when”条件或“if feature”表达式。"
    },
    {
      "indent": 3,
      "text": "The running configuration datastore MUST always be valid.",
      "zh-CHS": "正在运行的配置数据存储必须始终有效。"
    },
    {
      "indent": 0,
      "text": "8.2. Configuration Data Modifications",
      "section_title": true,
      "zh-CHS": "8.2. 配置数据修改"
    },
    {
      "indent": 3,
      "text": "o If a request creates configuration data nodes under a choice, any existing nodes from other case branches in the data tree are deleted by the server.",
      "zh-CHS": "o 如果请求在选项下创建配置数据节点，则服务器将删除数据树中其他案例分支中的任何现有节点。"
    },
    {
      "indent": 3,
      "text": "o If a request modifies a configuration data node such that any node's \"when\" expression becomes false, then the node in the data tree with the \"when\" expression is deleted by the server.",
      "zh-CHS": "o 如果请求修改配置数据节点，使得任何节点的“何时”表达式变为false，则服务器将删除数据树中具有“何时”表达式的节点。"
    },
    {
      "indent": 0,
      "text": "8.3. NETCONF Constraint Enforcement Model",
      "section_title": true,
      "zh-CHS": "8.3. NETCONF约束实施模型"
    },
    {
      "indent": 3,
      "text": "For configuration data, there are three windows when constraints MUST be enforced:",
      "zh-CHS": "对于配置数据，必须强制执行约束时有三个窗口："
    },
    {
      "indent": 3,
      "text": "o during parsing of RPC payloads",
      "zh-CHS": "o 在分析RPC有效负载期间"
    },
    {
      "indent": 3,
      "text": "o during processing of the <edit-config> operation",
      "zh-CHS": "o 在处理<edit config>操作期间"
    },
    {
      "indent": 3,
      "text": "o during validation",
      "zh-CHS": "o 验证期间"
    },
    {
      "indent": 3,
      "text": "Each of these scenarios is considered in the following sections.",
      "zh-CHS": "以下各节将考虑其中的每种情况。"
    },
    {
      "indent": 0,
      "text": "8.3.1. Payload Parsing",
      "section_title": true,
      "zh-CHS": "8.3.1. 有效负载解析"
    },
    {
      "indent": 3,
      "text": "When content arrives in RPC payloads, it MUST be well-formed XML, following the hierarchy and content rules defined by the set of models the server implements.",
      "zh-CHS": "当内容到达RPC有效负载时，它必须是格式良好的XML，遵循服务器实现的模型集定义的层次结构和内容规则。"
    },
    {
      "indent": 3,
      "text": "o If a leaf data value does not match the type constraints for the leaf, including those defined in the type's \"range\", \"length\", and \"pattern\" properties, the server MUST reply with an \"invalid-value\" <error-tag> in the <rpc-error>, and with the error-app-tag (Section 7.5.4.2) and error-message (Section 7.5.4.1) associated with the constraint, if any exist.",
      "zh-CHS": "o 如果叶数据值与叶的类型约束（包括在类型的“范围”、“长度”和“模式”属性中定义的约束）不匹配，服务器必须在<rpc error>中使用“无效值”<error tag>，并使用与约束相关联的error app tag（第7.5.4.2节）和错误消息（第7.5.4.1节）进行回复，如果有的话。"
    },
    {
      "indent": 3,
      "text": "o If all keys of a list entry are not present, the server MUST reply with a \"missing-element\" <error-tag> in the <rpc-error>.",
      "zh-CHS": "o 如果列表项的所有键都不存在，服务器必须在<rpc error>中使用“缺少元素”<error tag>进行回复。"
    },
    {
      "indent": 3,
      "text": "o If data for more than one case branch of a choice is present, the server MUST reply with a \"bad-element\" <error-tag> in the <rpc-error>.",
      "zh-CHS": "o 如果存在一个选项的多个案例分支的数据，服务器必须在<rpc error>中使用“bad element”<error tag>进行回复。"
    },
    {
      "indent": 3,
      "text": "o If data for a node tagged with \"if-feature\" is present and the \"if-feature\" expression evaluates to \"false\" in the server, the server MUST reply with an \"unknown-element\" <error-tag> in the <rpc-error>.",
      "zh-CHS": "o 如果在服务器中存在标记为“If feature”的节点的数据，并且“If feature”表达式的计算结果为“false”，则服务器必须在<rpc error>中使用“unknown element”<error tag>进行回复。"
    },
    {
      "indent": 3,
      "text": "o If data for a node tagged with \"when\" is present and the \"when\" condition evaluates to \"false\", the server MUST reply with an \"unknown-element\" <error-tag> in the <rpc-error>.",
      "zh-CHS": "o 如果标记为“when”的节点的数据存在，并且“when”条件的计算结果为“false”，则服务器必须在<rpc error>中使用“unknown element”<error tag>进行回复。"
    },
    {
      "indent": 3,
      "text": "o For insert handling, if the values for the attributes \"before\" and \"after\" are not valid for the type of the appropriate key leafs, the server MUST reply with a \"bad-attribute\" <error-tag> in the <rpc-error>.",
      "zh-CHS": "o 对于插入处理，如果属性“before”和“after”的值对于相应密钥叶的类型无效，服务器必须在<rpc error>中使用“bad attribute”<error tag>进行回复。"
    },
    {
      "indent": 3,
      "text": "o If the attributes \"before\" and \"after\" appear in any element that is not a list whose \"ordered-by\" property is \"user\", the server MUST reply with an \"unknown-attribute\" <error-tag> in the <rpc-error>.",
      "zh-CHS": "o 如果属性“before”和“after”出现在不是“ordered by”属性为“user”的列表的任何元素中，则服务器必须在<rpc error>中使用“unknown attribute”<error tag>。"
    },
    {
      "indent": 0,
      "text": "8.3.2. NETCONF <edit-config> Processing",
      "section_title": true,
      "zh-CHS": "8.3.2. NETCONF<edit config>处理"
    },
    {
      "indent": 3,
      "text": "After the incoming data is parsed, the NETCONF server performs the <edit-config> operation by applying the data to the configuration datastore. During this processing, the following errors MUST be detected:",
      "zh-CHS": "解析传入数据后，NETCONF服务器通过将数据应用于配置数据存储来执行<edit config>操作。在此处理过程中，必须检测到以下错误："
    },
    {
      "indent": 3,
      "text": "o Delete requests for non-existent data.",
      "zh-CHS": "o 删除对不存在数据的请求。"
    },
    {
      "indent": 3,
      "text": "o Create requests for existent data.",
      "zh-CHS": "o 创建对现有数据的请求。"
    },
    {
      "indent": 3,
      "text": "o Insert requests with \"before\" or \"after\" parameters that do not exist.",
      "zh-CHS": "o 使用不存在的“before”或“after”参数插入请求。"
    },
    {
      "indent": 3,
      "text": "o Modification requests for nodes tagged with \"when\", and the \"when\" condition evaluates to \"false\". In this case, the server MUST reply with an \"unknown-element\" <error-tag> in the <rpc-error>.",
      "zh-CHS": "o 对标记为“when”且“when”条件评估为“false”的节点的修改请求。在这种情况下，服务器必须在<rpc error>中使用“未知元素”<error tag>进行回复。"
    },
    {
      "indent": 0,
      "text": "8.3.3. Validation",
      "section_title": true,
      "zh-CHS": "8.3.3. 验证"
    },
    {
      "indent": 3,
      "text": "When datastore processing is complete, the final contents MUST obey all validation constraints. This validation processing is performed at differing times according to the datastore. If the datastore is \"running\" or \"startup\", these constraints MUST be enforced at the end of the <edit-config> or <copy-config> operation. If the datastore is \"candidate\", the constraint enforcement is delayed until a <commit> or <validate> operation takes place.",
      "zh-CHS": "数据存储处理完成后，最终内容必须遵守所有验证约束。此验证处理根据数据存储在不同的时间执行。如果数据存储正在“运行”或“启动”，则必须在<edit config>或<copy config>操作结束时强制执行这些约束。如果数据存储为“候选”，则约束实施将延迟，直到发生<commit>或<validate>操作。"
    },
    {
      "indent": 0,
      "text": "9. Built-In Types",
      "section_title": true,
      "zh-CHS": "9. 内置类型"
    },
    {
      "indent": 3,
      "text": "YANG has a set of built-in types, similar to those of many programming languages, but with some differences due to special requirements from the management information model.",
      "zh-CHS": "YANG有一组内置类型，类似于许多编程语言的类型，但由于管理信息模型的特殊要求而有所不同。"
    },
    {
      "indent": 3,
      "text": "Additional types may be defined that are derived from those built-in types or from other derived types. Derived types may use subtyping to formally restrict the set of possible values.",
      "zh-CHS": "可以定义从这些内置类型或其他派生类型派生的其他类型。派生类型可以使用子类型来正式限制可能的值集。"
    },
    {
      "indent": 3,
      "text": "The different built-in types and their derived types allow different kinds of subtyping, namely length and regular expression restrictions of strings (Sections 9.4.4 and 9.4.5) and range restrictions of numeric types (Section 9.2.4).",
      "zh-CHS": "不同的内置类型及其派生类型允许不同类型的子类型，即字符串的长度和正则表达式限制（第9.4.4节和第9.4.5节）和数字类型的范围限制（第9.2.4节）。"
    },
    {
      "indent": 3,
      "text": "The lexical representation of a value of a certain type is used in the XML encoding and when specifying default values and numerical ranges in YANG modules.",
      "zh-CHS": "在XML编码中以及在模块中指定默认值和数字范围时，使用特定类型值的词汇表示。"
    },
    {
      "indent": 0,
      "text": "9.1. Canonical Representation",
      "section_title": true,
      "zh-CHS": "9.1. 典范表示"
    },
    {
      "indent": 3,
      "text": "For most types, there is a single canonical representation of the type's values. Some types allow multiple lexical representations of the same value; for example, the positive integer \"17\" can be represented as \"+17\" or \"17\". Implementations MUST support all lexical representations specified in this document.",
      "zh-CHS": "对于大多数类型，该类型的值只有一个规范表示形式。某些类型允许相同值的多个词汇表示；例如，正整数“17”可以表示为“+17”或“17”。实现必须支持本文档中指定的所有词汇表示。"
    },
    {
      "indent": 3,
      "text": "When a server sends XML-encoded data, it MUST use the canonical form defined in this section. Other encodings may introduce alternate representations. Note, however, that values in the data tree are conceptually stored in the canonical representation as defined in this section. In particular, any XPath expression evaluations are done using the canonical form if the data type has a canonical form. If the data type does not have a canonical form, the format of the value MUST match the data type's lexical representation, but the exact format is implementation dependent.",
      "zh-CHS": "当服务器发送XML编码的数据时，它必须使用本节中定义的规范格式。其他编码可能引入替代表示。但是，请注意，数据树中的值在概念上存储在本节中定义的规范表示中。特别是，如果数据类型具有规范形式，则任何XPath表达式计算都是使用规范形式完成的。如果数据类型没有规范形式，则值的格式必须与数据类型的词汇表示形式匹配，但确切的格式取决于实现。"
    },
    {
      "indent": 3,
      "text": "Some types have a lexical representation that depends on the encoding, e.g., the XML context in which they occur. These types do not have a canonical form.",
      "zh-CHS": "某些类型的词汇表示取决于编码，例如，它们出现的XML上下文。这些类型没有规范形式。"
    },
    {
      "indent": 0,
      "text": "9.2. The Integer Built-In Types",
      "section_title": true,
      "zh-CHS": "9.2. 内置类型的整数"
    },
    {
      "indent": 3,
      "text": "The integer built-in types are int8, int16, int32, int64, uint8, uint16, uint32, and uint64. They represent signed and unsigned integers of different sizes:",
      "zh-CHS": "内置的整数类型有int8、int16、int32、int64、uint8、uint16、uint32和uint64。它们表示大小不同的有符号和无符号整数："
    },
    {
      "indent": 3,
      "text": "int8 represents integer values between -128 and 127, inclusively.",
      "zh-CHS": "int8表示介于-128和127之间的整数值。"
    },
    {
      "indent": 3,
      "text": "int16 represents integer values between -32768 and 32767, inclusively.",
      "zh-CHS": "int16表示介于-32768和32767之间的整数值。"
    },
    {
      "indent": 3,
      "text": "int32 represents integer values between -2147483648 and 2147483647, inclusively.",
      "zh-CHS": "int32表示介于-2147483648和2147483647之间的整数值。"
    },
    {
      "indent": 3,
      "text": "int64 represents integer values between -9223372036854775808 and 9223372036854775807, inclusively.",
      "zh-CHS": "int64表示介于-9223372036854775808和9223372036854775807之间的整数值（包括）。"
    },
    {
      "indent": 3,
      "text": "uint8 represents integer values between 0 and 255, inclusively.",
      "zh-CHS": "uint8表示介于0和255之间的整数值（包括）。"
    },
    {
      "indent": 3,
      "text": "uint16 represents integer values between 0 and 65535, inclusively.",
      "zh-CHS": "uint16表示介于0和65535之间的整数值。"
    },
    {
      "indent": 3,
      "text": "uint32 represents integer values between 0 and 4294967295, inclusively.",
      "zh-CHS": "uint32表示0和4294967295之间的整数值，包括0和4294967295。"
    },
    {
      "indent": 3,
      "text": "uint64 represents integer values between 0 and 18446744073709551615, inclusively.",
      "zh-CHS": "uint64表示介于0和18446744073709551615之间的整数值。"
    },
    {
      "indent": 0,
      "text": "9.2.1. Lexical Representation",
      "section_title": true,
      "zh-CHS": "9.2.1. 词汇表征"
    },
    {
      "indent": 3,
      "text": "An integer value is lexically represented as an optional sign (\"+\" or \"-\"), followed by a sequence of decimal digits. If no sign is specified, \"+\" is assumed.",
      "zh-CHS": "整数值在词汇上表示为可选符号（“+”或“-”），后跟一系列十进制数字。如果未指定符号，则假定为“+”。"
    },
    {
      "indent": 3,
      "text": "For convenience, when specifying a default value for an integer in a YANG module, an alternative lexical representation can be used that represents the value in a hexadecimal or octal notation. The hexadecimal notation consists of an optional sign (\"+\" or \"-\"), followed by the characters \"0x\", followed by a number of hexadecimal digits where letters may be uppercase or lowercase. The octal notation consists of an optional sign (\"+\" or \"-\"), followed by the character \"0\", followed by a number of octal digits.",
      "zh-CHS": "为方便起见，在阳模块中为整数指定默认值时，可以使用另一种词汇表示法，以十六进制或八进制表示值。十六进制表示法由可选符号（“+”或“-”）组成，后面是字符“0x”，后面是一些十六进制数字，其中字母可以是大写或小写。八进制表示法由可选符号（“+”或“-”）组成，后跟字符“0”，后跟许多八进制数字。"
    },
    {
      "indent": 3,
      "text": "Note that if a default value in a YANG module has a leading zero (\"0\"), it is interpreted as an octal number. In the XML encoding, an integer is always interpreted as a decimal number, and leading zeros are allowed.",
      "zh-CHS": "请注意，如果YANG模块中的默认值具有前导零（“0”），则会将其解释为八进制数。在XML编码中，整数总是被解释为十进制数，并且允许前导零。"
    },
    {
      "indent": 3,
      "text": "Examples:",
      "zh-CHS": "示例："
    },
    {
      "indent": 5,
      "text": "// legal values\n+4711                       // legal positive value\n4711                        // legal positive value\n-123                        // legal negative value\n0xf00f                      // legal positive hexadecimal value\n-0xf                        // legal negative hexadecimal value\n052                         // legal positive octal value",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "// illegal values\n- 1                         // illegal intermediate space",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "9.2.2. Canonical Form",
      "section_title": true,
      "zh-CHS": "9.2.2. 标准形"
    },
    {
      "indent": 3,
      "text": "The canonical form of a positive integer does not include the sign \"+\". Leading zeros are prohibited. The value zero is represented as \"0\".",
      "zh-CHS": "正整数的标准形式不包括符号“+”。禁止使用前导零。值0表示为“0”。"
    },
    {
      "indent": 0,
      "text": "9.2.3. Restrictions",
      "section_title": true,
      "zh-CHS": "9.2.3. 限制"
    },
    {
      "indent": 3,
      "text": "All integer types can be restricted with the \"range\" statement (Section 9.2.4).",
      "zh-CHS": "所有整数类型都可以用“range”语句进行限制（第9.2.4节）。"
    },
    {
      "indent": 0,
      "text": "9.2.4. The \"range\" Statement",
      "section_title": true,
      "zh-CHS": "9.2.4. “范围”声明"
    },
    {
      "indent": 3,
      "text": "The \"range\" statement, which is an optional substatement to the \"type\" statement, takes as an argument a range expression string. It is used to restrict integer and decimal built-in types, or types derived from them.",
      "zh-CHS": "“range”语句是“type”语句的可选子语句，它将range表达式字符串作为参数。它用于限制整数和十进制内置类型，或从它们派生的类型。"
    },
    {
      "indent": 3,
      "text": "A range consists of an explicit value, or a lower-inclusive bound, two consecutive dots \"..\", and an upper-inclusive bound. Multiple values or ranges can be given, separated by \"|\". If multiple values or ranges are given, they all MUST be disjoint and MUST be in ascending order. If a range restriction is applied to a type that is already range-restricted, the new restriction MUST be equally limiting or more limiting, i.e., raising the lower bounds, reducing the upper bounds, removing explicit values or ranges, or splitting ranges into multiple ranges with intermediate gaps. Each explicit value and range boundary value given in the range expression MUST",
      "zh-CHS": "范围由一个显式值或一个包含下限、两个连续点“.”和一个包含上限组成。可以给出多个值或范围，以“|”分隔。如果给定了多个值或范围，则它们都必须是不相交的，并且必须按升序排列。如果将范围限制应用于已受范围限制的类型，则新限制必须具有相同的限制或更大的限制，即提高下限、降低上限、删除显式值或范围，或将范围拆分为具有中间间隙的多个范围。范围表达式中给出的每个显式值和范围边界值必须"
    },
    {
      "indent": 3,
      "text": "match the type being restricted or be one of the special values \"min\" or \"max\". \"min\" and \"max\" mean the minimum and maximum values accepted for the type being restricted, respectively.",
      "zh-CHS": "匹配被限制的类型，或者是特殊值“最小”或“最大”之一。“最小值”和“最大值”分别指受限制类型可接受的最小值和最大值。"
    },
    {
      "indent": 3,
      "text": "The range expression syntax is formally defined by the rule \"range-arg\" in Section 14.",
      "zh-CHS": "范围表达式语法由第14节中的规则“range arg”正式定义。"
    },
    {
      "indent": 0,
      "text": "9.2.4.1. The range's Substatements",
      "section_title": true,
      "zh-CHS": "9.2.4.1. 范围的子状态"
    },
    {
      "indent": 17,
      "text": "+---------------+---------+-------------+\n| substatement  | section | cardinality |\n+---------------+---------+-------------+\n| description   | 7.21.3  | 0..1        |\n| error-app-tag | 7.5.4.2 | 0..1        |\n| error-message | 7.5.4.1 | 0..1        |\n| reference     | 7.21.4  | 0..1        |\n+---------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "9.2.5. Usage Example",
      "section_title": true,
      "zh-CHS": "9.2.5. 用法示例"
    },
    {
      "indent": 5,
      "text": "typedef my-base-int32-type {\n  type int32 {\n    range \"1..4 | 10..20\";\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "typedef my-type1 {\n  type my-base-int32-type {\n    // legal range restriction\n    range \"11..max\"; // 11..20\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "typedef my-type2 {\n  type my-base-int32-type {\n    // illegal range restriction\n    range \"11..100\";\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "9.3. The decimal64 Built-In Type",
      "section_title": true,
      "zh-CHS": "9.3. 小数64内置类型"
    },
    {
      "indent": 3,
      "text": "The decimal64 built-in type represents a subset of the real numbers, which can be represented by decimal numerals. The value space of decimal64 is the set of numbers that can be obtained by multiplying a 64-bit signed integer by a negative power of ten, i.e., expressible as \"i x 10^-n\" where i is an integer64 and n is an integer between 1 and 18, inclusively.",
      "zh-CHS": "decimal64内置类型表示实数的子集，可以用十进制数字表示。小数64的值空间是可通过将64位有符号整数乘以10的负幂而获得的一组数字，即，可表示为“i x 10^-n”，其中i是整数64，n是介于1和18之间的整数。"
    },
    {
      "indent": 0,
      "text": "9.3.1. Lexical Representation",
      "section_title": true,
      "zh-CHS": "9.3.1. 词汇表征"
    },
    {
      "indent": 3,
      "text": "A decimal64 value is lexically represented as an optional sign (\"+\" or \"-\"), followed by a sequence of decimal digits, optionally followed by a period ('.') as a decimal indicator and a sequence of decimal digits. If no sign is specified, \"+\" is assumed.",
      "zh-CHS": "十进制64值在词汇上表示为可选符号（“+”或“-”），后跟十进制数字序列，可选后跟句点（“.”）作为十进制指示符和十进制数字序列。如果未指定符号，则假定为“+”。"
    },
    {
      "indent": 0,
      "text": "9.3.2. Canonical Form",
      "section_title": true,
      "zh-CHS": "9.3.2. 标准形"
    },
    {
      "indent": 3,
      "text": "The canonical form of a positive decimal64 value does not include the sign \"+\". The decimal point is required. Leading and trailing zeros are prohibited, subject to the rule that there MUST be at least one digit before and after the decimal point. The value zero is represented as \"0.0\".",
      "zh-CHS": "正小数64值的标准形式不包括符号“+”。小数点是必需的。禁止使用前导零和尾随零，前提是小数点前后必须至少有一位数字。值0表示为“0.0”。"
    },
    {
      "indent": 0,
      "text": "9.3.3. Restrictions",
      "section_title": true,
      "zh-CHS": "9.3.3. 限制"
    },
    {
      "indent": 3,
      "text": "A decimal64 type can be restricted with the \"range\" statement (Section 9.2.4).",
      "zh-CHS": "小数64类型可通过“范围”语句进行限制（第9.2.4节）。"
    },
    {
      "indent": 0,
      "text": "9.3.4. The \"fraction-digits\" Statement",
      "section_title": true,
      "zh-CHS": "9.3.4. “分数位数”语句"
    },
    {
      "indent": 3,
      "text": "The \"fraction-digits\" statement, which is a substatement to the \"type\" statement, MUST be present if the type is \"decimal64\". It takes as an argument an integer between 1 and 18, inclusively. It controls the size of the minimum difference between values of a decimal64 type by restricting the value space to numbers that are expressible as \"i x 10^-n\" where n is the fraction-digits argument.",
      "zh-CHS": "“小数位数”语句是“type”语句的子语句，如果类型为“decimal64”，则必须存在该语句。它接受一个介于1和18之间的整数作为参数。它通过将值空间限制为可表示为“i x 10^-n”的数字来控制小数64类型的值之间最小差值的大小，其中n是小数位数参数。"
    },
    {
      "indent": 3,
      "text": "The following table lists the minimum and maximum values for each fraction-digit value:",
      "zh-CHS": "下表列出了每个分数位数的最小值和最大值："
    },
    {
      "indent": 5,
      "text": "+----------------+-----------------------+----------------------+\n| fraction-digit | min                   | max                  |\n+----------------+-----------------------+----------------------+\n| 1              | -922337203685477580.8 | 922337203685477580.7 |\n| 2              | -92233720368547758.08 | 92233720368547758.07 |\n| 3              | -9223372036854775.808 | 9223372036854775.807 |\n| 4              | -922337203685477.5808 | 922337203685477.5807 |\n| 5              | -92233720368547.75808 | 92233720368547.75807 |\n| 6              | -9223372036854.775808 | 9223372036854.775807 |\n| 7              | -922337203685.4775808 | 922337203685.4775807 |\n| 8              | -92233720368.54775808 | 92233720368.54775807 |\n| 9              | -9223372036.854775808 | 9223372036.854775807 |\n| 10             | -922337203.6854775808 | 922337203.6854775807 |\n| 11             | -92233720.36854775808 | 92233720.36854775807 |\n| 12             | -9223372.036854775808 | 9223372.036854775807 |\n| 13             | -922337.2036854775808 | 922337.2036854775807 |\n| 14             | -92233.72036854775808 | 92233.72036854775807 |\n| 15             | -9223.372036854775808 | 9223.372036854775807 |\n| 16             | -922.3372036854775808 | 922.3372036854775807 |\n| 17             | -92.23372036854775808 | 92.23372036854775807 |\n| 18             | -9.223372036854775808 | 9.223372036854775807 |\n+----------------+-----------------------+----------------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "9.3.5. Usage Example",
      "section_title": true,
      "zh-CHS": "9.3.5. 用法示例"
    },
    {
      "indent": 5,
      "text": "typedef my-decimal {\n  type decimal64 {\n    fraction-digits 2;\n    range \"1 .. 3.14 | 10 | 20..max\";\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "9.4. The string Built-In Type",
      "section_title": true,
      "zh-CHS": "9.4. 字符串内置类型"
    },
    {
      "indent": 3,
      "text": "The string built-in type represents human-readable strings in YANG. Legal characters are the Unicode and ISO/IEC 10646 [ISO.10646] characters, including tab, carriage return, and line feed but excluding the other C0 control characters, the surrogate blocks, and the noncharacters. The string syntax is formally defined by the rule \"yang-string\" in Section 14.",
      "zh-CHS": "字符串内置类型表示YANG中的人类可读字符串。合法字符是Unicode和ISO/IEC 10646[ISO.10646]字符，包括制表符、回车符和换行符，但不包括其他C0控制字符、代理块和非字符。字符串语法由第14节中的规则“yang string”正式定义。"
    },
    {
      "indent": 0,
      "text": "9.4.1. Lexical Representation",
      "section_title": true,
      "zh-CHS": "9.4.1. 词汇表征"
    },
    {
      "indent": 3,
      "text": "A string value is lexically represented as character data in the XML encoding.",
      "zh-CHS": "在XML编码中，字符串值在词汇上表示为字符数据。"
    },
    {
      "indent": 0,
      "text": "9.4.2. Canonical Form",
      "section_title": true,
      "zh-CHS": "9.4.2. 标准形"
    },
    {
      "indent": 3,
      "text": "The canonical form is the same as the lexical representation. No Unicode normalization of string values is performed.",
      "zh-CHS": "规范形式与词汇表示相同。不执行字符串值的Unicode规范化。"
    },
    {
      "indent": 0,
      "text": "9.4.3. Restrictions",
      "section_title": true,
      "zh-CHS": "9.4.3. 限制"
    },
    {
      "indent": 3,
      "text": "A string can be restricted with the \"length\" (Section 9.4.4) and \"pattern\" (Section 9.4.5) statements.",
      "zh-CHS": "可以使用“长度”（第9.4.4节）和“模式”（第9.4.5节）语句限制字符串。"
    },
    {
      "indent": 0,
      "text": "9.4.4. The \"length\" Statement",
      "section_title": true,
      "zh-CHS": "9.4.4. “长度”陈述"
    },
    {
      "indent": 3,
      "text": "The \"length\" statement, which is an optional substatement to the \"type\" statement, takes as an argument a length expression string. It is used to restrict the built-in types \"string\" and \"binary\" or types derived from them.",
      "zh-CHS": "“length”语句是“type”语句的可选子语句，它以长度表达式字符串作为参数。它用于限制内置类型“string”和“binary”或从它们派生的类型。"
    },
    {
      "indent": 3,
      "text": "A \"length\" statement restricts the number of Unicode characters in the string.",
      "zh-CHS": "“length”语句限制字符串中Unicode字符的数量。"
    },
    {
      "indent": 3,
      "text": "A length range consists of an explicit value, or a lower bound, two consecutive dots \"..\", and an upper bound. Multiple values or ranges can be given, separated by \"|\". Length-restricting values MUST NOT be negative. If multiple values or ranges are given, they all MUST be disjoint and MUST be in ascending order. If a length restriction is applied to a type that is already length-restricted, the new restriction MUST be equally limiting or more limiting, i.e., raising the lower bounds, reducing the upper bounds, removing explicit length values or ranges, or splitting ranges into multiple ranges with intermediate gaps. A length value is a non-negative integer or one of the special values \"min\" or \"max\". \"min\" and \"max\" mean the minimum and maximum lengths accepted for the type being restricted, respectively. An implementation is not required to support a length value larger than 18446744073709551615.",
      "zh-CHS": "长度范围由一个显式值或一个下限、两个连续点“.”和一个上限组成。可以给出多个值或范围，以“|”分隔。长度限制值不得为负值。如果给定了多个值或范围，则它们都必须是不相交的，并且必须按升序排列。如果将长度限制应用于已受长度限制的类型，则新限制必须具有相同的限制或更大的限制，即提高下界、降低上界、删除显式长度值或范围，或将范围拆分为具有中间间隙的多个范围。长度值是非负整数或特殊值“min”或“max”之一。“最小”和“最大”分别指受限制类型可接受的最小和最大长度。实现不需要支持大于18446744073709551615的长度值。"
    },
    {
      "indent": 3,
      "text": "The length expression syntax is formally defined by the rule \"length-arg\" in Section 14.",
      "zh-CHS": "长度表达式语法由第14节中的规则“length arg”正式定义。"
    },
    {
      "indent": 0,
      "text": "9.4.4.1. The length's Substatements",
      "section_title": true,
      "zh-CHS": "9.4.4.1. 长度的子状态"
    },
    {
      "indent": 17,
      "text": "+---------------+---------+-------------+\n| substatement  | section | cardinality |\n+---------------+---------+-------------+\n| description   | 7.21.3  | 0..1        |\n| error-app-tag | 7.5.4.2 | 0..1        |\n| error-message | 7.5.4.1 | 0..1        |\n| reference     | 7.21.4  | 0..1        |\n+---------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "9.4.5. The \"pattern\" Statement",
      "section_title": true,
      "zh-CHS": "9.4.5. “模式”声明"
    },
    {
      "indent": 3,
      "text": "The \"pattern\" statement, which is an optional substatement to the \"type\" statement, takes as an argument a regular expression string, as defined in [XSD-TYPES]. It is used to restrict the built-in type \"string\", or types derived from \"string\", to values that match the pattern.",
      "zh-CHS": "“pattern”语句是“type”语句的可选子语句，它将[XSD-TYPES]中定义的正则表达式字符串作为参数。它用于将内置类型“string”或从“string”派生的类型限制为与模式匹配的值。"
    },
    {
      "indent": 3,
      "text": "If the type has multiple \"pattern\" statements, the expressions are ANDed together, i.e., all such expressions have to match.",
      "zh-CHS": "如果类型有多个“模式”语句，则表达式将被AND放在一起，即所有此类表达式都必须匹配。"
    },
    {
      "indent": 3,
      "text": "If a pattern restriction is applied to a type that is already pattern-restricted, values must match all patterns in the base type, in addition to the new patterns.",
      "zh-CHS": "如果对已受模式限制的类型应用了模式限制，则除了新模式外，值还必须与基类型中的所有模式匹配。"
    },
    {
      "indent": 0,
      "text": "9.4.5.1. The pattern's Substatements",
      "section_title": true,
      "zh-CHS": "9.4.5.1. 模式的子状态"
    },
    {
      "indent": 17,
      "text": "+---------------+---------+-------------+\n| substatement  | section | cardinality |\n+---------------+---------+-------------+\n| description   | 7.21.3  | 0..1        |\n| error-app-tag | 7.5.4.2 | 0..1        |\n| error-message | 7.5.4.1 | 0..1        |\n| modifier      | 9.4.6   | 0..1        |\n| reference     | 7.21.4  | 0..1        |\n+---------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "9.4.6. The \"modifier\" Statement",
      "section_title": true,
      "zh-CHS": "9.4.6. “修饰语”语句"
    },
    {
      "indent": 3,
      "text": "The \"modifier\" statement, which is an optional substatement to the \"pattern\" statement, takes as an argument the string \"invert-match\".",
      "zh-CHS": "“modifier”语句是“pattern”语句的可选子语句，它将字符串“invert match”作为参数。"
    },
    {
      "indent": 3,
      "text": "If a pattern has the \"invert-match\" modifier present, the type is restricted to values that do not match the pattern.",
      "zh-CHS": "如果图案具有“反转匹配”修饰符，则该类型仅限于与图案不匹配的值。"
    },
    {
      "indent": 0,
      "text": "9.4.7. Usage Example",
      "section_title": true,
      "zh-CHS": "9.4.7. 用法示例"
    },
    {
      "indent": 3,
      "text": "With the following typedef:",
      "zh-CHS": "使用以下typedef："
    },
    {
      "indent": 5,
      "text": "typedef my-base-str-type {\n  type string {\n    length \"1..255\";\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "the following refinement is legal:",
      "zh-CHS": "以下改进是合法的："
    },
    {
      "indent": 5,
      "text": "type my-base-str-type {\n  // legal length refinement\n  length \"11 | 42..max\"; // 11 | 42..255\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "and the following refinement is illegal:",
      "zh-CHS": "以下细化是非法的："
    },
    {
      "indent": 5,
      "text": "type my-base-str-type {\n  // illegal length refinement\n  length \"1..999\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "With the following type:",
      "zh-CHS": "使用以下类型："
    },
    {
      "indent": 5,
      "text": "type string {\n  length \"0..4\";\n  pattern \"[0-9a-fA-F]*\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "the following strings match:",
      "zh-CHS": "以下字符串匹配："
    },
    {
      "indent": 5,
      "text": "AB          // legal\n9A00        // legal",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "and the following strings do not match:",
      "zh-CHS": "并且以下字符串不匹配："
    },
    {
      "indent": 5,
      "text": "00ABAB      // illegal, too long\nxx00        // illegal, bad characters",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "With the following type:",
      "zh-CHS": "使用以下类型："
    },
    {
      "indent": 5,
      "text": "type string {\n  length \"1..max\";\n  pattern '[a-zA-Z_][a-zA-Z0-9\\-_.]*';\n  pattern '[xX][mM][lL].*' {\n    modifier invert-match;\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "the following string matches:",
      "zh-CHS": "以下字符串匹配："
    },
    {
      "indent": 5,
      "text": "enabled // legal",
      "zh-CHS": "启用//合法"
    },
    {
      "indent": 3,
      "text": "and the following strings do not match:",
      "zh-CHS": "并且以下字符串不匹配："
    },
    {
      "indent": 5,
      "text": "10-mbit     // illegal, starts with a number\nxml-element // illegal, starts with illegal sequence",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "9.5. The boolean Built-In Type",
      "section_title": true,
      "zh-CHS": "9.5. 布尔型内置类型"
    },
    {
      "indent": 3,
      "text": "The boolean built-in type represents a boolean value.",
      "zh-CHS": "布尔内置类型表示布尔值。"
    },
    {
      "indent": 0,
      "text": "9.5.1. Lexical Representation",
      "section_title": true,
      "zh-CHS": "9.5.1. 词汇表征"
    },
    {
      "indent": 3,
      "text": "The lexical representation of a boolean value is a string with a value of \"true\" or \"false\". These values MUST be in lowercase.",
      "zh-CHS": "布尔值的词汇表示是一个值为“真”或“假”的字符串。这些值必须为小写。"
    },
    {
      "indent": 0,
      "text": "9.5.2. Canonical Form",
      "section_title": true,
      "zh-CHS": "9.5.2. 标准形"
    },
    {
      "indent": 3,
      "text": "The canonical form is the same as the lexical representation.",
      "zh-CHS": "规范形式与词汇表示相同。"
    },
    {
      "indent": 0,
      "text": "9.5.3. Restrictions",
      "section_title": true,
      "zh-CHS": "9.5.3. 限制"
    },
    {
      "indent": 3,
      "text": "A boolean cannot be restricted.",
      "zh-CHS": "布尔值不能被限制。"
    },
    {
      "indent": 0,
      "text": "9.6. The enumeration Built-In Type",
      "section_title": true,
      "zh-CHS": "9.6. 枚举内置类型"
    },
    {
      "indent": 3,
      "text": "The enumeration built-in type represents values from a set of assigned names.",
      "zh-CHS": "枚举内置类型表示一组指定名称中的值。"
    },
    {
      "indent": 0,
      "text": "9.6.1. Lexical Representation",
      "section_title": true,
      "zh-CHS": "9.6.1. 词汇表征"
    },
    {
      "indent": 3,
      "text": "The lexical representation of an enumeration value is the assigned name string.",
      "zh-CHS": "枚举值的词法表示是指定的名称字符串。"
    },
    {
      "indent": 0,
      "text": "9.6.2. Canonical Form",
      "section_title": true,
      "zh-CHS": "9.6.2. 标准形"
    },
    {
      "indent": 3,
      "text": "The canonical form is the assigned name string.",
      "zh-CHS": "规范形式是指定的名称字符串。"
    },
    {
      "indent": 0,
      "text": "9.6.3. Restrictions",
      "section_title": true,
      "zh-CHS": "9.6.3. 限制"
    },
    {
      "indent": 3,
      "text": "An enumeration can be restricted with one or more \"enum\" (Section 9.6.4) statements, which enumerate a subset of the values for the base type.",
      "zh-CHS": "可以使用一个或多个“enum”（第9.6.4节）语句限制枚举，这些语句枚举基类型值的子集。"
    },
    {
      "indent": 0,
      "text": "9.6.4. The \"enum\" Statement",
      "section_title": true,
      "zh-CHS": "9.6.4. “enum”语句"
    },
    {
      "indent": 3,
      "text": "The \"enum\" statement, which is a substatement to the \"type\" statement, MUST be present if the type is \"enumeration\". It is repeatedly used to specify each assigned name of an enumeration type. It takes as an argument a string that is the assigned name. The string MUST NOT be zero-length and MUST NOT have any leading or trailing whitespace characters (any Unicode character with the \"White_Space\" property). The use of Unicode control codes SHOULD be avoided.",
      "zh-CHS": "“enum”语句是“type”语句的子语句，如果类型为“enumeration”，则必须存在该语句。它反复用于指定枚举类型的每个指定名称。它将指定名称的字符串作为参数。字符串长度不得为零，且不得包含任何前导或尾随空格字符（任何具有“White_Space”属性的Unicode字符）。应避免使用Unicode控制代码。"
    },
    {
      "indent": 3,
      "text": "The statement is optionally followed by a block of substatements that holds detailed enum information.",
      "zh-CHS": "该语句后面有一个包含详细枚举信息的子语句块（可选）。"
    },
    {
      "indent": 3,
      "text": "All assigned names in an enumeration MUST be unique.",
      "zh-CHS": "枚举中所有分配的名称都必须是唯一的。"
    },
    {
      "indent": 3,
      "text": "When an existing enumeration type is restricted, the set of assigned names in the new type MUST be a subset of the base type's set of assigned names. The value of such an assigned name MUST NOT be changed.",
      "zh-CHS": "当限制现有枚举类型时，新类型中的已分配名称集必须是基类型的已分配名称集的子集。不得更改此类指定名称的值。"
    },
    {
      "indent": 0,
      "text": "9.6.4.1. The enum's Substatements",
      "section_title": true,
      "zh-CHS": "9.6.4.1. 枚举的子语句"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| description  | 7.21.3  | 0..1        |\n| if-feature   | 7.20.2  | 0..n        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| value        | 9.6.4.2 | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "9.6.4.2. The \"value\" Statement",
      "section_title": true,
      "zh-CHS": "9.6.4.2. “价值”陈述"
    },
    {
      "indent": 3,
      "text": "The \"value\" statement, which is optional, is used to associate an integer value with the assigned name for the enum. This integer value MUST be in the range -2147483648 to 2147483647, and it MUST be unique within the enumeration type.",
      "zh-CHS": "“value”语句是可选的，用于将整数值与枚举的指定名称相关联。此整数值必须在-2147483648到2147483647之间，并且在枚举类型中必须是唯一的。"
    },
    {
      "indent": 3,
      "text": "If a value is not specified, then one will be automatically assigned. If the \"enum\" substatement is the first one defined, the assigned value is zero (0); otherwise, the assigned value is one greater than the current highest enum value (i.e., the highest enum value, implicit or explicit, prior to the current \"enum\" substatement in the parent \"type\" statement).",
      "zh-CHS": "如果未指定值，则将自动指定一个值。如果“enum”子状态是第一个定义的子状态，则赋值为零（0）；否则，分配的值比当前最高枚举值大一个（即，在父“type”语句中当前“enum”子语句之前的隐式或显式最高枚举值）。"
    },
    {
      "indent": 3,
      "text": "Note that the presence of an \"if-feature\" statement in an \"enum\" statement does not affect the automatically assigned value.",
      "zh-CHS": "请注意，“enum”语句中存在“if feature”语句不会影响自动分配的值。"
    },
    {
      "indent": 3,
      "text": "If the current highest value is equal to 2147483647, then an enum value MUST be specified for \"enum\" substatements following the one with the current highest value.",
      "zh-CHS": "如果当前最大值等于2147483647，则必须为具有当前最大值的子状态之后的“enum”子状态指定枚举值。"
    },
    {
      "indent": 3,
      "text": "When an existing enumeration type is restricted, the \"value\" statement MUST either have the same value as in the base type or not be present, in which case the value is the same as in the base type.",
      "zh-CHS": "当限制现有枚举类型时，“value”语句必须与基类型中的值相同或不存在，在这种情况下，该值与基类型中的值相同。"
    },
    {
      "indent": 0,
      "text": "9.6.5. Usage Example",
      "section_title": true,
      "zh-CHS": "9.6.5. 用法示例"
    },
    {
      "indent": 5,
      "text": "leaf myenum {\n  type enumeration {\n    enum zero;\n    enum one;\n    enum seven {\n      value 7;\n    }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The lexical representation of the leaf \"myenum\" with value \"seven\" is:",
      "zh-CHS": "值为“seven”的叶“myenum”的词汇表示为："
    },
    {
      "indent": 5,
      "text": "<myenum>seven</myenum>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "With the following typedef:",
      "zh-CHS": "使用以下typedef："
    },
    {
      "indent": 5,
      "text": "typedef my-base-enumeration-type {\n  type enumeration {\n    enum white {\n      value 1;\n    }\n    enum yellow {\n      value 2;\n    }\n    enum red {\n      value 3;\n    }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "the following refinement is legal:",
      "zh-CHS": "以下改进是合法的："
    },
    {
      "indent": 5,
      "text": "type my-base-enumeration-type {\n  // legal enum refinement\n  enum yellow;\n  enum red {\n    value 3;\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "and the following refinement is illegal:",
      "zh-CHS": "以下细化是非法的："
    },
    {
      "indent": 5,
      "text": "type my-base-enumeration-type {\n  // illegal enum refinement\n  enum yellow {\n    value 4; // illegal value change\n  }\n  enum black; // illegal addition of new name\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The following example shows how an \"enum\" can be tagged with \"if-feature\", making the value legal only on servers that advertise the corresponding feature:",
      "zh-CHS": "以下示例显示了如何使用“if feature”标记“enum”，使该值仅在发布相应功能的服务器上合法："
    },
    {
      "indent": 5,
      "text": "type enumeration {\n  enum tcp;\n  enum ssh {\n    if-feature ssh;\n  }\n  enum tls {\n    if-feature tls;\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "9.7. The bits Built-In Type",
      "section_title": true,
      "zh-CHS": "9.7. 内置式钻头"
    },
    {
      "indent": 3,
      "text": "The bits built-in type represents a bit set. That is, a bits value is a set of flags identified by small integer position numbers starting at 0. Each bit number has an assigned name.",
      "zh-CHS": "bits内置类型表示位集。也就是说，位值是由从0开始的小整数位置号标识的一组标志。每个位号都有一个指定的名称。"
    },
    {
      "indent": 3,
      "text": "When an existing bits type is restricted, the set of assigned names in the new type MUST be a subset of the base type's set of assigned names. The bit position of such an assigned name MUST NOT be changed.",
      "zh-CHS": "当现有bits类型受到限制时，新类型中的已分配名称集必须是基本类型的已分配名称集的子集。不得更改此类指定名称的位位置。"
    },
    {
      "indent": 0,
      "text": "9.7.1. Restrictions",
      "section_title": true,
      "zh-CHS": "9.7.1. 限制"
    },
    {
      "indent": 3,
      "text": "A bits type can be restricted with the \"bit\" (Section 9.7.4) statement.",
      "zh-CHS": "bits类型可通过“bit”（第9.7.4节）语句进行限制。"
    },
    {
      "indent": 0,
      "text": "9.7.2. Lexical Representation",
      "section_title": true,
      "zh-CHS": "9.7.2. 词汇表征"
    },
    {
      "indent": 3,
      "text": "The lexical representation of the bits type is a space-separated list of the names of the bits that are set. A zero-length string thus represents a value where no bits are set.",
      "zh-CHS": "bits类型的词汇表示是一个以空格分隔的列表，其中列出了所设置的位的名称。因此，零长度字符串表示未设置位的值。"
    },
    {
      "indent": 0,
      "text": "9.7.3. Canonical Form",
      "section_title": true,
      "zh-CHS": "9.7.3. 标准形"
    },
    {
      "indent": 3,
      "text": "In the canonical form, the bit values are separated by a single space character and they appear ordered by their position (see Section 9.7.4.2).",
      "zh-CHS": "在标准格式中，位值由单个空格字符分隔，并按其位置排列（见第9.7.4.2节）。"
    },
    {
      "indent": 0,
      "text": "9.7.4. The \"bit\" Statement",
      "section_title": true,
      "zh-CHS": "9.7.4. “比特”声明"
    },
    {
      "indent": 3,
      "text": "The \"bit\" statement, which is a substatement to the \"type\" statement, MUST be present if the type is \"bits\". It is repeatedly used to specify each assigned named bit of a bits type. It takes as an argument a string that is the assigned name of the bit. It is followed by a block of substatements that holds detailed bit information. The assigned name follows the same syntax rules as an identifier (see Section 6.2).",
      "zh-CHS": "“bit”语句是“type”语句的子语句，如果类型为“bits”，则必须存在该语句。它反复用于指定位类型的每个指定的命名位。它接受一个字符串作为参数，该字符串是位的指定名称。它后面是一个包含详细位信息的子语句块。分配的名称遵循与标识符相同的语法规则（参见第6.2节）。"
    },
    {
      "indent": 3,
      "text": "All assigned names in a bits type MUST be unique.",
      "zh-CHS": "bits类型中所有分配的名称必须是唯一的。"
    },
    {
      "indent": 0,
      "text": "9.7.4.1. The bit's Substatements",
      "section_title": true,
      "zh-CHS": "9.7.4.1. 钻头的子级"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| description  | 7.21.3  | 0..1        |\n| if-feature   | 7.20.2  | 0..n        |\n| position     | 9.7.4.2 | 0..1        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "9.7.4.2. The \"position\" Statement",
      "section_title": true,
      "zh-CHS": "9.7.4.2. “立场”声明"
    },
    {
      "indent": 3,
      "text": "The \"position\" statement, which is optional, takes as an argument a non-negative integer value that specifies the bit's position within a hypothetical bit field. The position value MUST be in the range 0 to 4294967295, and it MUST be unique within the bits type.",
      "zh-CHS": "“position”语句是可选的，它接受一个非负整数值作为参数，该数值指定位在假设位字段中的位置。位置值必须在0到4294967295之间，并且在bits类型中必须是唯一的。"
    },
    {
      "indent": 3,
      "text": "If a bit position is not specified, then one will be automatically assigned. If the \"bit\" substatement is the first one defined, the assigned value is zero (0); otherwise, the assigned value is one greater than the current highest bit position (i.e., the highest bit position, implicit or explicit, prior to the current \"bit\" substatement in the parent \"type\" statement).",
      "zh-CHS": "如果未指定位位置，则将自动分配一个位位置。如果“位”子状态是第一个定义的子状态，则赋值为零（0）；否则，分配的值比当前最高位位置大一个（即，在父“type”语句中当前“bit”子状态之前的隐式或显式最高位位置）。"
    },
    {
      "indent": 3,
      "text": "Note that the presence of an \"if-feature\" statement in a \"bit\" statement does not affect the automatically assigned position.",
      "zh-CHS": "请注意，“bit”语句中出现“if feature”语句不会影响自动分配的位置。"
    },
    {
      "indent": 3,
      "text": "If the current highest bit position value is equal to 4294967295, then a position value MUST be specified for \"bit\" substatements following the one with the current highest position value.",
      "zh-CHS": "如果当前最高位位置值等于4294967295，则必须为具有当前最高位置值的子状态之后的“位”子状态指定位置值。"
    },
    {
      "indent": 3,
      "text": "When an existing bits type is restricted, the \"position\" statement MUST either have the same value as in the base type or not be present, in which case the value is the same as in the base type.",
      "zh-CHS": "当现有bits类型受到限制时，“position”语句必须与基类型中的值相同或不存在，在这种情况下，该值与基类型中的值相同。"
    },
    {
      "indent": 0,
      "text": "9.7.5. Usage Example",
      "section_title": true,
      "zh-CHS": "9.7.5. 用法示例"
    },
    {
      "indent": 3,
      "text": "Given the following typedef and leaf:",
      "zh-CHS": "给定以下typedef和leaf："
    },
    {
      "indent": 5,
      "text": "typedef mybits-type {\n  type bits {\n    bit disable-nagle {\n      position 0;\n    }\n    bit auto-sense-speed {\n      position 1;\n    }\n    bit ten-mb-only {\n      position 2;\n    }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "leaf mybits {\n  type mybits-type;\n  default \"auto-sense-speed\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The lexical representation of this leaf with bit values disable-nagle and ten-mb-only set would be:",
      "zh-CHS": "此叶的词法表示（位值为disable nagle且仅设置了10 mb）为："
    },
    {
      "indent": 5,
      "text": "<mybits>disable-nagle ten-mb-only</mybits>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The following example shows a legal refinement of this type:",
      "zh-CHS": "以下示例显示了此类型的法律细化："
    },
    {
      "indent": 5,
      "text": "type mybits-type {\n  // legal bit refinement\n  bit disable-nagle {\n    position 0;\n  }\n  bit auto-sense-speed {\n    position 1;\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "and the following refinement is illegal:",
      "zh-CHS": "以下细化是非法的："
    },
    {
      "indent": 5,
      "text": "type mybits-type {\n  // illegal bit refinement\n  bit disable-nagle {\n    position 2; // illegal position change\n  }\n  bit hundred-mb-only; // illegal addition of new name\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "9.8. The binary Built-In Type",
      "section_title": true,
      "zh-CHS": "9.8. 二进制内置类型"
    },
    {
      "indent": 3,
      "text": "The binary built-in type represents any binary data, i.e., a sequence of octets.",
      "zh-CHS": "二进制内置类型表示任何二进制数据，即八位字节序列。"
    },
    {
      "indent": 0,
      "text": "9.8.1. Restrictions",
      "section_title": true,
      "zh-CHS": "9.8.1. 限制"
    },
    {
      "indent": 3,
      "text": "A binary type can be restricted with the \"length\" (Section 9.4.4) statement. The length of a binary value is the number of octets it contains.",
      "zh-CHS": "二进制类型可以通过“长度”（第9.4.4节）语句进行限制。二进制值的长度是它包含的八位字节数。"
    },
    {
      "indent": 0,
      "text": "9.8.2. Lexical Representation",
      "section_title": true,
      "zh-CHS": "9.8.2. 词汇表征"
    },
    {
      "indent": 3,
      "text": "Binary values are encoded with the base64 encoding scheme (see Section 4 in [RFC4648]).",
      "zh-CHS": "二进制值采用base64编码方案进行编码（参见[RFC4648]中的第4节）。"
    },
    {
      "indent": 0,
      "text": "9.8.3. Canonical Form",
      "section_title": true,
      "zh-CHS": "9.8.3. 标准形"
    },
    {
      "indent": 3,
      "text": "The canonical form of a binary value follows the rules of \"Base 64 Encoding\" in [RFC4648].",
      "zh-CHS": "二进制值的标准形式遵循[RFC4648]中的“base64编码”规则。"
    },
    {
      "indent": 0,
      "text": "9.9. The leafref Built-In Type",
      "section_title": true,
      "zh-CHS": "9.9. leafref内置类型"
    },
    {
      "indent": 3,
      "text": "The leafref built-in type is restricted to the value space of some leaf or leaf-list node in the schema tree and optionally further restricted by corresponding instance nodes in the data tree. The \"path\" substatement (Section 9.9.2) is used to identify the referred leaf or leaf-list node in the schema tree. The value space of the referring node is the value space of the referred node.",
      "zh-CHS": "leafref内置类型仅限于模式树中某个叶或叶列表节点的值空间，并且还可以进一步受到数据树中相应实例节点的限制。“路径”子语句（第9.9.2节）用于标识模式树中引用的叶或叶列表节点。引用节点的值空间是引用节点的值空间。"
    },
    {
      "indent": 3,
      "text": "If the \"require-instance\" property (Section 9.9.3) is \"true\", there MUST exist a node in the data tree, or a node with a default value in use (see Sections 7.6.1 and 7.7.2), of the referred schema tree leaf or leaf-list node with the same value as the leafref value in a valid data tree.",
      "zh-CHS": "如果“require instance”属性（第9.9.3节）为“true”，则数据树中必须存在一个节点，或者引用的模式树叶或叶列表节点的默认值（见第7.6.1节和第7.7.2节）与有效数据树中的leafref值相同的节点。"
    },
    {
      "indent": 3,
      "text": "If the referring node represents configuration data and the \"require-instance\" property (Section 9.9.3) is \"true\", the referred node MUST also represent configuration.",
      "zh-CHS": "如果引用节点表示配置数据且“require instance”属性（第9.9.3节）为“true”，则引用节点还必须表示配置。"
    },
    {
      "indent": 3,
      "text": "There MUST NOT be any circular chains of leafrefs.",
      "zh-CHS": "叶参照不得有任何环形链。"
    },
    {
      "indent": 3,
      "text": "If the leaf that the leafref refers to is conditional based on one or more features (see Section 7.20.2), then the leaf with the leafref type MUST also be conditional based on at least the same set of features.",
      "zh-CHS": "如果leafref引用的叶基于一个或多个特征（见第7.20.2节），则具有leafref类型的叶也必须基于至少相同的特征集。"
    },
    {
      "indent": 0,
      "text": "9.9.1. Restrictions",
      "section_title": true,
      "zh-CHS": "9.9.1. 限制"
    },
    {
      "indent": 3,
      "text": "A leafref can be restricted with the \"require-instance\" statement (Section 9.9.3).",
      "zh-CHS": "leafref可以通过“require instance”语句进行限制（第9.9.3节）。"
    },
    {
      "indent": 0,
      "text": "9.9.2. The \"path\" Statement",
      "section_title": true,
      "zh-CHS": "9.9.2. “路径”语句"
    },
    {
      "indent": 3,
      "text": "The \"path\" statement, which is a substatement to the \"type\" statement, MUST be present if the type is \"leafref\". It takes as an argument a string that MUST refer to a leaf or leaf-list node.",
      "zh-CHS": "“path”语句是“type”语句的子语句，如果类型为“leafref”，则必须存在该语句。它接受一个必须引用叶或叶列表节点的字符串作为参数。"
    },
    {
      "indent": 3,
      "text": "The syntax for a path argument is a subset of the XPath abbreviated syntax. Predicates are used only for constraining the values for the key nodes for list entries. Each predicate consists of exactly one equality test per key, and multiple adjacent predicates MAY be present if a list has multiple keys. The syntax is formally defined by the rule \"path-arg\" in Section 14.",
      "zh-CHS": "path参数的语法是XPath缩写语法的子集。谓词仅用于约束列表项的关键节点的值。每个谓词对于每个键只包含一个相等测试，如果列表有多个键，则可能存在多个相邻谓词。语法由第14节中的规则“path arg”正式定义。"
    },
    {
      "indent": 3,
      "text": "The predicates are only used when more than one key reference is needed to uniquely identify a leaf instance. This occurs if a list has multiple keys or a reference to a leaf other than the key in a list is needed. In these cases, multiple leafrefs are typically specified, and predicates are used to tie them together.",
      "zh-CHS": "谓词仅在需要多个键引用来唯一标识叶实例时使用。如果列表有多个键，或者需要对列表中键以外的叶的引用，则会发生这种情况。在这些情况下，通常会指定多个leafref，并使用谓词将它们连接在一起。"
    },
    {
      "indent": 3,
      "text": "The \"path\" expression evaluates to a node set consisting of zero, one, or more nodes. If the \"require-instance\" property is \"true\", this node set MUST be non-empty.",
      "zh-CHS": "“路径”表达式的计算结果是由零个、一个或多个节点组成的节点集。如果“require instance”属性为“true”，则此节点集必须为非空。"
    },
    {
      "indent": 3,
      "text": "The \"path\" XPath expression is conceptually evaluated in the following context, in addition to the definition in Section 6.4.1:",
      "zh-CHS": "除了第6.4.1节中的定义外，还将在以下上下文中对“path”XPath表达式进行概念性评估："
    },
    {
      "indent": 3,
      "text": "o If the \"path\" statement is defined within a typedef, the context node is the leaf or leaf-list node in the data tree that references the typedef.",
      "zh-CHS": "o 如果在typedef中定义了“path”语句，则上下文节点是引用typedef的数据树中的叶或叶列表节点。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, the context node is the node in the data tree for which the \"path\" statement is defined.",
      "zh-CHS": "o 否则，上下文节点就是为其定义“path”语句的数据树中的节点。"
    },
    {
      "indent": 0,
      "text": "9.9.3. The \"require-instance\" Statement",
      "section_title": true,
      "zh-CHS": "9.9.3. “require instance”语句"
    },
    {
      "indent": 3,
      "text": "The \"require-instance\" statement, which is a substatement to the \"type\" statement, MAY be present if the type is \"instance-identifier\" or \"leafref\". It takes as an argument the string \"true\" or \"false\". If this statement is not present, it defaults to \"true\".",
      "zh-CHS": "“require instance”语句是“type”语句的子语句，如果类型是“instance identifier”或“leafref”，则可能存在该语句。它将字符串“true”或“false”作为参数。如果此语句不存在，则默认为“true”。"
    },
    {
      "indent": 3,
      "text": "If \"require-instance\" is \"true\", it means that the instance being referred to MUST exist for the data to be valid. This constraint is enforced according to the rules in Section 8.",
      "zh-CHS": "如果“require instance”为“true”，则表示引用的实例必须存在才能使数据有效。此约束根据第8节中的规则强制执行。"
    },
    {
      "indent": 3,
      "text": "If \"require-instance\" is \"false\", it means that the instance being referred to MAY exist in valid data.",
      "zh-CHS": "如果“require instance”为“false”，则表示引用的实例可能存在于有效数据中。"
    },
    {
      "indent": 0,
      "text": "9.9.4. Lexical Representation",
      "section_title": true,
      "zh-CHS": "9.9.4. 词汇表征"
    },
    {
      "indent": 3,
      "text": "A leafref value is lexically represented the same way as the leaf it references represents its value.",
      "zh-CHS": "leafref值在词汇上的表示方式与其引用的叶表示其值的方式相同。"
    },
    {
      "indent": 0,
      "text": "9.9.5. Canonical Form",
      "section_title": true,
      "zh-CHS": "9.9.5. 标准形"
    },
    {
      "indent": 3,
      "text": "The canonical form of a leafref is the same as the canonical form of the leaf it references.",
      "zh-CHS": "leafref的标准形式与它引用的叶的标准形式相同。"
    },
    {
      "indent": 0,
      "text": "9.9.6. Usage Example",
      "section_title": true,
      "zh-CHS": "9.9.6. 用法示例"
    },
    {
      "indent": 3,
      "text": "With the following list:",
      "zh-CHS": "以下是："
    },
    {
      "indent": 5,
      "text": "list interface {\n  key \"name\";\n  leaf name {\n    type string;\n  }\n  leaf admin-status {\n    type admin-status;\n  }\n  list address {\n    key \"ip\";\n    leaf ip {\n      type yang:ip-address;\n    }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "the following leafref refers to an existing interface:",
      "zh-CHS": "以下leafref引用现有接口："
    },
    {
      "indent": 5,
      "text": "leaf mgmt-interface {\n  type leafref {\n    path \"../interface/name\";\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "An example of a corresponding XML snippet:",
      "zh-CHS": "对应的XML代码段示例："
    },
    {
      "indent": 5,
      "text": "<interface>\n  <name>eth0</name>\n</interface>\n<interface>\n  <name>lo</name>\n</interface>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "<mgmt-interface>eth0</mgmt-interface>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The following leafrefs refer to an existing address of an interface:",
      "zh-CHS": "以下叶引用引用接口的现有地址："
    },
    {
      "indent": 5,
      "text": "container default-address {\n  leaf ifname {\n    type leafref {\n      path \"../../interface/name\";\n    }\n  }\n  leaf address {\n    type leafref {\n      path \"../../interface[name = current()/../ifname]\"\n         + \"/address/ip\";\n    }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "An example of a corresponding XML snippet:",
      "zh-CHS": "对应的XML代码段示例："
    },
    {
      "indent": 5,
      "text": "<interface>\n  <name>eth0</name>\n  <admin-status>up</admin-status>\n  <address>\n    <ip>192.0.2.1</ip>\n  </address>\n  <address>\n    <ip>192.0.2.2</ip>\n  </address>\n</interface>\n<interface>\n  <name>lo</name>\n  <admin-status>up</admin-status>\n  <address>\n    <ip>127.0.0.1</ip>\n  </address>\n</interface>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "<default-address>\n  <ifname>eth0</ifname>\n  <address>192.0.2.2</address>\n</default-address>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The following list uses a leafref for one of its keys. This is similar to a foreign key in a relational database.",
      "zh-CHS": "下面的列表使用leafref作为其键之一。这类似于关系数据库中的外键。"
    },
    {
      "indent": 5,
      "text": "list packet-filter {\n  key \"if-name filter-id\";\n  leaf if-name {\n    type leafref {\n      path \"/interface/name\";\n    }\n  }\n  leaf filter-id {\n    type uint32;\n  }\n  ...\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "An example of a corresponding XML snippet:",
      "zh-CHS": "对应的XML代码段示例："
    },
    {
      "indent": 5,
      "text": "<interface>\n  <name>eth0</name>\n  <admin-status>up</admin-status>\n  <address>\n    <ip>192.0.2.1</ip>\n  </address>\n  <address>\n    <ip>192.0.2.2</ip>\n  </address>\n</interface>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "<packet-filter>\n  <if-name>eth0</if-name>\n  <filter-id>1</filter-id>\n  ...\n</packet-filter>\n<packet-filter>\n  <if-name>eth0</if-name>\n  <filter-id>2</filter-id>\n  ...\n</packet-filter>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The following notification defines two leafrefs to refer to an existing admin-status:",
      "zh-CHS": "以下通知定义了两个LeafRef以引用现有管理员状态："
    },
    {
      "indent": 5,
      "text": "notification link-failure {\n  leaf if-name {\n    type leafref {\n      path \"/interface/name\";\n    }\n  }\n  leaf admin-status {\n    type leafref {\n      path \"/interface[name = current()/../if-name]\"\n         + \"/admin-status\";\n    }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "An example of a corresponding XML notification:",
      "zh-CHS": "相应的XML通知示例如下："
    },
    {
      "indent": 5,
      "text": "<notification\n  xmlns=\"urn:ietf:params:xml:ns:netconf:notification:1.0\">\n  <eventTime>2008-04-01T00:01:00Z</eventTime>\n  <link-failure xmlns=\"urn:example:system\">\n    <if-name>eth0</if-name>\n    <admin-status>up</admin-status>\n  </link-failure>\n</notification>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "9.10. The identityref Built-In Type",
      "section_title": true,
      "zh-CHS": "9.10. identityref内置类型"
    },
    {
      "indent": 3,
      "text": "The identityref built-in type is used to reference an existing identity (see Section 7.18).",
      "zh-CHS": "identityref内置类型用于引用现有标识（见第7.18节）。"
    },
    {
      "indent": 0,
      "text": "9.10.1. Restrictions",
      "section_title": true,
      "zh-CHS": "9.10.1. 限制"
    },
    {
      "indent": 3,
      "text": "An identityref cannot be restricted.",
      "zh-CHS": "无法限制identityref。"
    },
    {
      "indent": 0,
      "text": "9.10.2. The identityref's \"base\" Statement",
      "section_title": true,
      "zh-CHS": "9.10.2. identityref的“base”语句"
    },
    {
      "indent": 3,
      "text": "The \"base\" statement, which is a substatement to the \"type\" statement, MUST be present at least once if the type is \"identityref\". The argument is the name of an identity, as defined by an \"identity\" statement. If a prefix is present on the identity name, it refers to an identity defined in the module that was imported with that prefix. Otherwise, an identity with the matching name MUST be defined in the current module or an included submodule.",
      "zh-CHS": "如果类型为“identityref”，则作为“type”语句的子语句的“base”语句必须至少出现一次。参数是由“identity”语句定义的标识的名称。如果标识名上存在前缀，则它指的是使用该前缀导入的模块中定义的标识。否则，必须在当前模块或包含的子模块中定义具有匹配名称的标识。"
    },
    {
      "indent": 3,
      "text": "Valid values for an identityref are any identities derived from all the identityref's base identities. On a particular server, the valid values are further restricted to the set of identities defined in the modules implemented by the server.",
      "zh-CHS": "identityref的有效值是从所有identityref的基本标识派生的任何标识。在特定服务器上，有效值进一步限制为服务器实现的模块中定义的标识集。"
    },
    {
      "indent": 0,
      "text": "9.10.3. Lexical Representation",
      "section_title": true,
      "zh-CHS": "9.10.3. 词汇表征"
    },
    {
      "indent": 3,
      "text": "An identityref is lexically represented as the referred identity's qualified name as defined in [XML-NAMES]. If the prefix is not present, the namespace of the identityref is the default namespace in effect on the element that contains the identityref value.",
      "zh-CHS": "identityref在词汇上表示为[XML-NAMES]中定义的引用标识的限定名。如果前缀不存在，则identityref的命名空间是对包含identityref值的元素有效的默认命名空间。"
    },
    {
      "indent": 3,
      "text": "When an identityref is given a default value using the \"default\" statement, the identity name in the default value MAY have a prefix. If a prefix is present on the identity name, it refers to an identity defined in the module that was imported with that prefix, or the prefix for the current module if the identity is defined in the",
      "zh-CHS": "当使用“default”语句为identityref指定默认值时，默认值中的标识名可能有前缀。如果标识名上存在前缀，则该前缀指的是使用该前缀导入的模块中定义的标识，或者如果标识是在中定义的，则指的是当前模块的前缀"
    },
    {
      "indent": 3,
      "text": "current module or one of its submodules. Otherwise, an identity with the matching name MUST be defined in the current module or one of its submodules.",
      "zh-CHS": "当前模块或其子模块之一。否则，必须在当前模块或其子模块之一中定义具有匹配名称的标识。"
    },
    {
      "indent": 3,
      "text": "The string value of a node of type \"identityref\" in a \"must\" or \"when\" XPath expression is the referred identity's qualified name with the prefix present. If the referred identity is defined in an imported module, the prefix in the string value is the prefix defined in the corresponding \"import\" statement. Otherwise, the prefix in the string value is the prefix for the current module.",
      "zh-CHS": "“must”或“when”XPath表达式中类型为“identityref”的节点的字符串值是引用的标识的限定名，前缀为present。如果引用的标识是在导入的模块中定义的，则字符串值中的前缀是在相应的“import”语句中定义的前缀。否则，字符串值中的前缀就是当前模块的前缀。"
    },
    {
      "indent": 0,
      "text": "9.10.4. Canonical Form",
      "section_title": true,
      "zh-CHS": "9.10.4. 标准形"
    },
    {
      "indent": 3,
      "text": "Since the lexical form depends on the XML context in which the value occurs, this type does not have a canonical form.",
      "zh-CHS": "由于词汇形式取决于值出现的XML上下文，因此该类型没有规范形式。"
    },
    {
      "indent": 0,
      "text": "9.10.5. Usage Example",
      "section_title": true,
      "zh-CHS": "9.10.5. 用法示例"
    },
    {
      "indent": 3,
      "text": "With the identity definitions in Section 7.18.3 and the following module:",
      "zh-CHS": "使用第7.18.3节中的标识定义和以下模块："
    },
    {
      "indent": 5,
      "text": "module example-my-crypto {\n  yang-version 1.1;\n  namespace \"urn:example:my-crypto\";\n  prefix mc;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "import \"example-crypto-base\" {\n  prefix \"crypto\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "identity aes {\n  base \"crypto:crypto-alg\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "leaf crypto {\n  type identityref {\n    base \"crypto:crypto-alg\";\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "  container aes-parameters {\n    when \"../crypto = 'mc:aes'\";\n    ...\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "the following is an example of how the leaf \"crypto\" can be encoded, if the value is the \"des3\" identity defined in the \"des\" module:",
      "zh-CHS": "如果值是“des”模块中定义的“des3”标识，下面是如何对叶“crypto”进行编码的示例："
    },
    {
      "indent": 5,
      "text": "<crypto xmlns:des=\"urn:example:des\">des:des3</crypto>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Any prefixes used in the encoding are local to each instance encoding. This means that the same identityref may be encoded differently by different implementations. For example, the following example encodes the same leaf as above:",
      "zh-CHS": "编码中使用的任何前缀都是每个实例编码的本地前缀。这意味着相同的identityref可以通过不同的实现进行不同的编码。例如，以下示例对与上面相同的叶进行编码："
    },
    {
      "indent": 5,
      "text": "<crypto xmlns:x=\"urn:example:des\">x:des3</crypto>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "If the \"crypto\" leaf's value is instead \"aes\", defined in the \"example-my-crypto\" module, it can be encoded as:",
      "zh-CHS": "如果“加密”叶的值改为“aes”（在“示例my crypto”模块中定义），则可以将其编码为："
    },
    {
      "indent": 5,
      "text": "<crypto xmlns:mc=\"urn:example:my-crypto\">mc:aes</crypto>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "or, using the default namespace:",
      "zh-CHS": "或者，使用默认名称空间："
    },
    {
      "indent": 5,
      "text": "<crypto>aes</crypto>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "9.11. The empty Built-In Type",
      "section_title": true,
      "zh-CHS": "9.11. 空的内置类型"
    },
    {
      "indent": 3,
      "text": "The empty built-in type represents a leaf that does not have any value; it conveys information by its presence or absence.",
      "zh-CHS": "空的内置类型表示没有任何值的叶；它通过存在或不存在来传递信息。"
    },
    {
      "indent": 3,
      "text": "An empty type cannot have a default value.",
      "zh-CHS": "空类型不能有默认值。"
    },
    {
      "indent": 0,
      "text": "9.11.1. Restrictions",
      "section_title": true,
      "zh-CHS": "9.11.1. 限制"
    },
    {
      "indent": 3,
      "text": "An empty type cannot be restricted.",
      "zh-CHS": "不能限制空类型。"
    },
    {
      "indent": 0,
      "text": "9.11.2. Lexical Representation",
      "section_title": true,
      "zh-CHS": "9.11.2. 词汇表征"
    },
    {
      "indent": 3,
      "text": "Not applicable.",
      "zh-CHS": "不适用。"
    },
    {
      "indent": 0,
      "text": "9.11.3. Canonical Form",
      "section_title": true,
      "zh-CHS": "9.11.3. 标准形"
    },
    {
      "indent": 3,
      "text": "Not applicable.",
      "zh-CHS": "不适用。"
    },
    {
      "indent": 0,
      "text": "9.11.4. Usage Example",
      "section_title": true,
      "zh-CHS": "9.11.4. 用法示例"
    },
    {
      "indent": 3,
      "text": "With the following leaf:",
      "zh-CHS": "具有以下叶："
    },
    {
      "indent": 5,
      "text": "leaf enable-qos {\n  type empty;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "the following is an example of a valid encoding if the leaf exists:",
      "zh-CHS": "以下是叶存在时有效编码的示例："
    },
    {
      "indent": 5,
      "text": "<enable-qos/>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "9.12. The union Built-In Type",
      "section_title": true,
      "zh-CHS": "9.12. 内置式工会"
    },
    {
      "indent": 3,
      "text": "The union built-in type represents a value that corresponds to one of its member types.",
      "zh-CHS": "union内置类型表示与其成员类型之一对应的值。"
    },
    {
      "indent": 3,
      "text": "When the type is \"union\", the \"type\" statement (Section 7.4) MUST be present. It is repeatedly used to specify each member type of the union. It takes as an argument a string that is the name of a member type.",
      "zh-CHS": "当类型为“union”时，“type”语句（第7.4节）必须存在。它反复用于指定联合的每个成员类型。它接受一个字符串作为参数，该字符串是成员类型的名称。"
    },
    {
      "indent": 3,
      "text": "A member type can be of any built-in or derived type.",
      "zh-CHS": "成员类型可以是任何内置类型或派生类型。"
    },
    {
      "indent": 3,
      "text": "When generating an XML encoding, a value is encoded according to the rules of the member type to which the value belongs. When interpreting an XML encoding, a value is validated consecutively against each member type, in the order they are specified in the \"type\" statement, until a match is found. The type that matched will be the type of the value for the node that was validated, and the encoding is interpreted according to the rules for that type.",
      "zh-CHS": "生成XML编码时，将根据值所属的成员类型的规则对值进行编码。解释XML编码时，将按照“type”语句中指定的顺序，针对每个成员类型连续验证一个值，直到找到匹配项。匹配的类型将是已验证节点的值的类型，编码将根据该类型的规则进行解释。"
    },
    {
      "indent": 3,
      "text": "Any default value or \"units\" property defined in the member types is not inherited by the union type.",
      "zh-CHS": "联合类型不会继承成员类型中定义的任何默认值或“units”属性。"
    },
    {
      "indent": 0,
      "text": "9.12.1. Restrictions",
      "section_title": true,
      "zh-CHS": "9.12.1. 限制"
    },
    {
      "indent": 3,
      "text": "A union cannot be restricted. However, each member type can be restricted, based on the rules defined in Section 9.",
      "zh-CHS": "工会不能受到限制。但是，根据第9节中定义的规则，可以限制每种成员类型。"
    },
    {
      "indent": 0,
      "text": "9.12.2. Lexical Representation",
      "section_title": true,
      "zh-CHS": "9.12.2. 词汇表征"
    },
    {
      "indent": 3,
      "text": "The lexical representation of a union is a value that corresponds to the representation of any one of the member types.",
      "zh-CHS": "联合的词法表示是与任何一种成员类型的表示相对应的值。"
    },
    {
      "indent": 0,
      "text": "9.12.3. Canonical Form",
      "section_title": true,
      "zh-CHS": "9.12.3. 标准形"
    },
    {
      "indent": 3,
      "text": "The canonical form of a union value is the same as the canonical form of the member type of the value.",
      "zh-CHS": "联合值的标准形式与值的成员类型的标准形式相同。"
    },
    {
      "indent": 0,
      "text": "9.12.4. Usage Example",
      "section_title": true,
      "zh-CHS": "9.12.4. 用法示例"
    },
    {
      "indent": 3,
      "text": "The following is a union of an int32 and an enumeration:",
      "zh-CHS": "以下是int32和枚举的并集："
    },
    {
      "indent": 5,
      "text": "type union {\n  type int32;\n  type enumeration {\n    enum \"unbounded\";\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Care must be taken when a member type is a leafref where the \"require-instance\" property (Section 9.9.3) is \"true\". If a leaf of such a type refers to an existing instance, the leaf's value must be revalidated if the target instance is deleted. For example, with the following definitions:",
      "zh-CHS": "当成员类型为leafref，且“require instance”属性（第9.9.3节）为“true”时，必须小心。如果此类叶引用现有实例，则如果删除目标实例，则必须重新验证该叶的值。例如，使用以下定义："
    },
    {
      "indent": 5,
      "text": "list filter {\n  key name;\n  leaf name {\n    type string;\n  }\n  ...\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "leaf outbound-filter {\n  type union {\n    type leafref {\n      path \"/filter/name\";\n    }\n    type enumeration {\n      enum default-filter;\n    }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "assume that there exists an entry in the filter list with the name \"http\" and that the outbound-filter leaf has this value:",
      "zh-CHS": "假设过滤器列表中存在一个名为“http”的条目，并且出站过滤器叶具有以下值："
    },
    {
      "indent": 5,
      "text": "<filter>\n  <name>http</name>\n</filter>\n<outbound-filter>http</outbound-filter>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "If the filter entry \"http\" is removed, the outbound-filter leaf's value doesn't match the leafref, and the next member type is checked. The current value (\"http\") doesn't match the enumeration, so the resulting configuration is invalid.",
      "zh-CHS": "如果删除了筛选器条目“http”，则出站筛选器叶的值与leafref不匹配，并检查下一个成员类型。当前值（“http”）与枚举不匹配，因此生成的配置无效。"
    },
    {
      "indent": 3,
      "text": "If the second member type in the union had been of type \"string\" instead of an enumeration, the current value would have matched, and the resulting configuration would have been valid.",
      "zh-CHS": "如果联合中的第二个成员类型是“string”类型而不是枚举类型，则当前值将匹配，并且生成的配置将是有效的。"
    },
    {
      "indent": 0,
      "text": "9.13. The instance-identifier Built-In Type",
      "section_title": true,
      "zh-CHS": "9.13. 内置类型的实例标识符"
    },
    {
      "indent": 3,
      "text": "The instance-identifier built-in type is used to uniquely identify a particular instance node in the data tree.",
      "zh-CHS": "实例标识符内置类型用于唯一标识数据树中的特定实例节点。"
    },
    {
      "indent": 3,
      "text": "The syntax for an instance-identifier is a subset of the XPath abbreviated syntax, formally defined by the rule \"instance-identifier\" in Section 14. It is used to uniquely identify a node in the data tree. Predicates are used only for specifying the values for the key nodes for list entries, a value of a leaf-list entry, or a positional index for a list without keys. For identifying list entries with keys, each predicate consists of one equality test per key, and each key MUST have a corresponding predicate. If a key is of type \"empty\", it is represented as a zero-length string (\"\").",
      "zh-CHS": "实例标识符的语法是XPath缩写语法的子集，由第14节中的规则“实例标识符”正式定义。它用于唯一标识数据树中的节点。谓词仅用于指定列表项的键节点值、叶列表项的值或无键列表的位置索引。为了用键标识列表项，每个谓词由每个键的一个相等性测试组成，每个键必须有一个对应的谓词。如果键的类型为“empty”，则表示为长度为零的字符串（“”）。"
    },
    {
      "indent": 3,
      "text": "If the leaf with the instance-identifier type represents configuration data and the \"require-instance\" property (Section 9.9.3) is \"true\", the node it refers to MUST also represent configuration. Such a leaf puts a constraint on valid data. All such leaf nodes MUST reference existing nodes or leaf or leaf-list nodes with their default value in use (see Sections 7.6.1 and 7.7.2) for the data to be valid. This constraint is enforced according to the rules in Section 8.",
      "zh-CHS": "如果具有实例标识符类型的叶表示配置数据，且“require instance”属性（第9.9.3节）为“true”，则其引用的节点也必须表示配置。这样的叶子对有效数据施加了约束。所有此类叶节点必须引用现有节点或叶或叶列表节点及其默认值（见第7.6.1节和第7.7.2节），以使数据有效。此约束根据第8节中的规则强制执行。"
    },
    {
      "indent": 3,
      "text": "The \"instance-identifier\" XPath expression is conceptually evaluated in the following context, in addition to the definition in Section 6.4.1:",
      "zh-CHS": "除了第6.4.1节中的定义外，“实例标识符”XPath表达式在以下上下文中进行概念性评估："
    },
    {
      "indent": 3,
      "text": "o The context node is the root node in the accessible tree.",
      "zh-CHS": "o 上下文节点是可访问树中的根节点。"
    },
    {
      "indent": 0,
      "text": "9.13.1. Restrictions",
      "section_title": true,
      "zh-CHS": "9.13.1. 限制"
    },
    {
      "indent": 3,
      "text": "An instance-identifier can be restricted with the \"require-instance\" statement (Section 9.9.3).",
      "zh-CHS": "实例标识符可以通过“require instance”语句进行限制（第9.9.3节）。"
    },
    {
      "indent": 0,
      "text": "9.13.2. Lexical Representation",
      "section_title": true,
      "zh-CHS": "9.13.2. 词汇表征"
    },
    {
      "indent": 3,
      "text": "An instance-identifier value is lexically represented as a string. All node names in an instance-identifier value MUST be qualified with explicit namespace prefixes, and these prefixes MUST be declared in the XML namespace scope in the instance-identifier's XML element.",
      "zh-CHS": "实例标识符值在词汇上表示为字符串。实例标识符值中的所有节点名称都必须使用显式命名空间前缀限定，并且这些前缀必须在实例标识符的XML元素的XML命名空间范围中声明。"
    },
    {
      "indent": 3,
      "text": "Any prefixes used in the encoding are local to each instance encoding. This means that the same instance-identifier may be encoded differently by different implementations.",
      "zh-CHS": "编码中使用的任何前缀都是每个实例编码的本地前缀。这意味着相同的实例标识符可以通过不同的实现进行不同的编码。"
    },
    {
      "indent": 0,
      "text": "9.13.3. Canonical Form",
      "section_title": true,
      "zh-CHS": "9.13.3. 标准形"
    },
    {
      "indent": 3,
      "text": "Since the lexical form depends on the XML context in which the value occurs, this type does not have a canonical form.",
      "zh-CHS": "由于词汇形式取决于值出现的XML上下文，因此该类型没有规范形式。"
    },
    {
      "indent": 0,
      "text": "9.13.4. Usage Example",
      "section_title": true,
      "zh-CHS": "9.13.4. 用法示例"
    },
    {
      "indent": 3,
      "text": "The following are examples of instance identifiers:",
      "zh-CHS": "以下是实例标识符的示例："
    },
    {
      "indent": 5,
      "text": "/* instance-identifier for a container */\n/ex:system/ex:services/ex:ssh",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "/* instance-identifier for a leaf */\n/ex:system/ex:services/ex:ssh/ex:port",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "/* instance-identifier for a list entry */\n/ex:system/ex:user[ex:name='fred']",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "/* instance-identifier for a leaf in a list entry */\n/ex:system/ex:user[ex:name='fred']/ex:type",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "/* instance-identifier for a list entry with two keys */\n/ex:system/ex:server[ex:ip='192.0.2.1'][ex:port='80']",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "/* instance-identifier for a list entry where the second\n   key (\"enabled\") is of type \"empty\" */\n/ex:system/ex:service[ex:name='foo'][ex:enabled='']",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "/* instance-identifier for a leaf-list entry */\n/ex:system/ex:services/ex:ssh/ex:cipher[.='blowfish-cbc']",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "/* instance-identifier for a list entry without keys */\n/ex:stats/ex:port[3]",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "10. XPath Functions",
      "section_title": true,
      "zh-CHS": "10. XPath函数"
    },
    {
      "indent": 3,
      "text": "This document defines two generic XPath functions and five YANG type-specific XPath functions. The function signatures are specified with the syntax used in [XPATH].",
      "zh-CHS": "本文档定义了两个通用XPath函数和五个特定于类型的XPath函数。函数签名是使用[XPATH]中使用的语法指定的。"
    },
    {
      "indent": 0,
      "text": "10.1. Function for Node Sets",
      "section_title": true,
      "zh-CHS": "10.1. 节点集函数"
    },
    {
      "indent": 0,
      "text": "10.1.1. current()",
      "section_title": true,
      "zh-CHS": "10.1.1. 当前（）"
    },
    {
      "indent": 5,
      "text": "node-set current()",
      "zh-CHS": "节点集当前值（）"
    },
    {
      "indent": 3,
      "text": "The current() function takes no input parameters and returns a node set with the initial context node as its only member.",
      "zh-CHS": "current（）函数不接受任何输入参数，并返回一个节点集，其中初始上下文节点是其唯一成员。"
    },
    {
      "indent": 0,
      "text": "10.1.1.1. Usage Example",
      "section_title": true,
      "zh-CHS": "10.1.1.1. 用法示例"
    },
    {
      "indent": 3,
      "text": "With this list:",
      "zh-CHS": "在此列表中："
    },
    {
      "indent": 5,
      "text": "list interface {\n  key \"name\";\n  ...\n  leaf enabled {\n    type boolean;\n  }\n  ...\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "the following leaf defines a \"must\" expression that ensures that the referred interface is enabled:",
      "zh-CHS": "以下叶定义了一个“必须”表达式，以确保启用引用的接口："
    },
    {
      "indent": 5,
      "text": "leaf outgoing-interface {\n  type leafref {\n    path \"/interface/name\";\n  }\n  must '/interface[name=current()]/enabled = \"true\"';\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "10.2. Function for Strings",
      "section_title": true,
      "zh-CHS": "10.2. 字符串函数"
    },
    {
      "indent": 0,
      "text": "10.2.1. re-match()",
      "section_title": true,
      "zh-CHS": "10.2.1. 重新匹配（）"
    },
    {
      "indent": 5,
      "text": "boolean re-match(string subject, string pattern)",
      "zh-CHS": "布尔值重新匹配（字符串主题、字符串模式）"
    },
    {
      "indent": 3,
      "text": "The re-match() function returns \"true\" if the \"subject\" string matches the regular expression \"pattern\"; otherwise, it returns \"false\".",
      "zh-CHS": "如果“subject”字符串与正则表达式“pattern”匹配，则re-match（）函数返回“true”；否则，它将返回“false”。"
    },
    {
      "indent": 3,
      "text": "The re-match() function checks to see if a string matches a given regular expression. The regular expressions used are the XML Schema regular expressions [XSD-TYPES]. Note that this includes implicit anchoring of the regular expression at the head and tail.",
      "zh-CHS": "函数的作用是：检查字符串是否与给定的正则表达式匹配。使用的正则表达式是XML模式正则表达式[XSD-TYPES]。注意，这包括正则表达式在头部和尾部的隐式锚定。"
    },
    {
      "indent": 0,
      "text": "10.2.1.1. Usage Example",
      "section_title": true,
      "zh-CHS": "10.2.1.1. 用法示例"
    },
    {
      "indent": 3,
      "text": "The expression:",
      "zh-CHS": "表达方式："
    },
    {
      "indent": 5,
      "text": "re-match(\"1.22.333\", \"\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\")",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "returns \"true\".",
      "zh-CHS": "返回“true”。"
    },
    {
      "indent": 3,
      "text": "To count all logical interfaces called eth0.<number>, do:",
      "zh-CHS": "要统计所有名为eth0的逻辑接口，请执行以下操作："
    },
    {
      "indent": 5,
      "text": "count(/interface[re-match(name, \"eth0\\.\\d+\")])",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "10.3. Function for the YANG Types \"leafref\" and \"instance-identifier\"",
      "section_title": true,
      "zh-CHS": "10.3. 用于类型“leafref”和“实例标识符”的函数"
    },
    {
      "indent": 0,
      "text": "10.3.1. deref()",
      "section_title": true,
      "zh-CHS": "10.3.1. 德里夫（）"
    },
    {
      "indent": 5,
      "text": "node-set deref(node-set nodes)",
      "zh-CHS": "节点集deref（节点集节点）"
    },
    {
      "indent": 3,
      "text": "The deref() function follows the reference defined by the first node in document order in the argument \"nodes\" and returns the nodes it refers to.",
      "zh-CHS": "函数的作用是：根据参数“nodes”中文档顺序的第一个节点定义的引用，返回它引用的节点。"
    },
    {
      "indent": 3,
      "text": "If the first argument node is of type \"instance-identifier\", the function returns a node set that contains the single node that the instance identifier refers to, if it exists. If no such node exists, an empty node set is returned.",
      "zh-CHS": "如果第一个参数节点的类型为“实例标识符”，则函数返回一个节点集，该节点集包含实例标识符引用的单个节点（如果存在）。如果不存在这样的节点，则返回一个空节点集。"
    },
    {
      "indent": 3,
      "text": "If the first argument node is of type \"leafref\", the function returns a node set that contains the nodes that the leafref refers to. Specifically, this set contains the nodes selected by the leafref's \"path\" statement (Section 9.9.2) that have the same value as the first argument node.",
      "zh-CHS": "如果第一个参数节点的类型为“leafref”，则函数将返回一个节点集，其中包含leafref引用的节点。具体而言，此集合包含由leafref的“path”语句（第9.9.2节）选择的节点，这些节点的值与第一个参数节点的值相同。"
    },
    {
      "indent": 3,
      "text": "If the first argument node is of any other type, an empty node set is returned.",
      "zh-CHS": "如果第一个参数节点属于任何其他类型，则返回空节点集。"
    },
    {
      "indent": 0,
      "text": "10.3.1.1. Usage Example",
      "section_title": true,
      "zh-CHS": "10.3.1.1. 用法示例"
    },
    {
      "indent": 5,
      "text": "list interface {\n  key \"name type\";\n  leaf name { ... }\n  leaf type { ... }\n  leaf enabled {\n    type boolean;\n  }\n  ...\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "container mgmt-interface {\n  leaf name {\n    type leafref {\n      path \"/interface/name\";\n    }\n  }\n  leaf type {\n    type leafref {\n      path \"/interface[name=current()/../name]/type\";\n    }\n    must 'deref(.)/../enabled = \"true\"' {\n      error-message\n        \"The management interface cannot be disabled.\";\n    }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "10.4. Functions for the YANG Type \"identityref\"",
      "section_title": true,
      "zh-CHS": "10.4. 用于YANG类型“identityref”的函数"
    },
    {
      "indent": 0,
      "text": "10.4.1. derived-from()",
      "section_title": true,
      "zh-CHS": "10.4.1. 派生自"
    },
    {
      "indent": 5,
      "text": "boolean derived-from(node-set nodes, string identity)",
      "zh-CHS": "从（节点集节点、字符串标识）派生的布尔值"
    },
    {
      "indent": 3,
      "text": "The derived-from() function returns \"true\" if any node in the argument \"nodes\" is a node of type \"identityref\" and its value is an identity that is derived from (see Section 7.18.2) the identity \"identity\"; otherwise, it returns \"false\".",
      "zh-CHS": "如果参数“nodes”中的任何节点是“identityref”类型的节点，并且其值是从标识“identity”派生的标识（参见第7.18.2节），则派生自（）函数返回“true”；否则，它将返回“false”。"
    },
    {
      "indent": 3,
      "text": "The parameter \"identity\" is a string matching the rule \"identifier-ref\" in Section 14. If a prefix is present on the identity, it refers to an identity defined in the module that was imported with that prefix, or the local module if the prefix matches the local module's prefix. If no prefix is present, the identity refers to an identity defined in the current module or an included submodule.",
      "zh-CHS": "参数“identity”是与第14节中的规则“identifier ref”匹配的字符串。如果标识上存在前缀，则它指的是使用该前缀导入的模块中定义的标识，如果前缀与本地模块的前缀匹配，则指的是本地模块。如果不存在前缀，则标识引用当前模块或包含的子模块中定义的标识。"
    },
    {
      "indent": 0,
      "text": "10.4.1.1. Usage Example",
      "section_title": true,
      "zh-CHS": "10.4.1.1. 用法示例"
    },
    {
      "indent": 5,
      "text": "module example-interface {\n  yang-version 1.1;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "... identity interface-type;",
      "zh-CHS": "... 身份接口类型；"
    },
    {
      "indent": 7,
      "text": "identity ethernet {\n  base interface-type;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "identity fast-ethernet {\n  base ethernet;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "identity gigabit-ethernet {\n  base ethernet;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "list interface {\n  key name;\n  ...\n  leaf type {\n    type identityref {\n      base interface-type;\n    }\n  }\n  ...\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "  augment \"/interface\" {\n    when 'derived-from(type, \"exif:ethernet\")';\n    // generic Ethernet definitions here\n  }\n  ...\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "10.4.2. derived-from-or-self()",
      "section_title": true,
      "zh-CHS": "10.4.2. 派生自或自（）"
    },
    {
      "indent": 5,
      "text": "boolean derived-from-or-self(node-set nodes, string identity)",
      "zh-CHS": "从或自身派生的布尔值（节点集节点、字符串标识）"
    },
    {
      "indent": 3,
      "text": "The derived-from-or-self() function returns \"true\" if any node in the argument \"nodes\" is a node of type \"identityref\" and its value is an identity that is equal to or derived from (see Section 7.18.2) the identity \"identity\"; otherwise, it returns \"false\".",
      "zh-CHS": "如果参数“nodes”中的任何节点是“identityref”类型的节点，且其值是等于或派生自标识“identity”的标识（见第7.18.2节），则派生自或self（）函数返回“true”；否则，它将返回“false”。"
    },
    {
      "indent": 3,
      "text": "The parameter \"identity\" is a string matching the rule \"identifier-ref\" in Section 14. If a prefix is present on the identity, it refers to an identity defined in the module that was imported with that prefix, or the local module if the prefix matches the local module's prefix. If no prefix is present, the identity refers to an identity defined in the current module or an included submodule.",
      "zh-CHS": "参数“identity”是与第14节中的规则“identifier ref”匹配的字符串。如果标识上存在前缀，则它指的是使用该前缀导入的模块中定义的标识，如果前缀与本地模块的前缀匹配，则指的是本地模块。如果不存在前缀，则标识引用当前模块或包含的子模块中定义的标识。"
    },
    {
      "indent": 0,
      "text": "10.4.2.1. Usage Example",
      "section_title": true,
      "zh-CHS": "10.4.2.1. 用法示例"
    },
    {
      "indent": 3,
      "text": "The module defined in Section 10.4.1.1 might also have:",
      "zh-CHS": "第10.4.1.1节中定义的模块也可能具有："
    },
    {
      "indent": 7,
      "text": "augment \"/interface\" {\n  when 'derived-from-or-self(type, \"exif:fast-ethernet\");\n  // Fast-Ethernet-specific definitions here\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "10.5. Function for the YANG Type \"enumeration\"",
      "section_title": true,
      "zh-CHS": "10.5. 用于YANG类型“枚举”的函数"
    },
    {
      "indent": 0,
      "text": "10.5.1. enum-value()",
      "section_title": true,
      "zh-CHS": "10.5.1. 枚举值（）"
    },
    {
      "indent": 5,
      "text": "number enum-value(node-set nodes)",
      "zh-CHS": "编号枚举值（节点集节点）"
    },
    {
      "indent": 3,
      "text": "The enum-value() function checks to see if the first node in document order in the argument \"nodes\" is a node of type \"enumeration\" and returns the enum's integer value. If the \"nodes\" node set is empty or if the first node in \"nodes\" is not of type \"enumeration\", it returns NaN (not a number).",
      "zh-CHS": "函数的作用是：检查参数“nodes”中文档顺序中的第一个节点是否为“enumeration”类型的节点，并返回枚举的整数值。如果“节点”节点集为空或“节点”中的第一个节点不是“枚举”类型，则返回NaN（不是数字）。"
    },
    {
      "indent": 0,
      "text": "10.5.1.1. Usage Example",
      "section_title": true,
      "zh-CHS": "10.5.1.1. 用法示例"
    },
    {
      "indent": 3,
      "text": "With this data model:",
      "zh-CHS": "使用此数据模型："
    },
    {
      "indent": 5,
      "text": "list alarm {\n  ...\n  leaf severity {\n    type enumeration {\n      enum cleared {\n        value 1;\n      }\n      enum indeterminate {\n        value 2;\n      }\n      enum minor {\n        value 3;\n      }\n      enum warning {\n        value 4;\n      }\n      enum major {\n        value 5;\n      }\n      enum critical {\n        value 6;\n      }\n    }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "the following XPath expression selects only alarms that are of severity \"major\" or higher:",
      "zh-CHS": "以下XPath表达式仅选择严重性为“严重”或更高的报警："
    },
    {
      "indent": 5,
      "text": "/alarm[enum-value(severity) >= 5]",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "10.6. Function for the YANG Type \"bits\"",
      "section_title": true,
      "zh-CHS": "10.6. 阳型“位”的功能"
    },
    {
      "indent": 0,
      "text": "10.6.1. bit-is-set()",
      "section_title": true,
      "zh-CHS": "10.6.1. bit-is-set（）"
    },
    {
      "indent": 5,
      "text": "boolean bit-is-set(node-set nodes, string bit-name)",
      "zh-CHS": "已设置布尔位（节点集节点、字符串位名称）"
    },
    {
      "indent": 3,
      "text": "The bit-is-set() function returns \"true\" if the first node in document order in the argument \"nodes\" is a node of type \"bits\" and its value has the bit \"bit-name\" set; otherwise, it returns \"false\".",
      "zh-CHS": "如果参数“nodes”中文档顺序中的第一个节点是“bits”类型的节点，并且其值设置了位“bit name”，则bit-is-set（）函数返回“true”；否则，它将返回“false”。"
    },
    {
      "indent": 0,
      "text": "10.6.1.1. Usage Example",
      "section_title": true,
      "zh-CHS": "10.6.1.1. 用法示例"
    },
    {
      "indent": 3,
      "text": "If an interface has this leaf:",
      "zh-CHS": "如果接口具有此叶："
    },
    {
      "indent": 5,
      "text": "leaf flags {\n  type bits {\n    bit UP;\n    bit PROMISCUOUS\n    bit DISABLED;\n  }\n }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "the following XPath expression can be used to select all interfaces with the UP flag set:",
      "zh-CHS": "以下XPath表达式可用于选择设置了UP标志的所有接口："
    },
    {
      "indent": 5,
      "text": "/interface[bit-is-set(flags, \"UP\")]",
      "zh-CHS": "/接口[位已设置（标志“向上”）]"
    },
    {
      "indent": 0,
      "text": "11. Updating a Module",
      "section_title": true,
      "zh-CHS": "11. 更新模块"
    },
    {
      "indent": 3,
      "text": "As experience is gained with a module, it may be desirable to revise that module. However, changes to published modules are not allowed if they have any potential to cause interoperability problems between a client using an original specification and a server using an updated specification.",
      "zh-CHS": "由于从一个模块中获得了经验，因此可能需要修改该模块。但是，如果对已发布模块的更改可能导致使用原始规范的客户端和使用更新规范的服务器之间的互操作性问题，则不允许对这些模块进行更改。"
    },
    {
      "indent": 3,
      "text": "For any published change, a new \"revision\" statement (Section 7.1.9) MUST be included in front of the existing \"revision\" statements. If there are no existing \"revision\" statements, then one MUST be added to identify the new revision. Furthermore, any necessary changes MUST be applied to any metadata statements, including the \"organization\" and \"contact\" statements (Sections 7.1.7 and 7.1.8).",
      "zh-CHS": "对于任何已发布的变更，必须在现有“修订”声明之前包含新的“修订”声明（第7.1.9节）。如果没有现有的“修订”声明，则必须添加一个以标识新修订。此外，任何必要的更改必须应用于任何元数据语句，包括“组织”和“联系人”语句（第7.1.7节和第7.1.8节）。"
    },
    {
      "indent": 3,
      "text": "Note that definitions contained in a module are available to be imported by any other module and are referenced in \"import\" statements via the module name. Thus, a module name MUST NOT be changed. Furthermore, the \"namespace\" statement MUST NOT be changed, since all XML elements are qualified by the namespace.",
      "zh-CHS": "请注意，模块中包含的定义可由任何其他模块导入，并通过模块名称在“导入”语句中引用。因此，模块名称不得更改。此外，“namespace”语句不能更改，因为所有XML元素都由名称空间限定。"
    },
    {
      "indent": 3,
      "text": "Obsolete definitions MUST NOT be removed from published modules, since their identifiers may still be referenced by other modules.",
      "zh-CHS": "不能从已发布的模块中删除过时的定义，因为它们的标识符仍可能被其他模块引用。"
    },
    {
      "indent": 3,
      "text": "A definition in a published module may be revised in any of the following ways:",
      "zh-CHS": "已发布模块中的定义可通过以下任何方式进行修订："
    },
    {
      "indent": 3,
      "text": "o An \"enumeration\" type may have new enums added, provided the old enums's values do not change. Note that inserting a new enum before an existing enum or reordering existing enums will result in new values for the existing enums, unless they have explicit values assigned to them.",
      "zh-CHS": "o “枚举”类型可以添加新的枚举，前提是旧枚举的值不变。请注意，在现有枚举之前插入新枚举或对现有枚举重新排序将为现有枚举生成新值，除非已为其指定显式值。"
    },
    {
      "indent": 3,
      "text": "o A \"bits\" type may have new bits added, provided the old bit positions do not change. Note that inserting a new bit before an existing bit or reordering existing bits will result in new positions for the existing bits, unless they have explicit positions assigned to them.",
      "zh-CHS": "o “位”类型可以添加新位，前提是旧位位置不变。请注意，在现有位之前插入新位或对现有位重新排序将导致现有位的新位置，除非已为其指定显式位置。"
    },
    {
      "indent": 3,
      "text": "o A \"range\", \"length\", or \"pattern\" statement may expand the allowed value space.",
      "zh-CHS": "o “range”、“length”或“pattern”语句可以扩展允许的值空间。"
    },
    {
      "indent": 3,
      "text": "o A \"default\" statement may be added to a leaf that does not have a default value (either directly or indirectly through its type).",
      "zh-CHS": "o “default”语句可以添加到没有默认值（直接或通过其类型间接）的叶中。"
    },
    {
      "indent": 3,
      "text": "o A \"units\" statement may be added.",
      "zh-CHS": "o 可以添加“单位”语句。"
    },
    {
      "indent": 3,
      "text": "o A \"reference\" statement may be added or updated.",
      "zh-CHS": "o 可以添加或更新“参考”声明。"
    },
    {
      "indent": 3,
      "text": "o A \"must\" statement may be removed or its constraint relaxed.",
      "zh-CHS": "o 可以删除“必须”语句或放松其约束。"
    },
    {
      "indent": 3,
      "text": "o A \"when\" statement may be removed or its constraint relaxed.",
      "zh-CHS": "o 可以删除“when”语句或放松其约束。"
    },
    {
      "indent": 3,
      "text": "o A \"mandatory\" statement may be removed or changed from \"true\" to \"false\".",
      "zh-CHS": "o “强制性”声明可以删除或从“真”改为“假”。"
    },
    {
      "indent": 3,
      "text": "o A \"min-elements\" statement may be removed, or changed to require fewer elements.",
      "zh-CHS": "o “min elements”语句可以删除，也可以更改为需要更少的元素。"
    },
    {
      "indent": 3,
      "text": "o A \"max-elements\" statement may be removed, or changed to allow more elements.",
      "zh-CHS": "o “max elements”语句可以删除，也可以更改以允许更多元素。"
    },
    {
      "indent": 3,
      "text": "o A \"description\" statement may be added or changed without changing the semantics of the definition.",
      "zh-CHS": "o 在不改变定义语义的情况下，可以添加或更改“description”语句。"
    },
    {
      "indent": 3,
      "text": "o A \"base\" statement may be added to an \"identity\" statement.",
      "zh-CHS": "o “base”语句可以添加到“identity”语句中。"
    },
    {
      "indent": 3,
      "text": "o A \"base\" statement may be removed from an \"identityref\" type, provided there is at least one \"base\" statement left.",
      "zh-CHS": "o 可以从“identityref”类型中删除“base”语句，前提是至少剩下一个“base”语句。"
    },
    {
      "indent": 3,
      "text": "o New typedefs, groupings, rpcs, notifications, extensions, features, and identities may be added.",
      "zh-CHS": "o 可以添加新的类型定义、分组、RPC、通知、扩展、功能和标识。"
    },
    {
      "indent": 3,
      "text": "o New data definition statements may be added if they do not add mandatory nodes (Section 3) to existing nodes or at the top level in a module or submodule, or if they are conditionally dependent on a new feature (i.e., have an \"if-feature\" statement that refers to a new feature).",
      "zh-CHS": "o 如果新的数据定义语句没有向现有节点或模块或子模块的顶层添加强制节点（第3节），或者如果它们有条件地依赖于新特性（即，具有引用新特性的“如果特性”语句），则可以添加新的数据定义语句。"
    },
    {
      "indent": 3,
      "text": "o A new \"case\" statement may be added.",
      "zh-CHS": "o 可以添加新的“案例”陈述。"
    },
    {
      "indent": 3,
      "text": "o A node that represented state data may be changed to represent configuration, provided it is not mandatory (Section 3).",
      "zh-CHS": "o 表示状态数据的节点可以更改为表示配置，前提是它不是强制性的（第3节）。"
    },
    {
      "indent": 3,
      "text": "o An \"if-feature\" statement may be removed, provided its node is not mandatory (Section 3).",
      "zh-CHS": "o “如果特征”语句可以删除，前提是其节点不是强制性的（第3节）。"
    },
    {
      "indent": 3,
      "text": "o A \"status\" statement may be added, or changed from \"current\" to \"deprecated\" or \"obsolete\", or changed from \"deprecated\" to \"obsolete\".",
      "zh-CHS": "o 可以添加“状态”语句，或将其从“当前”更改为“已弃用”或“过时”，或将其从“已弃用”更改为“过时”。"
    },
    {
      "indent": 3,
      "text": "o A \"type\" statement may be replaced with another \"type\" statement that does not change the syntax or semantics of the type. For example, an inline type definition may be replaced with a typedef, but an int8 type cannot be replaced by an int16, since the syntax would change.",
      "zh-CHS": "o “type”语句可以替换为另一个“type”语句，该语句不会更改该类型的语法或语义。例如，内联类型定义可以替换为typedef，但int8类型不能替换为int16，因为语法会发生变化。"
    },
    {
      "indent": 3,
      "text": "o Any set of data definition nodes may be replaced with another set of syntactically and semantically equivalent nodes. For example, a set of leafs may be replaced by a \"uses\" statement of a grouping with the same leafs.",
      "zh-CHS": "o 任何一组数据定义节点都可以用另一组语法和语义上等价的节点来替换。例如，一组leaf可以替换为具有相同leaf的分组的“uses”语句。"
    },
    {
      "indent": 3,
      "text": "o A module may be split into a set of submodules or a submodule may be removed, provided the definitions in the module do not change in any way other than those allowed here.",
      "zh-CHS": "o 一个模块可以拆分为一组子模块，或者可以删除一个子模块，前提是该模块中的定义不会以此处允许的方式以外的任何方式发生更改。"
    },
    {
      "indent": 3,
      "text": "o The \"prefix\" statement may be changed, provided all local uses of the prefix are also changed.",
      "zh-CHS": "o “prefix”语句可能会更改，前提是前缀的所有本地使用也会更改。"
    },
    {
      "indent": 3,
      "text": "Otherwise, if the semantics of any previous definition are changed (i.e., if a non-editorial change is made to any definition other than those specifically allowed above), then this MUST be achieved by a new definition with a new identifier.",
      "zh-CHS": "否则，如果更改了任何先前定义的语义（即，如果对除上述明确允许的定义以外的任何定义进行了非编辑性更改），则必须通过使用新标识符的新定义来实现。"
    },
    {
      "indent": 3,
      "text": "In statements that have any data definition statements as substatements, those data definition substatements MUST NOT be reordered. If new data definition statements are added, they can be added anywhere in the sequence of existing substatements.",
      "zh-CHS": "在将任何数据定义语句作为子语句的语句中，不得对这些数据定义子语句重新排序。如果添加了新的数据定义语句，则可以将它们添加到现有子语句序列中的任何位置。"
    },
    {
      "indent": 0,
      "text": "12. Coexistence with YANG Version 1",
      "section_title": true,
      "zh-CHS": "12. 与杨共存第1版"
    },
    {
      "indent": 3,
      "text": "A YANG version 1.1 module MUST NOT include a YANG version 1 submodule, and a YANG version 1 module MUST NOT include a YANG version 1.1 submodule.",
      "zh-CHS": "YANG版本1.1模块不得包含YANG版本1子模块，YANG版本1模块不得包含YANG版本1.1子模块。"
    },
    {
      "indent": 3,
      "text": "A YANG version 1 module or submodule MUST NOT import a YANG version 1.1 module by revision.",
      "zh-CHS": "YANG版本1模块或子模块不得通过修订导入YANG版本1.1模块。"
    },
    {
      "indent": 3,
      "text": "A YANG version 1.1 module or submodule MAY import a YANG version 1 module by revision.",
      "zh-CHS": "YANG版本1.1模块或子模块可以通过修订版导入YANG版本1模块。"
    },
    {
      "indent": 3,
      "text": "If a YANG version 1 module A imports module B without revision and module B is updated to YANG version 1.1, a server MAY implement both of these modules (A and B) at the same time. In such cases, a NETCONF server MUST advertise both modules using the rules defined in Section 5.6.4, and SHOULD advertise module A and the latest revision of module B that is specified with YANG version 1 according to the rules defined in [RFC6020].",
      "zh-CHS": "如果YANG版本1模块a未经修订就导入模块B，并且模块B更新为YANG版本1.1，则服务器可能同时实现这两个模块（a和B）。在这种情况下，NETCONF服务器必须使用第5.6.4节中定义的规则发布这两个模块，并应根据[RFC6020]中定义的规则发布模块a和模块B的最新版本，该版本由YANG版本1指定。"
    },
    {
      "indent": 3,
      "text": "This rule exists in order to allow implementations of existing YANG version 1 modules together with YANG version 1.1 modules. Without this rule, updating a single module to YANG version 1.1 would have a cascading effect on modules that import it, requiring all of them to also be updated to YANG version 1.1, and so on.",
      "zh-CHS": "此规则的存在是为了允许现有的YANG版本1模块与YANG版本1.1模块一起实现。如果没有这个规则，将单个模块更新到YANG版本1.1会对导入它的模块产生级联效应，要求所有模块也更新到YANG版本1.1，以此类推。"
    },
    {
      "indent": 0,
      "text": "13. YIN",
      "section_title": true,
      "zh-CHS": "13. 尹"
    },
    {
      "indent": 3,
      "text": "A YANG module can be translated into an alternative XML-based syntax called YIN. The translated module is called a YIN module. This section describes bidirectional mapping rules between the two formats.",
      "zh-CHS": "YANG模块可以转换为另一种基于XML的语法，称为YIN。翻译后的模块称为阴模块。本节介绍两种格式之间的双向映射规则。"
    },
    {
      "indent": 3,
      "text": "The YANG and YIN formats contain equivalent information using different notations. The YIN notation enables developers to represent YANG data models in XML and therefore use the rich set of XML-based tools for data filtering and validation, automated generation of code and documentation, and other tasks. Tools like XSLT or XML validators can be utilized.",
      "zh-CHS": "阳和阴格式包含使用不同符号的等效信息。YIN符号使开发人员能够用XML表示YANG数据模型，从而使用丰富的基于XML的工具集进行数据过滤和验证、代码和文档的自动生成以及其他任务。可以使用XSLT或XML验证器等工具。"
    },
    {
      "indent": 3,
      "text": "The mapping between YANG and YIN does not modify the information content of the model. Comments and whitespace are not preserved.",
      "zh-CHS": "阳与阴之间的映射不会修改模型的信息内容。注释和空白不保留。"
    },
    {
      "indent": 0,
      "text": "13.1. Formal YIN Definition",
      "section_title": true,
      "zh-CHS": "13.1. 形式阴定义"
    },
    {
      "indent": 3,
      "text": "There is a one-to-one correspondence between YANG keywords and YIN elements. The local name of a YIN element is identical to the corresponding YANG keyword. This means, in particular, that the document element (root) of a YIN document is always <module> or <submodule>.",
      "zh-CHS": "阳关键词和阴元素之间有一对一的对应关系。阴元素的本地名称与对应的阳关键字相同。这特别意味着，YIN文档的文档元素（根）总是<module>或<submodule>。"
    },
    {
      "indent": 3,
      "text": "YIN elements corresponding to the YANG keywords belong to the namespace whose associated URI is \"urn:ietf:params:xml:ns:yang:yin:1\".",
      "zh-CHS": "与YANG关键字对应的YIN元素属于名称空间，其关联URI为“urn:ietf:params:xml:ns:YANG:YIN:1”。"
    },
    {
      "indent": 3,
      "text": "YIN elements corresponding to extension keywords belong to the namespace of the YANG module where the extension keyword is declared via the \"extension\" statement.",
      "zh-CHS": "与扩展关键字对应的YIN元素属于YANG模块的名称空间，在该名称空间中，扩展关键字通过“extension”语句声明。"
    },
    {
      "indent": 3,
      "text": "The names of all YIN elements MUST be properly qualified with their namespaces (as specified above) using the standard mechanisms of [XML-NAMES], i.e., \"xmlns\" and \"xmlns:xxx\" attributes.",
      "zh-CHS": "所有YIN元素的名称必须使用[XML-names]的标准机制，即“xmlns”和“xmlns:xxx”属性，使用它们的名称空间（如上所述）进行适当限定。"
    },
    {
      "indent": 3,
      "text": "The argument of a YANG statement is represented in YIN as either an XML attribute or a subelement of the keyword element. Table 1 defines the mapping for the set of YANG keywords. For extensions, the argument mapping is specified within the \"extension\" statement (see Section 7.19). The following rules hold for arguments:",
      "zh-CHS": "YANG语句的参数用YIN表示为XML属性或keyword元素的子元素。表1定义了YANG关键字集的映射。对于扩展，参数映射在“extension”语句中指定（参见第7.19节）。以下规则适用于参数："
    },
    {
      "indent": 3,
      "text": "o If the argument is represented as an attribute, this attribute has no namespace.",
      "zh-CHS": "o 如果参数表示为属性，则此属性没有命名空间。"
    },
    {
      "indent": 3,
      "text": "o If the argument is represented as an element, it is qualified by the same namespace as its parent keyword element.",
      "zh-CHS": "o 如果参数表示为一个元素，则它由与其父关键字元素相同的命名空间限定。"
    },
    {
      "indent": 3,
      "text": "o If the argument is represented as an element, it MUST be the first child of the keyword element.",
      "zh-CHS": "o 如果参数表示为元素，则它必须是关键字元素的第一个子元素。"
    },
    {
      "indent": 3,
      "text": "Substatements of a YANG statement are represented as (additional) children of the keyword element, and their relative order MUST be the same as the order of substatements in YANG.",
      "zh-CHS": "YANG语句的子语句表示为关键字元素的（附加）子语句，它们的相对顺序必须与YANG语句中的子语句顺序相同。"
    },
    {
      "indent": 3,
      "text": "Comments in YANG MAY be mapped to XML comments.",
      "zh-CHS": "YANG中的注释可以映射到XML注释。"
    },
    {
      "indent": 12,
      "text": "+------------------+---------------+-------------+\n| keyword          | argument name | yin-element |\n+------------------+---------------+-------------+\n| action           | name          | false       |\n| anydata          | name          | false       |\n| anyxml           | name          | false       |\n| argument         | name          | false       |\n| augment          | target-node   | false       |\n| base             | name          | false       |\n| belongs-to       | module        | false       |\n| bit              | name          | false       |\n| case             | name          | false       |\n| choice           | name          | false       |\n| config           | value         | false       |\n| contact          | text          | true        |\n| container        | name          | false       |\n| default          | value         | false       |\n| description      | text          | true        |\n| deviate          | value         | false       |\n| deviation        | target-node   | false       |\n| enum             | name          | false       |\n| error-app-tag    | value         | false       |\n| error-message    | value         | true        |\n| extension        | name          | false       |\n| feature          | name          | false       |\n| fraction-digits  | value         | false       |\n| grouping         | name          | false       |\n| identity         | name          | false       |\n| if-feature       | name          | false       |\n| import           | module        | false       |\n| include          | module        | false       |\n| input            | <no argument> | n/a         |\n| key              | value         | false       |\n| leaf             | name          | false       |\n| leaf-list        | name          | false       |\n| length           | value         | false       |\n| list             | name          | false       |\n| mandatory        | value         | false       |\n| max-elements     | value         | false       |\n| min-elements     | value         | false       |\n| modifier         | value         | false       |\n| module           | name          | false       |\n| must             | condition     | false       |\n| namespace        | uri           | false       |\n| notification     | name          | false       |\n| ordered-by       | value         | false       |\n| organization     | text          | true        |\n| output           | <no argument> | n/a         |",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 12,
      "text": "| path             | value         | false       |\n| pattern          | value         | false       |\n| position         | value         | false       |\n| prefix           | value         | false       |\n| presence         | value         | false       |\n| range            | value         | false       |\n| reference        | text          | true        |\n| refine           | target-node   | false       |\n| require-instance | value         | false       |\n| revision         | date          | false       |\n| revision-date    | date          | false       |\n| rpc              | name          | false       |\n| status           | value         | false       |\n| submodule        | name          | false       |\n| type             | name          | false       |\n| typedef          | name          | false       |\n| unique           | tag           | false       |\n| units            | name          | false       |\n| uses             | name          | false       |\n| value            | value         | false       |\n| when             | condition     | false       |\n| yang-version     | value         | false       |\n| yin-element      | value         | false       |\n+------------------+---------------+-------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 11,
      "text": "Table 1: Mapping of Arguments of the YANG Statements",
      "zh-CHS": "表1:YANG语句的参数映射"
    },
    {
      "indent": 0,
      "text": "13.1.1. Usage Example",
      "section_title": true,
      "zh-CHS": "13.1.1. 用法示例"
    },
    {
      "indent": 3,
      "text": "The following YANG module:",
      "zh-CHS": "以下模块："
    },
    {
      "indent": 5,
      "text": "module example-foo {\n  yang-version 1.1;\n  namespace \"urn:example:foo\";\n  prefix \"foo\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "import example-extensions {\n  prefix \"myext\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "list interface {\n  key \"name\";\n  leaf name {\n    type string;\n  }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "    leaf mtu {\n      type uint32;\n      description \"The MTU of the interface.\";\n      myext:c-define \"MY_MTU\";\n    }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "where the extension \"c-define\" is defined in Section 7.19.3, is translated into the following YIN:",
      "zh-CHS": "如果第7.19.3节中定义了扩展名“c-define”，则将其翻译为："
    },
    {
      "indent": 5,
      "text": "<module name=\"example-foo\"\n        xmlns=\"urn:ietf:params:xml:ns:yang:yin:1\"\n        xmlns:foo=\"urn:example:foo\"\n        xmlns:myext=\"urn:example:extensions\">",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "<namespace uri=\"urn:example:foo\"/>\n<prefix value=\"foo\"/>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "<import module=\"example-extensions\">\n  <prefix value=\"myext\"/>\n</import>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "  <list name=\"interface\">\n    <key value=\"name\"/>\n    <leaf name=\"name\">\n      <type name=\"string\"/>\n    </leaf>\n    <leaf name=\"mtu\">\n      <type name=\"uint32\"/>\n      <description>\n        <text>The MTU of the interface.</text>\n      </description>\n      <myext:c-define name=\"MY_MTU\"/>\n    </leaf>\n  </list>\n</module>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "14. YANG ABNF Grammar",
      "section_title": true,
      "zh-CHS": "14. 杨氏语法"
    },
    {
      "indent": 3,
      "text": "In YANG, almost all statements are unordered. The ABNF grammar [RFC5234] [RFC7405] defines the canonical order. To improve module readability, it is RECOMMENDED that clauses be entered in this order.",
      "zh-CHS": "在杨，几乎所有的陈述都是无序的。ABNF语法[RFC5234][RFC7405]定义了规范顺序。为了提高模块的可读性，建议按此顺序输入子句。"
    },
    {
      "indent": 3,
      "text": "Within the ABNF grammar, unordered statements are marked with comments.",
      "zh-CHS": "在ABNF语法中，无序语句用注释标记。"
    },
    {
      "indent": 3,
      "text": "This grammar assumes that the scanner replaces YANG comments with a single space character.",
      "zh-CHS": "此语法假定扫描程序使用单个空格字符替换注释。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS> file \"yang.abnf\"",
      "zh-CHS": "<CODE start>文件“yang.abnf”"
    },
    {
      "indent": 3,
      "text": "module-stmt = optsep module-keyword sep identifier-arg-str optsep \"{\" stmtsep module-header-stmts linkage-stmts meta-stmts revision-stmts body-stmts \"}\" optsep",
      "zh-CHS": "模块stmt=optsep模块关键字sep标识符arg str optsep“{”stmtsep模块头stmts链接stmts元stmts修订stmts正文stmts“}”optsep"
    },
    {
      "indent": 3,
      "text": "submodule-stmt = optsep submodule-keyword sep identifier-arg-str optsep \"{\" stmtsep submodule-header-stmts linkage-stmts meta-stmts revision-stmts body-stmts \"}\" optsep",
      "zh-CHS": "子模块stmt=optsep子模块关键字sep标识符arg str optsep“{”stmtsep子模块头stmts链接stmts元stmts修订stmts正文stmts“}”optsep"
    },
    {
      "indent": 3,
      "text": "module-header-stmts = ;; these stmts can appear in any order yang-version-stmt namespace-stmt prefix-stmt",
      "zh-CHS": "模块头stmts=；；这些stmt可以以任何顺序出现在版本stmt namespace stmt prefix stmt中"
    },
    {
      "indent": 3,
      "text": "submodule-header-stmts = ;; these stmts can appear in any order yang-version-stmt belongs-to-stmt",
      "zh-CHS": "子模块头stmts=；；这些stmt可以以stmt所属的任何顺序出现"
    },
    {
      "indent": 3,
      "text": "meta-stmts          = ;; these stmts can appear in any order\n                      [organization-stmt]\n                      [contact-stmt]\n                      [description-stmt]\n                      [reference-stmt]",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "linkage-stmts       = ;; these stmts can appear in any order\n                      *import-stmt\n                      *include-stmt",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "revision-stmts      = *revision-stmt",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "body-stmts          = *(extension-stmt /\n                        feature-stmt /\n                        identity-stmt /\n                        typedef-stmt /\n                        grouping-stmt /\n                        data-def-stmt /\n                        augment-stmt /\n                        rpc-stmt /\n                        notification-stmt /\n                        deviation-stmt)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "data-def-stmt = container-stmt / leaf-stmt / leaf-list-stmt / list-stmt / choice-stmt / anydata-stmt / anyxml-stmt / uses-stmt",
      "zh-CHS": "data def stmt=容器stmt/leaf stmt/leaf list stmt/list stmt/choice stmt/anydata stmt/anyxml stmt/uses stmt"
    },
    {
      "indent": 3,
      "text": "yang-version-stmt = yang-version-keyword sep yang-version-arg-str stmtend",
      "zh-CHS": "阳版本stmt=阳版本关键字sep阳版本arg str stmtend"
    },
    {
      "indent": 3,
      "text": "yang-version-arg-str = < a string that matches the rule >\n                       < yang-version-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "yang-version-arg = \"1.1\"",
      "zh-CHS": "yang版本arg=“1.1”"
    },
    {
      "indent": 3,
      "text": "import-stmt         = import-keyword sep identifier-arg-str optsep\n                      \"{\" stmtsep\n                          ;; these stmts can appear in any order\n                          prefix-stmt\n                          [revision-date-stmt]\n                          [description-stmt]\n                          [reference-stmt]\n                      \"}\" stmtsep",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "include-stmt        = include-keyword sep identifier-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [revision-date-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                       \"}\") stmtsep",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "namespace-stmt      = namespace-keyword sep uri-str stmtend",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "uri-str             = < a string that matches the rule >\n                      < URI in RFC 3986 >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "prefix-stmt = prefix-keyword sep prefix-arg-str stmtend",
      "zh-CHS": "前缀stmt=前缀关键字sep prefix arg str stmtend"
    },
    {
      "indent": 3,
      "text": "belongs-to-stmt = belongs-to-keyword sep identifier-arg-str optsep \"{\" stmtsep prefix-stmt \"}\" stmtsep",
      "zh-CHS": "属于stmt=属于关键字sep标识符arg str optsep“{”stmtsep prefix stmt“}”stmtsep"
    },
    {
      "indent": 3,
      "text": "organization-stmt   = organization-keyword sep string stmtend",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "contact-stmt        = contact-keyword sep string stmtend",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "description-stmt    = description-keyword sep string stmtend",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "reference-stmt      = reference-keyword sep string stmtend",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "units-stmt          = units-keyword sep string stmtend",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "revision-stmt = revision-keyword sep revision-date optsep (\";\" / \"{\" stmtsep ;; these stmts can appear in any order [description-stmt] [reference-stmt] \"}\") stmtsep",
      "zh-CHS": "revision stmt=修订关键字sep revision date optsep（“；”/“{”stmtsep；；这些stmt可以以任何顺序出现[description stmt][reference stmt]“}”）stmtsep"
    },
    {
      "indent": 3,
      "text": "revision-date       = date-arg-str",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "revision-date-stmt = revision-date-keyword sep revision-date stmtend",
      "zh-CHS": "修订日期stmt=修订日期关键字sep修订日期stmtend"
    },
    {
      "indent": 3,
      "text": "extension-stmt      = extension-keyword sep identifier-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [argument-stmt]\n                           [status-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                       \"}\") stmtsep",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "argument-stmt = argument-keyword sep identifier-arg-str optsep (\";\" / \"{\" stmtsep [yin-element-stmt] \"}\") stmtsep",
      "zh-CHS": "参数stmt=参数关键字sep标识符arg str optsep（“；”/“{”stmtsep[yin元素stmt]“}”）stmtsep"
    },
    {
      "indent": 3,
      "text": "yin-element-stmt = yin-element-keyword sep yin-element-arg-str stmtend",
      "zh-CHS": "yin element stmt=yin element关键字sep yin element arg str stmtend"
    },
    {
      "indent": 3,
      "text": "yin-element-arg-str = < a string that matches the rule >\n                      < yin-element-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "yin-element-arg     = true-keyword / false-keyword",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "identity-stmt       = identity-keyword sep identifier-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           *if-feature-stmt\n                           *base-stmt\n                           [status-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                       \"}\") stmtsep",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "base-stmt = base-keyword sep identifier-ref-arg-str stmtend",
      "zh-CHS": "base stmt=基本关键字sep标识符ref arg str stmtend"
    },
    {
      "indent": 3,
      "text": "feature-stmt        = feature-keyword sep identifier-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           *if-feature-stmt\n                           [status-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                       \"}\") stmtsep",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "if-feature-stmt = if-feature-keyword sep if-feature-expr-str stmtend",
      "zh-CHS": "if feature stmt=if feature关键字sep if feature expr str stmtend"
    },
    {
      "indent": 3,
      "text": "if-feature-expr-str = < a string that matches the rule >\n                      < if-feature-expr >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "if-feature-expr = if-feature-term [sep or-keyword sep if-feature-expr]",
      "zh-CHS": "if feature expr=if feature term[sep或关键字sep if feature expr]"
    },
    {
      "indent": 3,
      "text": "if-feature-term = if-feature-factor [sep and-keyword sep if-feature-term]",
      "zh-CHS": "如果特征项=如果特征因子[sep和关键字sep如果特征项]"
    },
    {
      "indent": 3,
      "text": "if-feature-factor = not-keyword sep if-feature-factor / \"(\" optsep if-feature-expr optsep \")\" / identifier-ref-arg",
      "zh-CHS": "if feature factor=not关键字sep if feature factor/“（“optsep if feature expr optsep”）”/identifier ref arg"
    },
    {
      "indent": 3,
      "text": "typedef-stmt        = typedef-keyword sep identifier-arg-str optsep\n                      \"{\" stmtsep\n                          ;; these stmts can appear in any order\n                          type-stmt\n                          [units-stmt]\n                          [default-stmt]\n                          [status-stmt]\n                          [description-stmt]\n                          [reference-stmt]\n                       \"}\" stmtsep",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "type-stmt = type-keyword sep identifier-ref-arg-str optsep (\";\" / \"{\" stmtsep [type-body-stmts] \"}\") stmtsep",
      "zh-CHS": "类型stmt=type关键字sep标识符ref arg str optsep（“；”/“{”stmtsep[type body stmts]“}”）stmtsep"
    },
    {
      "indent": 3,
      "text": "type-body-stmts = numerical-restrictions / decimal64-specification / string-restrictions / enum-specification / leafref-specification / identityref-specification / instance-identifier-specification / bits-specification / union-specification / binary-specification",
      "zh-CHS": "类型body stmts=数字限制/小数64规范/字符串限制/枚举规范/leafref规范/identityref规范/实例标识符规范/位规范/联合规范/二进制规范"
    },
    {
      "indent": 3,
      "text": "numerical-restrictions = [range-stmt]",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "range-stmt          = range-keyword sep range-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [error-message-stmt]\n                           [error-app-tag-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                        \"}\") stmtsep",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "decimal64-specification = ;; these stmts can appear in any order fraction-digits-stmt [range-stmt]",
      "zh-CHS": "小数64规范=；；这些stmt可以以分数位数stmt[范围stmt]的任何顺序出现"
    },
    {
      "indent": 3,
      "text": "fraction-digits-stmt = fraction-digits-keyword sep fraction-digits-arg-str stmtend",
      "zh-CHS": "分数位数stmt=分数位数关键字sep分数位数arg str stmtend"
    },
    {
      "indent": 3,
      "text": "fraction-digits-arg-str = < a string that matches the rule >\n                          < fraction-digits-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "fraction-digits-arg = (\"1\" [\"0\" / \"1\" / \"2\" / \"3\" / \"4\" /\n                            \"5\" / \"6\" / \"7\" / \"8\"])\n                      / \"2\" / \"3\" / \"4\" / \"5\" / \"6\" / \"7\" / \"8\" / \"9\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "string-restrictions = ;; these stmts can appear in any order [length-stmt] *pattern-stmt",
      "zh-CHS": "字符串限制=；；这些stmt可以按任意顺序显示[长度stmt]*图案stmt"
    },
    {
      "indent": 3,
      "text": "length-stmt         = length-keyword sep length-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [error-message-stmt]\n                           [error-app-tag-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                        \"}\") stmtsep",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "pattern-stmt        = pattern-keyword sep string optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [modifier-stmt]\n                           [error-message-stmt]\n                           [error-app-tag-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                        \"}\") stmtsep",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "modifier-stmt = modifier-keyword sep modifier-arg-str stmtend",
      "zh-CHS": "修饰符stmt=修饰符关键字sep修饰符arg str stmtend"
    },
    {
      "indent": 3,
      "text": "modifier-arg-str    = < a string that matches the rule >\n                      < modifier-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "modifier-arg        = invert-match-keyword",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "default-stmt        = default-keyword sep string stmtend",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "enum-specification  = 1*enum-stmt",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "enum-stmt           = enum-keyword sep string optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           *if-feature-stmt\n                           [value-stmt]\n                           [status-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                        \"}\") stmtsep",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "leafref-specification = ;; these stmts can appear in any order path-stmt [require-instance-stmt]",
      "zh-CHS": "leafref规范=；；这些stmt可以以任何顺序出现路径stmt[需要实例stmt]"
    },
    {
      "indent": 3,
      "text": "path-stmt           = path-keyword sep path-arg-str stmtend",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "require-instance-stmt = require-instance-keyword sep require-instance-arg-str stmtend",
      "zh-CHS": "require instance stmt=require instance关键字sep require instance arg str stmtend"
    },
    {
      "indent": 3,
      "text": "require-instance-arg-str = < a string that matches the rule >\n                           < require-instance-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "require-instance-arg = true-keyword / false-keyword",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "instance-identifier-specification = [require-instance-stmt]",
      "zh-CHS": "实例标识符规范=[需要实例stmt]"
    },
    {
      "indent": 3,
      "text": "identityref-specification =\n                      1*base-stmt",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "union-specification = 1*type-stmt",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "binary-specification = [length-stmt]",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "bits-specification  = 1*bit-stmt",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "bit-stmt            = bit-keyword sep identifier-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           *if-feature-stmt\n                           [position-stmt]\n                           [status-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                       \"}\") stmtsep",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "position-stmt = position-keyword sep position-value-arg-str stmtend",
      "zh-CHS": "position stmt=位置关键字sep位置值arg str stmtend"
    },
    {
      "indent": 3,
      "text": "position-value-arg-str = < a string that matches the rule >\n                         < position-value-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "position-value-arg  = non-negative-integer-value",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "status-stmt = status-keyword sep status-arg-str stmtend",
      "zh-CHS": "status stmt=状态关键字sep status arg str stmtend"
    },
    {
      "indent": 3,
      "text": "status-arg-str      = < a string that matches the rule >\n                      < status-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "status-arg = current-keyword / obsolete-keyword / deprecated-keyword",
      "zh-CHS": "状态参数=当前关键字/过时关键字/弃用关键字"
    },
    {
      "indent": 3,
      "text": "config-stmt = config-keyword sep config-arg-str stmtend",
      "zh-CHS": "config stmt=config关键字sep config arg str stmtend"
    },
    {
      "indent": 3,
      "text": "config-arg-str      = < a string that matches the rule >\n                      < config-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "config-arg          = true-keyword / false-keyword",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "mandatory-stmt = mandatory-keyword sep mandatory-arg-str stmtend",
      "zh-CHS": "mandatory stmt=强制关键字sep mandatory arg str stmtend"
    },
    {
      "indent": 3,
      "text": "mandatory-arg-str   = < a string that matches the rule >\n                      < mandatory-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "mandatory-arg       = true-keyword / false-keyword",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "presence-stmt       = presence-keyword sep string stmtend",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "ordered-by-stmt = ordered-by-keyword sep ordered-by-arg-str stmtend",
      "zh-CHS": "按stmt排序=按关键字sep排序按arg str stmtend排序"
    },
    {
      "indent": 3,
      "text": "ordered-by-arg-str  = < a string that matches the rule >\n                      < ordered-by-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "ordered-by-arg      = user-keyword / system-keyword",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "must-stmt           = must-keyword sep string optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [error-message-stmt]\n                           [error-app-tag-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                        \"}\") stmtsep",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "error-message-stmt  = error-message-keyword sep string stmtend",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "error-app-tag-stmt  = error-app-tag-keyword sep string stmtend",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "min-elements-stmt = min-elements-keyword sep min-value-arg-str stmtend",
      "zh-CHS": "最小元素stmt=min元素关键字sep最小值arg str stmtend"
    },
    {
      "indent": 3,
      "text": "min-value-arg-str   = < a string that matches the rule >\n                      < min-value-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "min-value-arg       = non-negative-integer-value",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "max-elements-stmt = max-elements-keyword sep max-value-arg-str stmtend",
      "zh-CHS": "max elements stmt=max elements关键字sep max value arg str stmtend"
    },
    {
      "indent": 3,
      "text": "max-value-arg-str   = < a string that matches the rule >\n                      < max-value-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "max-value-arg = unbounded-keyword / positive-integer-value",
      "zh-CHS": "最大值arg=无界关键字/正整数值"
    },
    {
      "indent": 3,
      "text": "value-stmt = value-keyword sep integer-value-str stmtend",
      "zh-CHS": "value stmt=value关键字sep整数值str stmtend"
    },
    {
      "indent": 3,
      "text": "integer-value-str   = < a string that matches the rule >\n                      < integer-value >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "grouping-stmt       = grouping-keyword sep identifier-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [status-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                           *(typedef-stmt / grouping-stmt)\n                           *data-def-stmt\n                           *action-stmt\n                           *notification-stmt\n                       \"}\") stmtsep",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "container-stmt      = container-keyword sep identifier-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [when-stmt]\n                           *if-feature-stmt\n                           *must-stmt\n                           [presence-stmt]\n                           [config-stmt]\n                           [status-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                           *(typedef-stmt / grouping-stmt)\n                           *data-def-stmt\n                           *action-stmt\n                           *notification-stmt\n                       \"}\") stmtsep",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "leaf-stmt           = leaf-keyword sep identifier-arg-str optsep\n                      \"{\" stmtsep\n                          ;; these stmts can appear in any order\n                          [when-stmt]\n                          *if-feature-stmt\n                          type-stmt\n                          [units-stmt]\n                          *must-stmt\n                          [default-stmt]\n                          [config-stmt]\n                          [mandatory-stmt]\n                          [status-stmt]\n                          [description-stmt]\n                          [reference-stmt]\n                       \"}\" stmtsep",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "leaf-list-stmt      = leaf-list-keyword sep identifier-arg-str optsep\n                      \"{\" stmtsep\n                          ;; these stmts can appear in any order\n                          [when-stmt]\n                          *if-feature-stmt\n                          type-stmt stmtsep\n                          [units-stmt]\n                          *must-stmt\n                          *default-stmt\n                          [config-stmt]\n                          [min-elements-stmt]\n                          [max-elements-stmt]\n                          [ordered-by-stmt]\n                          [status-stmt]\n                          [description-stmt]\n                          [reference-stmt]\n                       \"}\" stmtsep",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "list-stmt           = list-keyword sep identifier-arg-str optsep\n                      \"{\" stmtsep\n                          ;; these stmts can appear in any order\n                          [when-stmt]\n                          *if-feature-stmt\n                          *must-stmt\n                          [key-stmt]\n                          *unique-stmt\n                          [config-stmt]\n                          [min-elements-stmt]\n                          [max-elements-stmt]\n                          [ordered-by-stmt]\n                          [status-stmt]\n                          [description-stmt]\n                          [reference-stmt]\n                          *(typedef-stmt / grouping-stmt)\n                          1*data-def-stmt\n                          *action-stmt\n                          *notification-stmt\n                       \"}\" stmtsep",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "key-stmt            = key-keyword sep key-arg-str stmtend",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "key-arg-str         = < a string that matches the rule >\n                      < key-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "key-arg = node-identifier *(sep node-identifier)",
      "zh-CHS": "key arg=节点标识符*（sep节点标识符）"
    },
    {
      "indent": 3,
      "text": "unique-stmt = unique-keyword sep unique-arg-str stmtend",
      "zh-CHS": "unique stmt=unique关键字sep unique arg str stmtend"
    },
    {
      "indent": 3,
      "text": "unique-arg-str      = < a string that matches the rule >\n                      < unique-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "unique-arg = descendant-schema-nodeid *(sep descendant-schema-nodeid)",
      "zh-CHS": "唯一arg=子代架构nodeid*（sep子代架构nodeid）"
    },
    {
      "indent": 3,
      "text": "choice-stmt         = choice-keyword sep identifier-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [when-stmt]\n                           *if-feature-stmt\n                           [default-stmt]\n                           [config-stmt]\n                           [mandatory-stmt]\n                           [status-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                           *(short-case-stmt / case-stmt)\n                       \"}\") stmtsep",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "short-case-stmt = choice-stmt / container-stmt / leaf-stmt / leaf-list-stmt / list-stmt / anydata-stmt / anyxml-stmt",
      "zh-CHS": "short-case stmt=选择stmt/container stmt/leaf stmt/leaf list stmt/list stmt/anydata stmt/anyxml stmt"
    },
    {
      "indent": 3,
      "text": "case-stmt           = case-keyword sep identifier-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [when-stmt]\n                           *if-feature-stmt\n                           [status-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                           *data-def-stmt\n                       \"}\") stmtsep",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "anydata-stmt        = anydata-keyword sep identifier-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [when-stmt]\n                           *if-feature-stmt\n                           *must-stmt\n                           [config-stmt]\n                           [mandatory-stmt]\n                           [status-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                        \"}\") stmtsep",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "anyxml-stmt         = anyxml-keyword sep identifier-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [when-stmt]\n                           *if-feature-stmt\n                           *must-stmt\n                           [config-stmt]\n                           [mandatory-stmt]\n                           [status-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                        \"}\") stmtsep",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "uses-stmt           = uses-keyword sep identifier-ref-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [when-stmt]\n                           *if-feature-stmt\n                           [status-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                           *refine-stmt\n                           *uses-augment-stmt\n                       \"}\") stmtsep",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "refine-stmt         = refine-keyword sep refine-arg-str optsep\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           *if-feature-stmt\n                           *must-stmt\n                           [presence-stmt]\n                           *default-stmt\n                           [config-stmt]\n                           [mandatory-stmt]\n                           [min-elements-stmt]\n                           [max-elements-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                         \"}\" stmtsep",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "refine-arg-str      = < a string that matches the rule >\n                      < refine-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "refine-arg          = descendant-schema-nodeid",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "uses-augment-stmt   = augment-keyword sep uses-augment-arg-str optsep\n                      \"{\" stmtsep\n                          ;; these stmts can appear in any order\n                          [when-stmt]\n                          *if-feature-stmt\n                          [status-stmt]\n                          [description-stmt]\n                          [reference-stmt]\n                          1*(data-def-stmt / case-stmt /\n                             action-stmt / notification-stmt)\n                       \"}\" stmtsep",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "uses-augment-arg-str = < a string that matches the rule >\n                       < uses-augment-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "uses-augment-arg    = descendant-schema-nodeid",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "augment-stmt        = augment-keyword sep augment-arg-str optsep\n                      \"{\" stmtsep\n                          ;; these stmts can appear in any order\n                          [when-stmt]\n                          *if-feature-stmt\n                          [status-stmt]\n                          [description-stmt]\n                          [reference-stmt]\n                          1*(data-def-stmt / case-stmt /\n                             action-stmt / notification-stmt)\n                       \"}\" stmtsep",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "augment-arg-str     = < a string that matches the rule >\n                      < augment-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "augment-arg         = absolute-schema-nodeid",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "when-stmt = when-keyword sep string optsep (\";\" / \"{\" stmtsep ;; these stmts can appear in any order [description-stmt] [reference-stmt] \"}\") stmtsep",
      "zh-CHS": "当stmt=when关键字sep string optsep（“；”/“{”stmtsep；；这些stmt可以以任何顺序出现[description stmt][reference stmt]“}”）stmtsep"
    },
    {
      "indent": 3,
      "text": "rpc-stmt            = rpc-keyword sep identifier-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           *if-feature-stmt\n                           [status-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                           *(typedef-stmt / grouping-stmt)\n                           [input-stmt]\n                           [output-stmt]\n                       \"}\") stmtsep",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "action-stmt         = action-keyword sep identifier-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           *if-feature-stmt\n                           [status-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                           *(typedef-stmt / grouping-stmt)\n                           [input-stmt]\n                           [output-stmt]\n                       \"}\") stmtsep",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "input-stmt          = input-keyword optsep\n                      \"{\" stmtsep\n                          ;; these stmts can appear in any order\n                          *must-stmt\n                          *(typedef-stmt / grouping-stmt)\n                          1*data-def-stmt\n                      \"}\" stmtsep",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "output-stmt         = output-keyword optsep\n                      \"{\" stmtsep\n                          ;; these stmts can appear in any order\n                          *must-stmt\n                          *(typedef-stmt / grouping-stmt)\n                          1*data-def-stmt\n                      \"}\" stmtsep",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "notification-stmt   = notification-keyword sep\n                      identifier-arg-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           *if-feature-stmt\n                           *must-stmt\n                           [status-stmt]\n                           [description-stmt]\n                           [reference-stmt]\n                           *(typedef-stmt / grouping-stmt)\n                           *data-def-stmt\n                       \"}\") stmtsep",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "deviation-stmt = deviation-keyword sep deviation-arg-str optsep \"{\" stmtsep ;; these stmts can appear in any order [description-stmt] [reference-stmt] (deviate-not-supported-stmt / 1*(deviate-add-stmt / deviate-replace-stmt / deviate-delete-stmt)) \"}\" stmtsep",
      "zh-CHS": "偏差stmt=偏差关键字sep DEVISION arg str optsep“{”STMTSP；；这些stmt可以以任何顺序出现[说明stmt][参考stmt]（不支持偏差stmt/1*（偏差添加stmt/偏差替换stmt/偏差删除stmt））“}”STMTSP"
    },
    {
      "indent": 3,
      "text": "deviation-arg-str   = < a string that matches the rule >\n                      < deviation-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "deviation-arg       = absolute-schema-nodeid",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "deviate-not-supported-stmt = deviate-keyword sep not-supported-keyword-str stmtend",
      "zh-CHS": "偏离不支持的stmt=偏离关键字sep不支持的关键字str stmtend"
    },
    {
      "indent": 3,
      "text": "deviate-add-stmt    = deviate-keyword sep add-keyword-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [units-stmt]\n                           *must-stmt\n                           *unique-stmt\n                           *default-stmt\n                           [config-stmt]\n                           [mandatory-stmt]\n                           [min-elements-stmt]\n                           [max-elements-stmt]\n                       \"}\") stmtsep",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "deviate-delete-stmt = deviate-keyword sep delete-keyword-str optsep (\";\" / \"{\" stmtsep ;; these stmts can appear in any order [units-stmt] *must-stmt *unique-stmt *default-stmt \"}\") stmtsep",
      "zh-CHS": "偏离删除stmt=偏离关键字sep delete关键字str optsep（“；”/“{”stmtsep；；这些stmt可以以任何顺序出现[单位stmt]*必须stmt*唯一stmt*默认stmt“}”）stmtsep"
    },
    {
      "indent": 3,
      "text": "deviate-replace-stmt = deviate-keyword sep replace-keyword-str optsep\n                      (\";\" /\n                       \"{\" stmtsep\n                           ;; these stmts can appear in any order\n                           [type-stmt]\n                           [units-stmt]\n                           [default-stmt]\n                           [config-stmt]\n                           [mandatory-stmt]\n                           [min-elements-stmt]\n                           [max-elements-stmt]\n                       \"}\") stmtsep",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "not-supported-keyword-str = < a string that matches the rule >\n                            < not-supported-keyword >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "add-keyword-str     = < a string that matches the rule >\n                      < add-keyword >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "delete-keyword-str  = < a string that matches the rule >\n                      < delete-keyword >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "replace-keyword-str = < a string that matches the rule >\n                      < replace-keyword >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": ";; represents the usage of an extension\nunknown-statement   = prefix \":\" identifier [sep string] optsep\n                      (\";\" /\n                       \"{\" optsep\n                           *((yang-stmt / unknown-statement) optsep)\n                        \"}\") stmtsep",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "yang-stmt = action-stmt / anydata-stmt / anyxml-stmt / argument-stmt / augment-stmt / base-stmt / belongs-to-stmt / bit-stmt / case-stmt / choice-stmt / config-stmt / contact-stmt / container-stmt / default-stmt / description-stmt / deviate-add-stmt /",
      "zh-CHS": "yang stmt=action stmt/anydata stmt/anyxml stmt/argument stmt/augment stmt/base stmt/属于stmt/bit stmt/case stmt/choice stmt/config stmt/contact stmt/container stmt/default stmt/description stmt/develope add stmt/"
    },
    {
      "indent": 25,
      "text": "deviate-delete-stmt / deviate-not-supported-stmt / deviate-replace-stmt / deviation-stmt / enum-stmt / error-app-tag-stmt / error-message-stmt / extension-stmt / feature-stmt / fraction-digits-stmt / grouping-stmt / identity-stmt / if-feature-stmt / import-stmt / include-stmt / input-stmt / key-stmt / leaf-list-stmt / leaf-stmt / length-stmt / list-stmt / mandatory-stmt / max-elements-stmt / min-elements-stmt / modifier-stmt / module-stmt / must-stmt / namespace-stmt / notification-stmt / ordered-by-stmt / organization-stmt / output-stmt / path-stmt / pattern-stmt / position-stmt / prefix-stmt / presence-stmt / range-stmt / reference-stmt / refine-stmt / require-instance-stmt / revision-date-stmt / revision-stmt / rpc-stmt / status-stmt / submodule-stmt / typedef-stmt / type-stmt /",
      "zh-CHS": "偏差删除stmt/不支持偏差stmt/偏差替换stmt/偏差stmt/枚举stmt/错误应用标记stmt/错误消息stmt/扩展stmt/功能stmt/分数位数stmt/分组stmt/标识stmt/如果功能stmt/导入stmt/包括stmt/输入stmt/键stmt/叶列表stmt/叶stmt/长度stmt/列出stmt/强制stmt/max elements stmt/min elements stmt/修改器stmt/模块stmt/必须stmt/命名空间stmt/通知stmt/按stmt/组织stmt/输出stmt/路径stmt/模式stmt/位置stmt/前缀stmt/存在stmt/范围stmt/引用stmt/优化stmt/需要实例stmt/修订日期stmt/修订stmt/rpc stmt/状态stmt/子模块stmt/typedef stmt/type stmt/"
    },
    {
      "indent": 25,
      "text": "unique-stmt / units-stmt / uses-augment-stmt / uses-stmt / value-stmt / when-stmt / yang-version-stmt / yin-element-stmt",
      "zh-CHS": "唯一stmt/单位stmt/使用增强stmt/使用stmt/值stmt/当stmt/阳版本stmt/阴元素stmt"
    },
    {
      "indent": 3,
      "text": ";; Ranges",
      "zh-CHS": ";; 范围"
    },
    {
      "indent": 3,
      "text": "range-arg-str       = < a string that matches the rule >\n                      < range-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "range-arg = range-part *(optsep \"|\" optsep range-part)",
      "zh-CHS": "范围参数=范围部分*（optsep“|”optsep范围部分）"
    },
    {
      "indent": 3,
      "text": "range-part = range-boundary [optsep \"..\" optsep range-boundary]",
      "zh-CHS": "范围部分=范围边界[optsep”。“optsep范围边界]"
    },
    {
      "indent": 3,
      "text": "range-boundary      = min-keyword / max-keyword /\n                      integer-value / decimal-value",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": ";; Lengths",
      "zh-CHS": ";; 长度"
    },
    {
      "indent": 3,
      "text": "length-arg-str      = < a string that matches the rule >\n                      < length-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "length-arg = length-part *(optsep \"|\" optsep length-part)",
      "zh-CHS": "长度arg=长度部分*（optsep“|”optsep长度部分）"
    },
    {
      "indent": 3,
      "text": "length-part = length-boundary [optsep \"..\" optsep length-boundary]",
      "zh-CHS": "长度部分=长度边界[optsep”。“optsep长度边界]"
    },
    {
      "indent": 3,
      "text": "length-boundary = min-keyword / max-keyword / non-negative-integer-value",
      "zh-CHS": "长度边界=最小关键字/最大关键字/非负整数值"
    },
    {
      "indent": 3,
      "text": ";; Date",
      "zh-CHS": ";; 日期"
    },
    {
      "indent": 3,
      "text": "date-arg-str        = < a string that matches the rule >\n                      < date-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "date-arg = 4DIGIT \"-\" 2DIGIT \"-\" 2DIGIT",
      "zh-CHS": "日期arg=4DIGIT“-”2DIGIT“-”2DIGIT"
    },
    {
      "indent": 3,
      "text": ";; Schema Node Identifiers",
      "zh-CHS": ";; 模式节点标识符"
    },
    {
      "indent": 3,
      "text": "schema-nodeid = absolute-schema-nodeid / descendant-schema-nodeid",
      "zh-CHS": "schema nodeid=绝对模式nodeid/后代模式nodeid"
    },
    {
      "indent": 3,
      "text": "absolute-schema-nodeid = 1*(\"/\" node-identifier)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "descendant-schema-nodeid = node-identifier [absolute-schema-nodeid]",
      "zh-CHS": "子代架构nodeid=节点标识符[绝对架构nodeid]"
    },
    {
      "indent": 3,
      "text": "node-identifier     = [prefix \":\"] identifier",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": ";; Instance Identifiers",
      "zh-CHS": ";; 实例标识符"
    },
    {
      "indent": 3,
      "text": "instance-identifier = 1*(\"/\" (node-identifier\n                              [1*key-predicate /\n                               leaf-list-predicate /\n                               pos]))",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "key-predicate       = \"[\" *WSP key-predicate-expr *WSP \"]\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "key-predicate-expr  = node-identifier *WSP \"=\" *WSP quoted-string",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "leaf-list-predicate = \"[\" *WSP leaf-list-predicate-expr *WSP \"]\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "leaf-list-predicate-expr = \".\" *WSP \"=\" *WSP quoted-string",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "pos                 = \"[\" *WSP positive-integer-value *WSP \"]\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "quoted-string       = (DQUOTE string DQUOTE) / (SQUOTE string SQUOTE)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": ";; leafref path",
      "zh-CHS": ";; 叶参考路径"
    },
    {
      "indent": 3,
      "text": "path-arg-str        = < a string that matches the rule >\n                      < path-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "path-arg            = absolute-path / relative-path",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "absolute-path       = 1*(\"/\" (node-identifier *path-predicate))",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "relative-path       = 1*(\"../\") descendant-path",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "descendant-path = node-identifier [*path-predicate absolute-path]",
      "zh-CHS": "子体路径=节点标识符[*路径谓词绝对路径]"
    },
    {
      "indent": 3,
      "text": "path-predicate      = \"[\" *WSP path-equality-expr *WSP \"]\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "path-equality-expr  = node-identifier *WSP \"=\" *WSP path-key-expr",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "path-key-expr       = current-function-invocation *WSP \"/\" *WSP\n                      rel-path-keyexpr",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "rel-path-keyexpr    = 1*(\"..\" *WSP \"/\" *WSP)\n                      *(node-identifier *WSP \"/\" *WSP)\n                      node-identifier",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": ";;; Keywords, using the syntax for case-sensitive strings (RFC 7405)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": ";; statement keywords\naction-keyword           = %s\"action\"\nanydata-keyword          = %s\"anydata\"\nanyxml-keyword           = %s\"anyxml\"\nargument-keyword         = %s\"argument\"\naugment-keyword          = %s\"augment\"\nbase-keyword             = %s\"base\"\nbelongs-to-keyword       = %s\"belongs-to\"\nbit-keyword              = %s\"bit\"\ncase-keyword             = %s\"case\"\nchoice-keyword           = %s\"choice\"\nconfig-keyword           = %s\"config\"\ncontact-keyword          = %s\"contact\"\ncontainer-keyword        = %s\"container\"\ndefault-keyword          = %s\"default\"\ndescription-keyword      = %s\"description\"\ndeviate-keyword          = %s\"deviate\"\ndeviation-keyword        = %s\"deviation\"\nenum-keyword             = %s\"enum\"\nerror-app-tag-keyword    = %s\"error-app-tag\"\nerror-message-keyword    = %s\"error-message\"\nextension-keyword        = %s\"extension\"\nfeature-keyword          = %s\"feature\"\nfraction-digits-keyword  = %s\"fraction-digits\"\ngrouping-keyword         = %s\"grouping\"\nidentity-keyword         = %s\"identity\"\nif-feature-keyword       = %s\"if-feature\"\nimport-keyword           = %s\"import\"\ninclude-keyword          = %s\"include\"\ninput-keyword            = %s\"input\"\nkey-keyword              = %s\"key\"\nleaf-keyword             = %s\"leaf\"\nleaf-list-keyword        = %s\"leaf-list\"\nlength-keyword           = %s\"length\"\nlist-keyword             = %s\"list\"\nmandatory-keyword        = %s\"mandatory\"\nmax-elements-keyword     = %s\"max-elements\"\nmin-elements-keyword     = %s\"min-elements\"\nmodifier-keyword         = %s\"modifier\"\nmodule-keyword           = %s\"module\"\nmust-keyword             = %s\"must\"\nnamespace-keyword        = %s\"namespace\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "notification-keyword     = %s\"notification\"\nordered-by-keyword       = %s\"ordered-by\"\norganization-keyword     = %s\"organization\"\noutput-keyword           = %s\"output\"\npath-keyword             = %s\"path\"\npattern-keyword          = %s\"pattern\"\nposition-keyword         = %s\"position\"\nprefix-keyword           = %s\"prefix\"\npresence-keyword         = %s\"presence\"\nrange-keyword            = %s\"range\"\nreference-keyword        = %s\"reference\"\nrefine-keyword           = %s\"refine\"\nrequire-instance-keyword = %s\"require-instance\"\nrevision-keyword         = %s\"revision\"\nrevision-date-keyword    = %s\"revision-date\"\nrpc-keyword              = %s\"rpc\"\nstatus-keyword           = %s\"status\"\nsubmodule-keyword        = %s\"submodule\"\ntype-keyword             = %s\"type\"\ntypedef-keyword          = %s\"typedef\"\nunique-keyword           = %s\"unique\"\nunits-keyword            = %s\"units\"\nuses-keyword             = %s\"uses\"\nvalue-keyword            = %s\"value\"\nwhen-keyword             = %s\"when\"\nyang-version-keyword     = %s\"yang-version\"\nyin-element-keyword      = %s\"yin-element\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": ";; other keywords",
      "zh-CHS": ";; 其他关键字"
    },
    {
      "indent": 3,
      "text": "add-keyword              = %s\"add\"\ncurrent-keyword          = %s\"current\"\ndelete-keyword           = %s\"delete\"\ndeprecated-keyword       = %s\"deprecated\"\nfalse-keyword            = %s\"false\"\ninvert-match-keyword     = %s\"invert-match\"\nmax-keyword              = %s\"max\"\nmin-keyword              = %s\"min\"\nnot-supported-keyword    = %s\"not-supported\"\nobsolete-keyword         = %s\"obsolete\"\nreplace-keyword          = %s\"replace\"\nsystem-keyword           = %s\"system\"\ntrue-keyword             = %s\"true\"\nunbounded-keyword        = %s\"unbounded\"\nuser-keyword             = %s\"user\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "and-keyword              = %s\"and\"\nor-keyword               = %s\"or\"\nnot-keyword              = %s\"not\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "current-function-invocation = current-keyword *WSP \"(\" *WSP \")\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": ";;; Basic Rules",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "prefix-arg-str      = < a string that matches the rule >\n                      < prefix-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "prefix-arg          = prefix",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "prefix              = identifier",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "identifier-arg-str  = < a string that matches the rule >\n                      < identifier-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "identifier-arg      = identifier",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "identifier          = (ALPHA / \"_\")\n                      *(ALPHA / DIGIT / \"_\" / \"-\" / \".\")",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "identifier-ref-arg-str = < a string that matches the rule >\n                         < identifier-ref-arg >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "identifier-ref-arg  = identifier-ref",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "identifier-ref      = [prefix \":\"] identifier",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "string              = < an unquoted string, as returned by >\n                      < the scanner, that matches the rule >\n                      < yang-string >",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "yang-string         = *yang-char",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": ";; any Unicode or ISO/IEC 10646 character, including tab, carriage\n;; return, and line feed but excluding the other C0 control\n;; characters, the surrogate blocks, and the noncharacters\nyang-char = %x09 / %x0A / %x0D / %x20-D7FF /\n                            ; exclude surrogate blocks %xD800-DFFF\n           %xE000-FDCF /    ; exclude noncharacters %xFDD0-FDEF\n           %xFDF0-FFFD /    ; exclude noncharacters %xFFFE-FFFF\n           %x10000-1FFFD /  ; exclude noncharacters %x1FFFE-1FFFF\n           %x20000-2FFFD /  ; exclude noncharacters %x2FFFE-2FFFF\n           %x30000-3FFFD /  ; exclude noncharacters %x3FFFE-3FFFF\n           %x40000-4FFFD /  ; exclude noncharacters %x4FFFE-4FFFF\n           %x50000-5FFFD /  ; exclude noncharacters %x5FFFE-5FFFF\n           %x60000-6FFFD /  ; exclude noncharacters %x6FFFE-6FFFF\n           %x70000-7FFFD /  ; exclude noncharacters %x7FFFE-7FFFF\n           %x80000-8FFFD /  ; exclude noncharacters %x8FFFE-8FFFF\n           %x90000-9FFFD /  ; exclude noncharacters %x9FFFE-9FFFF\n           %xA0000-AFFFD /  ; exclude noncharacters %xAFFFE-AFFFF\n           %xB0000-BFFFD /  ; exclude noncharacters %xBFFFE-BFFFF\n           %xC0000-CFFFD /  ; exclude noncharacters %xCFFFE-CFFFF\n           %xD0000-DFFFD /  ; exclude noncharacters %xDFFFE-DFFFF\n           %xE0000-EFFFD /  ; exclude noncharacters %xEFFFE-EFFFF\n           %xF0000-FFFFD /  ; exclude noncharacters %xFFFFE-FFFFF\n           %x100000-10FFFD  ; exclude noncharacters %x10FFFE-10FFFF",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "integer-value       = (\"-\" non-negative-integer-value) /\n                       non-negative-integer-value",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "non-negative-integer-value = \"0\" / positive-integer-value",
      "zh-CHS": "非负整数值=“0”/正整数值"
    },
    {
      "indent": 3,
      "text": "positive-integer-value = (non-zero-digit *DIGIT)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "zero-integer-value  = 1*DIGIT",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "stmtend             = optsep (\";\" / \"{\" stmtsep \"}\") stmtsep",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "sep                 = 1*(WSP / line-break)\n                      ; unconditional separator",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "optsep              = *(WSP / line-break)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "stmtsep             = *(WSP / line-break / unknown-statement)",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "line-break          = CRLF / LF",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "non-zero-digit      = %x31-39",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "decimal-value = integer-value (\".\" zero-integer-value)",
      "zh-CHS": "十进制值=整数值（“.”零整数值）"
    },
    {
      "indent": 3,
      "text": "SQUOTE              = %x27\n                      ; single quote",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": ";;; core rules from RFC 5234",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "ALPHA               = %x41-5A / %x61-7A\n                      ; A-Z / a-z",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "CR                  = %x0D\n                      ; carriage return",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "CRLF = CR LF ; Internet standard newline",
      "zh-CHS": "CRLF=CRLF；互联网标准新线"
    },
    {
      "indent": 3,
      "text": "DIGIT               = %x30-39\n                      ; 0-9",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "DQUOTE              = %x22\n                      ; double quote",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "HTAB                = %x09\n                      ; horizontal tab",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "LF                  = %x0A\n                      ; line feed",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "SP                  = %x20\n                      ; space",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "WSP = SP / HTAB ; whitespace",
      "zh-CHS": "WSP=SP/HTAB；空白"
    },
    {
      "indent": 3,
      "text": "<CODE ENDS>",
      "zh-CHS": "<代码结束>"
    },
    {
      "indent": 0,
      "text": "15. NETCONF Error Responses for YANG-Related Errors",
      "section_title": true,
      "zh-CHS": "15. 与YANG相关错误的NETCONF错误响应"
    },
    {
      "indent": 3,
      "text": "A number of NETCONF error responses are defined for error cases related to the data model handling. If the relevant YANG statement has an \"error-app-tag\" substatement, that overrides the default value specified below.",
      "zh-CHS": "为与数据模型处理相关的错误案例定义了许多NETCONF错误响应。如果相关语句具有“error-app-tag”子语句，则会覆盖下面指定的默认值。"
    },
    {
      "indent": 0,
      "text": "15.1. Error Message for Data That Violates a \"unique\" Statement",
      "section_title": true,
      "zh-CHS": "15.1. 违反“unique”语句的数据的错误消息"
    },
    {
      "indent": 3,
      "text": "If a NETCONF operation would result in configuration data where a \"unique\" constraint is invalidated, the following error MUST be returned:",
      "zh-CHS": "如果NETCONF操作将导致配置数据中的“唯一”约束无效，则必须返回以下错误："
    },
    {
      "indent": 5,
      "text": "error-tag: operation-failed error-app-tag: data-not-unique error-info: <non-unique>: Contains an instance identifier that points to a leaf that invalidates the \"unique\" constraint. This element is present once for each non-unique leaf.",
      "zh-CHS": "错误标记：操作失败错误应用标记：数据不唯一错误信息：<non-unique>：包含一个实例标识符，该标识符指向使“unique”约束无效的叶。对于每个非唯一叶，此元素存在一次。"
    },
    {
      "indent": 21,
      "text": "The <non-unique> element is in the YANG namespace (\"urn:ietf:params:xml:ns:yang:1\").",
      "zh-CHS": "<non-unique>元素位于YANG名称空间（“urn:ietf:params:xml:ns:YANG:1”）中。"
    },
    {
      "indent": 0,
      "text": "15.2. Error Message for Data That Violates a \"max-elements\" Statement",
      "section_title": true,
      "zh-CHS": "15.2. 违反“max elements”语句的数据的错误消息"
    },
    {
      "indent": 3,
      "text": "If a NETCONF operation would result in configuration data where a list or a leaf-list would have too many entries, the following error MUST be returned:",
      "zh-CHS": "如果NETCONF操作将导致配置数据中的列表或叶列表包含过多条目，则必须返回以下错误："
    },
    {
      "indent": 5,
      "text": "error-tag: operation-failed error-app-tag: too-many-elements",
      "zh-CHS": "错误标记：操作失败错误应用标记：元素太多"
    },
    {
      "indent": 3,
      "text": "This error is returned once, with the error-path identifying the list node, even if there is more than one extra child present.",
      "zh-CHS": "此错误返回一次，错误路径标识列表节点，即使存在多个子节点。"
    },
    {
      "indent": 0,
      "text": "15.3. Error Message for Data That Violates a \"min-elements\" Statement",
      "section_title": true,
      "zh-CHS": "15.3. 违反“min elements”语句的数据的错误消息"
    },
    {
      "indent": 3,
      "text": "If a NETCONF operation would result in configuration data where a list or a leaf-list would have too few entries, the following error MUST be returned:",
      "zh-CHS": "如果NETCONF操作将导致配置数据中列表或叶列表的条目太少，则必须返回以下错误："
    },
    {
      "indent": 5,
      "text": "error-tag: operation-failed error-app-tag: too-few-elements",
      "zh-CHS": "错误标记：操作失败错误应用标记：元素太少"
    },
    {
      "indent": 3,
      "text": "This error is returned once, with the error-path identifying the list node, even if there is more than one child missing.",
      "zh-CHS": "此错误返回一次，错误路径标识列表节点，即使缺少多个子节点也是如此。"
    },
    {
      "indent": 0,
      "text": "15.4. Error Message for Data That Violates a \"must\" Statement",
      "section_title": true,
      "zh-CHS": "15.4. 违反“必须”语句的数据的错误消息"
    },
    {
      "indent": 3,
      "text": "If a NETCONF operation would result in configuration data where the restrictions imposed by a \"must\" statement are violated, the following error MUST be returned, unless a specific \"error-app-tag\" substatement is present for the \"must\" statement.",
      "zh-CHS": "如果NETCONF操作将导致配置数据违反“必须”语句施加的限制，则必须返回以下错误，除非“必须”语句存在特定的“错误应用程序标记”子语句。"
    },
    {
      "indent": 5,
      "text": "error-tag: operation-failed error-app-tag: must-violation",
      "zh-CHS": "错误标记：操作失败错误应用标记：必须违反"
    },
    {
      "indent": 0,
      "text": "15.5. Error Message for Data That Violates a \"require-instance\" Statement",
      "zh-CHS": "15.5. 违反“require instance”语句的数据的错误消息"
    },
    {
      "indent": 3,
      "text": "If a NETCONF operation would result in configuration data where a leaf of type \"instance-identifier\" or \"leafref\" marked with require-instance \"true\" refers to an instance that does not exist, the following error MUST be returned:",
      "zh-CHS": "如果NETCONF操作将导致配置数据中带有require instance“true”标记的“instance identifier”或“leafref”类型的叶引用不存在的实例，则必须返回以下错误："
    },
    {
      "indent": 5,
      "text": "error-tag: data-missing error-app-tag: instance-required error-path: Path to the instance-identifier or leafref leaf.",
      "zh-CHS": "错误标记：数据丢失错误应用程序标记：实例所需错误路径：实例标识符或leafref叶的路径。"
    },
    {
      "indent": 0,
      "text": "15.6. Error Message for Data That Violates a Mandatory \"choice\" Statement",
      "zh-CHS": "15.6. 违反强制“choice”语句的数据的错误消息"
    },
    {
      "indent": 3,
      "text": "If a NETCONF operation would result in configuration data where no nodes exists in a mandatory choice, the following error MUST be returned:",
      "zh-CHS": "如果NETCONF操作将导致配置数据中不存在强制选项中的节点，则必须返回以下错误："
    },
    {
      "indent": 5,
      "text": "error-tag: data-missing error-app-tag: missing-choice error-path: Path to the element with the missing choice. error-info: <missing-choice>: Contains the name of the missing mandatory choice.",
      "zh-CHS": "错误标记：数据丢失错误应用程序标记：缺少选项错误路径：缺少选项的元素的路径。错误信息：<missing choice>：包含缺少的强制选项的名称。"
    },
    {
      "indent": 21,
      "text": "The <missing-choice> element is in the YANG namespace (\"urn:ietf:params:xml:ns:yang:1\").",
      "zh-CHS": "<missing choice>元素位于YANG名称空间（“urn:ietf:params:xml:ns:YANG:1”）中。"
    },
    {
      "indent": 0,
      "text": "15.7. Error Message for the \"insert\" Operation",
      "section_title": true,
      "zh-CHS": "15.7. “插入”操作的错误消息"
    },
    {
      "indent": 3,
      "text": "If the \"insert\" and \"key\" or \"value\" attributes are used in an <edit-config> for a list or leaf-list node and the \"key\" or \"value\" refers to an instance that does not exist, the following error MUST be returned:",
      "zh-CHS": "如果在列表或叶列表节点的<edit config>中使用了“insert”和“key”或“value”属性，并且“key”或“value”引用了不存在的实例，则必须返回以下错误："
    },
    {
      "indent": 5,
      "text": "error-tag: bad-attribute error-app-tag: missing-instance",
      "zh-CHS": "错误标记：错误属性错误应用标记：缺少实例"
    },
    {
      "indent": 0,
      "text": "16. IANA Considerations",
      "section_title": true,
      "zh-CHS": "16. IANA考虑"
    },
    {
      "indent": 3,
      "text": "This document registers one capability identifier URN from the \"Network Configuration Protocol (NETCONF) Capability URNs\" registry:",
      "zh-CHS": "本文档从“网络配置协议（NETCONF）能力URN”注册表中注册一个能力标识符URN："
    },
    {
      "indent": 5,
      "text": "Index           Capability Identifier\n-------------   ---------------------------------------------------\n:yang-library   urn:ietf:params:netconf:capability:yang-library:1.0",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "17. Security Considerations",
      "section_title": true,
      "zh-CHS": "17. 安全考虑"
    },
    {
      "indent": 3,
      "text": "This document defines a language with which to write and read descriptions of management information. The language itself has no security impact on the Internet.",
      "zh-CHS": "本文档定义了一种用于编写和读取管理信息描述的语言。这种语言本身对互联网没有安全影响。"
    },
    {
      "indent": 3,
      "text": "The same considerations are relevant as those for the base NETCONF protocol (see Section 9 in [RFC6241]).",
      "zh-CHS": "与基本NETCONF协议相关的注意事项相同（参见[RFC6241]中的第9节）。"
    },
    {
      "indent": 3,
      "text": "Data modeled in YANG might contain sensitive information. RPCs or notifications defined in YANG might transfer sensitive information.",
      "zh-CHS": "在YANG中建模的数据可能包含敏感信息。中定义的RPC或通知可能会传输敏感信息。"
    },
    {
      "indent": 3,
      "text": "Security issues are related to the usage of data modeled in YANG. Such issues shall be dealt with in documents describing the data models and documents about the interfaces used to manipulate the data, e.g., the NETCONF documents.",
      "zh-CHS": "安全问题与YANG中建模的数据的使用有关。此类问题应在描述数据模型的文件和用于操作数据的接口的文件中处理，例如NETCONF文件。"
    },
    {
      "indent": 3,
      "text": "Data modeled in YANG is dependent upon:",
      "zh-CHS": "在YANG中建模的数据取决于："
    },
    {
      "indent": 3,
      "text": "o the security of the transmission infrastructure used to send sensitive information.",
      "zh-CHS": "o 用于发送敏感信息的传输基础设施的安全性。"
    },
    {
      "indent": 3,
      "text": "o the security of applications that store or release such sensitive information.",
      "zh-CHS": "o 存储或发布此类敏感信息的应用程序的安全性。"
    },
    {
      "indent": 3,
      "text": "o adequate authentication and access control mechanisms to restrict the usage of sensitive data.",
      "zh-CHS": "o 充分的身份验证和访问控制机制，以限制敏感数据的使用。"
    },
    {
      "indent": 3,
      "text": "YANG parsers need to be robust with respect to malformed documents. Reading malformed documents from unknown or untrusted sources could result in an attacker gaining the privileges of the user running the YANG parser. In an extreme situation, the entire machine could be compromised.",
      "zh-CHS": "YANG解析器需要对格式错误的文档具有健壮性。从未知或不受信任的来源读取格式错误的文档可能会导致攻击者获得运行YANG解析器的用户的权限。在极端情况下，整个机器可能受到威胁。"
    },
    {
      "indent": 0,
      "text": "18. References",
      "section_title": true,
      "zh-CHS": "18. 工具书类"
    },
    {
      "indent": 0,
      "text": "18.1. Normative References",
      "section_title": true,
      "zh-CHS": "18.1. 规范性引用文件"
    },
    {
      "indent": 3,
      "text": "[ISO.10646] International Organization for Standardization, \"Information Technology - Universal Multiple-Octet Coded Character Set (UCS)\", ISO Standard 10646:2014, 2014.",
      "zh-CHS": "[ISO.10646]国际标准化组织，“信息技术-通用多八位编码字符集（UCS）”，ISO标准10646:2014，2014。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "zh-CHS": "[RFC2119]Bradner，S.，“RFC中用于表示需求水平的关键词”，BCP 14，RFC 2119，DOI 10.17487/RFC2119，1997年3月<http://www.rfc-editor.org/info/rfc2119>."
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, DOI 10.17487/RFC3629, November 2003, <http://www.rfc-editor.org/info/rfc3629>.",
      "zh-CHS": "[RFC3629]Yergeau，F.，“UTF-8，ISO 10646的转换格式”，STD 63，RFC 3629，DOI 10.17487/RFC3629，2003年11月<http://www.rfc-editor.org/info/rfc3629>."
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005, <http://www.rfc-editor.org/info/rfc3986>.",
      "zh-CHS": "[RFC3986]Berners Lee，T.，Fielding，R.，和L.Masinter，“统一资源标识符（URI）：通用语法”，STD 66，RFC 3986，DOI 10.17487/RFC3986，2005年1月<http://www.rfc-editor.org/info/rfc3986>."
    },
    {
      "indent": 3,
      "text": "[RFC4648] Josefsson, S., \"The Base16, Base32, and Base64 Data Encodings\", RFC 4648, DOI 10.17487/RFC4648, October 2006, <http://www.rfc-editor.org/info/rfc4648>.",
      "zh-CHS": "[RFC4648]Josefsson，S.，“Base16、Base32和Base64数据编码”，RFC 4648，DOI 10.17487/RFC4648，2006年10月<http://www.rfc-editor.org/info/rfc4648>."
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D., Ed., and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, DOI 10.17487/RFC5234, January 2008, <http://www.rfc-editor.org/info/rfc5234>.",
      "zh-CHS": "[RFC5234]Crocker，D.，Ed.，和P.Overell，“语法规范的扩充BNF:ABNF”，STD 68，RFC 5234，DOI 10.17487/RFC5234，2008年1月<http://www.rfc-editor.org/info/rfc5234>."
    },
    {
      "indent": 3,
      "text": "[RFC5277] Chisholm, S. and H. Trevino, \"NETCONF Event Notifications\", RFC 5277, DOI 10.17487/RFC5277, July 2008, <http://www.rfc-editor.org/info/rfc5277>.",
      "zh-CHS": "[RFC5277]Chisholm，S.和H.Trevino，“NETCONF事件通知”，RFC 5277，DOI 10.17487/RFC5277，2008年7月<http://www.rfc-editor.org/info/rfc5277>."
    },
    {
      "indent": 3,
      "text": "[RFC6241] Enns, R., Ed., Bjorklund, M., Ed., Schoenwaelder, J., Ed., and A. Bierman, Ed., \"Network Configuration Protocol (NETCONF)\", RFC 6241, DOI 10.17487/RFC6241, June 2011, <http://www.rfc-editor.org/info/rfc6241>.",
      "zh-CHS": "[RFC6241]Enns，R.，Ed.，Bjorklund，M.，Ed.，Schoenwaeld，J.，Ed.，和A.Bierman，Ed.，“网络配置协议（NETCONF）”，RFC 6241，DOI 10.17487/RFC6241，2011年6月<http://www.rfc-editor.org/info/rfc6241>."
    },
    {
      "indent": 3,
      "text": "[RFC7405] Kyzivat, P., \"Case-Sensitive String Support in ABNF\", RFC 7405, DOI 10.17487/RFC7405, December 2014, <http://www.rfc-editor.org/info/rfc7405>.",
      "zh-CHS": "[RFC7405]Kyzivat，P.，“ABNF中的区分大小写字符串支持”，RFC 7405，DOI 10.17487/RFC7405，2014年12月<http://www.rfc-editor.org/info/rfc7405>."
    },
    {
      "indent": 3,
      "text": "[RFC7895] Bierman, A., Bjorklund, M., and K. Watsen, \"YANG Module Library\", RFC 7895, DOI 10.17487/RFC7895, June 2016, <http://www.rfc-editor.org/info/rfc7895>.",
      "zh-CHS": "[RFC7895]Bierman，A.，Bjorklund，M.，和K.Watsen，“阳模块库”，RFC 7895，DOI 10.17487/RFC78952016年6月<http://www.rfc-editor.org/info/rfc7895>."
    },
    {
      "indent": 3,
      "text": "[XML] Bray, T., Paoli, J., Sperberg-McQueen, C., Maler, E., and F. Yergeau, \"Extensible Markup Language (XML) 1.0 (Fifth Edition)\", W3C Recommendation REC-xml-20081126, November 2008, <https://www.w3.org/TR/2008/REC-xml-20081126/>.",
      "zh-CHS": "[XML]Bray，T.，Paoli，J.，Sperberg McQueen，C.，Maler，E.，和F.Yergeau，“可扩展标记语言（XML）1.0（第五版）”，W3C建议REC-XML-20081126，2008年11月<https://www.w3.org/TR/2008/REC-xml-20081126/>."
    },
    {
      "indent": 3,
      "text": "[XML-NAMES] Bray, T., Hollander, D., Layman, A., Tobin, R., and H. Thompson, \"Namespaces in XML 1.0 (Third Edition)\", World Wide Web Consortium Recommendation REC-xml-names-20091208, December 2009, <http://www.w3.org/TR/2009/REC-xml-names-20091208>.",
      "zh-CHS": "[XML-NAMES]Bray，T.，Hollander，D.，Layman，A.，Tobin，R.，和H.Thompson，“XML 1.0中的名称空间（第三版）”，万维网联盟建议REC-XML-NAMES-20091208，2009年12月<http://www.w3.org/TR/2009/REC-xml-names-20091208>."
    },
    {
      "indent": 3,
      "text": "[XPATH] Clark, J. and S. DeRose, \"XML Path Language (XPath) Version 1.0\", World Wide Web Consortium Recommendation REC-xpath-19991116, November 1999, <http://www.w3.org/TR/1999/REC-xpath-19991116>.",
      "zh-CHS": "[XPATH]Clark，J.和S.DeRose，“XML路径语言（XPATH）1.0版”，万维网联盟建议REC-XPATH-19991116，1999年11月<http://www.w3.org/TR/1999/REC-xpath-19991116>."
    },
    {
      "indent": 3,
      "text": "[XSD-TYPES] Biron, P. and A. Malhotra, \"XML Schema Part 2: Datatypes Second Edition\", World Wide Web Consortium Recommendation REC-xmlschema-2-20041028, October 2004, <http://www.w3.org/TR/2004/REC-xmlschema-2-20041028>.",
      "zh-CHS": "[XSD-TYPES]Biron，P.和A.Malhotra，“XML模式第2部分：数据类型第二版”，万维网联盟建议REC-xmlschema-2-20041028，2004年10月<http://www.w3.org/TR/2004/REC-xmlschema-2-20041028>."
    },
    {
      "indent": 0,
      "text": "18.2. Informative References",
      "section_title": true,
      "zh-CHS": "18.2. 资料性引用"
    },
    {
      "indent": 3,
      "text": "[CoMI] van der Stok, P. and A. Bierman, \"CoAP Management Interface\", Work in Progress, draft-vanderstok-core-comi-09, March 2016.",
      "zh-CHS": "[CoMI]van der Stok，P.和A.Bierman，“CoAP管理界面”，在建工程，草稿-vanderstok-core-CoMI-092016年3月。"
    },
    {
      "indent": 3,
      "text": "[IEEE754-2008] IEEE, \"IEEE Standard for Floating-Point Arithmetic\", IEEE 754-2008, DOI 10.1109/IEEESTD.2008.4610935, 2008, <http://standards.ieee.org/findstds/ standard/754-2008.html>.",
      "zh-CHS": "[IEEE754-2008]IEEE，“IEEE浮点运算标准”，IEEE 754-2008，DOI 10.1109/IEEESTD.2008.46109352008<http://standards.ieee.org/findstds/ 标准/754-2008.html>。"
    },
    {
      "indent": 3,
      "text": "[RESTCONF] Bierman, A., Bjorklund, M., and K. Watsen, \"RESTCONF Protocol\", Work in Progress, draft-ietf-netconf-restconf-16, August 2016.",
      "zh-CHS": "[RESTCONF]Bierman，A.，Bjorklund，M.，和K.Watsen，“RESTCONF协议”，正在进行的工作，草稿-ietf-netconf-RESTCONF-162016年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC2578] McCloghrie, K., Ed., Perkins, D., Ed., and J. Schoenwaelder, Ed., \"Structure of Management Information Version 2 (SMIv2)\", STD 58, RFC 2578, DOI 10.17487/RFC2578, April 1999, <http://www.rfc-editor.org/info/rfc2578>.",
      "zh-CHS": "[RFC2578]McCloghrie，K.，Ed.，Perkins，D.，Ed.，和J.Schoenwaeld，Ed.“管理信息的结构版本2（SMIv2）”，STD 58，RFC 2578，DOI 10.17487/RFC2578，1999年4月<http://www.rfc-editor.org/info/rfc2578>."
    },
    {
      "indent": 3,
      "text": "[RFC2579] McCloghrie, K., Ed., Perkins, D., Ed., and J. Schoenwaelder, Ed., \"Textual Conventions for SMIv2\", STD 58, RFC 2579, DOI 10.17487/RFC2579, April 1999, <http://www.rfc-editor.org/info/rfc2579>.",
      "zh-CHS": "[RFC2579]McCloghrie，K.，Ed.，Perkins，D.，Ed.，和J.Schoenwaeld，Ed.“SMIv2的文本约定”，STD 58，RFC 2579，DOI 10.17487/RFC2579，1999年4月<http://www.rfc-editor.org/info/rfc2579>."
    },
    {
      "indent": 3,
      "text": "[RFC3780] Strauss, F. and J. Schoenwaelder, \"SMIng - Next Generation Structure of Management Information\", RFC 3780, DOI 10.17487/RFC3780, May 2004, <http://www.rfc-editor.org/info/rfc3780>.",
      "zh-CHS": "[RFC3780]Strauss，F.和J.Schoenwaeld，“SMIng-下一代管理信息结构”，RFC 3780，DOI 10.17487/RFC3780，2004年5月<http://www.rfc-editor.org/info/rfc3780>."
    },
    {
      "indent": 3,
      "text": "[RFC4844] Daigle, L., Ed., and Internet Architecture Board, \"The RFC Series and RFC Editor\", RFC 4844, DOI 10.17487/RFC4844, July 2007, <http://www.rfc-editor.org/info/rfc4844>.",
      "zh-CHS": "[RFC4844]Daigle，L.，Ed.，和互联网架构委员会，“RFC系列和RFC编辑器”，RFC 4844，DOI 10.17487/RFC4844，2007年7月<http://www.rfc-editor.org/info/rfc4844>."
    },
    {
      "indent": 3,
      "text": "[RFC6020] Bjorklund, M., Ed., \"YANG - A Data Modeling Language for the Network Configuration Protocol (NETCONF)\", RFC 6020, DOI 10.17487/RFC6020, October 2010, <http://www.rfc-editor.org/info/rfc6020>.",
      "zh-CHS": "[RFC6020]Bjorklund，M.，Ed.“YANG-网络配置协议的数据建模语言（NETCONF）”，RFC 6020，DOI 10.17487/RFC6020，2010年10月<http://www.rfc-editor.org/info/rfc6020>."
    },
    {
      "indent": 3,
      "text": "[RFC6643] Schoenwaelder, J., \"Translation of Structure of Management Information Version 2 (SMIv2) MIB Modules to YANG Modules\", RFC 6643, DOI 10.17487/RFC6643, July 2012, <http://www.rfc-editor.org/info/rfc6643>.",
      "zh-CHS": "[RFC6643]Schoenwaeld，J.，“管理信息版本2（SMIv2）MIB模块结构到YANG模块的翻译”，RFC 6643，DOI 10.17487/RFC6643，2012年7月<http://www.rfc-editor.org/info/rfc6643>."
    },
    {
      "indent": 3,
      "text": "[RFC6991] Schoenwaelder, J., Ed., \"Common YANG Data Types\", RFC 6991, DOI 10.17487/RFC6991, July 2013, <http://www.rfc-editor.org/info/rfc6991>.",
      "zh-CHS": "[RFC6991]Schoenwaeld，J.，Ed.，“常见杨数据类型”，RFC 6991，DOI 10.17487/RFC69911913年7月<http://www.rfc-editor.org/info/rfc6991>."
    },
    {
      "indent": 3,
      "text": "[RFC7951] Lhotka, L., \"JSON Encoding of Data Modeled with YANG\", RFC 7951, DOI 10.17487/RFC7951, August 2016, <http://www.rfc-editor.org/info/rfc7951>.",
      "zh-CHS": "[RFC7951]Lhotka，L.，“用YANG建模的数据的JSON编码”，RFC 7951，DOI 10.17487/RFC7951，2016年8月<http://www.rfc-editor.org/info/rfc7951>."
    },
    {
      "indent": 3,
      "text": "[XPATH2.0] Berglund, A., Boag, S., Chamberlin, D., Fernandez, M., Kay, M., Robie, J., and J. Simeon, \"XML Path Language (XPath) 2.0 (Second Edition)\", World Wide Web Consortium Recommendation REC-xpath20-20101214, December 2010, <http://www.w3.org/TR/2010/REC-xpath20-20101214>.",
      "zh-CHS": "[XPATH2.0]Berglund，A.，Boag，S.，Chamberlin，D.，Fernandez，M.，Kay，M.，Robie，J.，和J.Simeon，“XML路径语言（XPath）2.0（第二版）”，万维网联盟建议REC-xpath20-20101214，2010年12月<http://www.w3.org/TR/2010/REC-xpath20-20101214>."
    },
    {
      "indent": 3,
      "text": "[XSLT] Clark, J., \"XSL Transformations (XSLT) Version 1.0\", World Wide Web Consortium Recommendation REC-xslt-19991116, November 1999, <http://www.w3.org/TR/1999/REC-xslt-19991116>.",
      "zh-CHS": "[XSLT]Clark，J.，“XSL转换（XSLT）1.0版”，万维网联盟建议REC-XSLT-19991116，1999年11月<http://www.w3.org/TR/1999/REC-xslt-19991116>."
    },
    {
      "indent": 3,
      "text": "[YANG-Guidelines] Bierman, A., \"Guidelines for Authors and Reviewers of YANG Data Model Documents\", Work in Progress, draft-ietf-netmod-rfc6087bis-07, July 2016.",
      "zh-CHS": "[YANG指南]Bierman，A.，“YANG数据模型文件的作者和评审者指南”，正在进行的工作，草稿-ietf-netmod-rfc6087bis-07，2016年7月。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "zh-CHS": "致谢"
    },
    {
      "indent": 3,
      "text": "The editor wishes to thank the following individuals, who all provided helpful comments on various draft versions of this document: Mehmet Ersue, Washam Fan, Joel Halpern, Per Hedeland, Leif Johansson, Ladislav Lhotka, Lionel Morand, Gerhard Muenz, Peyman Owladi, Tom Petch, Randy Presuhn, David Reid, Jernej Tuljak, Kent Watsen, Bert Wijnen, Robert Wilton, and Dale Worley.",
      "zh-CHS": "编辑希望感谢以下个人，他们都对本文件的各种草案版本提供了有益的意见：梅米特·厄苏、瓦萨姆·范、乔尔·哈尔佩恩、佩尔·海德兰、莱夫·约翰逊、拉迪斯拉夫·洛特卡、莱昂内尔·莫兰德、格哈德·穆恩斯、佩曼·奥拉迪、汤姆·佩奇、兰迪·普雷森、大卫·里德、杰尼·图尔雅克、肯特·沃特森、伯特·维恩、，罗伯特·威尔顿和戴尔·沃利。"
    },
    {
      "indent": 0,
      "text": "Contributors",
      "zh-CHS": "贡献者"
    },
    {
      "indent": 3,
      "text": "The following people all contributed significantly to the initial YANG document:",
      "zh-CHS": "以下人员都对最初的YANG文件做出了重大贡献："
    },
    {
      "indent": 4,
      "text": "- Andy Bierman (YumaWorks) - Balazs Lengyel (Ericsson) - David Partain (Ericsson) - Juergen Schoenwaelder (Jacobs University Bremen) - Phil Shafer (Juniper Networks)",
      "zh-CHS": "- 安迪·比尔曼（尤马works）-巴拉兹·伦杰尔（爱立信）-大卫·帕坦（爱立信）-尤尔根·舍恩瓦埃尔德（不来梅雅各布大学）-菲尔·沙弗（朱尼珀网络公司）"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "zh-CHS": "作者地址"
    },
    {
      "indent": 3,
      "text": "Martin Bjorklund (editor) Tail-f Systems",
      "zh-CHS": "Martin Bjorklund（编辑）Tail-f系统"
    },
    {
      "indent": 3,
      "text": "Email: mbj@tail-f.com",
      "raw": true,
      "zh-CHS": " "
    }
  ]
}