{
  "title": {
    "text": "RFC 7951: JSON Encoding of Data Modeled with YANG",
    "zh-CHS": "RFC 7951"
  },
  "number": 7951,
  "created_at": "2021-11-01 09:52:34.461220+08:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                         L. Lhotka\nRequest for Comments: 7951                                        CZ.NIC\nCategory: Standards Track                                    August 2016\nISSN: 2070-1721",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 16,
      "text": "JSON Encoding of Data Modeled with YANG",
      "zh-CHS": "用YANG建模的数据的JSON编码"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "zh-CHS": "摘要"
    },
    {
      "indent": 3,
      "text": "This document defines encoding rules for representing configuration data, state data, parameters of Remote Procedure Call (RPC) operations or actions, and notifications defined using YANG as JavaScript Object Notation (JSON) text.",
      "zh-CHS": "本文档定义了编码规则，用于表示配置数据、状态数据、远程过程调用（RPC）操作或动作的参数，以及使用YANG作为JavaScript对象表示法（JSON）文本定义的通知。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "zh-CHS": "关于下段备忘"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "zh-CHS": "这是一份互联网标准跟踪文件。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "zh-CHS": "本文件是互联网工程任务组（IETF）的产品。它代表了IETF社区的共识。它已经接受了公众审查，并已被互联网工程指导小组（IESG）批准出版。有关互联网标准的更多信息，请参见RFC 7841第2节。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7951.",
      "zh-CHS": "有关本文件当前状态、任何勘误表以及如何提供反馈的信息，请访问http://www.rfc-editor.org/info/rfc7951."
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "zh-CHS": "版权公告"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2016 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "zh-CHS": "版权所有（c）2016 IETF信托基金和确定为文件作者的人员。版权所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "zh-CHS": "本文件受BCP 78和IETF信托有关IETF文件的法律规定的约束(http://trustee.ietf.org/license-info)自本文件出版之日起生效。请仔细阅读这些文件，因为它们描述了您对本文件的权利和限制。从本文件中提取的代码组件必须包括信托法律条款第4.e节中所述的简化BSD许可证文本，并提供简化BSD许可证中所述的无担保。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "zh-CHS": "目录"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\n2.  Terminology and Notation  . . . . . . . . . . . . . . . . . .   3\n3.  Properties of the JSON Encoding . . . . . . . . . . . . . . .   4\n4.  Names and Namespaces  . . . . . . . . . . . . . . . . . . . .   5\n5.  Encoding of YANG Data Node Instances  . . . . . . . . . . . .   7\n  5.1.  The \"leaf\" Data Node  . . . . . . . . . . . . . . . . . .   7\n  5.2.  The \"container\" Data Node . . . . . . . . . . . . . . . .   8\n  5.3.  The \"leaf-list\" Data Node . . . . . . . . . . . . . . . .   8\n  5.4.  The \"list\" Data Node  . . . . . . . . . . . . . . . . . .   9\n  5.5.  The \"anydata\" Data Node . . . . . . . . . . . . . . . . .   9\n  5.6.  The \"anyxml\" Data Node  . . . . . . . . . . . . . . . . .  10\n  5.7.  Metadata Objects  . . . . . . . . . . . . . . . . . . . .  11\n6.  Representing YANG Data Types in JSON Values . . . . . . . . .  11\n  6.1.  Numeric Types . . . . . . . . . . . . . . . . . . . . . .  11\n  6.2.  The \"string\" Type . . . . . . . . . . . . . . . . . . . .  11\n  6.3.  The \"boolean\" Type  . . . . . . . . . . . . . . . . . . .  11\n  6.4.  The \"enumeration\" Type  . . . . . . . . . . . . . . . . .  12\n  6.5.  The \"bits\" Type . . . . . . . . . . . . . . . . . . . . .  12\n  6.6.  The \"binary\" Type . . . . . . . . . . . . . . . . . . . .  12\n  6.7.  The \"leafref\" Type  . . . . . . . . . . . . . . . . . . .  12\n  6.8.  The \"identityref\" Type  . . . . . . . . . . . . . . . . .  12\n  6.9.  The \"empty\" Type  . . . . . . . . . . . . . . . . . . . .  13\n  6.10. The \"union\" Type  . . . . . . . . . . . . . . . . . . . .  14\n  6.11. The \"instance-identifier\" Type  . . . . . . . . . . . . .  15\n7.  I-JSON Compliance . . . . . . . . . . . . . . . . . . . . . .  15\n8.  Security Considerations . . . . . . . . . . . . . . . . . . .  16\n9.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  16\n  9.1.  Normative References  . . . . . . . . . . . . . . . . . .  16\n  9.2.  Informative References  . . . . . . . . . . . . . . . . .  17\nAppendix A.  A Complete Example . . . . . . . . . . . . . . . . .  18\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  20\nAuthor's Address  . . . . . . . . . . . . . . . . . . . . . . . .  20",
      "raw": true,
      "toc": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "zh-CHS": "1. 介绍"
    },
    {
      "indent": 3,
      "text": "The Network Configuration Protocol (NETCONF) [RFC6241] uses XML [XML] for encoding data in its Content Layer. Other management protocols might want to use other encodings while still benefiting from using YANG [RFC7950] as the data modeling language.",
      "zh-CHS": "网络配置协议（NETCONF）[RFC6241]使用XML[XML]对其内容层中的数据进行编码。其他管理协议可能希望使用其他编码，同时仍然受益于使用YANG[RFC7950]作为数据建模语言。"
    },
    {
      "indent": 3,
      "text": "For example, the RESTCONF protocol [RESTCONF] supports two encodings: XML (media type \"application/yang.data+xml\") and JavaScript Object Notation (JSON) (media type \"application/yang.data+json\").",
      "zh-CHS": "例如，RESTCONF协议[RESTCONF]支持两种编码：XML（媒体类型“application/yang.data+XML”）和JavaScript对象表示法（JSON）（媒体类型“application/yang.data+JSON”）。"
    },
    {
      "indent": 3,
      "text": "The specification of the YANG 1.1 data modeling language [RFC7950] defines only XML encoding of data trees, i.e., configuration data, state data, input/output parameters of Remote Procedure Call (RPC) operations or actions, and notifications. The aim of this document is to define rules for encoding the same data as JSON text [RFC7159].",
      "zh-CHS": "YANG 1.1数据建模语言[RFC7950]的规范仅定义数据树的XML编码，即配置数据、状态数据、远程过程调用（RPC）操作或动作的输入/输出参数以及通知。本文档的目的是定义编码与JSON文本相同数据的规则[RFC7159]。"
    },
    {
      "indent": 0,
      "text": "2. Terminology and Notation",
      "section_title": true,
      "zh-CHS": "2. 术语和符号"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "zh-CHS": "本文件中的关键词“必须”、“不得”、“必需”、“应”、“不应”、“应”、“不应”、“建议”、“可”和“可选”应按照[RFC2119]中所述进行解释。"
    },
    {
      "indent": 3,
      "text": "The following terms are defined in [RFC7950]:",
      "zh-CHS": "[RFC7950]中定义了以下术语："
    },
    {
      "indent": 3,
      "text": "o action",
      "zh-CHS": "o 行动"
    },
    {
      "indent": 3,
      "text": "o anydata",
      "zh-CHS": "o 任何数据"
    },
    {
      "indent": 3,
      "text": "o anyxml",
      "zh-CHS": "o 任意XML"
    },
    {
      "indent": 3,
      "text": "o augment",
      "zh-CHS": "o 加强"
    },
    {
      "indent": 3,
      "text": "o container",
      "zh-CHS": "o 容器"
    },
    {
      "indent": 3,
      "text": "o data node",
      "zh-CHS": "o 数据节点"
    },
    {
      "indent": 3,
      "text": "o data tree",
      "zh-CHS": "o 数据树"
    },
    {
      "indent": 3,
      "text": "o identity",
      "zh-CHS": "o 身份"
    },
    {
      "indent": 3,
      "text": "o instance identifier",
      "zh-CHS": "o 实例标示符"
    },
    {
      "indent": 3,
      "text": "o leaf",
      "zh-CHS": "o 叶"
    },
    {
      "indent": 3,
      "text": "o leaf-list",
      "zh-CHS": "o 叶列表"
    },
    {
      "indent": 3,
      "text": "o list",
      "zh-CHS": "o 列表"
    },
    {
      "indent": 3,
      "text": "o module",
      "zh-CHS": "o 单元"
    },
    {
      "indent": 3,
      "text": "o RPC operation",
      "zh-CHS": "o RPC操作"
    },
    {
      "indent": 3,
      "text": "o submodule",
      "zh-CHS": "o 子模块"
    },
    {
      "indent": 3,
      "text": "The following terms are defined in [RFC6241]:",
      "zh-CHS": "[RFC6241]中定义了以下术语："
    },
    {
      "indent": 3,
      "text": "o configuration data",
      "zh-CHS": "o 配置数据"
    },
    {
      "indent": 3,
      "text": "o notification",
      "zh-CHS": "o 通知"
    },
    {
      "indent": 3,
      "text": "o state data",
      "zh-CHS": "o 状态数据"
    },
    {
      "indent": 0,
      "text": "3. Properties of the JSON Encoding",
      "section_title": true,
      "zh-CHS": "3. JSON编码的属性"
    },
    {
      "indent": 3,
      "text": "This document defines JSON encoding for YANG data trees and their subtrees. It is always assumed that the top-level structure in JSON-encoded data is an object.",
      "zh-CHS": "本文档定义了数据树及其子树的JSON编码。通常假定JSON编码数据中的顶级结构是一个对象。"
    },
    {
      "indent": 3,
      "text": "Instances of YANG data nodes (leafs, containers, leaf-lists, lists, anydata nodes, and anyxml nodes) are encoded as members of a JSON object, i.e., name/value pairs. Section 4 defines how the name part is formed, and the following sections deal with the value part. The encoding rules are identical for all types of data trees, i.e., configuration data, state data, parameters of RPC operations, actions, and notifications.",
      "zh-CHS": "数据节点的实例（叶、容器、叶列表、列表、anydata节点和anyxml节点）被编码为JSON对象的成员，即名称/值对。第4节定义了名称部分是如何形成的，下面几节讨论了值部分。编码规则对于所有类型的数据树都是相同的，即配置数据、状态数据、RPC操作参数、操作和通知。"
    },
    {
      "indent": 3,
      "text": "With the exception of \"anydata\" encoding (Section 5.5), all rules in this document are also applicable to YANG 1.0 [RFC6020].",
      "zh-CHS": "除“anydata”编码（第5.5节）外，本文件中的所有规则也适用于YANG 1.0[RFC6020]。"
    },
    {
      "indent": 3,
      "text": "Unlike XML element content, JSON values carry partial type information (number, string, boolean). The JSON encoding is defined so that this information is never in conflict with the data type of the corresponding YANG leaf or leaf-list.",
      "zh-CHS": "与XML元素内容不同，JSON值携带部分类型信息（数字、字符串、布尔值）。JSON编码的定义使得该信息永远不会与相应的YANG叶或叶列表的数据类型冲突。"
    },
    {
      "indent": 3,
      "text": "With the exception of anyxml and schema-less anydata nodes, it is possible to map a JSON-encoded data tree to XML encoding as defined in [RFC7950], and vice versa. However, such conversions require the YANG data model to be available.",
      "zh-CHS": "除了anyxml和无模式的anydata节点外，可以将JSON编码的数据树映射为[RFC7950]中定义的XML编码，反之亦然。然而，这种转换要求YANG数据模型可用。"
    },
    {
      "indent": 3,
      "text": "In order to achieve maximum interoperability while allowing implementations to use a variety of existing JSON parsers, the JSON encoding rules follow, as much as possible, the constraints of the I-JSON (Internet JSON) restricted profile [RFC7493]. Section 7 discusses I-JSON conformance in more detail.",
      "zh-CHS": "为了实现最大的互操作性，同时允许实现使用各种现有的JSON解析器，JSON编码规则尽可能遵循I-JSON（Internet JSON）受限概要文件[RFC7493]的约束。第7节更详细地讨论了I-JSON一致性。"
    },
    {
      "indent": 0,
      "text": "4. Names and Namespaces",
      "section_title": true,
      "zh-CHS": "4. 名称和名称空间"
    },
    {
      "indent": 3,
      "text": "A JSON object member name MUST be in one of the following forms:",
      "zh-CHS": "JSON对象成员名称必须采用以下形式之一："
    },
    {
      "indent": 3,
      "text": "o simple - identical to the identifier of the corresponding YANG data node.",
      "zh-CHS": "o 简单-与相应数据节点的标识符相同。"
    },
    {
      "indent": 3,
      "text": "o namespace-qualified - the data node identifier is prefixed with the name of the module in which the data node is defined, separated from the data node identifier by the colon character (\":\").",
      "zh-CHS": "o namespace qualified（名称空间限定）-数据节点标识符以定义数据节点的模块名称作为前缀，以冒号（“：”）与数据节点标识符分隔。"
    },
    {
      "indent": 3,
      "text": "The name of a module determines the namespace of all data node names defined in that module. If a data node is defined in a submodule, then the namespace-qualified member name uses the name of the main module to which the submodule belongs.",
      "zh-CHS": "模块的名称确定该模块中定义的所有数据节点名称的命名空间。如果在子模块中定义了数据节点，则命名空间限定成员名称将使用子模块所属的主模块的名称。"
    },
    {
      "indent": 3,
      "text": "ABNF syntax [RFC5234] of a member name is shown in Figure 1, where the production for \"identifier\" is defined in Section 14 of [RFC7950].",
      "zh-CHS": "成员名称的ABNF语法[RFC5234]如图1所示，其中“标识符”的产生在[RFC7950]的第14节中定义。"
    },
    {
      "indent": 11,
      "text": "member-name = [identifier \":\"] identifier",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 13,
      "text": "Figure 1: ABNF Production for a JSON Member Name",
      "zh-CHS": "图1:JSON成员名的ABNF生产"
    },
    {
      "indent": 3,
      "text": "A namespace-qualified member name MUST be used for all members of a top-level JSON object and then also whenever the namespaces of the data node and its parent node are different. In all other cases, the simple form of the member name MUST be used.",
      "zh-CHS": "顶级JSON对象的所有成员都必须使用名称空间限定的成员名称，并且在数据节点及其父节点的名称空间不同时也必须使用名称空间限定的成员名称。在所有其他情况下，必须使用成员名称的简单形式。"
    },
    {
      "indent": 3,
      "text": "For example, consider the following YANG module:",
      "zh-CHS": "例如，考虑以下杨氏模块："
    },
    {
      "indent": 3,
      "text": "module example-foomod {",
      "zh-CHS": "模块示例foomod{"
    },
    {
      "indent": 5,
      "text": "namespace \"http://example.com/foomod\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "prefix \"foomod\";",
      "zh-CHS": "前缀“foomod”；"
    },
    {
      "indent": 3,
      "text": "  container top {\n    leaf foo {\n      type uint8;\n    }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "If the data model consists only of this module, then the following is valid JSON-encoded configuration data:",
      "zh-CHS": "如果数据模型仅包含此模块，则以下是有效的JSON编码配置数据："
    },
    {
      "indent": 3,
      "text": "{\n  \"example-foomod:top\": {\n    \"foo\": 54\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Note that the member of the top-level object uses the namespace-qualified name but the \"foo\" leaf doesn't because it is defined in the same module as its parent container \"top\".",
      "zh-CHS": "请注意，顶级对象的成员使用命名空间限定名，但“foo”叶不使用，因为它与其父容器“top”在同一模块中定义。"
    },
    {
      "indent": 3,
      "text": "Now, assume that the container \"top\" is augmented from another module, \"example-barmod\":",
      "zh-CHS": "现在，假设容器“top”是从另一个模块“example barmod”扩展而来的："
    },
    {
      "indent": 3,
      "text": "module example-barmod {",
      "zh-CHS": "模块示例barmod{"
    },
    {
      "indent": 5,
      "text": "namespace \"http://example.com/barmod\";",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "prefix \"barmod\";",
      "zh-CHS": "前缀“barmod”；"
    },
    {
      "indent": 5,
      "text": "import example-foomod {\n  prefix \"foomod\";\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "  augment \"/foomod:top\" {\n    leaf bar {\n      type boolean;\n    }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Valid JSON-encoded configuration data containing both leafs may then look like this:",
      "zh-CHS": "包含两个leaf的有效JSON编码配置数据可能如下所示："
    },
    {
      "indent": 3,
      "text": "{\n  \"example-foomod:top\": {\n    \"foo\": 54,\n    \"example-barmod:bar\": true\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The name of the \"bar\" leaf is prefixed with the namespace identifier because its parent is defined in a different module.",
      "zh-CHS": "“bar”叶的名称以名称空间标识符作为前缀，因为它的父级是在不同的模块中定义的。"
    },
    {
      "indent": 3,
      "text": "Explicit namespace identifiers are sometimes needed when encoding values of the \"identityref\" and \"instance-identifier\" types. The same form of namespace-qualified name as defined above is then used. See Sections 6.8 and 6.11 for details.",
      "zh-CHS": "在编码“identityref”和“instance identifier”类型的值时，有时需要显式命名空间标识符。然后使用与上面定义的名称空间限定名称相同的形式。详见第6.8节和第6.11节。"
    },
    {
      "indent": 0,
      "text": "5. Encoding of YANG Data Node Instances",
      "section_title": true,
      "zh-CHS": "5. 数据节点实例的编码"
    },
    {
      "indent": 3,
      "text": "Every data node instance is encoded as a name/value pair where the name is formed from the data node identifier using the rules of Section 4. The value depends on the category of the data node, as explained in the following subsections.",
      "zh-CHS": "每个数据节点实例被编码为名称/值对，其中名称是使用第4节的规则从数据节点标识符形成的。该值取决于数据节点的类别，如下小节所述。"
    },
    {
      "indent": 3,
      "text": "Character encoding MUST be UTF-8.",
      "zh-CHS": "字符编码必须是UTF-8。"
    },
    {
      "indent": 0,
      "text": "5.1. The \"leaf\" Data Node",
      "section_title": true,
      "zh-CHS": "5.1. “叶”数据节点"
    },
    {
      "indent": 3,
      "text": "A leaf instance is encoded as a name/value pair where the value can be a string, number, literal \"true\" or \"false\", or the special array \"[null]\", depending on the type of the leaf (see Section 6 for the type encoding rules).",
      "zh-CHS": "叶实例被编码为名称/值对，其中值可以是字符串、数字、文字“true”或“false”，或特殊数组“[null]”，具体取决于叶的类型（类型编码规则见第6节）。"
    },
    {
      "indent": 3,
      "text": "Example: For the leaf node definition",
      "zh-CHS": "示例：用于叶节点定义"
    },
    {
      "indent": 3,
      "text": "leaf foo {\n  type uint8;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "the following is a valid JSON-encoded instance:",
      "zh-CHS": "以下是一个有效的JSON编码实例："
    },
    {
      "indent": 3,
      "text": "\"foo\": 123",
      "zh-CHS": "“福”：123"
    },
    {
      "indent": 0,
      "text": "5.2. The \"container\" Data Node",
      "section_title": true,
      "zh-CHS": "5.2. “容器”数据节点"
    },
    {
      "indent": 3,
      "text": "A container instance is encoded as a name/object pair. The container's child data nodes are encoded as members of the object.",
      "zh-CHS": "容器实例编码为名称/对象对。容器的子数据节点被编码为对象的成员。"
    },
    {
      "indent": 3,
      "text": "Example: For the container definition",
      "zh-CHS": "示例：用于容器定义"
    },
    {
      "indent": 3,
      "text": "container bar {\n  leaf foo {\n    type uint8;\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "the following is a valid JSON-encoded instance:",
      "zh-CHS": "以下是一个有效的JSON编码实例："
    },
    {
      "indent": 3,
      "text": "\"bar\": {\n  \"foo\": 123\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "5.3. The \"leaf-list\" Data Node",
      "section_title": true,
      "zh-CHS": "5.3. “叶列表”数据节点"
    },
    {
      "indent": 3,
      "text": "A leaf-list is encoded as a name/array pair, and the array elements are values of some scalar type, which can be a string, number, literal \"true\" or \"false\", or the special array \"[null]\", depending on the type of the leaf-list (see Section 6 for the type encoding rules).",
      "zh-CHS": "叶列表编码为名称/数组对，数组元素是一些标量类型的值，可以是字符串、数字、文字“真”或“假”，或特殊数组“[null]”，具体取决于叶列表的类型（类型编码规则见第6节）。"
    },
    {
      "indent": 3,
      "text": "The ordering of array elements follows the same rules as the ordering of XML elements representing leaf-list entries in the XML encoding. Specifically, the \"ordered-by\" properties (Section 7.7.7 in [RFC7950]) MUST be observed.",
      "zh-CHS": "数组元素的顺序遵循与XML编码中表示叶列表项的XML元素的顺序相同的规则。具体而言，必须遵守“订购人”属性（RFC7950中的第7.7.7节）。"
    },
    {
      "indent": 3,
      "text": "Example: For the leaf-list definition",
      "zh-CHS": "示例：用于叶列表定义"
    },
    {
      "indent": 3,
      "text": "leaf-list foo {\n  type uint8;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "the following is a valid JSON-encoded instance:",
      "zh-CHS": "以下是一个有效的JSON编码实例："
    },
    {
      "indent": 3,
      "text": "\"foo\": [123, 0]",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "5.4. The \"list\" Data Node",
      "section_title": true,
      "zh-CHS": "5.4. “列表”数据节点"
    },
    {
      "indent": 3,
      "text": "A list instance is encoded as a name/array pair, and the array elements are JSON objects.",
      "zh-CHS": "列表实例编码为名称/数组对，数组元素是JSON对象。"
    },
    {
      "indent": 3,
      "text": "The ordering of array elements follows the same rules as the ordering of XML elements representing list entries in the XML encoding. Specifically, the \"ordered-by\" properties (Section 7.7.7 in [RFC7950]) MUST be observed.",
      "zh-CHS": "数组元素的顺序遵循与XML编码中表示列表项的XML元素的顺序相同的规则。具体而言，必须遵守“订购人”属性（RFC7950中的第7.7.7节）。"
    },
    {
      "indent": 3,
      "text": "Unlike the XML encoding, where list keys are required to precede any other siblings within a list entry and appear in the order specified by the data model, the order of members in a JSON-encoded list entry is arbitrary because JSON objects are fundamentally unordered collections of members.",
      "zh-CHS": "与XML编码不同，在XML编码中，列表键必须位于列表项中任何其他同级项之前，并按照数据模型指定的顺序显示，JSON编码列表项中的成员顺序是任意的，因为JSON对象基本上是无序的成员集合。"
    },
    {
      "indent": 3,
      "text": "Example: For the list definition",
      "zh-CHS": "示例：用于列表定义"
    },
    {
      "indent": 3,
      "text": "list bar {\n  key foo;\n  leaf foo {\n    type uint8;\n  }\n  leaf baz {\n    type string;\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "the following is a valid JSON-encoded instance:",
      "zh-CHS": "以下是一个有效的JSON编码实例："
    },
    {
      "indent": 3,
      "text": "\"bar\": [\n  {\n    \"foo\": 123,\n    \"baz\": \"zig\"\n  },\n  {\n    \"baz\": \"zag\",\n    \"foo\": 0\n  }\n]",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "5.5. The \"anydata\" Data Node",
      "section_title": true,
      "zh-CHS": "5.5. “anydata”数据节点"
    },
    {
      "indent": 3,
      "text": "The anydata data node serves as a container for an arbitrary set of nodes that otherwise appear as normal YANG-modeled data. A data model for anydata content may or may not be known at runtime. In the latter case, converting JSON-encoded instances to the XML encoding defined in [RFC7950] may be impossible.",
      "zh-CHS": "anydata数据节点用作任意一组节点的容器，否则这些节点将显示为正常数据。任何数据内容的数据模型在运行时可能已知，也可能未知。在后一种情况下，将JSON编码的实例转换为[RFC7950]中定义的XML编码可能是不可能的。"
    },
    {
      "indent": 3,
      "text": "An anydata instance is encoded in the same way as a container, i.e., as a name/object pair. The requirement that anydata content can be modeled by YANG implies the following rules for the JSON text inside the object:",
      "zh-CHS": "anydata实例的编码方式与容器相同，即名称/对象对。anydata内容可以由YANG建模的要求意味着对象内部JSON文本的以下规则："
    },
    {
      "indent": 3,
      "text": "o It is valid I-JSON [RFC7493].",
      "zh-CHS": "o 它是有效的I-JSON[RFC7493]。"
    },
    {
      "indent": 3,
      "text": "o All object member names satisfy the ABNF production in Figure 1.",
      "zh-CHS": "o 所有对象成员名称都满足图1中的ABNF产品。"
    },
    {
      "indent": 3,
      "text": "o Any JSON array contains either only unique scalar values (as a leaf-list; see Section 5.3) or only objects (as a list; see Section 5.4).",
      "zh-CHS": "o 任何JSON数组要么只包含唯一的标量值（作为叶列表；请参见第5.3节），要么只包含对象（作为列表；请参见第5.4节）。"
    },
    {
      "indent": 3,
      "text": "o The \"null\" value is only allowed in the single-element array \"[null]\" corresponding to the encoding of the \"empty\" type; see Section 6.9.",
      "zh-CHS": "o 仅在与“空”类型编码对应的单元素数组“[null]”中允许使用“null”值；见第6.9节。"
    },
    {
      "indent": 3,
      "text": "Example: For the anydata definition",
      "zh-CHS": "示例：对于anydata定义"
    },
    {
      "indent": 3,
      "text": "anydata data;",
      "zh-CHS": "任何数据数据；"
    },
    {
      "indent": 3,
      "text": "the following is a valid JSON-encoded instance:",
      "zh-CHS": "以下是一个有效的JSON编码实例："
    },
    {
      "indent": 3,
      "text": "\"data\": {\n  \"ietf-notification:notification\": {\n    \"eventTime\": \"2014-07-29T13:43:01Z\",\n    \"example-event:event\": {\n      \"event-class\": \"fault\",\n      \"reporting-entity\": {\n        \"card\": \"Ethernet0\"\n      },\n      \"severity\": \"major\"\n    }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "5.6. The \"anyxml\" Data Node",
      "section_title": true,
      "zh-CHS": "5.6. “anyxml”数据节点"
    },
    {
      "indent": 3,
      "text": "An anyxml instance is encoded as a JSON name/value pair. The value MUST satisfy I-JSON constraints.",
      "zh-CHS": "anyxml实例编码为JSON名称/值对。该值必须满足I-JSON约束。"
    },
    {
      "indent": 3,
      "text": "Example: For the anyxml definition",
      "zh-CHS": "示例：对于anyxml定义"
    },
    {
      "indent": 3,
      "text": "anyxml bar;",
      "zh-CHS": "anyxml条；"
    },
    {
      "indent": 3,
      "text": "the following is a valid JSON-encoded instance:",
      "zh-CHS": "以下是一个有效的JSON编码实例："
    },
    {
      "indent": 3,
      "text": "\"bar\": [true, null, true]",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "5.7. Metadata Objects",
      "section_title": true,
      "zh-CHS": "5.7. 元数据对象"
    },
    {
      "indent": 3,
      "text": "Apart from instances of YANG data nodes, a JSON document MAY contain special object members whose name starts with the \"@\" character (COMMERCIAL AT). Such members are used for special purposes, such as encoding metadata [RFC7952]. The exact syntax and semantics of such members are outside the scope of this document.",
      "zh-CHS": "除了数据节点的实例外，JSON文档可能包含名称以“@”字符开头的特殊对象成员（商业地址）。这些成员用于特殊目的，例如编码元数据[RFC7952]。这些成员的确切语法和语义不在本文档的范围内。"
    },
    {
      "indent": 0,
      "text": "6. Representing YANG Data Types in JSON Values",
      "section_title": true,
      "zh-CHS": "6. 用JSON值表示数据类型"
    },
    {
      "indent": 3,
      "text": "The type of the JSON value in an instance of the leaf or leaf-list data node depends on the type of that data node, as specified in the following subsections.",
      "zh-CHS": "叶或叶列表数据节点实例中JSON值的类型取决于该数据节点的类型，如下小节所述。"
    },
    {
      "indent": 0,
      "text": "6.1. Numeric Types",
      "section_title": true,
      "zh-CHS": "6.1. 数值类型"
    },
    {
      "indent": 3,
      "text": "A value of the \"int8\", \"int16\", \"int32\", \"uint8\", \"uint16\", or \"uint32\" type is represented as a JSON number.",
      "zh-CHS": "“int8”、“int16”、“int32”、“uint8”、“uint16”或“uint32”类型的值表示为JSON编号。"
    },
    {
      "indent": 3,
      "text": "A value of the \"int64\", \"uint64\", or \"decimal64\" type is represented as a JSON string whose content is the lexical representation of the corresponding YANG type as specified in Sections 9.2.1 and 9.3.1 of [RFC7950].",
      "zh-CHS": "“int64”、“uint64”或“decimal64”类型的值表示为JSON字符串，其内容是[RFC7950]第9.2.1节和第9.3.1节中规定的对应YANG类型的词汇表示。"
    },
    {
      "indent": 3,
      "text": "For example, if the type of the leaf \"foo\" in Section 5.1 was \"uint64\" instead of \"uint8\", the instance would have to be encoded as",
      "zh-CHS": "例如，如果第5.1节中叶“foo”的类型是“uint64”而不是“uint8”，则实例必须编码为"
    },
    {
      "indent": 3,
      "text": "\"foo\": \"123\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The special handling of 64-bit numbers follows from the I-JSON recommendation to encode numbers exceeding the IEEE 754-2008 double-precision range [IEEE754-2008] as strings; see Section 2.2 in [RFC7493].",
      "zh-CHS": "64位数字的特殊处理遵循I-JSON建议，将超过IEEE 754-2008双精度范围[IEEE754-2008]的数字编码为字符串；参见[RFC7493]中的第2.2节。"
    },
    {
      "indent": 0,
      "text": "6.2. The \"string\" Type",
      "section_title": true,
      "zh-CHS": "6.2. “字符串”类型"
    },
    {
      "indent": 3,
      "text": "A \"string\" value is represented as a JSON string, subject to JSON string encoding rules.",
      "zh-CHS": "“string”值表示为JSON字符串，遵循JSON字符串编码规则。"
    },
    {
      "indent": 0,
      "text": "6.3. The \"boolean\" Type",
      "section_title": true,
      "zh-CHS": "6.3. “布尔”类型"
    },
    {
      "indent": 3,
      "text": "A \"boolean\" value is represented as the corresponding JSON literal name \"true\" or \"false\".",
      "zh-CHS": "“boolean”值表示为相应的JSON文字名称“true”或“false”。"
    },
    {
      "indent": 0,
      "text": "6.4. The \"enumeration\" Type",
      "section_title": true,
      "zh-CHS": "6.4. “枚举”类型"
    },
    {
      "indent": 3,
      "text": "An \"enumeration\" value is represented as a JSON string -- one of the names assigned by \"enum\" statements in YANG.",
      "zh-CHS": "“enumeration”值表示为JSON字符串——YANG中“enum”语句指定的名称之一。"
    },
    {
      "indent": 3,
      "text": "The representation is identical to the lexical representation of the \"enumeration\" type in XML; see Section 9.6 in [RFC7950].",
      "zh-CHS": "该表示法与XML中“枚举”类型的词汇表示法相同；参见[RFC7950]中的第9.6节。"
    },
    {
      "indent": 0,
      "text": "6.5. The \"bits\" Type",
      "section_title": true,
      "zh-CHS": "6.5. “比特”类型"
    },
    {
      "indent": 3,
      "text": "A \"bits\" value is represented as a JSON string -- a space-separated sequence of names of bits that are set. The permitted bit names are assigned by \"bit\" statements in YANG.",
      "zh-CHS": "“bits”值表示为JSON字符串——一个由设置的位的名称组成的以空格分隔的序列。允许的位名称由YANG中的“bit”语句指定。"
    },
    {
      "indent": 3,
      "text": "The representation is identical to the lexical representation of the \"bits\" type; see Section 9.7 in [RFC7950].",
      "zh-CHS": "该表示法与“位”类型的词汇表示法相同；参见[RFC7950]中的第9.7节。"
    },
    {
      "indent": 0,
      "text": "6.6. The \"binary\" Type",
      "section_title": true,
      "zh-CHS": "6.6. “二进制”类型"
    },
    {
      "indent": 3,
      "text": "A \"binary\" value is represented as a JSON string -- base64 encoding of arbitrary binary data.",
      "zh-CHS": "“二进制”值表示为JSON字符串——任意二进制数据的base64编码。"
    },
    {
      "indent": 3,
      "text": "The representation is identical to the lexical representation of the \"binary\" type in XML; see Section 9.8 in [RFC7950].",
      "zh-CHS": "该表示法与XML中“二进制”类型的词汇表示法相同；参见[RFC7950]中的第9.8节。"
    },
    {
      "indent": 0,
      "text": "6.7. The \"leafref\" Type",
      "section_title": true,
      "zh-CHS": "6.7. “leafref”类型"
    },
    {
      "indent": 3,
      "text": "A \"leafref\" value is represented using the same rules as the type of the leaf to which the leafref value refers.",
      "zh-CHS": "“leafref”值使用与leafref值引用的叶类型相同的规则表示。"
    },
    {
      "indent": 0,
      "text": "6.8. The \"identityref\" Type",
      "section_title": true,
      "zh-CHS": "6.8. “identityref”类型"
    },
    {
      "indent": 3,
      "text": "An \"identityref\" value is represented as a string -- the name of an identity. If the identity is defined in a module other than the leaf node containing the identityref value, the namespace-qualified form (Section 4) MUST be used. Otherwise, both the simple and namespace-qualified forms are permitted.",
      "zh-CHS": "“identityref”值表示为字符串——标识的名称。如果标识是在包含identityref值的叶节点以外的模块中定义的，则必须使用命名空间限定形式（第4节）。否则，允许使用简单形式和命名空间限定形式。"
    },
    {
      "indent": 3,
      "text": "For example, consider the following schematic module:",
      "zh-CHS": "例如，考虑下面的示意性模块："
    },
    {
      "indent": 3,
      "text": "module example-mod {\n  ...\n  import ietf-interfaces {\n    prefix if;\n  }\n  ...\n  leaf type {\n    type identityref {\n      base \"if:interface-type\";\n    }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "A valid instance of the \"type\" leaf is then encoded as follows:",
      "zh-CHS": "“类型”叶的有效实例编码如下："
    },
    {
      "indent": 3,
      "text": "\"type\": \"iana-if-type:ethernetCsmacd\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The namespace identifier \"iana-if-type\" must be present in this case because the \"ethernetCsmacd\" identity is not defined in the same module as the \"type\" leaf.",
      "zh-CHS": "在这种情况下，名称空间标识符“iana if type”必须存在，因为“ethernetCsmacd”标识没有在与“type”叶相同的模块中定义。"
    },
    {
      "indent": 0,
      "text": "6.9. The \"empty\" Type",
      "section_title": true,
      "zh-CHS": "6.9. “空”类型"
    },
    {
      "indent": 3,
      "text": "An \"empty\" value is represented as \"[null]\", i.e., an array with the \"null\" literal being its only element. For the purposes of this document, \"[null]\" is considered an atomic scalar value.",
      "zh-CHS": "“空”值表示为“[null]”，即“null”文本是其唯一元素的数组。在本文档中，“[null]”被视为原子标量值。"
    },
    {
      "indent": 3,
      "text": "This encoding of the \"empty\" type was chosen instead of using simply \"null\" in order to facilitate the use of empty leafs in common programming languages where the \"null\" value of a member is treated as if the member is not present.",
      "zh-CHS": "选择“empty”类型的这种编码，而不是简单地使用“null”，以便于在通用编程语言中使用空叶，其中成员的“null”值被视为不存在。"
    },
    {
      "indent": 3,
      "text": "Example: For the leaf definition",
      "zh-CHS": "示例：用于叶定义"
    },
    {
      "indent": 3,
      "text": "leaf foo {\n  type empty;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "a valid instance is",
      "zh-CHS": "一个有效的实例是"
    },
    {
      "indent": 3,
      "text": "\"foo\": [null]",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "6.10. The \"union\" Type",
      "section_title": true,
      "zh-CHS": "6.10. “联合”型"
    },
    {
      "indent": 3,
      "text": "A value of the \"union\" type is encoded as the value of any of the member types.",
      "zh-CHS": "“union”类型的值被编码为任何成员类型的值。"
    },
    {
      "indent": 3,
      "text": "When validating a value of the \"union\" type, the type information conveyed by the JSON encoding MUST also be taken into account. JSON syntax thus provides additional means for resolving the member type of the union that are not available in XML encoding.",
      "zh-CHS": "验证“union”类型的值时，还必须考虑JSON编码传递的类型信息。因此，JSON语法为解析在XML编码中不可用的联合成员类型提供了额外的方法。"
    },
    {
      "indent": 3,
      "text": "For example, consider the following YANG definition:",
      "zh-CHS": "例如，考虑下面的阳定义："
    },
    {
      "indent": 3,
      "text": "leaf bar {\n  type union {\n    type uint16;\n    type string;\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "In RESTCONF [RESTCONF], it is possible to set the value of \"bar\" in the following way when using the \"application/yang.data+xml\" media type:",
      "zh-CHS": "在RESTCONF[RESTCONF]中，使用“application/yang.data+xml”媒体类型时，可以通过以下方式设置“bar”的值："
    },
    {
      "indent": 3,
      "text": "<bar>13.5</bar>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "because the value may be interpreted as a string, i.e., the second member type of the union. When using the \"application/yang.data+json\" media type, however, this is an error:",
      "zh-CHS": "因为该值可以解释为字符串，即union的第二个成员类型。但是，当使用“application/yang.data+json”媒体类型时，这是一个错误："
    },
    {
      "indent": 3,
      "text": "\"bar\": 13.5",
      "zh-CHS": "“巴”：13.5"
    },
    {
      "indent": 3,
      "text": "In this case, the JSON encoding indicates that the value is supposed to be a number rather than a string, and it is not a valid \"uint16\" value.",
      "zh-CHS": "在本例中，JSON编码表示该值应该是数字而不是字符串，并且它不是有效的“uint16”值。"
    },
    {
      "indent": 3,
      "text": "Conversely, the value of",
      "zh-CHS": "相反，价值"
    },
    {
      "indent": 3,
      "text": "\"bar\": \"1\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "is to be interpreted as a string.",
      "zh-CHS": "将被解释为字符串。"
    },
    {
      "indent": 0,
      "text": "6.11. The \"instance-identifier\" Type",
      "section_title": true,
      "zh-CHS": "6.11. “实例标识符”类型"
    },
    {
      "indent": 3,
      "text": "An \"instance-identifier\" value is encoded as a string that is analogical to the lexical representation in XML encoding; see Section 9.13.2 in [RFC7950]. However, the encoding of namespaces in instance-identifier values follows the rules stated in Section 4, namely:",
      "zh-CHS": "“实例标识符”值被编码为字符串，类似于XML编码中的词汇表示；参见[RFC7950]中的第9.13.2节。但是，实例标识符值中名称空间的编码遵循第4节中规定的规则，即："
    },
    {
      "indent": 3,
      "text": "o The leftmost (top-level) data node name is always in the namespace-qualified form.",
      "zh-CHS": "o 最左侧（顶级）数据节点名称始终采用命名空间限定形式。"
    },
    {
      "indent": 3,
      "text": "o Any subsequent data node name is in the namespace-qualified form if the node is defined in a module other than its parent node, and the simple form is used otherwise. This rule also holds for node names appearing in predicates.",
      "zh-CHS": "o 如果节点是在其父节点以外的模块中定义的，则任何后续数据节点名称都采用命名空间限定形式，否则使用简单形式。此规则也适用于谓词中出现的节点名称。"
    },
    {
      "indent": 3,
      "text": "For example,",
      "zh-CHS": "例如"
    },
    {
      "indent": 3,
      "text": "/ietf-interfaces:interfaces/interface[name='eth0']/ietf-ip:ipv4/ip",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "is a valid instance-identifier value because the data nodes \"interfaces\", \"interface\", and \"name\" are defined in the module \"ietf-interfaces\", whereas \"ipv4\" and \"ip\" are defined in \"ietf-ip\".",
      "zh-CHS": "是有效的实例标识符值，因为数据节点“接口”、“接口”和“名称”在模块“ietf接口”中定义，而“ipv4”和“ip”在“ietf ip”中定义。"
    },
    {
      "indent": 0,
      "text": "7. I-JSON Compliance",
      "section_title": true,
      "zh-CHS": "7. I-JSON遵从性"
    },
    {
      "indent": 3,
      "text": "I-JSON [RFC7493] is a restricted profile of JSON that guarantees maximum interoperability for protocols that use JSON in their messages, no matter what JSON encoders/decoders are used in protocol implementations. The encoding defined in this document therefore observes the I-JSON requirements and recommendations as closely as possible.",
      "zh-CHS": "I-JSON[RFC7493]是JSON的一个受限配置文件，它保证了在消息中使用JSON的协议的最大互操作性，而不管协议实现中使用了什么JSON编码器/解码器。因此，本文档中定义的编码尽可能遵守I-JSON要求和建议。"
    },
    {
      "indent": 3,
      "text": "In particular, the following properties are guaranteed:",
      "zh-CHS": "特别是，保证以下特性："
    },
    {
      "indent": 3,
      "text": "o Character encoding is UTF-8.",
      "zh-CHS": "o 字符编码是UTF-8。"
    },
    {
      "indent": 3,
      "text": "o Member names within the same JSON object are always unique.",
      "zh-CHS": "o 同一JSON对象中的成员名称始终是唯一的。"
    },
    {
      "indent": 3,
      "text": "o The order of JSON object members is never relied upon.",
      "zh-CHS": "o 永远不依赖JSON对象成员的顺序。"
    },
    {
      "indent": 3,
      "text": "o Numbers of any type supported by YANG can be exchanged reliably. See Section 6.1 for details.",
      "zh-CHS": "o YANG支持的任何类型的号码都可以可靠地交换。详见第6.1节。"
    },
    {
      "indent": 3,
      "text": "The JSON encoding defined in this document deviates from I-JSON only in the representation of the \"binary\" type. In order to remain compatible with XML encoding, the base64 encoding scheme is used (Section 6.6), whilst I-JSON recommends base64url instead.",
      "zh-CHS": "本文档中定义的JSON编码仅在“二进制”类型的表示形式上与I-JSON不同。为了与XML编码保持兼容，使用了base64编码方案（第6.6节），而I-JSON建议使用base64url。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "zh-CHS": "8. 安全考虑"
    },
    {
      "indent": 3,
      "text": "This document defines an alternative encoding for data modeled in the YANG data modeling language. As such, it doesn't contribute any new security issues beyond those discussed in Section 17 of [RFC7950].",
      "zh-CHS": "本文档定义了用YANG数据建模语言建模的数据的替代编码。因此，除了[RFC7950]第17节中讨论的问题外，它不会带来任何新的安全问题。"
    },
    {
      "indent": 3,
      "text": "This document defines no mechanisms for signing and encrypting data modeled with YANG. Under normal circumstances, data security and integrity are guaranteed by the management protocol in use, such as NETCONF [RFC6241] or RESTCONF [RESTCONF]. If this is not the case, external mechanisms, such as Public-Key Cryptography Standards (PKCS) #7 [RFC2315] or JSON Object Signing and Encryption (JOSE) [RFC7515] [RFC7516], need to be considered.",
      "zh-CHS": "本文档未定义使用YANG建模的数据签名和加密机制。在正常情况下，数据安全性和完整性由正在使用的管理协议（如NETCONF[RFC6241]或RESTCONF[RESTCONF]）保证。如果情况并非如此，则需要考虑外部机制，如公钥加密标准（PKCS）#7[RFC2315]或JSON对象签名和加密（JOSE）[RFC7515][RFC7516]。"
    },
    {
      "indent": 3,
      "text": "JSON processing is rather different from XML, and JSON parsers may thus suffer from different types of vulnerabilities than their XML counterparts. To minimize these new security risks, software on the receiving side SHOULD reject all messages that do not comply with the rules of this document and reply with an appropriate error message to the sender.",
      "zh-CHS": "JSON处理与XML有很大不同，因此JSON解析器可能比XML解析器遭受不同类型的漏洞。为了将这些新的安全风险降至最低，接收方的软件应拒绝所有不符合本文档规则的消息，并向发送方回复适当的错误消息。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "zh-CHS": "9. 工具书类"
    },
    {
      "indent": 0,
      "text": "9.1. Normative References",
      "section_title": true,
      "zh-CHS": "9.1. 规范性引用文件"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "zh-CHS": "[RFC2119]Bradner，S.，“RFC中用于表示需求水平的关键词”，BCP 14，RFC 2119，DOI 10.17487/RFC2119，1997年3月<http://www.rfc-editor.org/info/rfc2119>."
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, DOI 10.17487/RFC5234, January 2008, <http://www.rfc-editor.org/info/rfc5234>.",
      "zh-CHS": "[RFC5234]Crocker，D.，Ed.和P.Overell，“语法规范的扩充BNF:ABNF”，STD 68，RFC 5234，DOI 10.17487/RFC5234，2008年1月<http://www.rfc-editor.org/info/rfc5234>."
    },
    {
      "indent": 3,
      "text": "[RFC6241] Enns, R., Ed., Bjorklund, M., Ed., Schoenwaelder, J., Ed., and A. Bierman, Ed., \"Network Configuration Protocol (NETCONF)\", RFC 6241, DOI 10.17487/RFC6241, June 2011, <http://www.rfc-editor.org/info/rfc6241>.",
      "zh-CHS": "[RFC6241]Enns，R.，Ed.，Bjorklund，M.，Ed.，Schoenwaeld，J.，Ed.，和A.Bierman，Ed.，“网络配置协议（NETCONF）”，RFC 6241，DOI 10.17487/RFC6241，2011年6月<http://www.rfc-editor.org/info/rfc6241>."
    },
    {
      "indent": 3,
      "text": "[RFC7159] Bray, T., Ed., \"The JavaScript Object Notation (JSON) Data Interchange Format\", RFC 7159, DOI 10.17487/RFC7159, March 2014, <http://www.rfc-editor.org/info/rfc7159>.",
      "zh-CHS": "[RFC7159]Bray，T.，Ed.“JavaScript对象表示法（JSON）数据交换格式”，RFC 7159，DOI 10.17487/RFC7159，2014年3月<http://www.rfc-editor.org/info/rfc7159>."
    },
    {
      "indent": 3,
      "text": "[RFC7493] Bray, T., Ed., \"The I-JSON Message Format\", RFC 7493, DOI 10.17487/RFC7493, March 2015, <http://www.rfc-editor.org/info/rfc7493>.",
      "zh-CHS": "[RFC7493]Bray，T.，Ed.，“I-JSON消息格式”，RFC 7493，DOI 10.17487/RFC7493，2015年3月<http://www.rfc-editor.org/info/rfc7493>."
    },
    {
      "indent": 3,
      "text": "[RFC7950] Bjorklund, M., Ed., \"The YANG 1.1 Data Modeling Language\", RFC 7950, DOI 10.17487/RFC7950, August 2016, <http://www.rfc-editor.org/info/rfc7950>.",
      "zh-CHS": "[RFC7950]Bjorklund，M.，Ed.“YANG 1.1数据建模语言”，RFC 7950，DOI 10.17487/RFC7950，2016年8月<http://www.rfc-editor.org/info/rfc7950>."
    },
    {
      "indent": 0,
      "text": "9.2. Informative References",
      "section_title": true,
      "zh-CHS": "9.2. 资料性引用"
    },
    {
      "indent": 3,
      "text": "[IEEE754-2008] IEEE, \"IEEE Standard for Floating-Point Arithmetic\", IEEE 754-2008, DOI 10.1109/IEEESTD.2008.4610935, 2008, <http://standards.ieee.org/findstds/ standard/754-2008.html>.",
      "zh-CHS": "[IEEE754-2008]IEEE，“IEEE浮点运算标准”，IEEE 754-2008，DOI 10.1109/IEEESTD.2008.46109352008<http://standards.ieee.org/findstds/ 标准/754-2008.html>。"
    },
    {
      "indent": 3,
      "text": "[RESTCONF] Bierman, A., Bjorklund, M., and K. Watsen, \"RESTCONF Protocol\", Work in Progress, draft-ietf-netconf-restconf-16, August 2016.",
      "zh-CHS": "[RESTCONF]Bierman，A.，Bjorklund，M.，和K.Watsen，“RESTCONF协议”，正在进行的工作，草稿-ietf-netconf-RESTCONF-162016年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC2315] Kaliski, B., \"PKCS #7: Cryptographic Message Syntax Version 1.5\", RFC 2315, DOI 10.17487/RFC2315, March 1998, <http://www.rfc-editor.org/info/rfc2315>.",
      "zh-CHS": "[RFC2315]Kaliski，B.，“PKCS#7：加密消息语法版本1.5”，RFC 2315，DOI 10.17487/RFC2315，1998年3月<http://www.rfc-editor.org/info/rfc2315>."
    },
    {
      "indent": 3,
      "text": "[RFC6020] Bjorklund, M., Ed., \"YANG - A Data Modeling Language for the Network Configuration Protocol (NETCONF)\", RFC 6020, DOI 10.17487/RFC6020, October 2010, <http://www.rfc-editor.org/info/rfc6020>.",
      "zh-CHS": "[RFC6020]Bjorklund，M.，Ed.“YANG-网络配置协议的数据建模语言（NETCONF）”，RFC 6020，DOI 10.17487/RFC6020，2010年10月<http://www.rfc-editor.org/info/rfc6020>."
    },
    {
      "indent": 3,
      "text": "[RFC7223] Bjorklund, M., \"A YANG Data Model for Interface Management\", RFC 7223, DOI 10.17487/RFC7223, May 2014, <http://www.rfc-editor.org/info/rfc7223>.",
      "zh-CHS": "[RFC7223]Bjorklund，M.，“用于接口管理的YANG数据模型”，RFC 7223，DOI 10.17487/RFC7223，2014年5月<http://www.rfc-editor.org/info/rfc7223>."
    },
    {
      "indent": 3,
      "text": "[RFC7515] Jones, M., Bradley, J., and N. Sakimura, \"JSON Web Signature (JWS)\", RFC 7515, DOI 10.17487/RFC7515, May 2015, <http://www.rfc-editor.org/info/rfc7515>.",
      "zh-CHS": "[RFC7515]Jones，M.，Bradley，J.和N.Sakimura，“JSON网络签名（JWS）”，RFC 7515，DOI 10.17487/RFC7515，2015年5月<http://www.rfc-editor.org/info/rfc7515>."
    },
    {
      "indent": 3,
      "text": "[RFC7516] Jones, M. and J. Hildebrand, \"JSON Web Encryption (JWE)\", RFC 7516, DOI 10.17487/RFC7516, May 2015, <http://www.rfc-editor.org/info/rfc7516>.",
      "zh-CHS": "[RFC7516]Jones，M.和J.Hildebrand，“JSON Web加密（JWE）”，RFC 7516，DOI 10.17487/RFC7516，2015年5月<http://www.rfc-editor.org/info/rfc7516>."
    },
    {
      "indent": 3,
      "text": "[RFC7952] Lhotka, L., \"Defining and Using Metadata with YANG\", RFC 7952, DOI 10.17487/RFC7952, August 2016, <http://www.rfc-editor.org/info/rfc7952>.",
      "zh-CHS": "[RFC7952]Lhotka，L.，“与YANG一起定义和使用元数据”，RFC 7952，DOI 10.17487/RFC7952，2016年8月<http://www.rfc-editor.org/info/rfc7952>."
    },
    {
      "indent": 3,
      "text": "[XML] Bray, T., Paoli, J., Sperberg-McQueen, M., Maler, E., and F. Yergeau, \"Extensible Markup Language (XML) 1.0 (Fifth Edition)\", World Wide Web Consortium Recommendation REC-xml-20081126, November 2008, <http://www.w3.org/TR/2008/REC-xml-20081126>.",
      "zh-CHS": "[XML]Bray，T.，Paoli，J.，Sperberg McQueen，M.，Maler，E.，和F.Yergeau，“可扩展标记语言（XML）1.0（第五版）”，万维网联盟建议REC-XML-20081126，2008年11月<http://www.w3.org/TR/2008/REC-xml-20081126>."
    },
    {
      "indent": 0,
      "text": "Appendix A. A Complete Example",
      "section_title": true,
      "zh-CHS": "附录A.一个完整的示例"
    },
    {
      "indent": 3,
      "text": "The JSON document shown below represents the same data as the reply to the NETCONF <get> request appearing in Appendix D of [RFC7223]. The data model is a combination of two YANG modules: \"ietf-interfaces\" and \"ex-vlan\" (the latter is an example module from Appendix C of [RFC7223]). The \"if-mib\" feature defined in the \"ietf-interfaces\" module is supported.",
      "zh-CHS": "下面显示的JSON文档表示的数据与[RFC7223]附录D中出现的对NETCONF<get>请求的回复相同。数据模型是两个模块的组合：“ietf接口”和“ex vlan”（后者是[RFC7223]附录C中的示例模块）。支持“ietf接口”模块中定义的“if mib”功能。"
    },
    {
      "indent": 3,
      "text": "{\n  \"ietf-interfaces:interfaces\": {\n    \"interface\": [\n      {\n        \"name\": \"eth0\",\n        \"type\": \"iana-if-type:ethernetCsmacd\",\n        \"enabled\": false\n      },\n      {\n        \"name\": \"eth1\",\n        \"type\": \"iana-if-type:ethernetCsmacd\",\n        \"enabled\": true,\n        \"ex-vlan:vlan-tagging\": true\n      },\n      {\n        \"name\": \"eth1.10\",\n        \"type\": \"iana-if-type:l2vlan\",\n        \"enabled\": true,\n        \"ex-vlan:base-interface\": \"eth1\",\n        \"ex-vlan:vlan-id\": 10\n      },\n      {\n        \"name\": \"lo1\",\n        \"type\": \"iana-if-type:softwareLoopback\",\n        \"enabled\": true\n      }\n    ]\n  },\n  \"ietf-interfaces:interfaces-state\": {\n    \"interface\": [\n      {\n        \"name\": \"eth0\",\n        \"type\": \"iana-if-type:ethernetCsmacd\",\n        \"admin-status\": \"down\",\n        \"oper-status\": \"down\",\n        \"if-index\": 2,\n        \"phys-address\": \"00:01:02:03:04:05\",\n        \"statistics\": {\n          \"discontinuity-time\": \"2013-04-01T03:00:00+00:00\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 9,
      "text": "  }\n},\n{\n  \"name\": \"eth1\",\n  \"type\": \"iana-if-type:ethernetCsmacd\",\n  \"admin-status\": \"up\",\n  \"oper-status\": \"up\",\n  \"if-index\": 7,\n  \"phys-address\": \"00:01:02:03:04:06\",\n  \"higher-layer-if\": [\n    \"eth1.10\"\n  ],\n  \"statistics\": {\n    \"discontinuity-time\": \"2013-04-01T03:00:00+00:00\"\n  }\n},\n{\n  \"name\": \"eth1.10\",\n  \"type\": \"iana-if-type:l2vlan\",\n  \"admin-status\": \"up\",\n  \"oper-status\": \"up\",\n  \"if-index\": 9,\n  \"lower-layer-if\": [\n    \"eth1\"\n  ],\n  \"statistics\": {\n    \"discontinuity-time\": \"2013-04-01T03:00:00+00:00\"\n  }\n},\n{\n  \"name\": \"eth2\",\n  \"type\": \"iana-if-type:ethernetCsmacd\",\n  \"admin-status\": \"down\",\n  \"oper-status\": \"down\",\n  \"if-index\": 8,\n  \"phys-address\": \"00:01:02:03:04:07\",\n  \"statistics\": {\n    \"discontinuity-time\": \"2013-04-01T03:00:00+00:00\"\n  }\n},\n{\n  \"name\": \"lo1\",\n  \"type\": \"iana-if-type:softwareLoopback\",\n  \"admin-status\": \"up\",\n  \"oper-status\": \"up\",\n  \"if-index\": 1,\n  \"statistics\": {\n    \"discontinuity-time\": \"2013-04-01T03:00:00+00:00\"",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "        }\n      }\n    ]\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "zh-CHS": "致谢"
    },
    {
      "indent": 3,
      "text": "The author wishes to thank Andy Bierman, Martin Bjorklund, Dean Bogdanovic, Balazs Lengyel, Juergen Schoenwaelder, and Phil Shafer for their helpful comments and suggestions.",
      "zh-CHS": "作者希望感谢安迪·比尔曼、马丁·比约克隆德、迪安·博格达诺维奇、巴拉兹·伦杰尔、尤尔根·舍恩瓦埃尔德和菲尔·沙弗提出的有益意见和建议。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "zh-CHS": "作者地址"
    },
    {
      "indent": 3,
      "text": "Ladislav Lhotka CZ.NIC",
      "zh-CHS": "拉迪斯拉夫·洛特卡CZ.NIC"
    },
    {
      "indent": 3,
      "text": "Email: lhotka@nic.cz",
      "raw": true,
      "zh-CHS": " "
    }
  ]
}